(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.mapboxgl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    'use strict';

// a simple wrapper around a single arraybuffer

    module.exports = Buffer;

    function Buffer(buffer) {
        if (!buffer) {
            this.array = new ArrayBuffer(this.defaultLength);
            this.length = this.defaultLength;
            this.setupViews();

        } else {
            // we only recreate buffers after receiving them from workers for binding to gl,
            // so we only need these 2 properties
            this.array = buffer.array;
            this.pos = buffer.pos;
        }
    }

    Buffer.prototype = {
        pos: 0,
        itemSize: 4, // bytes in one item
        defaultLength: 8192, // initial buffer size
        arrayType: 'ARRAY_BUFFER', // gl buffer type

        get index() {
            return this.pos / this.itemSize;
        },

        setupViews: function() {
            // set up views for each type to add data of different types to the same buffer
            this.ubytes = new Uint8Array(this.array);
            this.bytes = new Int8Array(this.array);
            this.ushorts = new Uint16Array(this.array);
            this.shorts = new Int16Array(this.array);
        },

        // binds the buffer to a webgl context
        bind: function(gl) {
            var type = gl[this.arrayType];
            if (!this.buffer) {
                this.buffer = gl.createBuffer();
                gl.bindBuffer(type, this.buffer);
                gl.bufferData(type, this.array.slice(0, this.pos), gl.STATIC_DRAW);

                // dump array buffer once it's bound to gl
                this.array = null;
            } else {
                gl.bindBuffer(type, this.buffer);
            }
        },

        destroy: function(gl) {
            if (this.buffer) {
                gl.deleteBuffer(this.buffer);
            }
        },

        // increase the buffer size by 50% if a new item doesn't fit
        resize: function() {
            if (this.length < this.pos + this.itemSize) {

                while (this.length < this.pos + this.itemSize) {
                    // increase the length by 50% but keep it even
                    this.length = Math.round(this.length * 1.5 / 2) * 2;
                }

                // array buffers can't be resized, so we create a new one and reset all bytes there
                this.array = new ArrayBuffer(this.length);

                var ubytes = new Uint8Array(this.array);
                ubytes.set(this.ubytes);

                this.setupViews();
            }
        }
    };

},{}],2:[function(require,module,exports){
    'use strict';

    var LineVertexBuffer = require('./line_vertex_buffer');
    var LineElementBuffer = require('./line_element_buffer');
    var FillVertexBuffer = require('./fill_vertex_buffer');
    var FillElementBuffer = require('./triangle_element_buffer');
    var OutlineElementBuffer = require('./outline_element_buffer');
    var GlyphVertexBuffer = require('./glyph_vertex_buffer');
    var GlyphElementBuffer = require('./triangle_element_buffer');
    var IconVertexBuffer = require('./icon_vertex_buffer');
    var IconElementBuffer = require('./triangle_element_buffer');
    var CollisionBoxVertexBuffer = require('./collision_box_vertex_buffer');

    module.exports = function(bufferset) {
        bufferset = bufferset || {};
        return {
            glyphVertex: new GlyphVertexBuffer(bufferset.glyphVertex),
            glyphElement: new GlyphElementBuffer(bufferset.glyphElement),
            iconVertex: new IconVertexBuffer(bufferset.iconVertex),
            iconElement: new IconElementBuffer(bufferset.iconElement),
            fillVertex: new FillVertexBuffer(bufferset.fillVertex),
            fillElement: new FillElementBuffer(bufferset.fillElement),
            outlineElement: new OutlineElementBuffer(bufferset.outlineElement),
            lineVertex: new LineVertexBuffer(bufferset.lineVertex),
            lineElement: new LineElementBuffer(bufferset.lineElement),
            collisionBoxVertex: new CollisionBoxVertexBuffer(bufferset.collisionBoxVertex)
        };
    };

},{"./collision_box_vertex_buffer":3,"./fill_vertex_buffer":4,"./glyph_vertex_buffer":5,"./icon_vertex_buffer":6,"./line_element_buffer":7,"./line_vertex_buffer":8,"./outline_element_buffer":9,"./triangle_element_buffer":10}],3:[function(require,module,exports){
    'use strict';

    var util = require('../../util/util');
    var Buffer = require('./buffer');

    module.exports = CollisionBoxVertexBuffer;

    function CollisionBoxVertexBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    CollisionBoxVertexBuffer.prototype = util.inherit(Buffer, {
        itemSize: 12, // bytes per vertex (2 * short + 1 * short + 2 * byte = 8 bytes)
        defaultLength: 32768,

        // add a vertex to this buffer;
        // x, y - vertex position
        // ex, ey - extrude normal
        add: function(point, extrude, maxZoom, placementZoom) {
            var pos = this.pos,
                pos2 = pos / 2,
                index = this.index;

            this.resize();

            this.shorts[pos2 + 0] = point.x;
            this.shorts[pos2 + 1] = point.y;

            this.shorts[pos2 + 2] = Math.round(extrude.x);
            this.shorts[pos2 + 3] = Math.round(extrude.y);
            this.ubytes[pos + 8] = Math.floor(maxZoom * 10);
            this.ubytes[pos + 9] = Math.floor(placementZoom * 10);

            this.pos += this.itemSize;
            return index;
        }
    });

},{"../../util/util":103,"./buffer":1}],4:[function(require,module,exports){
    'use strict';

    var util = require('../../util/util');
    var Buffer = require('./buffer');

    module.exports = FillVertexBuffer;

    function FillVertexBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    FillVertexBuffer.prototype = util.inherit(Buffer, {
        itemSize: 4, // bytes per vertex (2 * short == 4 bytes)

        add: function(x, y) {
            var pos2 = this.pos / 2;

            this.resize();

            this.shorts[pos2 + 0] = x;
            this.shorts[pos2 + 1] = y;

            this.pos += this.itemSize;
        }
    });

},{"../../util/util":103,"./buffer":1}],5:[function(require,module,exports){
    'use strict';

    var util = require('../../util/util');
    var Buffer = require('./buffer');

    module.exports = GlyphVertexBuffer;

    function GlyphVertexBuffer(buffer) {
        Buffer.call(this, buffer);
    }


    GlyphVertexBuffer.prototype = util.inherit(Buffer, {
        defaultLength: 2048 * 16,
        itemSize: 16,

        add: function(x, y, ox, oy, tx, ty, minzoom, maxzoom, labelminzoom) {
            var pos = this.pos,
                pos2 = pos / 2;

            this.resize();

            this.shorts[pos2 + 0] = x;
            this.shorts[pos2 + 1] = y;
            this.shorts[pos2 + 2] = Math.round(ox * 64); // use 1/64 pixels for placement
            this.shorts[pos2 + 3] = Math.round(oy * 64);

            // a_data1
            this.ubytes[pos + 8] /* tex */ = Math.floor(tx / 4);
            this.ubytes[pos + 9] /* tex */ = Math.floor(ty / 4);
            this.ubytes[pos + 10] /* labelminzoom */ = Math.floor((labelminzoom) * 10);

            // a_data2
            this.ubytes[pos + 12] /* minzoom */ = Math.floor((minzoom) * 10); // 1/10 zoom levels: z16 == 160.
            this.ubytes[pos + 13] /* maxzoom */ = Math.floor(Math.min(maxzoom, 25) * 10); // 1/10 zoom levels: z16 == 160.

            this.pos += this.itemSize;
        },

        bind: function(gl, shader, offset) {
            Buffer.prototype.bind.call(this, gl);

            var stride = this.itemSize;

            gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, stride, offset + 0);
            gl.vertexAttribPointer(shader.a_offset, 2, gl.SHORT, false, stride, offset + 4);

            gl.vertexAttribPointer(shader.a_data1, 4, gl.UNSIGNED_BYTE, false, stride, offset + 8);
            gl.vertexAttribPointer(shader.a_data2, 2, gl.UNSIGNED_BYTE, false, stride, offset + 12);
        }
    });

},{"../../util/util":103,"./buffer":1}],6:[function(require,module,exports){
    'use strict';

    var util = require('../../util/util');
    var Buffer = require('./buffer');

    module.exports = IconVertexBuffer;

    function IconVertexBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    IconVertexBuffer.prototype = util.inherit(Buffer, {
        defaultLength: 2048 * 16,
        itemSize: 16,

        add: function(x, y, ox, oy, tx, ty, minzoom, maxzoom, labelminzoom) {
            var pos = this.pos,
                pos2 = pos / 2;

            this.resize();

            this.shorts[pos2 + 0] = x;
            this.shorts[pos2 + 1] = y;
            this.shorts[pos2 + 2] = Math.round(ox * 64); // use 1/64 pixels for placement
            this.shorts[pos2 + 3] = Math.round(oy * 64);

            // a_data1
            this.ubytes[pos + 8] /* tex */ = tx / 4;
            this.ubytes[pos + 9] /* tex */ = ty / 4;
            this.ubytes[pos + 10] /* labelminzoom */ = Math.floor((labelminzoom || 0) * 10);

            // a_data2
            this.ubytes[pos + 12] /* minzoom */ = Math.floor((minzoom || 0) * 10); // 1/10 zoom levels: z16 == 160.
            this.ubytes[pos + 13] /* maxzoom */ = Math.floor(Math.min(maxzoom || 25, 25) * 10); // 1/10 zoom levels: z16 == 160.

            this.pos += this.itemSize;
        },

        bind: function(gl, shader, offset) {
            Buffer.prototype.bind.call(this, gl);

            var stride = this.itemSize;

            gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, stride, offset + 0);
            gl.vertexAttribPointer(shader.a_offset, 2, gl.SHORT, false, stride, offset + 4);
            gl.vertexAttribPointer(shader.a_data1, 4, gl.UNSIGNED_BYTE, false, stride, offset + 8);
            gl.vertexAttribPointer(shader.a_data2, 2, gl.UNSIGNED_BYTE, false, stride, offset + 12);
        }
    });

},{"../../util/util":103,"./buffer":1}],7:[function(require,module,exports){
    'use strict';

    var util = require('../../util/util');
    var Buffer = require('./buffer');

    module.exports = LineElementBuffer;

    function LineElementBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    LineElementBuffer.prototype = util.inherit(Buffer, {
        itemSize: 6, // bytes per triangle (3 * unsigned short == 6 bytes)
        arrayType: 'ELEMENT_ARRAY_BUFFER',

        add: function(a, b, c) {
            var pos2 = this.pos / 2;

            this.resize();

            this.ushorts[pos2 + 0] = a;
            this.ushorts[pos2 + 1] = b;
            this.ushorts[pos2 + 2] = c;

            this.pos += this.itemSize;
        }
    });

},{"../../util/util":103,"./buffer":1}],8:[function(require,module,exports){
    'use strict';

    var util = require('../../util/util');
    var Buffer = require('./buffer');

    module.exports = LineVertexBuffer;

    function LineVertexBuffer(buffer) {
        Buffer.call(this, buffer);
    }

// scale the extrusion vector so that the normal length is this value.
// contains the "texture" normals (-1..1). this is distinct from the extrude
// normals for line joins, because the x-value remains 0 for the texture
// normal array, while the extrude normal actually moves the vertex to create
// the acute/bevelled line join.
    LineVertexBuffer.extrudeScale = 63;

    LineVertexBuffer.prototype = util.inherit(Buffer, {
        itemSize: 8, // bytes per vertex (2 * short + 1 * short + 2 * byte = 8 bytes)
        defaultLength: 32768,

        // add a vertex to this buffer;
        // x, y - vertex position
        // ex, ey - extrude normal
        // tx, ty - texture normal
        add: function(point, extrude, tx, ty, linesofar) {
            var pos = this.pos,
                pos2 = pos / 2,
                index = this.index,
                extrudeScale = LineVertexBuffer.extrudeScale;

            this.resize();

            this.shorts[pos2 + 0] = (Math.floor(point.x) * 2) | tx;
            this.shorts[pos2 + 1] = (Math.floor(point.y) * 2) | ty;

            this.bytes[pos + 4] = Math.round(extrudeScale * extrude.x);
            this.bytes[pos + 5] = Math.round(extrudeScale * extrude.y);
            this.bytes[pos + 6] = (linesofar || 0) / 128;
            this.bytes[pos + 7] = (linesofar || 0) % 128;

            this.pos += this.itemSize;
            return index;
        }
    });

},{"../../util/util":103,"./buffer":1}],9:[function(require,module,exports){
    'use strict';

    var util = require('../../util/util');
    var Buffer = require('./buffer');

    module.exports = OutlineElementBuffer;

    function OutlineElementBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    OutlineElementBuffer.prototype = util.inherit(Buffer, {
        itemSize: 4, // bytes per line (2 * unsigned short == 4 bytes)
        arrayType: 'ELEMENT_ARRAY_BUFFER',

        add: function(a, b) {
            var pos2 = this.pos / 2;

            this.resize();

            this.ushorts[pos2 + 0] = a;
            this.ushorts[pos2 + 1] = b;

            this.pos += this.itemSize;
        }
    });

},{"../../util/util":103,"./buffer":1}],10:[function(require,module,exports){
    'use strict';

    var util = require('../../util/util');
    var Buffer = require('./buffer');

    module.exports = TriangleElementBuffer;

    function TriangleElementBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    TriangleElementBuffer.prototype = util.inherit(Buffer, {
        itemSize: 6, // bytes per triangle (3 * unsigned short == 6 bytes)
        arrayType: 'ELEMENT_ARRAY_BUFFER',

        add: function(a, b, c) {
            var pos2 = this.pos / 2;

            this.resize();

            this.ushorts[pos2 + 0] = a;
            this.ushorts[pos2 + 1] = b;
            this.ushorts[pos2 + 2] = c;

            this.pos += this.itemSize;
        }
    });

},{"../../util/util":103,"./buffer":1}],11:[function(require,module,exports){
    'use strict';

    module.exports = createBucket;

    var LineBucket = require('./line_bucket');
    var FillBucket = require('./fill_bucket');
    var SymbolBucket = require('./symbol_bucket');
    var LayoutProperties = require('../style/layout_properties');
    var featureFilter = require('feature-filter');
    var StyleDeclarationSet = require('../style/style_declaration_set');

    function createBucket(layer, buffers, z, overscaling, collisionDebug) {
        var values = new StyleDeclarationSet('layout', layer.type, layer.layout, {}).values(),
            fakeZoomHistory = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 },
            layout = {};

        for (var k in values) {
            layout[k] = values[k].calculate(z, fakeZoomHistory);
        }

        var BucketClass =
                layer.type === 'line' ? LineBucket :
                layer.type === 'fill' ? FillBucket :
                layer.type === 'symbol' ? SymbolBucket : null;

        var bucket = new BucketClass(buffers, new LayoutProperties[layer.type](layout), overscaling, z, collisionDebug);

        bucket.id = layer.id;
        bucket.type = layer.type;
        bucket['source-layer'] = layer['source-layer'];
        bucket.interactive = layer.interactive;
        bucket.minZoom = layer.minzoom;
        bucket.maxZoom = layer.maxzoom;
        bucket.filter = featureFilter(layer.filter);
        bucket.features = [];

        return bucket;
    }

},{"../style/layout_properties":49,"../style/style_declaration_set":56,"./fill_bucket":14,"./line_bucket":15,"./symbol_bucket":16,"feature-filter":109}],12:[function(require,module,exports){
    'use strict';

    module.exports = ElementGroups;

    function ElementGroups(vertexBuffer, elementBuffer, secondElementBuffer) {

        this.vertexBuffer = vertexBuffer;
        this.elementBuffer = elementBuffer;
        this.secondElementBuffer = secondElementBuffer;
        this.groups = [];
    }

    ElementGroups.prototype.makeRoomFor = function(numVertices) {
        if (!this.current || this.current.vertexLength + numVertices > 65535) {
            this.current = new ElementGroup(this.vertexBuffer.index,
                    this.elementBuffer && this.elementBuffer.index,
                    this.secondElementBuffer && this.secondElementBuffer.index);
            this.groups.push(this.current);
        }
    };

    function ElementGroup(vertexStartIndex, elementStartIndex, secondElementStartIndex) {
        // the offset into the vertex buffer of the first vertex in this group
        this.vertexStartIndex = vertexStartIndex;
        this.elementStartIndex = elementStartIndex;
        this.secondElementStartIndex = secondElementStartIndex;
        this.elementLength = 0;
        this.vertexLength = 0;
        this.secondElementLength = 0;
    }

},{}],13:[function(require,module,exports){
    'use strict';

    var rbush = require('rbush');
    var Point = require('point-geometry');
    var vt = require('vector-tile');
    var util = require('../util/util');

    module.exports = FeatureTree;

    function FeatureTree(coord, overscaling) {
        this.x = coord.x;
        this.y = coord.y;
        this.z = coord.z - Math.log(overscaling) / Math.LN2;
        this.rtree = rbush(9);
        this.toBeInserted = [];
    }

    FeatureTree.prototype.insert = function(bbox, layers, feature) {
        bbox.layers = layers;
        bbox.feature = feature;
        this.toBeInserted.push(bbox);
    };

// bulk insert into tree
    FeatureTree.prototype._load = function() {
        this.rtree.load(this.toBeInserted);
        this.toBeInserted = [];
    };

// Finds features in this tile at a particular position.
    FeatureTree.prototype.query = function(args, callback) {
        if (this.toBeInserted.length) this._load();

        var params = args.params || {},
            radius = (params.radius || 0) * 4096 / args.scale,
            x = args.x,
            y = args.y,
            result = [];

        var matching = this.rtree.search([ x - radius, y - radius, x + radius, y + radius ]);
        for (var i = 0; i < matching.length; i++) {
            var feature = matching[i].feature,
                layers = matching[i].layers,
                type = vt.VectorTileFeature.types[feature.type];

            if (params.$type && type !== params.$type)
                continue;
            if (!geometryContainsPoint(feature.loadGeometry(), type, new Point(x, y), radius))
                continue;

            var geoJSON = feature.toGeoJSON(this.x, this.y, this.z);
            for (var l = 0; l < layers.length; l++) {
                var layer = layers[l];

                if (params.layer && layer !== params.layer.id)
                    continue;

                result.push(util.extend({layer: layer}, geoJSON));
            }
        }

        callback(null, result);
    };

    function geometryContainsPoint(rings, type, p, radius) {
        return type === 'Point' ? pointContainsPoint(rings, p, radius) :
                type === 'LineString' ? lineContainsPoint(rings, p, radius) :
                type === 'Polygon' ? polyContainsPoint(rings, p) || lineContainsPoint(rings, p, radius) : false;
    }

// Code from http://stackoverflow.com/a/1501725/331379.
    function distToSegmentSquared(p, v, w) {
        var l2 = v.distSqr(w);
        if (l2 === 0) return p.distSqr(v);
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        if (t < 0) return p.distSqr(v);
        if (t > 1) return p.distSqr(w);
        return p.distSqr(w.sub(v)._mult(t)._add(v));
    }

    function lineContainsPoint(rings, p, radius) {
        var r = radius * radius;

        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i];
            for (var j = 1; j < ring.length; j++) {
                // Find line segments that have a distance <= radius^2 to p
                // In that case, we treat the line as "containing point p".
                var v = ring[j - 1], w = ring[j];
                if (distToSegmentSquared(p, v, w) < r) return true;
            }
        }
        return false;
    }

// point in polygon ray casting algorithm
    function polyContainsPoint(rings, p) {
        var c = false,
            ring, p1, p2;

        for (var k = 0; k < rings.length; k++) {
            ring = rings[k];
            for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                p1 = ring[i];
                p2 = ring[j];
                if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                    c = !c;
                }
            }
        }
        return c;
    }

    function pointContainsPoint(rings, p, radius) {
        var r = radius * radius;

        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i];
            for (var j = 0; j < ring.length; j++) {
                if (ring[j].distSqr(p) <= r) return true;
            }
        }
        return false;
    }

},{"../util/util":103,"point-geometry":150,"rbush":151,"vector-tile":154}],14:[function(require,module,exports){
    'use strict';

    var ElementGroups = require('./element_groups');

    module.exports = FillBucket;

    function FillBucket(buffers) {
        this.buffers = buffers;
        this.elementGroups = new ElementGroups(buffers.fillVertex, buffers.fillElement, buffers.outlineElement);
    }

    FillBucket.prototype.addFeatures = function() {
        var features = this.features;
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            this.addFeature(feature.loadGeometry());
        }
    };

    FillBucket.prototype.addFeature = function(lines) {
        for (var i = 0; i < lines.length; i++) {
            this.addFill(lines[i]);
        }
    };

    FillBucket.prototype.addFill = function(vertices) {
        if (vertices.length < 3) {
            //console.warn('a fill must have at least three vertices');
            return;
        }

        // Calculate the total number of vertices we're going to produce so that we
        // can resize the buffer beforehand, or detect whether the current line
        // won't fit into the buffer anymore.
        // In order to be able to use the vertex buffer for drawing the antialiased
        // outlines, we separate all polygon vertices with a degenerate (out-of-
        // viewplane) vertex.

        var len = vertices.length;

        // Check whether this geometry buffer can hold all the required vertices.
        this.elementGroups.makeRoomFor(len + 1);
        var elementGroup = this.elementGroups.current;

        var fillVertex = this.buffers.fillVertex;
        var fillElement = this.buffers.fillElement;
        var outlineElement = this.buffers.outlineElement;

        // We're generating triangle fans, so we always start with the first coordinate in this polygon.
        var firstIndex = fillVertex.index - elementGroup.vertexStartIndex,
            prevIndex, currentIndex, currentVertex;

        for (var i = 0; i < vertices.length; i++) {
            currentIndex = fillVertex.index - elementGroup.vertexStartIndex;
            currentVertex = vertices[i];

            fillVertex.add(currentVertex.x, currentVertex.y);
            elementGroup.vertexLength++;

            // Only add triangles that have distinct vertices.
            if (i >= 2 && (currentVertex.x !== vertices[0].x || currentVertex.y !== vertices[0].y)) {
                fillElement.add(firstIndex, prevIndex, currentIndex);
                elementGroup.elementLength++;
            }

            if (i >= 1) {
                outlineElement.add(prevIndex, currentIndex);
                elementGroup.secondElementLength++;
            }

            prevIndex = currentIndex;
        }
    };

},{"./element_groups":12}],15:[function(require,module,exports){
    'use strict';

    var ElementGroups = require('./element_groups');

    module.exports = LineBucket;

    /**
     * @class LineBucket
     * @private
     */
    function LineBucket(buffers, layoutProperties) {
        this.buffers = buffers;
        this.elementGroups = new ElementGroups(buffers.lineVertex, buffers.lineElement);
        this.layoutProperties = layoutProperties;
    }

    LineBucket.prototype.addFeatures = function() {
        var features = this.features;
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            this.addFeature(feature.loadGeometry());
        }
    };

    LineBucket.prototype.addFeature = function(lines) {
        var layoutProperties = this.layoutProperties;
        for (var i = 0; i < lines.length; i++) {
            this.addLine(lines[i],
                layoutProperties['line-join'],
                layoutProperties['line-cap'],
                layoutProperties['line-miter-limit'],
                layoutProperties['line-round-limit']);
        }
    };

    LineBucket.prototype.addLine = function(vertices, join, cap, miterLimit, roundLimit) {

        var len = vertices.length;
        // If the line has duplicate vertices at the end, adjust length to remove them.
        while (len > 2 && vertices[len - 1].equals(vertices[len - 2])) {
            len--;
        }

        if (vertices.length < 2) {
            //console.warn('a line must have at least two vertices');
            return;
        }

        if (join === 'bevel') miterLimit = 1.05;

        var firstVertex = vertices[0],
            lastVertex = vertices[len - 1],
            closed = firstVertex.equals(lastVertex);

        // we could be more precise, but it would only save a negligible amount of space
        this.elementGroups.makeRoomFor(len * 4);

        if (len === 2 && closed) {
            // console.warn('a line may not have coincident points');
            return;
        }

        var beginCap = cap,
            endCap = closed ? 'butt' : cap,
            flip = 1,
            distance = 0,
            startOfLine = true,
            currentVertex, prevVertex, nextVertex, prevNormal, nextNormal, offsetA, offsetB;

        // the last three vertices added
        this.e1 = this.e2 = this.e3 = -1;

        if (closed) {
            currentVertex = vertices[len - 2];
            nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
        }

        for (var i = 0; i < len; i++) {

            nextVertex = closed && i === len - 1 ?
                vertices[1] : // if the line is closed, we treat the last vertex like the first
                vertices[i + 1]; // just the next vertex

            // if two consecutive vertices exist, skip the current one
            if (nextVertex && vertices[i].equals(nextVertex)) continue;

            if (nextNormal) prevNormal = nextNormal;
            if (currentVertex) prevVertex = currentVertex;

            currentVertex = vertices[i];

            // Calculate how far along the line the currentVertex is
            if (prevVertex) distance += currentVertex.dist(prevVertex);

            // Calculate the normal towards the next vertex in this line. In case
            // there is no next vertex, pretend that the line is continuing straight,
            // meaning that we are just using the previous normal.
            nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;

            // If we still don't have a previous normal, this is the beginning of a
            // non-closed line, so we're doing a straight "join".
            prevNormal = prevNormal || nextNormal;

            // Determine the normal of the join extrusion. It is the angle bisector
            // of the segments between the previous line and the next line.
            var joinNormal = prevNormal.add(nextNormal)._unit();

            /*  joinNormal     prevNormal
             *             ↖      ↑
             *                .________. prevVertex
             *                |
             * nextNormal  ←  |  currentVertex
             *                |
             *     nextVertex !
             *
             */

            // Calculate the length of the miter (the ratio of the miter to the width).
            // Find the cosine of the angle between the next and join normals
            // using dot product. The inverse of that is the miter length.
            var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
            var miterLength = 1 / cosHalfAngle;

            // The join if a middle vertex, otherwise the cap.
            var middleVertex = prevVertex && nextVertex;
            var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;

            if (middleVertex && currentJoin === 'round' && miterLength < roundLimit) {
                currentJoin = 'miter';
            }

            if (currentJoin === 'miter' && miterLength > miterLimit) {
                currentJoin = 'bevel';
            }

            if (currentJoin === 'bevel') {
                // The maximum extrude length is 128 / 63 = 2 times the width of the line
                // so if miterLength >= 2 we need to draw a different type of bevel where.
                if (miterLength > 2) currentJoin = 'flipbevel';

                // If the miterLength is really small and the line bevel wouldn't be visible,
                // just draw a miter join to save a triangle.
                if (miterLength < miterLimit) currentJoin = 'miter';
            }

            if (currentJoin === 'miter') {
                joinNormal._mult(miterLength);
                this.addCurrentVertex(currentVertex, flip, distance, joinNormal, 0, 0, false);

            } else if (currentJoin === 'flipbevel') {
                // miter is too big, flip the direction to make a beveled join

                if (miterLength > 100) {
                    // Almost parallel lines
                    joinNormal = nextNormal.clone();

                } else {
                    var direction = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0 ? -1 : 1;
                    var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                    joinNormal._perp()._mult(bevelLength * direction);
                }
                this.addCurrentVertex(currentVertex, flip, distance, joinNormal, 0, 0, false);
                flip = -flip;

            } else if (currentJoin === 'bevel') {
                var dir = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x;
                var offset = -Math.sqrt(miterLength * miterLength - 1);
                if (flip * dir > 0) {
                    offsetB = 0;
                    offsetA = offset;
                } else {
                    offsetA = 0;
                    offsetB = offset;
                }

                // Close previous segment with a bevel
                if (!startOfLine) {
                    this.addCurrentVertex(currentVertex, flip, distance, prevNormal, offsetA, offsetB, false);
                }

                // Start next segment
                if (nextVertex) {
                    this.addCurrentVertex(currentVertex, flip, distance, nextNormal, -offsetA, -offsetB, false);
                }

            } else if (currentJoin === 'butt') {
                if (!startOfLine) {
                    // Close previous segment with a butt
                    this.addCurrentVertex(currentVertex, flip, distance, prevNormal, 0, 0, false);
                }

                // Start next segment with a butt
                if (nextVertex) {
                    this.addCurrentVertex(currentVertex, flip, distance, nextNormal, 0, 0, false);
                }

            } else if (currentJoin === 'square') {

                if (!startOfLine) {
                    // Close previous segment with a square cap
                    this.addCurrentVertex(currentVertex, flip, distance, prevNormal, 1, 1, false);

                    // The segment is done. Unset vertices to disconnect segments.
                    this.e1 = this.e2 = -1;
                    flip = 1;
                }

                // Start next segment
                if (nextVertex) {
                    this.addCurrentVertex(currentVertex, flip, distance, nextNormal, -1, -1, false);
                }

            } else if (currentJoin === 'round') {

                if (!startOfLine) {
                    // Close previous segment with butt
                    this.addCurrentVertex(currentVertex, flip, distance, prevNormal, 0, 0, false);

                    // Add round cap or linejoin at end of segment
                    this.addCurrentVertex(currentVertex, flip, distance, prevNormal, 1, 1, true);

                    // The segment is done. Unset vertices to disconnect segments.
                    this.e1 = this.e2 = -1;
                    flip = 1;

                } else if (beginCap === 'round') {
                    // Add round cap before first segment
                    this.addCurrentVertex(currentVertex, flip, distance, nextNormal, -1, -1, true);
                }

                // Start next segment with a butt
                if (nextVertex) {
                    this.addCurrentVertex(currentVertex, flip, distance, nextNormal, 0, 0, false);
                }
            }

            startOfLine = false;
        }


    };

    /**
     * Add two vertices to the buffers.
     *
     * @param {Object} currentVertex the line vertex to add buffer vertices for
     * @param {number} flip -1 if the vertices should be flipped, 1 otherwise
     * @param {number} distance the distance from the beggining of the line to the vertex
     * @param {number} endLeft extrude to shift the left vertex along the line
     * @param {number} endRight extrude to shift the left vertex along the line
     * @param {boolean} round whether this is a round cap
     * @private
     */
    LineBucket.prototype.addCurrentVertex = function(currentVertex, flip, distance, normal, endLeft, endRight, round) {
        var tx = round ? 1 : 0;
        var extrude;

        var lineVertex = this.buffers.lineVertex;
        var lineElement = this.buffers.lineElement;
        var elementGroup = this.elementGroups.current;
        var vertexStartIndex = this.elementGroups.current.vertexStartIndex;

        extrude = normal.mult(flip);
        if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
        this.e3 = lineVertex.add(currentVertex, extrude, tx, 0, distance) - vertexStartIndex;
        if (this.e1 >= 0 && this.e2 >= 0) {
            lineElement.add(this.e1, this.e2, this.e3);
            elementGroup.elementLength++;
        }
        this.e1 = this.e2;
        this.e2 = this.e3;

        extrude = normal.mult(-flip);
        if (endRight) extrude._sub(normal.perp()._mult(endRight));
        this.e3 = lineVertex.add(currentVertex, extrude, tx, 1, distance) - vertexStartIndex;
        if (this.e1 >= 0 && this.e2 >= 0) {
            lineElement.add(this.e1, this.e2, this.e3);
            elementGroup.elementLength++;
        }
        this.e1 = this.e2;
        this.e2 = this.e3;

        elementGroup.vertexLength += 2;
    };

},{"./element_groups":12}],16:[function(require,module,exports){
    'use strict';

    var ElementGroups = require('./element_groups');
    var Anchor = require('../symbol/anchor');
    var getAnchors = require('../symbol/get_anchors');
    var resolveTokens = require('../util/token');
    var Quads = require('../symbol/quads');
    var Shaping = require('../symbol/shaping');
    var resolveText = require('../symbol/resolve_text');
    var resolveIcons = require('../symbol/resolve_icons');
    var mergeLines = require('../symbol/mergelines');
    var shapeText = Shaping.shapeText;
    var shapeIcon = Shaping.shapeIcon;
    var getGlyphQuads = Quads.getGlyphQuads;
    var getIconQuads = Quads.getIconQuads;
    var clipLine = require('../symbol/clip_line');
    var Point = require('point-geometry');

    var CollisionFeature = require('../symbol/collision_feature');

    module.exports = SymbolBucket;

    function SymbolBucket(buffers, layoutProperties, overscaling, zoom, collisionDebug) {
        this.buffers = buffers;
        this.layoutProperties = layoutProperties;
        this.overscaling = overscaling;
        this.zoom = zoom;
        this.collisionDebug = collisionDebug;

        var tileSize = 512 * overscaling;
        var tileExtent = 4096;
        this.tilePixelRatio = tileExtent / tileSize;

        this.symbolInstances = [];

    }

    SymbolBucket.prototype.needsPlacement = true;

    SymbolBucket.prototype.addFeatures = function(collisionTile) {
        var layout = this.layoutProperties;
        var features = this.features;
        var textFeatures = this.textFeatures;

        var horizontalAlign = 0.5,
            verticalAlign = 0.5;

        switch (layout['text-anchor']) {
            case 'right':
            case 'top-right':
            case 'bottom-right':
                horizontalAlign = 1;
                break;
            case 'left':
            case 'top-left':
            case 'bottom-left':
                horizontalAlign = 0;
                break;
        }

        switch (layout['text-anchor']) {
            case 'bottom':
            case 'bottom-right':
            case 'bottom-left':
                verticalAlign = 1;
                break;
            case 'top':
            case 'top-right':
            case 'top-left':
                verticalAlign = 0;
                break;
        }

        var justify = layout['text-justify'] === 'right' ? 1 :
                layout['text-justify'] === 'left' ? 0 :
            0.5;

        var oneEm = 24;
        var lineHeight = layout['text-line-height'] * oneEm;
        var maxWidth = layout['symbol-placement'] !== 'line' ? layout['text-max-width'] * oneEm : 0;
        var spacing = layout['text-letter-spacing'] * oneEm;
        var textOffset = [layout['text-offset'][0] * oneEm, layout['text-offset'][1] * oneEm];
        var fontstack = layout['text-font'];

        var geometries = [];
        for (var g = 0; g < features.length; g++) {
            geometries.push(features[g].loadGeometry());
        }

        if (layout['symbol-placement'] === 'line') {
            // Merge adjacent lines with the same text to improve labelling.
            // It's better to place labels on one long line than on many short segments.
            var merged = mergeLines(features, textFeatures, geometries);

            geometries = merged.geometries;
            features = merged.features;
            textFeatures = merged.textFeatures;
        }

        var shapedText, shapedIcon;

        for (var k = 0; k < features.length; k++) {
            if (!geometries[k]) continue;

            if (textFeatures[k]) {
                shapedText = shapeText(textFeatures[k], this.stacks[fontstack], maxWidth,
                    lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);
            } else {
                shapedText = null;
            }

            if (layout['icon-image']) {
                var iconName = resolveTokens(features[k].properties, layout['icon-image']);
                var image = this.icons[iconName];
                shapedIcon = shapeIcon(image, layout);

                if (image) {
                    if (this.sdfIcons === undefined) {
                        this.sdfIcons = image.sdf;
                    } else if (this.sdfIcons !== image.sdf) {
                        console.warn('Style sheet warning: Cannot mix SDF and non-SDF icons in one bucket');
                    }
                }
            } else {
                shapedIcon = null;
            }

            if (shapedText || shapedIcon) {
                this.addFeature(geometries[k], shapedText, shapedIcon);
            }
        }

        this.placeFeatures(collisionTile, this.buffers, this.collisionDebug);
    };

    SymbolBucket.prototype.addFeature = function(lines, shapedText, shapedIcon) {
        var layout = this.layoutProperties;

        var glyphSize = 24;

        var fontScale = layout['text-max-size'] / glyphSize,
            textBoxScale = this.tilePixelRatio * fontScale,
            iconBoxScale = this.tilePixelRatio * layout['icon-max-size'],
            symbolMinDistance = this.tilePixelRatio * layout['symbol-min-distance'],
            avoidEdges = layout['symbol-avoid-edges'],
            textPadding = layout['text-padding'] * this.tilePixelRatio,
            iconPadding = layout['icon-padding'] * this.tilePixelRatio,
            textMaxAngle = layout['text-max-angle'] / 180 * Math.PI,
            textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
            iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
            mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
                layout['text-ignore-placement'] || layout['icon-ignore-placement'];

        if (layout['symbol-placement'] === 'line') {
            lines = clipLine(lines, 0, 0, 4096, 4096);
        }

        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];

            // Calculate the anchor points around which you want to place labels
            var anchors = layout['symbol-placement'] === 'line' ?
                getAnchors(line, symbolMinDistance, textMaxAngle, shapedText, glyphSize, textBoxScale, this.overscaling) :
                [ new Anchor(line[0].x, line[0].y, 0) ];

            // For each potential label, create the placement features used to check for collisions, and the quads use for rendering.
            for (var j = 0, len = anchors.length; j < len; j++) {
                var anchor = anchors[j];

                var inside = !(anchor.x < 0 || anchor.x > 4096 || anchor.y < 0 || anchor.y > 4096);

                if (avoidEdges && !inside) continue;

                // Normally symbol layers are drawn across tile boundaries. Only symbols
                // with their anchors within the tile boundaries are added to the buffers
                // to prevent symbols from being drawn twice.
                //
                // Symbols in layers with overlap are sorted in the y direction so that
                // symbols lower on the canvas are drawn on top of symbols near the top.
                // To preserve this order across tile boundaries these symbols can't
                // be drawn across tile boundaries. Instead they need to be included in
                // the buffers for both tiles and clipped to tile boundaries at draw time.
                var addToBuffers = inside || mayOverlap;

                this.symbolInstances.push(new SymbolInstance(anchor, line, shapedText, shapedIcon, layout, addToBuffers,
                    textBoxScale, textPadding, textAlongLine,
                    iconBoxScale, iconPadding, iconAlongLine));
            }
        }
    };

    SymbolBucket.prototype.placeFeatures = function(collisionTile, buffers, collisionDebug) {

        // Calculate which labels can be shown and when they can be shown and
        // create the bufers used for rendering.

        this.buffers = buffers;

        var elementGroups = this.elementGroups = {
            text: new ElementGroups(buffers.glyphVertex, buffers.glyphElement),
            icon: new ElementGroups(buffers.iconVertex, buffers.iconElement),
            sdfIcons: this.sdfIcons
        };

        var layout = this.layoutProperties;
        var maxScale = collisionTile.maxScale;

        var textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';
        var iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';

        var mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
            layout['text-ignore-placement'] || layout['icon-ignore-placement'];

        // Sort symbols by their y position on the canvas so that they lower symbols
        // are drawn on top of higher symbols.
        // Don't sort symbols that won't overlap because it isn't necessary and
        // because it causes more labels to pop in and out when rotating.
        if (mayOverlap) {
            var angle = collisionTile.angle;
            var sin = Math.sin(angle),
                cos = Math.cos(angle);

            this.symbolInstances.sort(function(a, b) {
                var aRotated = sin * a.x + cos * a.y;
                var bRotated = sin * b.x + cos * b.y;
                return bRotated - aRotated;
            });
        }

        for (var p = 0; p < this.symbolInstances.length; p++) {
            var symbolInstance = this.symbolInstances[p];
            var hasText = symbolInstance.hasText;
            var hasIcon = symbolInstance.hasIcon;

            var iconWithoutText = layout['text-optional'] || !hasText,
                textWithoutIcon = layout['icon-optional'] || !hasIcon;


            // Calculate the scales at which the text and icon can be placed without collision.

            var glyphScale = hasText && !layout['text-allow-overlap'] ?
                collisionTile.placeCollisionFeature(symbolInstance.textCollisionFeature) :
                collisionTile.minScale;

            var iconScale = hasIcon && !layout['icon-allow-overlap'] ?
                collisionTile.placeCollisionFeature(symbolInstance.iconCollisionFeature) :
                collisionTile.minScale;


            // Combine the scales for icons and text.

            if (!iconWithoutText && !textWithoutIcon) {
                iconScale = glyphScale = Math.max(iconScale, glyphScale);
            } else if (!textWithoutIcon && glyphScale) {
                glyphScale = Math.max(iconScale, glyphScale);
            } else if (!iconWithoutText && iconScale) {
                iconScale = Math.max(iconScale, glyphScale);
            }


            // Insert final placement into collision tree and add glyphs/icons to buffers

            if (hasText) {
                if (!layout['text-ignore-placement']) {
                    collisionTile.insertCollisionFeature(symbolInstance.textCollisionFeature, glyphScale);
                }
                if (glyphScale <= maxScale) {
                    this.addSymbols(buffers.glyphVertex, buffers.glyphElement, elementGroups.text,
                        symbolInstance.glyphQuads, glyphScale, layout['text-keep-upright'], textAlongLine,
                        collisionTile.angle);
                }
            }

            if (hasIcon) {
                if (!layout['icon-ignore-placement']) {
                    collisionTile.insertCollisionFeature(symbolInstance.iconCollisionFeature, iconScale);
                }
                if (iconScale <= maxScale) {
                    this.addSymbols(buffers.iconVertex, buffers.iconElement, elementGroups.icon,
                        symbolInstance.iconQuads, iconScale, layout['icon-keep-upright'], iconAlongLine,
                        collisionTile.angle);
                }
            }

        }

        if (collisionDebug) this.addToDebugBuffers(collisionTile);
    };

    SymbolBucket.prototype.addSymbols = function(vertex, element, elementGroups, quads, scale, keepUpright, alongLine, placementAngle) {

        elementGroups.makeRoomFor(4 * quads.length);
        var elementGroup = elementGroups.current;

        var zoom = this.zoom;
        var placementZoom = Math.max(Math.log(scale) / Math.LN2 + zoom, 0);

        for (var k = 0; k < quads.length; k++) {

            var symbol = quads[k],
                angle = symbol.angle;

            // drop upside down versions of glyphs
            var a = (angle + placementAngle + Math.PI) % (Math.PI * 2);
            if (keepUpright && alongLine && (a <= Math.PI / 2 || a > Math.PI * 3 / 2)) continue;

            var tl = symbol.tl,
                tr = symbol.tr,
                bl = symbol.bl,
                br = symbol.br,
                tex = symbol.tex,
                anchorPoint = symbol.anchorPoint,

                minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),
                maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);

            if (maxZoom <= minZoom) continue;

            // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels
            if (minZoom === placementZoom) minZoom = 0;

            var triangleIndex = vertex.index - elementGroup.vertexStartIndex;

            vertex.add(anchorPoint.x, anchorPoint.y, tl.x, tl.y, tex.x, tex.y, minZoom, maxZoom, placementZoom);
            vertex.add(anchorPoint.x, anchorPoint.y, tr.x, tr.y, tex.x + tex.w, tex.y, minZoom, maxZoom, placementZoom);
            vertex.add(anchorPoint.x, anchorPoint.y, bl.x, bl.y, tex.x, tex.y + tex.h, minZoom, maxZoom, placementZoom);
            vertex.add(anchorPoint.x, anchorPoint.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, minZoom, maxZoom, placementZoom);
            elementGroup.vertexLength += 4;

            element.add(triangleIndex, triangleIndex + 1, triangleIndex + 2);
            element.add(triangleIndex + 1, triangleIndex + 2, triangleIndex + 3);
            elementGroup.elementLength += 2;
        }

    };

    SymbolBucket.prototype.getDependencies = function(tile, actor, callback) {
        var firstdone = false;
        this.getTextDependencies(tile, actor, done);
        this.getIconDependencies(tile, actor, done);
        function done(err) {
            if (err || firstdone) return callback(err);
            firstdone = true;
        }
    };

    SymbolBucket.prototype.getIconDependencies = function(tile, actor, callback) {
        if (this.layoutProperties['icon-image']) {
            var features = this.features;
            var icons = resolveIcons(features, this.layoutProperties);

            if (icons.length) {
                actor.send('get icons', { icons: icons }, setIcons.bind(this));
            } else {
                callback();
            }
        } else {
            callback();
        }

        function setIcons(err, newicons) {
            if (err) return callback(err);
            this.icons = newicons;
            callback();
        }
    };

    SymbolBucket.prototype.getTextDependencies = function(tile, actor, callback) {
        var features = this.features;
        var fontstack = this.layoutProperties['text-font'];

        var stacks = this.stacks = tile.stacks;
        if (stacks[fontstack] === undefined) {
            stacks[fontstack] = {};
        }
        var stack = stacks[fontstack];

        var data = resolveText(features, this.layoutProperties, stack);
        this.textFeatures = data.textFeatures;

        actor.send('get glyphs', {
            uid: tile.uid,
            fontstack: fontstack,
            codepoints: data.codepoints
        }, function(err, newstack) {
            if (err) return callback(err);

            for (var codepoint in newstack) {
                stack[codepoint] = newstack[codepoint];
            }

            callback();
        });
    };

    SymbolBucket.prototype.addToDebugBuffers = function(collisionTile) {

        this.elementGroups.collisionBox = new ElementGroups(this.buffers.collisionBoxVertex);
        this.elementGroups.collisionBox.makeRoomFor(0);
        var buffer = this.buffers.collisionBoxVertex;
        var angle = -collisionTile.angle;
        var yStretch = collisionTile.yStretch;

        for (var j = 0; j < this.symbolInstances.length; j++) {
            for (var i = 0; i < 2; i++) {
                var feature = this.symbolInstances[j][i === 0 ? 'textCollisionFeature' : 'iconCollisionFeature'];
                if (!feature) continue;
                var boxes = feature.boxes;

                for (var b = 0; b < boxes.length; b++) {
                    var box = boxes[b];
                    var anchorPoint = box.anchorPoint;

                    var tl = new Point(box.x1, box.y1 * yStretch)._rotate(angle);
                    var tr = new Point(box.x2, box.y1 * yStretch)._rotate(angle);
                    var bl = new Point(box.x1, box.y2 * yStretch)._rotate(angle);
                    var br = new Point(box.x2, box.y2 * yStretch)._rotate(angle);

                    var maxZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.maxScale) / Math.LN2));
                    var placementZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.placementScale) / Math.LN2));

                    buffer.add(anchorPoint, tl, maxZoom, placementZoom);
                    buffer.add(anchorPoint, tr, maxZoom, placementZoom);
                    buffer.add(anchorPoint, tr, maxZoom, placementZoom);
                    buffer.add(anchorPoint, br, maxZoom, placementZoom);
                    buffer.add(anchorPoint, br, maxZoom, placementZoom);
                    buffer.add(anchorPoint, bl, maxZoom, placementZoom);
                    buffer.add(anchorPoint, bl, maxZoom, placementZoom);
                    buffer.add(anchorPoint, tl, maxZoom, placementZoom);

                    this.elementGroups.collisionBox.current.vertexLength += 8;
                }
            }
        }
    };

    function SymbolInstance(anchor, line, shapedText, shapedIcon, layout, addToBuffers,
                            textBoxScale, textPadding, textAlongLine,
                            iconBoxScale, iconPadding, iconAlongLine) {

        this.x = anchor.x;
        this.y = anchor.y;
        this.hasText = !!shapedText;
        this.hasIcon = !!shapedIcon;

        if (this.hasText) {
            this.glyphQuads = addToBuffers ? getGlyphQuads(anchor, shapedText, textBoxScale, line, layout, textAlongLine) : [];
            this.textCollisionFeature = new CollisionFeature(line, anchor, shapedText, textBoxScale, textPadding, textAlongLine);
        }

        if (this.hasIcon) {
            this.iconQuads = addToBuffers ? getIconQuads(anchor, shapedIcon, iconBoxScale, line, layout, iconAlongLine) : [];
            this.iconCollisionFeature = new CollisionFeature(line, anchor, shapedIcon, iconBoxScale, iconPadding, iconAlongLine);
        }
    }

},{"../symbol/anchor":59,"../symbol/clip_line":62,"../symbol/collision_feature":64,"../symbol/get_anchors":66,"../symbol/mergelines":69,"../symbol/quads":70,"../symbol/resolve_icons":71,"../symbol/resolve_text":72,"../symbol/shaping":73,"../util/token":102,"./element_groups":12,"point-geometry":150}],17:[function(require,module,exports){
    'use strict';

    module.exports = Coordinate;

    /**
     * A coordinate is a column, row, zoom combination, often used
     * as the data component of a tile.
     *
     * @param {number} column
     * @param {number} row
     * @param {number} zoom
     * @private
     */
    function Coordinate(column, row, zoom) {
        this.column = column;
        this.row = row;
        this.zoom = zoom;
    }

    Coordinate.prototype = {

        /**
         * Create a clone of this coordinate that can be mutated without
         * changing the original coordinate
         *
         * @returns {Coordinate} clone
         * @private
         * var coord = new Coordinate(0, 0, 0);
         * var c2 = coord.clone();
         * // since coord is cloned, modifying a property of c2 does
         * // not modify it.
         * c2.zoom = 2;
         */
        clone: function() {
            return new Coordinate(this.column, this.row, this.zoom);
        },

        /**
         * Zoom this coordinate to a given zoom level. This returns a new
         * coordinate object, not mutating the old one.
         *
         * @param {number} zoom
         * @returns {Coordinate} zoomed coordinate
         * @private
         * @example
         * var coord = new Coordinate(0, 0, 0);
         * var c2 = coord.zoomTo(1);
         * c2 // equals new Coordinate(0, 0, 1);
         */
        zoomTo: function(zoom) { return this.clone()._zoomTo(zoom); },

        /**
         * Subtract the column and row values of this coordinate from those
         * of another coordinate. The other coordinat will be zoomed to the
         * same level as `this` before the subtraction occurs
         *
         * @param {Coordinate} c other coordinate
         * @returns {Coordinate} result
         * @private
         */
        sub: function(c) { return this.clone()._sub(c); },

        _zoomTo: function(zoom) {
            var scale = Math.pow(2, zoom - this.zoom);
            this.column *= scale;
            this.row *= scale;
            this.zoom = zoom;
            return this;
        },

        _sub: function(c) {
            c = c.zoomTo(this.zoom);
            this.column -= c.column;
            this.row -= c.row;
            return this;
        }
    };

},{}],18:[function(require,module,exports){
    'use strict';

    module.exports = LatLng;

    var wrap = require('../util/util').wrap;

    /**
     * Create a latitude, longitude object from a given latitude and longitude pair in degrees.
     *
     * @class LatLng
     * @classdesc A representation of a latitude and longitude point, in degrees.
     * @param {number} lat latitude
     * @param {number} lng longitude
     * @example
     * var latlng = new mapboxgl.LatLng(37.76, -122.44);
     */
    function LatLng(lat, lng) {
        if (isNaN(lat) || isNaN(lng)) {
            throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
        }
        this.lat = +lat;
        this.lng = +lng;
    }

    /**
     * Return a new `LatLng` object whose longitude is wrapped to the range (-180, 180).
     *
     * @returns {LatLng} wrapped LatLng object
     * @example
     * var point = mapboxgl.LatLng(0, 200);
     * var wrapped = point.wrap();
     * wrapped.lng; // = -160
     */
    LatLng.prototype.wrap = function () {
        return new LatLng(this.lat, wrap(this.lng, -180, 180));
    };

    /**
     * Convert an array to a `LatLng` object, or return an existing `LatLng` object
     * unchanged.
     *
     * @param {Array<number>|LatLng} input `input` to convert
     * @returns {LatLng} LatLng object or original input
     * @example
     * var ll = mapboxgl.LatLng.convert([10, 10]);
     * var ll2 = new mapboxgl.LatLng(10, 10);
     * ll // = ll2
     */
    LatLng.convert = function (input) {
        if (input instanceof LatLng) {
            return input;
        }
        if (Array.isArray(input)) {
            return new LatLng(input[0], input[1]);
        }
        return input;
    };

},{"../util/util":103}],19:[function(require,module,exports){
    'use strict';

    module.exports = LatLngBounds;

    var LatLng = require('./lat_lng');

    /**
     * Creates a bounding box from the given pair of points. If parameteres are omitted, a `null` bounding box is created.
     *
     * @class LatLngBounds
     * @classdesc A representation of rectangular box on the earth, defined by its southwest and northeast points in latitude and longitude.
     * @param {LatLng} sw southwest
     * @param {LatLng} ne northeast
     * @example
     * var sw = new mapboxgl.LatLng(0, 0);
     * var ne = new mapboxgl.LatLng(10, -10);
     * var bounds = new mapboxgl.LatLngBounds(sw, ne);
     *
     */
    function LatLngBounds(sw, ne) {
        if (!sw) return;

        var latlngs = ne ? [sw, ne] : sw;

        for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
        }
    }

    LatLngBounds.prototype = {

        /**
         * Extend the bounds to include a given LatLng or LatLngBounds.
         *
         * @param {LatLng|LatLngBounds} obj object to extend to
         * @returns {LatLngBounds} `this`
         */
        extend: function(obj) {
            var sw = this._sw,
                ne = this._ne,
                sw2, ne2;

            if (obj instanceof LatLng) {
                sw2 = obj;
                ne2 = obj;

            } else if (obj instanceof LatLngBounds) {
                sw2 = obj._sw;
                ne2 = obj._ne;

                if (!sw2 || !ne2) return this;

            } else {
                return obj ? this.extend(LatLng.convert(obj) || LatLngBounds.convert(obj)) : this;
            }

            if (!sw && !ne) {
                this._sw = new LatLng(sw2.lat, sw2.lng);
                this._ne = new LatLng(ne2.lat, ne2.lng);

            } else {
                sw.lat = Math.min(sw2.lat, sw.lat);
                sw.lng = Math.min(sw2.lng, sw.lng);
                ne.lat = Math.max(ne2.lat, ne.lat);
                ne.lng = Math.max(ne2.lng, ne.lng);
            }

            return this;
        },

        /**
         * Get the point equidistant from this box's corners
         * @returns {LatLng} centerpoint
         * @example
         * var bounds = new mapboxgl.LatLngBounds(
         *   new mapboxgl.LatLng(10, 10),
         *   new mapboxgl.LatLng(-10, -10);
         * bounds.getCenter(); // equals mapboxgl.LatLng(0, 0)
         */
        getCenter: function() {
            return new LatLng((this._sw.lat + this._ne.lat) / 2, (this._sw.lng + this._ne.lng) / 2);
        },

        /**
         * Get southwest corner
         * @returns {LatLng} southwest
         */
        getSouthWest: function() { return this._sw; },

        /**
         * Get northeast corner
         * @returns {LatLng} northeast
         */
        getNorthEast: function() { return this._ne; },

        /**
         * Get northwest corner
         * @returns {LatLng} northwest
         */
        getNorthWest: function() { return new LatLng(this.getNorth(), this.getWest()); },

        /**
         * Get southeast corner
         * @returns {LatLng} southeast
         */
        getSouthEast: function() { return new LatLng(this.getSouth(), this.getEast()); },

        /**
         * Get west edge longitude
         * @returns {number} west
         */
        getWest:  function() { return this._sw.lng; },

        /**
         * Get south edge latitude
         * @returns {number} south
         */
        getSouth: function() { return this._sw.lat; },

        /**
         * Get east edge longitude
         * @returns {number} east
         */
        getEast:  function() { return this._ne.lng; },

        /**
         * Get north edge latitude
         * @returns {number} north
         */
        getNorth: function() { return this._ne.lat; }
    };

    /**
     * constructs LatLngBounds from an array if necessary
     * @param {LatLngBounds|*} a any input
     * @returns {LatLngBounds|false}
     * @example
     * // calls LatLng.convert internally to
     * // support arrays as latlng values
     * LatLngBounds.convert([[-10, -10], [10, 10]]);
     */
    LatLngBounds.convert = function (a) {
        if (!a || a instanceof LatLngBounds) return a;
        return new LatLngBounds(a);
    };

},{"./lat_lng":18}],20:[function(require,module,exports){
    'use strict';

    var LatLng = require('./lat_lng'),
        Point = require('point-geometry'),
        Coordinate = require('./coordinate'),
        wrap = require('../util/util').wrap,
        interp = require('../util/interpolate'),
        vec4 = require('gl-matrix').vec4,
        mat4 = require('gl-matrix').mat4;

    module.exports = Transform;

    /*
     * A single transform, generally used for a single tile to be
     * scaled, rotated, and zoomed.
     *
     * @param {number} minZoom
     * @param {number} maxZoom
     * @private
     */
    function Transform(minZoom, maxZoom) {
        this.tileSize = 512; // constant

        this._minZoom = minZoom || 0;
        this._maxZoom = maxZoom || 22;

        this.latRange = [-85.05113, 85.05113];

        this.width = 0;
        this.height = 0;
        this.zoom = 0;
        this.center = new LatLng(0, 0);
        this.angle = 0;
        this._altitude = 1.5;
        this._pitch = 0;
    }

    Transform.prototype = {
        get minZoom() { return this._minZoom; },
        set minZoom(zoom) {
            this._minZoom = zoom;
            this.zoom = Math.max(this.zoom, zoom);
        },

        get maxZoom() { return this._maxZoom; },
        set maxZoom(zoom) {
            this._maxZoom = zoom;
            this.zoom = Math.min(this.zoom, zoom);
        },

        get worldSize() {
            return this.tileSize * this.scale;
        },

        get centerPoint() {
            return this.size._div(2);
        },

        get size() {
            return new Point(this.width, this.height);
        },

        get bearing() {
            return -this.angle / Math.PI * 180;
        },
        set bearing(bearing) {
            this.angle = -wrap(bearing, -180, 180) * Math.PI / 180;
        },

        get pitch() {
            return this._pitch / Math.PI * 180;
        },
        set pitch(pitch) {
            this._pitch = Math.min(60, pitch) / 180 * Math.PI;
        },

        get altitude() {
            return this._altitude;
        },
        set altitude(altitude) {
            this._altitude = Math.max(0.75, altitude);
        },

        get zoom() { return this._zoom; },
        set zoom(zoom) {
            zoom = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
            this._zoom = zoom;
            this.scale = this.zoomScale(zoom);
            this.tileZoom = Math.floor(zoom);
            this.zoomFraction = zoom - this.tileZoom;
            this._constrain();
        },

        zoomScale: function(zoom) { return Math.pow(2, zoom); },
        scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },

        project: function(latlng, worldSize) {
            return new Point(
                this.lngX(latlng.lng, worldSize),
                this.latY(latlng.lat, worldSize));
        },

        unproject: function(point, worldSize) {
            return new LatLng(
                this.yLat(point.y, worldSize),
                this.xLng(point.x, worldSize));
        },

        get x() { return this.lngX(this.center.lng); },
        get y() { return this.latY(this.center.lat); },

        get point() { return new Point(this.x, this.y); },

        /**
         * lat/lon <-> absolute pixel coords conversion
         * @param {number} lon
         * @param {number} [worldSize=this.worldSize]
         * @returns {number} pixel coordinate
         * @private
         */
        lngX: function(lon, worldSize) {
            return (180 + lon) * (worldSize || this.worldSize) / 360;
        },
        /**
         * latitude to absolute y coord
         *
         * @param {number} lat
         * @param {number} [worldSize=this.worldSize]
         * @returns {number} pixel coordinate
         * @private
         */
        latY: function(lat, worldSize) {
            var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
            return (180 - y) * (worldSize || this.worldSize) / 360;
        },

        xLng: function(x, worldSize) {
            return x * 360 / (worldSize || this.worldSize) - 180;
        },
        yLat: function(y, worldSize) {
            var y2 = 180 - y * 360 / (worldSize || this.worldSize);
            return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
        },

        panBy: function(offset) {
            var point = this.centerPoint._add(offset);
            this.center = this.pointLocation(point);
            this._constrain();
        },

        setLocationAtPoint: function(latlng, point) {
            var c = this.locationCoordinate(latlng);
            var coordAtPoint = this.pointCoordinate(point);
            var coordCenter = this.pointCoordinate(this.centerPoint);

            var translate = coordAtPoint._sub(c);
            this.center = this.coordinateLocation(coordCenter._sub(translate));

            this._constrain();
        },

        setZoomAround: function(zoom, center) {
            var p;
            if (center) p = this.locationPoint(center);
            this.zoom = zoom;
            if (center) this.setLocationAtPoint(center, p);
        },

        setBearingAround: function(bearing, center) {
            var p;
            if (center) p = this.locationPoint(center);
            this.bearing = bearing;
            if (center) this.setLocationAtPoint(center, p);
        },

        /**
         * Given a location, return the screen point that corresponds to it
         * @param {LatLng} latlng location
         * @returns {Point} screen point
         * @private
         */
        locationPoint: function(latlng) {
            return this.coordinatePoint(this.locationCoordinate(latlng));
        },

        /**
         * Given a point on screen, return its latlng
         * @param {Point} p screen point
         * @returns {LatLng} latlng location
         * @private
         */
        pointLocation: function(p) {
            return this.coordinateLocation(this.pointCoordinate(p));
        },

        /**
         * Given a geographical latlng, return an unrounded
         * coordinate that represents it at this transform's zoom level and
         * worldsize.
         * @param {LatLng} latlng
         * @returns {Coordinate}
         * @private
         */
        locationCoordinate: function(latlng) {
            var k = this.zoomScale(this.tileZoom) / this.worldSize;
            return new Coordinate(
                    this.lngX(latlng.lng) * k,
                    this.latY(latlng.lat) * k,
                this.tileZoom);
        },

        /**
         * Given a Coordinate, return its geographical position.
         * @param {Coordinate} coord
         * @returns {LatLng} latlng
         * @private
         */
        coordinateLocation: function(coord) {
            var worldSize = this.zoomScale(coord.zoom);
            return new LatLng(
                this.yLat(coord.row, worldSize),
                this.xLng(coord.column, worldSize));
        },

        pointCoordinate: function(p, targetZ) {

            if (targetZ === undefined) targetZ = 0;

            var matrix = this.coordinatePointMatrix(this.tileZoom);
            var inverted = mat4.invert(new Float64Array(16), matrix);

            if (!inverted) throw "failed to invert matrix";

            // since we don't know the correct projected z value for the point,
            // unproject two points to get a line and then find the point on that
            // line with z=0

            var coord0 = vec4.transformMat4([], [p.x, p.y, 0, 1], inverted);
            var coord1 = vec4.transformMat4([], [p.x, p.y, 1, 1], inverted);

            var w0 = coord0[3];
            var w1 = coord1[3];
            var x0 = coord0[0] / w0;
            var x1 = coord1[0] / w1;
            var y0 = coord0[1] / w0;
            var y1 = coord1[1] / w1;
            var z0 = coord0[2] / w0;
            var z1 = coord1[2] / w1;


            var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);

            return new Coordinate(
                interp(x0, x1, t),
                interp(y0, y1, t),
                this.tileZoom);
        },

        /**
         * Given a coordinate, return the screen point that corresponds to it
         * @param {Coordinate} coord
         * @returns {Point} screen point
         * @private
         */
        coordinatePoint: function(coord) {
            var matrix = this.coordinatePointMatrix(coord.zoom);
            var p = vec4.transformMat4([], [coord.column, coord.row, 0, 1], matrix);
            return new Point(p[0] / p[3], p[1] / p[3]);
        },

        coordinatePointMatrix: function(z) {
            var proj = this.getProjMatrix();
            var scale = this.worldSize / this.zoomScale(z);
            mat4.scale(proj, proj, [scale, scale, 1]);
            mat4.multiply(proj, this.getPixelMatrix(), proj);
            return proj;
        },

        /**
         * converts gl coordinates -1..1 to pixels 0..width
         * @returns {Object} matrix
         * @private
         */
        getPixelMatrix: function() {
            var m = mat4.create();
            mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
            mat4.translate(m, m, [1, -1, 0]);
            return m;
        },

        _constrain: function() {
            if (!this.center) return;

            var minY, maxY, minX, maxX, sy, sx, x2, y2,
                size = this.size;

            if (this.latRange) {
                minY = this.latY(this.latRange[1]);
                maxY = this.latY(this.latRange[0]);
                sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
            }

            if (this.lngRange) {
                minX = this.lngX(this.lngRange[0]);
                maxX = this.lngX(this.lngRange[1]);
                sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
            }

            // how much the map should scale to fit the screen into given latitude/longitude ranges
            var s = Math.max(sx || 0, sy || 0);

            if (s) {
                this.center = this.unproject(new Point(
                    sx ? (maxX + minX) / 2 : this.x,
                    sy ? (maxY + minY) / 2 : this.y));
                this.zoom += this.scaleZoom(s);
                return;
            }

            if (this.latRange) {
                var y = this.y,
                    h2 = size.y / 2;

                if (y - h2 < minY) y2 = minY + h2;
                if (y + h2 > maxY) y2 = maxY - h2;
            }

            if (this.lngRange) {
                var x = this.x,
                    w2 = size.x / 2;

                if (x - w2 < minX) x2 = minX + w2;
                if (x + w2 > maxX) x2 = maxX - w2;
            }

            // pan the map if the screen goes off the range
            if (x2 !== undefined || y2 !== undefined) {
                this.center = this.unproject(new Point(
                        x2 !== undefined ? x2 : this.x,
                        y2 !== undefined ? y2 : this.y));
            }
        },

        getProjMatrix: function() {
            var m = new Float64Array(16);

            // Find the distance from the center point to the center top in altitude units using law of sines.
            var halfFov = Math.atan(0.5 / this.altitude);
            var topHalfSurfaceDistance = Math.sin(halfFov) * this.altitude / Math.sin(Math.PI / 2 - this._pitch - halfFov);
            // Calculate z value of the farthest fragment that should be rendered.
            var farZ = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.altitude;

            mat4.perspective(m, 2 * Math.atan((this.height / 2) / this.altitude), this.width / this.height, 0.1, farZ);

            mat4.translate(m, m, [0, 0, -this.altitude]);

            // After the rotateX, z values are in pixel units. Convert them to
            // altitude unites. 1 altitude unit = the screen height.
            mat4.scale(m, m, [1, -1, 1 / this.height]);

            mat4.rotateX(m, m, this._pitch);
            mat4.rotateZ(m, m, this.angle);
            mat4.translate(m, m, [-this.x, -this.y, 0]);
            return m;
        }
    };

},{"../util/interpolate":99,"../util/util":103,"./coordinate":17,"./lat_lng":18,"gl-matrix":116,"point-geometry":150}],21:[function(require,module,exports){
    'use strict';

// Font data From Hershey Simplex Font
// http://paulbourke.net/dataformats/hershey/
    var simplexFont = {
        " ": [16, []],
        "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        "\"": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],
        "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],
        "$": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
        "%": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],
        "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],
        "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
        "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],
        ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],
        "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],
        "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],
        ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
        "-": [26, [4, 9, 22, 9]],
        ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        "/": [22, [20, 25, 2, -7]],
        "0": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],
        "1": [20, [6, 17, 8, 18, 11, 21, 11, 0]],
        "2": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
        "3": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
        "4": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
        "5": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
        "6": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],
        "7": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
        "8": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],
        "9": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],
        ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
        "<": [24, [20, 18, 4, 9, 20, 0]],
        "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],
        ">": [24, [4, 18, 20, 9, 4, 0]],
        "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],
        "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],
        "A": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],
        "B": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],
        "C": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],
        "D": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],
        "E": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],
        "F": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],
        "G": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],
        "H": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],
        "I": [8, [4, 21, 4, 0]],
        "J": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
        "K": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],
        "L": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],
        "M": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],
        "N": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],
        "O": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],
        "P": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
        "Q": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],
        "R": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],
        "S": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
        "T": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],
        "U": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
        "V": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],
        "W": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],
        "X": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],
        "Y": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],
        "Z": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],
        "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],
        "\\": [14, [0, 21, 14, -3]],
        "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],
        "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],
        "_": [16, [0, -2, 16, -2]],
        "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
        "a": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "b": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
        "c": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "d": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "e": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "f": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],
        "g": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "h": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
        "i": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],
        "j": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],
        "k": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
        "l": [8, [4, 21, 4, 0]],
        "m": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],
        "n": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
        "o": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],
        "p": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
        "q": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        "r": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
        "s": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],
        "t": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],
        "u": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],
        "v": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],
        "w": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],
        "x": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],
        "y": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],
        "z": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],
        "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],
        "|": [8, [4, 25, 4, -7]],
        "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],
        "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]
    };

    module.exports = function textVertices(text, left, baseline, scale) {
        scale = scale || 1;

        var strokes = [],
            i, len, j, len2, glyph, x, y, prev;

        for (i = 0, len = text.length; i < len; i++) {
            glyph = simplexFont[text[i]];
            if (!glyph) continue;
            prev = null;

            for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {
                if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {
                    prev = null;

                } else {
                    x = left + glyph[1][j] * scale;
                    y = baseline - glyph[1][j + 1] * scale;
                    if (prev) {
                        strokes.push(prev.x, prev.y, x, y);
                    }
                    prev = {x: x, y: y};
                }
            }
            left += glyph[0] * scale;
        }

        return strokes;
    };

},{}],22:[function(require,module,exports){
    'use strict';

    /**
     * mapboxgl is a A WebGL JavaScript interactive maps library that can render
     * [Mapbox vector tiles](https://www.mapbox.com/blog/vector-tiles/).
     *
     * @module mapboxgl
     * @summary WebGL JavaScript map library
     */

// jshint -W079
    var mapboxgl = module.exports = {};

    mapboxgl.Map = require('./ui/map');
    mapboxgl.Navigation = require('./ui/control/navigation');
    mapboxgl.Attribution = require('./ui/control/attribution');
    mapboxgl.Popup = require('./ui/popup');

    mapboxgl.GeoJSONSource = require('./source/geojson_source');
    mapboxgl.VideoSource = require('./source/video_source');

    mapboxgl.Style = require('./style/style');

    mapboxgl.LatLng = require('./geo/lat_lng');
    mapboxgl.LatLngBounds = require('./geo/lat_lng_bounds');
    mapboxgl.Point = require('point-geometry');

    mapboxgl.Evented = require('./util/evented');
    mapboxgl.util = require('./util/util');

    mapboxgl.supported = require('./util/browser').supported;

    var ajax = require('./util/ajax');
    mapboxgl.util.getJSON = ajax.getJSON;
    mapboxgl.util.getArrayBuffer = ajax.getArrayBuffer;

    var config = require('./util/config');
    mapboxgl.config = config;

    Object.defineProperty(mapboxgl, 'accessToken', {
        get: function() { return config.ACCESS_TOKEN; },
        set: function(token) { config.ACCESS_TOKEN = token; }
    });

},{"./geo/lat_lng":18,"./geo/lat_lng_bounds":19,"./source/geojson_source":36,"./source/video_source":44,"./style/style":52,"./ui/control/attribution":76,"./ui/control/navigation":78,"./ui/map":88,"./ui/popup":89,"./util/ajax":91,"./util/browser":92,"./util/config":96,"./util/evented":97,"./util/util":103,"point-geometry":150}],23:[function(require,module,exports){
    'use strict';

    var mat3 = require('gl-matrix').mat3;

    module.exports = drawBackground;

    function drawBackground(painter, layer, posMatrix) {
        var gl = painter.gl;
        var color = layer.paint['background-color'];
        var image = layer.paint['background-image'];
        var opacity = layer.paint['background-opacity'];
        var shader;

        var imagePosA = image ? painter.spriteAtlas.getPosition(image.from, true) : null;
        var imagePosB = image ? painter.spriteAtlas.getPosition(image.to, true) : null;

        if (imagePosA && imagePosB) {
            // Draw texture fill
            shader = painter.patternShader;
            gl.switchShader(shader, posMatrix);
            gl.uniform1i(shader.u_image, 0);
            gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
            gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
            gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
            gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
            gl.uniform1f(shader.u_opacity, opacity);

            var transform = painter.transform;
            var sizeA = imagePosA.size;
            var sizeB = imagePosB.size;
            var center = transform.locationCoordinate(transform.center);
            var scale = 1 / Math.pow(2, transform.zoomFraction);

            gl.uniform1f(shader.u_mix, image.t);

            var matrixA = mat3.create();
            mat3.scale(matrixA, matrixA, [
                    1 / (sizeA[0] * image.fromScale),
                    1 / (sizeA[1] * image.fromScale)
            ]);
            mat3.translate(matrixA, matrixA, [
                    (center.column * transform.tileSize) % (sizeA[0] * image.fromScale),
                    (center.row    * transform.tileSize) % (sizeA[1] * image.fromScale)
            ]);
            mat3.rotate(matrixA, matrixA, -transform.angle);
            mat3.scale(matrixA, matrixA, [
                    scale * transform.width  / 2,
                    -scale * transform.height / 2
            ]);

            var matrixB = mat3.create();
            mat3.scale(matrixB, matrixB, [
                    1 / (sizeB[0] * image.toScale),
                    1 / (sizeB[1] * image.toScale)
            ]);
            mat3.translate(matrixB, matrixB, [
                    (center.column * transform.tileSize) % (sizeB[0] * image.toScale),
                    (center.row    * transform.tileSize) % (sizeB[1] * image.toScale)
            ]);
            mat3.rotate(matrixB, matrixB, -transform.angle);
            mat3.scale(matrixB, matrixB, [
                    scale * transform.width  / 2,
                    -scale * transform.height / 2
            ]);

            gl.uniformMatrix3fv(shader.u_patternmatrix_a, false, matrixA);
            gl.uniformMatrix3fv(shader.u_patternmatrix_b, false, matrixB);

            painter.spriteAtlas.bind(gl, true);

        } else {
            // Draw filling rectangle.
            shader = painter.fillShader;
            gl.switchShader(shader, posMatrix);
            gl.disableVertexAttribArray(shader.a_color);
            gl.vertexAttrib4fv(shader.a_color, color);
        }

        gl.disable(gl.STENCIL_TEST);
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.backgroundBuffer);
        gl.vertexAttribPointer(shader.a_pos, painter.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.backgroundBuffer.itemCount);
        gl.enable(gl.STENCIL_TEST);

        gl.stencilMask(0x00);
        gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
    }

},{"gl-matrix":116}],24:[function(require,module,exports){
    'use strict';

    module.exports = drawPlacementDebug;

    function drawPlacementDebug(painter, layer, posMatrix, tile) {

        var elementGroups = tile.elementGroups[layer.ref || layer.id].collisionBox;
        if (!elementGroups) return;

        var gl = painter.gl;
        var buffer = tile.buffers.collisionBoxVertex;
        var shader = painter.collisionBoxShader;

        gl.enable(gl.STENCIL_TEST);

        gl.switchShader(shader, posMatrix);
        buffer.bind(gl, shader);
        gl.lineWidth(1);

        var stride = 12;
        gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, stride, 0);
        gl.vertexAttribPointer(shader.a_extrude, 2, gl.SHORT, false, stride, 4);
        gl.vertexAttribPointer(shader.a_data, 2, gl.UNSIGNED_BYTE, false, stride, 8);

        gl.uniform1f(shader.u_scale, Math.pow(2, painter.transform.zoom - tile.coord.z));
        gl.uniform1f(shader.u_zoom, painter.transform.zoom * 10);
        gl.uniform1f(shader.u_maxzoom, (tile.coord.z + 1) * 10);

        var begin = elementGroups.groups[0].vertexStartIndex;
        var len = elementGroups.groups[0].vertexLength;
        gl.drawArrays(gl.LINES, begin, len);

        gl.disable(gl.STENCIL_TEST);
    }

},{}],25:[function(require,module,exports){
    'use strict';

    var textVertices = require('../lib/debugtext');
    var browser = require('../util/browser');

    module.exports = drawDebug;

    function drawDebug(painter, tile) {
        var gl = painter.gl;

        // Blend to the front, not the back.
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        gl.switchShader(painter.debugShader, tile.posMatrix);

        // draw bounding rectangle
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugBuffer);
        gl.vertexAttribPointer(painter.debugShader.a_pos, painter.debugBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.uniform4f(painter.debugShader.u_color, 1, 0, 0, 1);
        gl.lineWidth(4);
        gl.drawArrays(gl.LINE_STRIP, 0, painter.debugBuffer.itemCount);

        var vertices = textVertices(tile.coord.toString(), 50, 200, 5);

        gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugTextBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Int16Array(vertices), gl.STREAM_DRAW);
        gl.vertexAttribPointer(painter.debugShader.a_pos, painter.debugTextBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.lineWidth(8 * browser.devicePixelRatio);
        gl.uniform4f(painter.debugShader.u_color, 1, 1, 1, 1);
        gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
        gl.lineWidth(2 * browser.devicePixelRatio);
        gl.uniform4f(painter.debugShader.u_color, 0, 0, 0, 1);
        gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);

        // Revert blending mode to blend to the back.
        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
    }

},{"../lib/debugtext":21,"../util/browser":92}],26:[function(require,module,exports){
    'use strict';

    var browser = require('../util/browser');
    var mat3 = require('gl-matrix').mat3;

    module.exports = drawFill;

    function drawFill(painter, layer, posMatrix, tile) {
        // No data
        if (!tile.buffers) return;
        var elementGroups = tile.elementGroups[layer.ref || layer.id];
        if (!elementGroups) return;

        var gl = painter.gl;
        var translatedPosMatrix = painter.translateMatrix(posMatrix, tile, layer.paint['fill-translate'], layer.paint['fill-translate-anchor']);

        var color = layer.paint['fill-color'];

        var vertex, elements, group, count;

        // Draw the stencil mask.

        // We're only drawing to the first seven bits (== support a maximum of
        // 127 overlapping polygons in one place before we get rendering errors).
        gl.stencilMask(0x3F);
        gl.clear(gl.STENCIL_BUFFER_BIT);

        // Draw front facing triangles. Wherever the 0x80 bit is 1, we are
        // increasing the lower 7 bits by one if the triangle is a front-facing
        // triangle. This means that all visible polygons should be in CCW
        // orientation, while all holes (see below) are in CW orientation.
        gl.stencilFunc(gl.NOTEQUAL, 0x80, 0x80);

        // When we do a nonzero fill, we count the number of times a pixel is
        // covered by a counterclockwise polygon, and subtract the number of
        // times it is "uncovered" by a clockwise polygon.
        gl.stencilOpSeparate(gl.FRONT, gl.INCR_WRAP, gl.KEEP, gl.KEEP);
        gl.stencilOpSeparate(gl.BACK, gl.DECR_WRAP, gl.KEEP, gl.KEEP);

        // When drawing a shape, we first draw all shapes to the stencil buffer
        // and incrementing all areas where polygons are
        gl.colorMask(false, false, false, false);

        // Draw the actual triangle fan into the stencil buffer.
        gl.switchShader(painter.fillShader, translatedPosMatrix);

        // Draw all buffers
        vertex = tile.buffers.fillVertex;
        vertex.bind(gl);
        elements = tile.buffers.fillElement;
        elements.bind(gl);

        var offset, elementOffset;

        gl.disableVertexAttribArray(painter.fillShader.a_color);

        for (var i = 0; i < elementGroups.groups.length; i++) {
            group = elementGroups.groups[i];
            offset = group.vertexStartIndex * vertex.itemSize;
            gl.vertexAttribPointer(painter.fillShader.a_pos, 2, gl.SHORT, false, 4, offset + 0);

            count = group.elementLength * 3;
            elementOffset = group.elementStartIndex * elements.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }

        // Now that we have the stencil mask in the stencil buffer, we can start
        // writing to the color buffer.
        gl.colorMask(true, true, true, true);

        // From now on, we don't want to update the stencil buffer anymore.
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMask(0x0);

        var strokeColor = layer.paint['fill-outline-color'];

        // Because we're drawing top-to-bottom, and we update the stencil mask
        // below, we have to draw the outline first (!)
        if (layer.paint['fill-antialias'] === true && !(layer.paint['fill-image'] && !strokeColor)) {
            gl.switchShader(painter.outlineShader, translatedPosMatrix);
            gl.lineWidth(2 * browser.devicePixelRatio);

            if (strokeColor) {
                // If we defined a different color for the fill outline, we are
                // going to ignore the bits in 0x3F and just care about the global
                // clipping mask.
                gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
            } else {
                // Otherwise, we only want to draw the antialiased parts that are
                // *outside* the current shape. This is important in case the fill
                // or stroke color is translucent. If we wouldn't clip to outside
                // the current shape, some pixels from the outline stroke overlapped
                // the (non-antialiased) fill.
                gl.stencilFunc(gl.EQUAL, 0x80, 0xBF);
            }

            gl.uniform2f(painter.outlineShader.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);

            // Draw all buffers
            vertex = tile.buffers.fillVertex;
            elements = tile.buffers.outlineElement;
            elements.bind(gl);

            gl.disableVertexAttribArray(painter.outlineShader.a_color);
            gl.vertexAttrib4fv(painter.outlineShader.a_color, strokeColor ? strokeColor : color);

            for (var k = 0; k < elementGroups.groups.length; k++) {
                group = elementGroups.groups[k];
                offset = group.vertexStartIndex * vertex.itemSize;
                gl.vertexAttribPointer(painter.outlineShader.a_pos, 2, gl.SHORT, false, 4, offset + 0);

                count = group.secondElementLength * 2;
                elementOffset = group.secondElementStartIndex * elements.itemSize;
                gl.drawElements(gl.LINES, count, gl.UNSIGNED_SHORT, elementOffset);
            }
        }

        var image = layer.paint['fill-image'];
        var opacity = layer.paint['fill-opacity'] || 1;
        var shader;

        if (image) {
            // Draw texture fill
            var imagePosA = painter.spriteAtlas.getPosition(image.from, true);
            var imagePosB = painter.spriteAtlas.getPosition(image.to, true);
            if (!imagePosA || !imagePosB) return;

            shader = painter.patternShader;
            gl.switchShader(shader, posMatrix);
            gl.uniform1i(shader.u_image, 0);
            gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
            gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
            gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
            gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
            gl.uniform1f(shader.u_opacity, opacity);
            gl.uniform1f(shader.u_mix, image.t);

            var factor = (tile.tileExtent / tile.tileSize) / Math.pow(2, painter.transform.tileZoom - tile.coord.z);

            var matrixA = mat3.create();
            mat3.scale(matrixA, matrixA, [
                    1 / (imagePosA.size[0] * factor * image.fromScale),
                    1 / (imagePosA.size[1] * factor * image.fromScale)
            ]);

            var matrixB = mat3.create();
            mat3.scale(matrixB, matrixB, [
                    1 / (imagePosB.size[0] * factor * image.toScale),
                    1 / (imagePosB.size[1] * factor * image.toScale)
            ]);

            gl.uniformMatrix3fv(shader.u_patternmatrix_a, false, matrixA);
            gl.uniformMatrix3fv(shader.u_patternmatrix_b, false, matrixB);

            painter.spriteAtlas.bind(gl, true);

        } else {
            // Draw filling rectangle.
            shader = painter.fillShader;
            gl.switchShader(shader, posMatrix);
            gl.disableVertexAttribArray(shader.a_color);
            gl.vertexAttrib4fv(shader.a_color, color);
        }

        // Only draw regions that we marked
        gl.stencilFunc(gl.NOTEQUAL, 0x0, 0x3F);
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
        gl.vertexAttribPointer(shader.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);

        gl.stencilMask(0x00);
        gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
    }

},{"../util/browser":92,"gl-matrix":116}],27:[function(require,module,exports){
    'use strict';

    var browser = require('../util/browser');
    var mat2 = require('gl-matrix').mat2;

    /**
     * Draw a line. Under the hood this will read elements from
     * a tile, dash textures from a lineAtlas, and style properties from a layer.
     * @param {Object} painter
     * @param {Object} layer
     * @param {Object} posMatrix
     * @param {Tile} tile
     * @returns {undefined} draws with the painter
     * @private
     */
    module.exports = function drawLine(painter, layer, posMatrix, tile) {
        // No data
        if (!tile.buffers) return;
        var elementGroups = tile.elementGroups[layer.ref || layer.id];
        if (!elementGroups) return;

        var gl = painter.gl;

        // don't draw zero-width lines
        if (layer.paint['line-width'] <= 0) return;

        // the distance over which the line edge fades out.
        // Retina devices need a smaller distance to avoid aliasing.
        var antialiasing = 1 / browser.devicePixelRatio;

        var blur = layer.paint['line-blur'] + antialiasing;
        var edgeWidth = layer.paint['line-width'] / 2;
        var inset = -1;
        var offset = 0;
        var shift = 0;

        if (layer.paint['line-gap-width'] > 0) {
            inset = layer.paint['line-gap-width'] / 2 + antialiasing * 0.5;
            edgeWidth = layer.paint['line-width'];

            // shift outer lines half a pixel towards the middle to eliminate the crack
            offset = inset - antialiasing / 2;
        }

        var outset = offset + edgeWidth + antialiasing / 2 + shift;

        var color = layer.paint['line-color'];
        var ratio = painter.transform.scale / (1 << tile.coord.z) / (tile.tileExtent / tile.tileSize);
        var vtxMatrix = painter.translateMatrix(posMatrix, tile, layer.paint['line-translate'], layer.paint['line-translate-anchor']);

        var tr = painter.transform;


        var antialiasingMatrix = mat2.create();
        mat2.scale(antialiasingMatrix, antialiasingMatrix, [1, Math.cos(tr._pitch)]);
        mat2.rotate(antialiasingMatrix, antialiasingMatrix, painter.transform.angle);

        // calculate how much longer the real world distance is at the top of the screen
        // than at the middle of the screen.
        var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
        var x = tr.height / 2 * Math.tan(tr._pitch);
        var extra = (topedgelength + x) / topedgelength - 1;

        // how much the tile is overscaled by
        var overscaling = tile.tileSize / painter.transform.tileSize;

        var shader;


        var dasharray = layer.paint['line-dasharray'];
        var image = layer.paint['line-image'];

        if (dasharray) {

            shader = painter.linesdfpatternShader;
            gl.switchShader(shader, vtxMatrix, tile.exMatrix);

            gl.uniform1f(shader.u_ratio, ratio);

            var posA = painter.lineAtlas.getDash(dasharray.from, layer.layout['line-cap'] === 'round');
            var posB = painter.lineAtlas.getDash(dasharray.to, layer.layout['line-cap'] === 'round');
            painter.lineAtlas.bind(gl);

            var patternratio = Math.pow(2, Math.floor(Math.log(painter.transform.scale) / Math.LN2) - tile.coord.z) / 8 * overscaling;
            var scaleA = [patternratio / posA.width / dasharray.fromScale, -posA.height / 2];
            var gammaA = painter.lineAtlas.width / (dasharray.fromScale * posA.width * 256 * browser.devicePixelRatio) / 2;
            var scaleB = [patternratio / posB.width / dasharray.toScale, -posB.height / 2];
            var gammaB = painter.lineAtlas.width / (dasharray.toScale * posB.width * 256 * browser.devicePixelRatio) / 2;

            gl.uniform2fv(shader.u_patternscale_a, scaleA);
            gl.uniform1f(shader.u_tex_y_a, posA.y);
            gl.uniform2fv(shader.u_patternscale_b, scaleB);
            gl.uniform1f(shader.u_tex_y_b, posB.y);

            gl.uniform1i(shader.u_image, 0);
            gl.uniform1f(shader.u_sdfgamma, Math.max(gammaA, gammaB));
            gl.uniform1f(shader.u_mix, dasharray.t);

        } else if (image) {
            var imagePosA = painter.spriteAtlas.getPosition(image.from, true);
            var imagePosB = painter.spriteAtlas.getPosition(image.to, true);
            if (!imagePosA || !imagePosB) return;
            var factor = tile.tileExtent / tile.tileSize / Math.pow(2, painter.transform.tileZoom - tile.coord.z) * overscaling;

            painter.spriteAtlas.bind(gl, true);

            shader = painter.linepatternShader;
            gl.switchShader(shader, vtxMatrix, tile.exMatrix);

            gl.uniform1f(shader.u_ratio, ratio);

            gl.uniform2fv(shader.u_pattern_size_a, [imagePosA.size[0] * factor * image.fromScale, imagePosB.size[1] ]);
            gl.uniform2fv(shader.u_pattern_size_b, [imagePosB.size[0] * factor * image.toScale, imagePosB.size[1] ]);
            gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
            gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
            gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
            gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
            gl.uniform1f(shader.u_fade, image.t);

            gl.disableVertexAttribArray(shader.a_opacity);
            gl.vertexAttrib1f(shader.a_opacity, layer.paint['line-opacity']);

        } else {
            shader = painter.lineShader;
            gl.switchShader(shader, vtxMatrix, tile.exMatrix);

            gl.uniform1f(shader.u_ratio, ratio);
            gl.uniform1f(shader.u_extra, extra);
            gl.uniformMatrix2fv(shader.u_antialiasingmatrix, false, antialiasingMatrix);
        }

        // linepattern does not have a color attribute
        if (shader.a_color !== undefined) {
            gl.disableVertexAttribArray(shader.a_color);
            gl.vertexAttrib4fv(shader.a_color, color);
        }

        gl.disableVertexAttribArray(shader.a_linewidth);
        gl.vertexAttrib2f(shader.a_linewidth, outset, inset);

        gl.disableVertexAttribArray(shader.a_blur);
        gl.vertexAttrib1f(shader.a_blur, blur);

        var vertex = tile.buffers.lineVertex;
        vertex.bind(gl);
        var element = tile.buffers.lineElement;
        element.bind(gl);

        for (var i = 0; i < elementGroups.groups.length; i++) {
            var group = elementGroups.groups[i];
            var vtxOffset = group.vertexStartIndex * vertex.itemSize;
            gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, 8, vtxOffset + 0);
            gl.vertexAttribPointer(shader.a_data, 4, gl.BYTE, false, 8, vtxOffset + 4);

            var count = group.elementLength * 3;
            var elementOffset = group.elementStartIndex * element.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }
    };

},{"../util/browser":92,"gl-matrix":116}],28:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');

    module.exports = drawRaster;

    function drawRaster(painter, layer, posMatrix, tile) {
        var gl = painter.gl;

        gl.disable(gl.STENCIL_TEST);

        var shader = painter.rasterShader;
        gl.switchShader(shader, posMatrix);

        // color parameters
        gl.uniform1f(shader.u_brightness_low, layer.paint['raster-brightness-min']);
        gl.uniform1f(shader.u_brightness_high, layer.paint['raster-brightness-max']);
        gl.uniform1f(shader.u_saturation_factor, saturationFactor(layer.paint['raster-saturation']));
        gl.uniform1f(shader.u_contrast_factor, contrastFactor(layer.paint['raster-contrast']));
        gl.uniform3fv(shader.u_spin_weights, spinWeights(layer.paint['raster-hue-rotate']));

        var parentTile = tile.source && tile.source._pyramid.findLoadedParent(tile.coord, 0, {}),
            opacities = getOpacities(tile, parentTile, layer, painter.transform);

        var parentScaleBy, parentTL;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tile.texture);

        if (parentTile) {
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, parentTile.texture);

            parentScaleBy = Math.pow(2, parentTile.coord.z - tile.coord.z);
            parentTL = [tile.coord.x * parentScaleBy % 1, tile.coord.y * parentScaleBy % 1];
        } else {
            opacities[1] = 0;
        }

        // cross-fade parameters
        gl.uniform2fv(shader.u_tl_parent, parentTL || [0, 0]);
        gl.uniform1f(shader.u_scale_parent, parentScaleBy || 1);
        gl.uniform1f(shader.u_buffer_scale, 1);
        gl.uniform1f(shader.u_opacity0, opacities[0]);
        gl.uniform1f(shader.u_opacity1, opacities[1]);
        gl.uniform1i(shader.u_image0, 0);
        gl.uniform1i(shader.u_image1, 1);

        gl.bindBuffer(gl.ARRAY_BUFFER, tile.boundsBuffer || painter.tileExtentBuffer);

        gl.vertexAttribPointer(shader.a_pos,         2, gl.SHORT, false, 8, 0);
        gl.vertexAttribPointer(shader.a_texture_pos, 2, gl.SHORT, false, 8, 4);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        gl.enable(gl.STENCIL_TEST);
    }

    function spinWeights(angle) {
        angle *= Math.PI / 180;
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        return [
                (2 * c + 1) / 3,
                (-Math.sqrt(3) * s - c + 1) / 3,
                (Math.sqrt(3) * s - c + 1) / 3
        ];
    }

    function contrastFactor(contrast) {
        return contrast > 0 ?
            1 / (1 - contrast) :
            1 + contrast;
    }

    function saturationFactor(saturation) {
        return saturation > 0 ?
            1 - 1 / (1.001 - saturation) :
            -saturation;
    }

    function getOpacities(tile, parentTile, layer, transform) {
        if (!tile.source) return [1, 0];

        var now = new Date().getTime();

        var fadeDuration = layer.paint['raster-fade-duration'];
        var sinceTile = (now - tile.timeAdded) / fadeDuration;
        var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;

        var idealZ = tile.source._pyramid.coveringZoomLevel(transform);
        var parentFurther = parentTile ? Math.abs(parentTile.coord.z - idealZ) > Math.abs(tile.coord.z - idealZ) : false;

        var opacity = [];
        if (!parentTile || parentFurther) {
            // if no parent or parent is older
            opacity[0] = util.clamp(sinceTile, 0, 1);
            opacity[1] = 1 - opacity[0];
        } else {
            // parent is younger, zooming out
            opacity[0] = util.clamp(1 - sinceParent, 0, 1);
            opacity[1] = 1 - opacity[0];
        }

        var op = layer.paint['raster-opacity'];
        opacity[0] *= op;
        opacity[1] *= op;

        return opacity;
    }

},{"../util/util":103}],29:[function(require,module,exports){
    'use strict';

    var browser = require('../util/browser');
    var mat4 = require('gl-matrix').mat4;

    var drawCollisionDebug = require('./draw_collision_debug');

    module.exports = drawSymbols;

    function drawSymbols(painter, layer, posMatrix, tile) {
        // No data
        if (!tile.buffers) return;
        var elementGroups = tile.elementGroups[layer.ref || layer.id];
        if (!elementGroups) return;

        var drawAcrossEdges = !(layer.layout['text-allow-overlap'] || layer.layout['icon-allow-overlap'] ||
            layer.layout['text-ignore-placement'] || layer.layout['icon-ignore-placement']);

        var gl = painter.gl;

        if (drawAcrossEdges) {
            // Disable the stencil test so that labels aren't clipped to tile boundaries.
            //
            // Layers with features that may be drawn overlapping aren't clipped. These
            // layers are sorted in the y direction, and to draw the correct ordering near
            // tile edges the icons are included in both tiles and clipped when drawing.
            gl.disable(gl.STENCIL_TEST);
        }

        if (elementGroups.text.groups.length) {
            drawSymbol(painter, layer, posMatrix, tile, elementGroups.text, 'text', true);
        }
        if (elementGroups.icon.groups.length) {
            drawSymbol(painter, layer, posMatrix, tile, elementGroups.icon, 'icon', elementGroups.sdfIcons);
        }

        drawCollisionDebug(painter, layer, posMatrix, tile);

        if (drawAcrossEdges) {
            gl.enable(gl.STENCIL_TEST);
        }
    }

    var defaultSizes = {
        icon: 1,
        text: 24
    };

    function drawSymbol(painter, layer, posMatrix, tile, elementGroups, prefix, sdf) {
        var gl = painter.gl;

        posMatrix = painter.translateMatrix(posMatrix, tile, layer.paint[prefix + '-translate'], layer.paint[prefix + '-translate-anchor']);

        var tr = painter.transform;
        var alignedWithMap = layer.layout[prefix + '-rotation-alignment'] === 'map';
        var skewed = alignedWithMap;
        var exMatrix, s, gammaScale;

        if (skewed) {
            exMatrix = mat4.create();
            s = tile.tileExtent / tile.tileSize / Math.pow(2, painter.transform.zoom - tile.coord.z);
            gammaScale = 1 / Math.cos(tr._pitch);
        } else {
            exMatrix = mat4.clone(tile.exMatrix);
            s = painter.transform.altitude;
            gammaScale = 1;
        }
        mat4.scale(exMatrix, exMatrix, [s, s, 1]);

        // If layer.paint.size > layer.layout[prefix + '-max-size'] then labels may collide
        var fontSize = layer.paint[prefix + '-size'];
        var fontScale = fontSize / defaultSizes[prefix];
        mat4.scale(exMatrix, exMatrix, [ fontScale, fontScale, 1 ]);

        // calculate how much longer the real world distance is at the top of the screen
        // than at the middle of the screen.
        var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
        var x = tr.height / 2 * Math.tan(tr._pitch);
        var extra = (topedgelength + x) / topedgelength - 1;

        var text = prefix === 'text';
        var shader, vertex, elements, texsize;

        if (!text && !painter.style.sprite.loaded())
            return;

        gl.activeTexture(gl.TEXTURE0);

        if (sdf) {
            shader = painter.sdfShader;
        } else {
            shader = painter.iconShader;
        }

        if (text) {
            painter.glyphAtlas.updateTexture(gl);
            vertex = tile.buffers.glyphVertex;
            elements = tile.buffers.glyphElement;
            texsize = [painter.glyphAtlas.width / 4, painter.glyphAtlas.height / 4];
        } else {
            painter.spriteAtlas.bind(gl, alignedWithMap || painter.options.rotating ||
                painter.options.zooming || fontScale !== 1 || sdf || painter.transform.pitch);
            vertex = tile.buffers.iconVertex;
            elements = tile.buffers.iconElement;
            texsize = [painter.spriteAtlas.width / 4, painter.spriteAtlas.height / 4];
        }

        gl.switchShader(shader, posMatrix, exMatrix);
        gl.uniform1i(shader.u_texture, 0);
        gl.uniform2fv(shader.u_texsize, texsize);
        gl.uniform1i(shader.u_skewed, skewed);
        gl.uniform1f(shader.u_extra, extra);

        // adjust min/max zooms for variable font sies
        var zoomAdjust = Math.log(fontSize / layer.layout[prefix + '-max-size']) / Math.LN2 || 0;

        gl.uniform1f(shader.u_zoom, (painter.transform.zoom - zoomAdjust) * 10); // current zoom level

        var f = painter.frameHistory.getFadeProperties(300);
        gl.uniform1f(shader.u_fadedist, f.fadedist * 10);
        gl.uniform1f(shader.u_minfadezoom, Math.floor(f.minfadezoom * 10));
        gl.uniform1f(shader.u_maxfadezoom, Math.floor(f.maxfadezoom * 10));
        gl.uniform1f(shader.u_fadezoom, (painter.transform.zoom + f.bump) * 10);

        var group, offset, count, elementOffset;

        elements.bind(gl);

        if (sdf) {
            var sdfPx = 8;
            var blurOffset = 1.19;
            var haloOffset = 6;
            var gamma = 0.105 * defaultSizes[prefix] / fontSize / browser.devicePixelRatio;

            gl.disableVertexAttribArray(shader.a_gamma);
            gl.vertexAttrib1f(shader.a_gamma, gamma * gammaScale);

            gl.disableVertexAttribArray(shader.a_color);
            gl.vertexAttrib4fv(shader.a_color, layer.paint[prefix + '-color']);

            gl.disableVertexAttribArray(shader.a_buffer);
            gl.vertexAttrib1f(shader.a_buffer, (256 - 64) / 256);

            for (var i = 0; i < elementGroups.groups.length; i++) {
                group = elementGroups.groups[i];
                offset = group.vertexStartIndex * vertex.itemSize;
                vertex.bind(gl, shader, offset);

                count = group.elementLength * 3;
                elementOffset = group.elementStartIndex * elements.itemSize;
                gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
            }

            if (layer.paint[prefix + '-halo-color']) {

                // vertex attrib arrays disabled above
                gl.vertexAttrib4fv(shader.a_color, layer.paint[prefix + '-halo-color']);
                gl.vertexAttrib1f(shader.a_buffer, (haloOffset - layer.paint[prefix + '-halo-width'] / fontScale) / sdfPx);
                gl.vertexAttrib1f(shader.a_gamma, (layer.paint[prefix + '-halo-blur'] * blurOffset / fontScale / sdfPx + gamma) * gammaScale);

                for (var j = 0; j < elementGroups.groups.length; j++) {
                    group = elementGroups.groups[j];
                    offset = group.vertexStartIndex * vertex.itemSize;
                    vertex.bind(gl, shader, offset);

                    count = group.elementLength * 3;
                    elementOffset = group.elementStartIndex * elements.itemSize;
                    gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
                }
            }
        } else {
            gl.disableVertexAttribArray(shader.a_opacity);
            gl.vertexAttrib1f(shader.a_opacity, layer.paint['icon-opacity']);

            for (var k = 0; k < elementGroups.groups.length; k++) {
                group = elementGroups.groups[k];
                offset = group.vertexStartIndex * vertex.itemSize;
                vertex.bind(gl, shader, offset);

                count = group.elementLength * 3;
                elementOffset = group.elementStartIndex * elements.itemSize;
                gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
            }
        }
    }

},{"../util/browser":92,"./draw_collision_debug":24,"gl-matrix":116}],30:[function(require,module,exports){
    'use strict';

    var browser = require('../util/browser');
    var mat4 = require('gl-matrix').mat4;

    module.exports = drawVertices;

    function drawVertices(painter, layer, posMatrix, tile) {
        var gl = painter.gl;

        if (!tile || !tile.buffers) return;
        var elementGroups = tile.elementGroups[layer.ref || layer.id];
        if (!elementGroups) return;

        // Blend to the front, not the back.
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        // Draw all buffers
        if (layer.type === 'fill') {
            drawPoints(tile.buffers.fillVertex, elementGroups.groups, posMatrix, 4);
        } else if (layer.type === 'symbol') {
            drawPoints(tile.buffers.iconVertex, elementGroups.icon.groups, posMatrix, 16);
            drawPoints(tile.buffers.glyphVertex, elementGroups.text.groups, posMatrix, 16);
        } else if (layer.type === 'line') {
            var newPosMatrix = mat4.clone(posMatrix);
            mat4.scale(newPosMatrix, newPosMatrix, [0.5, 0.5, 1]);
            drawPoints(tile.buffers.lineVertex, elementGroups.groups, newPosMatrix, 8);
        }

        function drawPoints(vertex, groups, matrix, stride) {
            gl.switchShader(painter.dotShader, matrix);

            gl.uniform1f(painter.dotShader.u_size, 4 * browser.devicePixelRatio);
            gl.uniform1f(painter.dotShader.u_blur, 0.25);
            gl.uniform4fv(painter.dotShader.u_color, [0.1, 0, 0, 0.1]);

            vertex.bind(gl, painter.dotShader, 0);
            for (var i = 0; i < groups.length; i++) {
                var group = groups[i];
                var begin = group.vertexStartIndex;
                var count = group.vertexLength;
                gl.vertexAttribPointer(painter.dotShader.a_pos, 2, gl.SHORT, false, stride, 0);
                gl.drawArrays(gl.POINTS, begin, count);
            }
        }

        // Revert blending mode to blend to the back.
        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
    }

},{"../util/browser":92,"gl-matrix":116}],31:[function(require,module,exports){
    'use strict';

    module.exports = FrameHistory;

    function FrameHistory() {
        this.frameHistory = [];
    }

    FrameHistory.prototype.getFadeProperties = function(duration) {
        if (duration === undefined) duration = 300;
        var currentTime = (new Date()).getTime();

        // Remove frames until only one is outside the duration, or until there are only three
        while (this.frameHistory.length > 3 && this.frameHistory[1].time + duration < currentTime) {
            this.frameHistory.shift();
        }

        if (this.frameHistory[1].time + duration < currentTime) {
            this.frameHistory[0].z = this.frameHistory[1].z;
        }

        var frameLen = this.frameHistory.length;
        if (frameLen < 3) console.warn('there should never be less than three frames in the history');

        // Find the range of zoom levels we want to fade between
        var startingZ = this.frameHistory[0].z,
            lastFrame = this.frameHistory[frameLen - 1],
            endingZ = lastFrame.z,
            lowZ = Math.min(startingZ, endingZ),
            highZ = Math.max(startingZ, endingZ);

        // Calculate the speed of zooming, and how far it would zoom in terms of zoom levels in one duration
        var zoomDiff = lastFrame.z - this.frameHistory[1].z,
            timeDiff = lastFrame.time - this.frameHistory[1].time;
        var fadedist = zoomDiff / (timeDiff / duration);

        if (isNaN(fadedist)) console.warn('fadedist should never be NaN');

        // At end of a zoom when the zoom stops changing continue pretending to zoom at that speed
        // bump is how much farther it would have been if it had continued zooming at the same rate
        var bump = (currentTime - lastFrame.time) / duration * fadedist;

        return {
            fadedist: fadedist,
            minfadezoom: lowZ,
            maxfadezoom: highZ,
            bump: bump
        };
    };

// Record frame history that will be used to calculate fading params
    FrameHistory.prototype.record = function(zoom) {
        var currentTime = (new Date()).getTime();

        // first frame ever
        if (!this.frameHistory.length) {
            this.frameHistory.push({time: 0, z: zoom }, {time: 0, z: zoom });
        }

        if (this.frameHistory.length === 2 || this.frameHistory[this.frameHistory.length - 1].z !== zoom) {
            this.frameHistory.push({
                time: currentTime,
                z: zoom
            });
        }
    };

},{}],32:[function(require,module,exports){
    'use strict';

    var shaders = require('./shaders');
    var util = require('../util/util');

    exports.extend = function(context) {
        var origLineWidth = context.lineWidth,
            lineWidthRange = context.getParameter(context.ALIASED_LINE_WIDTH_RANGE);

        context.lineWidth = function(width) {
            origLineWidth.call(context, util.clamp(width, lineWidthRange[0], lineWidthRange[1]));
        };

        context.getShader = function(name, type) {
            var kind = type === this.FRAGMENT_SHADER ? 'fragment' : 'vertex';
            if (!shaders[name] || !shaders[name][kind]) {
                throw new Error("Could not find shader " + name);
            }

            var shader = this.createShader(type);
            var shaderSource = shaders[name][kind];

            if (typeof orientation === 'undefined') {
                // only use highp precision on mobile browsers
                shaderSource = shaderSource.replace(/ highp /g, ' ');
            }

            this.shaderSource(shader, shaderSource);
            this.compileShader(shader);
            if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
                throw new Error(this.getShaderInfoLog(shader));
            }
            return shader;
        };

        context.initializeShader = function(name, attributes, uniforms) {
            var shader = {
                program: this.createProgram(),
                fragment: this.getShader(name, this.FRAGMENT_SHADER),
                vertex: this.getShader(name, this.VERTEX_SHADER),
                attributes: []
            };
            this.attachShader(shader.program, shader.vertex);
            this.attachShader(shader.program, shader.fragment);

            // Disabling attrib location 0 causes weird behaviour. To avoid the problem, we assign
            // 'a_pos' to attrib location 0 making the assumptions that
            //
            //   - `a_pos` is never disabled
            //   - every shader has an `a_pos` attribute
            //
            // see: https://developer.mozilla.org/en-US/docs/Web/WebGL/WebGL_best_practices
            this.bindAttribLocation(shader.program, 0, 'a_pos');

            this.linkProgram(shader.program);

            if (!this.getProgramParameter(shader.program, this.LINK_STATUS)) {
                console.error(this.getProgramInfoLog(shader.program));
            } else {
                for (var i = 0; i < attributes.length; i++) {
                    shader[attributes[i]] = this.getAttribLocation(shader.program, attributes[i]);
                    shader.attributes.push(shader[attributes[i]]);
                }
                for (var k = 0; k < uniforms.length; k++) {
                    shader[uniforms[k]] = this.getUniformLocation(shader.program, uniforms[k]);
                }
            }

            return shader;
        };

        // Switches to a different shader program.
        context.switchShader = function(shader, posMatrix, exMatrix) {
            if (!posMatrix) {
                console.trace('posMatrix does not have required argument');
            }

            if (this.currentShader !== shader) {
                this.useProgram(shader.program);

                // Disable all attribute arrays used by the previous shader and enable all the attribute
                // arrays used by the next shader. Ideally we would do a better job diffing these to
                // minimize operations (as we did in previously) but it is hard to keep track of state
                // in spaghetti shader boilerplate code and hard to debug when things go wrong.
                var previous = this.currentShader ? this.currentShader.attributes : [];
                for (var i = 0; i < previous.length; i++) {
                    this.disableVertexAttribArray(previous[i]);
                }
                var next = shader.attributes;
                for (var j = 0; j < next.length; j++) {
                    this.enableVertexAttribArray(next[j]);
                }

                this.currentShader = shader;
            }

            // Update the matrices if necessary. Note: This relies on object identity!
            // This means changing the matrix values without the actual matrix object
            // will FAIL to update the matrix properly.
            if (shader.posMatrix !== posMatrix) {
                this.uniformMatrix4fv(shader.u_matrix, false, posMatrix);
                shader.posMatrix = posMatrix;
            }
            if (exMatrix && shader.exMatrix !== exMatrix && shader.u_exmatrix) {
                this.uniformMatrix4fv(shader.u_exmatrix, false, exMatrix);
                shader.exMatrix = exMatrix;
            }
        };

        context.vertexAttrib2fv = function(attribute, values) {
            context.vertexAttrib2f(attribute, values[0], values[1]);
        };

        context.vertexAttrib3fv = function(attribute, values) {
            context.vertexAttrib3f(attribute, values[0], values[1], values[2]);
        };

        context.vertexAttrib4fv = function(attribute, values) {
            context.vertexAttrib4f(attribute, values[0], values[1], values[2], values[3]);
        };

        return context;
    };

},{"../util/util":103,"./shaders":35}],33:[function(require,module,exports){
    'use strict';

    module.exports = LineAtlas;

    /**
     * Much like a GlyphAtlas, a LineAtlas lets us reuse rendered dashed lines
     * by writing many of them to a texture and then fetching their positions
     * using .getDash.
     *
     * @param {number} width
     * @param {number} height
     * @private
     */
    function LineAtlas(width, height) {
        this.width = width;
        this.height = height;
        this.nextRow = 0;

        this.bytes = 4;
        this.data = new Uint8Array(this.width * this.height * this.bytes);

        this.positions = {};
    }

    LineAtlas.prototype.setSprite = function(sprite) {
        this.sprite = sprite;
    };

    /**
     * Get or create a dash line pattern.
     *
     * @param {Array<number>} dasharray
     * @param {boolean} round whether to add circle caps in between dash segments
     * @returns {Object} position of dash texture in { y, height, width }
     * @private
     */
    LineAtlas.prototype.getDash = function(dasharray, round) {
        var key = dasharray.join(",") + round;

        if (!this.positions[key]) {
            this.positions[key] = this.addDash(dasharray, round);
        }
        return this.positions[key];
    };

    LineAtlas.prototype.addDash = function(dasharray, round) {

        var n = round ? 7 : 0;
        var height = 2 * n + 1;
        var offset = 128;

        if (this.nextRow + height > this.height) {
            console.warn('LineAtlas out of space');
            return null;
        }

        var length = 0;
        for (var i = 0; i < dasharray.length; i++) {
            length += dasharray[i];
        }

        var stretch = this.width / length;
        var halfWidth = stretch / 2;

        // If dasharray has an odd length, both the first and last parts
        // are dashes and should be joined seamlessly.
        var oddLength = dasharray.length % 2 === 1;

        for (var y = -n; y <= n; y++) {
            var row = this.nextRow + n + y;
            var index = this.width * row;

            var left = oddLength ? -dasharray[dasharray.length - 1] : 0;
            var right = dasharray[0];
            var partIndex = 1;

            for (var x = 0; x < this.width; x++) {

                while (right < x / stretch) {
                    left = right;
                    right = right + dasharray[partIndex];

                    if (oddLength && partIndex === dasharray.length - 1) {
                        right += dasharray[0];
                    }

                    partIndex++;
                }

                var distLeft = Math.abs(x - left * stretch);
                var distRight = Math.abs(x - right * stretch);
                var dist = Math.min(distLeft, distRight);
                var inside = (partIndex % 2) === 1;
                var signedDistance;

                if (round) {
                    // Add circle caps
                    var distMiddle = n ? y / n * (halfWidth + 1) : 0;
                    if (inside) {
                        var distEdge = halfWidth - Math.abs(distMiddle);
                        signedDistance = Math.sqrt(dist * dist + distEdge * distEdge);
                    } else {
                        signedDistance = halfWidth - Math.sqrt(dist * dist + distMiddle * distMiddle);
                    }
                } else {
                    signedDistance = (inside ? 1 : -1) * dist;
                }

                this.data[3 + (index + x) * 4] = Math.max(0, Math.min(255, signedDistance + offset));
            }
        }

        var pos = {
            y: (this.nextRow + n + 0.5) / this.height,
            height: 2 * n / this.height,
            width: length
        };

        this.nextRow += height;
        this.dirty = true;

        return pos;
    };

    LineAtlas.prototype.bind = function(gl) {
        if (!this.texture) {
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);

        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.texture);

            if (this.dirty) {
                this.dirty = false;
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
            }
        }
    };

    LineAtlas.prototype.debug = function() {

        var canvas = document.createElement('canvas');

        document.body.appendChild(canvas);
        canvas.style.position = 'absolute';
        canvas.style.top = 0;
        canvas.style.left = 0;
        canvas.style.background = '#ff0';

        canvas.width = this.width;
        canvas.height = this.height;

        var ctx = canvas.getContext('2d');
        var data = ctx.getImageData(0, 0, this.width, this.height);
        for (var i = 0; i < this.data.length; i++) {
            if (this.sdf) {
                var k = i * 4;
                data.data[k] = data.data[k + 1] = data.data[k + 2] = 0;
                data.data[k + 3] = this.data[i];
            } else {
                data.data[i] = this.data[i];
            }
        }
        ctx.putImageData(data, 0, 0);
    };

},{}],34:[function(require,module,exports){
    'use strict';

    var glutil = require('./gl_util');
    var browser = require('../util/browser');
    var mat4 = require('gl-matrix').mat4;
    var FrameHistory = require('./frame_history');

    /*
     * Initialize a new painter object.
     *
     * @param {Canvas} gl an experimental-webgl drawing context
     */
    module.exports = Painter;
    function Painter(gl, transform) {
        this.gl = glutil.extend(gl);
        this.transform = transform;

        this.reusableTextures = {};
        this.preFbos = {};

        this.frameHistory = new FrameHistory();

        this.setup();
    }

    /*
     * Update the GL viewport, projection matrix, and transforms to compensate
     * for a new width and height value.
     */
    Painter.prototype.resize = function(width, height) {
        var gl = this.gl;

        this.width = width * browser.devicePixelRatio;
        this.height = height * browser.devicePixelRatio;
        gl.viewport(0, 0, this.width, this.height);

    };


    Painter.prototype.setup = function() {
        var gl = this.gl;

        gl.verbose = true;

        // We are blending the new pixels *behind* the existing pixels. That way we can
        // draw front-to-back and use then stencil buffer to cull opaque pixels early.
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);

        gl.enable(gl.STENCIL_TEST);

        // Initialize shaders
        this.debugShader = gl.initializeShader('debug',
            ['a_pos'],
            ['u_matrix', 'u_pointsize', 'u_color']);

        this.gaussianShader = gl.initializeShader('gaussian',
            ['a_pos'],
            ['u_matrix', 'u_image', 'u_offset']);

        this.rasterShader = gl.initializeShader('raster',
            ['a_pos', 'a_texture_pos'],
            ['u_matrix', 'u_brightness_low', 'u_brightness_high', 'u_saturation_factor', 'u_spin_weights', 'u_contrast_factor', 'u_opacity0', 'u_opacity1', 'u_image0', 'u_image1', 'u_tl_parent', 'u_scale_parent', 'u_buffer_scale']);

        this.lineShader = gl.initializeShader('line',
            ['a_pos', 'a_data', 'a_color', 'a_linewidth', 'a_blur'],
            ['u_matrix', 'u_ratio', 'u_extra', 'u_antialiasingmatrix']);

        this.linepatternShader = gl.initializeShader('linepattern',
            ['a_pos', 'a_data', 'a_linewidth', 'a_blur', 'a_opacity'],
            ['u_matrix', 'u_exmatrix', 'u_ratio', 'u_pattern_size_a', 'u_pattern_size_b', 'u_pattern_tl_a', 'u_pattern_br_a', 'u_pattern_tl_b', 'u_pattern_br_b', 'u_fade']);

        this.linesdfpatternShader = gl.initializeShader('linesdfpattern',
            ['a_pos', 'a_data', 'a_color', 'a_linewidth', 'a_blur'],
            ['u_matrix', 'u_exmatrix', 'u_ratio', 'u_patternscale_a', 'u_tex_y_a', 'u_patternscale_b', 'u_tex_y_b', 'u_image', 'u_sdfgamma', 'u_mix']);

        this.dotShader = gl.initializeShader('dot',
            ['a_pos'],
            ['u_matrix', 'u_size', 'u_color', 'u_blur']);

        this.sdfShader = gl.initializeShader('sdf',
            ['a_pos', 'a_offset', 'a_data1', 'a_data2', 'a_color', 'a_buffer', 'a_gamma'],
            ['u_matrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_zoom', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom', 'u_skewed', 'u_extra']);

        this.iconShader = gl.initializeShader('icon',
            ['a_pos', 'a_offset', 'a_data1', 'a_data2', 'a_opacity'],
            ['u_matrix', 'u_exmatrix', 'u_texture', 'u_texsize', 'u_zoom', 'u_fadedist', 'u_minfadezoom', 'u_maxfadezoom', 'u_fadezoom', 'u_skewed', 'u_extra']);

        this.outlineShader = gl.initializeShader('outline',
            ['a_pos', 'a_color'],
            ['u_matrix', 'u_world']
        );

        this.patternShader = gl.initializeShader('pattern',
            ['a_pos'],
            ['u_matrix', 'u_pattern_tl_a', 'u_pattern_br_a', 'u_pattern_tl_b', 'u_pattern_br_b', 'u_mix', 'u_patternmatrix_a', 'u_patternmatrix_b', 'u_opacity', 'u_image']
        );

        this.fillShader = gl.initializeShader('fill',
            ['a_pos', 'a_color'],
            ['u_matrix']
        );

        this.collisionBoxShader = gl.initializeShader('collisionbox',
            ['a_pos', 'a_extrude', 'a_data'],
            ['u_matrix', 'u_scale', 'u_zoom', 'u_maxzoom']
        );

        this.identityMatrix = mat4.create();

        // The backgroundBuffer is used when drawing to the full *canvas*
        this.backgroundBuffer = gl.createBuffer();
        this.backgroundBuffer.itemSize = 2;
        this.backgroundBuffer.itemCount = 4;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

        this.setExtent(4096);

        // The debugTextBuffer is used to draw tile IDs for debugging
        this.debugTextBuffer = gl.createBuffer();
        this.debugTextBuffer.itemSize = 2;
    };

    /**
     * Rebind the necessary buffers to render at a different extent than
     * the current one. No-ops if the extent is not changing.
     *
     * @param {number} newExtent
     * @example
     * this.setExtent(4096);
     * @private
     */
    Painter.prototype.setExtent = function(newExtent) {
        if (!newExtent || newExtent === this.tileExtent) return;

        this.tileExtent = newExtent;

        var gl = this.gl;

        // The tileExtentBuffer is used when drawing to a full *tile*
        this.tileExtentBuffer = gl.createBuffer();
        this.tileExtentBuffer.itemSize = 4;
        this.tileExtentBuffer.itemCount = 4;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Int16Array([
                // tile coord x, tile coord y, texture coord x, texture coord y
                0, 0, 0, 0,
                this.tileExtent, 0, 32767, 0,
                0, this.tileExtent, 0, 32767,
                this.tileExtent, this.tileExtent,  32767, 32767
            ]),
            gl.STATIC_DRAW);

        // The debugBuffer is used to draw tile outlines for debugging
        this.debugBuffer = gl.createBuffer();
        this.debugBuffer.itemSize = 2;
        this.debugBuffer.itemCount = 5;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.debugBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Int16Array([
                0, 0, this.tileExtent - 1, 0, this.tileExtent - 1, this.tileExtent - 1, 0, this.tileExtent - 1, 0, 0]),
            gl.STATIC_DRAW);
    };

    /*
     * Reset the color buffers of the drawing canvas.
     */
    Painter.prototype.clearColor = function() {
        var gl = this.gl;
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
    };

    /*
     * Reset the drawing canvas by clearing the stencil buffer so that we can draw
     * new tiles at the same location, while retaining previously drawn pixels.
     */
    Painter.prototype.clearStencil = function() {
        var gl = this.gl;
        gl.clearStencil(0x0);
        gl.stencilMask(0xFF);
        gl.clear(gl.STENCIL_BUFFER_BIT);
    };

    Painter.prototype.drawClippingMask = function(tile) {
        var gl = this.gl;
        gl.switchShader(this.fillShader, tile.posMatrix);
        gl.colorMask(false, false, false, false);

        // Clear the entire stencil buffer, except for the 7th bit, which stores
        // the global clipping mask that allows us to avoid drawing in regions of
        // tiles we've already painted in.
        gl.clearStencil(0x0);
        gl.stencilMask(0xBF);
        gl.clear(gl.STENCIL_BUFFER_BIT);

        // The stencil test will fail always, meaning we set all pixels covered
        // by this geometry to 0x80. We use the highest bit 0x80 to mark the regions
        // we want to draw in. All pixels that have this bit *not* set will never be
        // drawn in.
        gl.stencilFunc(gl.EQUAL, 0xC0, 0x40);
        gl.stencilMask(0xC0);
        gl.stencilOp(gl.REPLACE, gl.KEEP, gl.KEEP);

        // Draw the clipping mask
        gl.disableVertexAttribArray(this.fillShader.a_color);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
        gl.vertexAttribPointer(this.fillShader.a_pos, this.tileExtentBuffer.itemSize, gl.SHORT, false, 8, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);

        gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
        gl.stencilMask(0x00);
        gl.colorMask(true, true, true, true);
        gl.enableVertexAttribArray(this.fillShader.a_color);
    };

// Overridden by headless tests.
    Painter.prototype.prepareBuffers = function() {};
    Painter.prototype.bindDefaultFramebuffer = function() {
        var gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };

    var draw = {
        symbol: require('./draw_symbol'),
        line: require('./draw_line'),
        fill: require('./draw_fill'),
        raster: require('./draw_raster'),
        background: require('./draw_background'),
        debug: require('./draw_debug'),
        vertices: require('./draw_vertices')
    };

    Painter.prototype.render = function(style, options) {
        this.style = style;
        this.options = options;

        this.lineAtlas = style.lineAtlas;

        this.spriteAtlas = style.spriteAtlas;
        this.spriteAtlas.setSprite(style.sprite);

        this.glyphAtlas = style.glyphAtlas;
        this.glyphAtlas.bind(this.gl);

        this.frameHistory.record(this.transform.zoom);

        this.prepareBuffers();
        this.clearColor();

        for (var i = style._groups.length - 1; i >= 0; i--) {
            var group = style._groups[i];
            var source = style.sources[group.source];

            if (source) {
                this.clearStencil();
                source.render(group, this);

            } else if (group.source === undefined) {
                this.drawLayers(group, this.identityMatrix);
            }
        }
    };

    Painter.prototype.drawTile = function(tile, layers) {
        this.setExtent(tile.tileExtent);
        this.drawClippingMask(tile);
        this.drawLayers(layers, tile.posMatrix, tile);

        if (this.options.debug) {
            draw.debug(this, tile);
        }
    };

    Painter.prototype.drawLayers = function(layers, matrix, tile) {
        for (var i = layers.length - 1; i >= 0; i--) {
            var layer = layers[i];

            if (layer.hidden)
                continue;

            draw[layer.type](this, layer, matrix, tile);

            if (this.options.vertices) {
                draw.vertices(this, layer, matrix, tile);
            }
        }
    };

// Draws non-opaque areas. This is for debugging purposes.
    Painter.prototype.drawStencilBuffer = function() {
        var gl = this.gl;
        gl.switchShader(this.fillShader, this.identityMatrix);

        // Blend to the front, not the back.
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.stencilMask(0x00);
        gl.stencilFunc(gl.EQUAL, 0x80, 0x80);

        // Drw the filling quad where the stencil buffer isn't set.
        gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
        gl.vertexAttribPointer(this.fillShader.a_pos, this.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.disableVertexAttribArray(this.fillShader.a_color);
        gl.vertexAttrib4fv(this.fillShader.a_color, [0, 0, 0, 0.5]);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);

        // Revert blending mode to blend to the back.
        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
    };

    Painter.prototype.translateMatrix = function(matrix, tile, translate, anchor) {
        if (!translate[0] && !translate[1]) return matrix;

        if (anchor === 'viewport') {
            var sinA = Math.sin(-this.transform.angle);
            var cosA = Math.cos(-this.transform.angle);
            translate = [
                    translate[0] * cosA - translate[1] * sinA,
                    translate[0] * sinA + translate[1] * cosA
            ];
        }

        var tilePixelRatio = this.transform.scale / (1 << tile.coord.z) / (tile.tileExtent / tile.tileSize);
        var translation = [
                translate[0] / tilePixelRatio,
                translate[1] / tilePixelRatio,
            0
        ];

        var translatedMatrix = new Float32Array(16);
        mat4.translate(translatedMatrix, matrix, translation);
        return translatedMatrix;
    };

    Painter.prototype.saveTexture = function(texture) {
        var textures = this.reusableTextures[texture.size];
        if (!textures) {
            this.reusableTextures[texture.size] = [texture];
        } else {
            textures.push(texture);
        }
    };


    Painter.prototype.getTexture = function(size) {
        var textures = this.reusableTextures[size];
        return textures && textures.length > 0 ? textures.pop() : null;
    };

},{"../util/browser":92,"./draw_background":23,"./draw_debug":25,"./draw_fill":26,"./draw_line":27,"./draw_raster":28,"./draw_symbol":29,"./draw_vertices":30,"./frame_history":31,"./gl_util":32,"gl-matrix":116}],35:[function(require,module,exports){
    'use strict';

    var glify = undefined;

    module.exports = {
        "debug": {"vertex":"precision mediump float;attribute vec2 a_pos;uniform float u_pointsize;uniform mat4 u_matrix;void main(){gl_Position=u_matrix*vec4(a_pos,step(32767.,a_pos.x),1);gl_PointSize=u_pointsize;}","fragment":"precision mediump float;uniform vec4 u_color;void main(){gl_FragColor=u_color;}"},
        "dot": {"vertex":"precision mediump float;uniform mat4 u_matrix;uniform float u_size;attribute vec2 a_pos;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);gl_PointSize=u_size;}","fragment":"precision mediump float;uniform vec4 u_color;uniform float u_blur;void main(){float a,b;a=length(gl_PointCoord-.5);b=smoothstep(.5,.5-u_blur,a);gl_FragColor=u_color*b;}"},
        "fill": {"vertex":"precision mediump float;uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec4 a_color;varying vec4 a;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);gl_PointSize=2.;a=a_color;}","fragment":"precision mediump float;varying vec4 a;void main(){gl_FragColor=a;}"},
        "gaussian": {"vertex":"precision mediump float;attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_offset;varying vec2 a[3];void main(){gl_Position=u_matrix*vec4(a_pos,0,1);vec2 b=gl_Position.xy/2.+.5;a[0]=b;a[1]=b+u_offset*1.1824255238063563;a[2]=b-u_offset*1.1824255238063563;}","fragment":"precision mediump float;uniform sampler2D u_image;varying vec2 a[3];void main(){vec4 b=vec4(0);b+=texture2D(u_image,a[0])*.40261994689424746;b+=texture2D(u_image,a[1])*.2986900265528763;b+=texture2D(u_image,a[2])*.2986900265528763;gl_FragColor=b;}"},
        "line": {"vertex":"precision mediump float;attribute vec2 a_pos,a_linewidth;attribute vec4 a_data,a_color;attribute float a_blur;uniform highp mat4 u_matrix;uniform float u_ratio,u_extra;uniform mat2 u_antialiasingmatrix;varying vec2 a,e;varying float b,d,f;varying vec4 c;void main(){vec2 g,h;g=a_data.xy;h=mod(a_pos,2.);h.y=sign(h.y-.5);a=h;vec4 i=vec4(a_linewidth.s*g*.015873016,0,0);gl_Position=u_matrix*vec4(floor(a_pos*.5)+i.xy/u_ratio,0,1);float j,k,l;j=gl_Position.y/gl_Position.w;k=length(g)/length(u_antialiasingmatrix*g);l=1./(1.-j*u_extra);d=l*k;c=a_color;e=a_linewidth;f=a_blur;}","fragment":"precision mediump float;uniform vec2 u_dasharray;varying vec4 c;varying vec2 a,e;varying float b,d,f;void main(){float g,h,i;g=length(a)*e.s;h=f*d;i=clamp(min(g-(e.t-h),e.s-g)/h,0.,1.);gl_FragColor=c*i;}"},
        "linepattern": {"vertex":"precision mediump float;attribute vec2 a_pos,a_linewidth;attribute vec4 a_data;attribute float a_blur,a_opacity;uniform highp mat4 u_matrix;uniform mat4 u_exmatrix;uniform float u_ratio;varying vec2 a,c;varying float b,d,e;void main(){vec2 f,h,i,j;f=a_data.xy;float g=a_data.z*128.+a_data.w;h=mod(a_pos,2.);h.y=sign(h.y-.5);a=h;i=f*.015873016;j=a_linewidth.s*i;gl_Position=u_matrix*vec4(floor(a_pos*.5)+j.xy/u_ratio,0,1);b=g;c=a_linewidth;d=a_blur;e=a_opacity;}","fragment":"precision mediump float;uniform float u_point,u_fade;uniform vec2 u_pattern_size_a,u_pattern_size_b,u_pattern_tl_a,u_pattern_br_a,u_pattern_tl_b,u_pattern_br_b;uniform sampler2D u_image;varying vec2 a,c;varying float b,d,e;void main(){float f,g,h,i,j,k;f=length(a)*c.s;g=clamp(min(f-(c.t-d),c.s-f)/d,0.,1.);h=mod(b/u_pattern_size_a.x,1.);i=mod(b/u_pattern_size_b.x,1.);j=.5+a.y*c.s/u_pattern_size_a.y;k=.5+a.y*c.s/u_pattern_size_b.y;vec2 l,m;l=mix(u_pattern_tl_a,u_pattern_br_a,vec2(h,j));m=mix(u_pattern_tl_b,u_pattern_br_b,vec2(i,k));vec4 n=mix(texture2D(u_image,l),texture2D(u_image,m),u_fade);g*=e;gl_FragColor=n*g;}"},
        "linesdfpattern": {"vertex":"precision mediump float;attribute vec2 a_pos,a_linewidth;attribute vec4 a_data,a_color;attribute float a_blur;uniform highp mat4 u_matrix;uniform mat4 u_exmatrix;uniform float u_ratio,u_tex_y_a,u_tex_y_b;uniform vec2 u_patternscale_a,u_patternscale_b;varying vec2 a,b,c,e;varying vec4 d;varying float f;void main(){vec2 g,i;g=a_data.xy;float h=a_data.z*128.+a_data.w;i=mod(a_pos,2.);i.y=sign(i.y-.5);a=i;vec4 j=vec4(a_linewidth.s*g*.015873016,0,0);gl_Position=u_matrix*vec4(floor(a_pos*.5)+j.xy/u_ratio,0,1);b=vec2(h*u_patternscale_a.x,i.y*u_patternscale_a.y+u_tex_y_a);c=vec2(h*u_patternscale_b.x,i.y*u_patternscale_b.y+u_tex_y_b);d=a_color;e=a_linewidth;f=a_blur;}","fragment":"precision mediump float;uniform sampler2D u_image;uniform float u_sdfgamma,u_mix;varying vec2 a,b,c,e;varying vec4 d;varying float f;void main(){float g,h,i,j,k;g=length(a)*e.s;h=clamp(min(g-(e.t-f),e.s-g)/f,0.,1.);i=texture2D(u_image,b).a;j=texture2D(u_image,c).a;k=mix(i,j,u_mix);h*=smoothstep(.5-u_sdfgamma,.5+u_sdfgamma,k);gl_FragColor=d*h;}"},
        "outline": {"vertex":"precision mediump float;attribute vec2 a_pos;attribute vec4 a_color;uniform highp mat4 u_matrix;uniform vec2 u_world;varying vec4 a;varying vec2 b;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);b=(gl_Position.xy/gl_Position.w+1.)/2.*u_world;a=a_color;}","fragment":"precision mediump float;varying vec4 a;varying vec2 b;void main(){float c,d;c=length(b-gl_FragCoord.xy);d=smoothstep(1.,0.,c);gl_FragColor=a*d;}"},
        "pattern": {"vertex":"precision mediump float;uniform mat4 u_matrix;uniform mat3 u_patternmatrix_a,u_patternmatrix_b;attribute vec2 a_pos;varying vec2 a,b;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);a=(u_patternmatrix_a*vec3(a_pos,1)).xy;b=(u_patternmatrix_b*vec3(a_pos,1)).xy;}","fragment":"precision mediump float;uniform float u_opacity,u_mix;uniform vec2 u_pattern_tl_a,u_pattern_br_a,u_pattern_tl_b,u_pattern_br_b;uniform sampler2D u_image;varying vec2 a,b;void main(){vec2 c,d,f,g;c=mod(a,1.);d=mix(u_pattern_tl_a,u_pattern_br_a,c);vec4 e,h;e=texture2D(u_image,d);f=mod(b,1.);g=mix(u_pattern_tl_b,u_pattern_br_b,f);h=texture2D(u_image,g);gl_FragColor=mix(e,h,u_mix)*u_opacity;}"},
        "raster": {"vertex":"precision mediump float;uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent,u_buffer_scale;attribute vec2 a_pos,a_texture_pos;varying vec2 a,b;void main(){gl_Position=u_matrix*vec4(a_pos,0,1);a=(a_texture_pos/32767.-.5)/u_buffer_scale+.5;b=a*u_scale_parent+u_tl_parent;}","fragment":"precision mediump float;uniform float u_opacity0,u_opacity1,u_brightness_low,u_brightness_high,u_saturation_factor,u_contrast_factor;uniform sampler2D u_image0,u_image1;varying vec2 a,b;uniform vec3 u_spin_weights;void main(){vec4 c,d,e;c=texture2D(u_image0,a);d=texture2D(u_image1,b);e=c*u_opacity0+d*u_opacity1;vec3 f,h,i;f=e.rgb;f=vec3(dot(f,u_spin_weights.xyz),dot(f,u_spin_weights.zxy),dot(f,u_spin_weights.yzx));float g=(e.r+e.g+e.b)/3.;f+=(g-f)*u_saturation_factor;f=(f-.5)*u_contrast_factor+.5;h=vec3(u_brightness_low);i=vec3(u_brightness_high);gl_FragColor=vec4(mix(h,i,f),e.a);}"},
        "icon": {"vertex":"precision mediump float;attribute vec2 a_pos,a_offset;attribute vec4 a_data1,a_data2;attribute float a_opacity;uniform highp mat4 u_matrix;uniform mat4 u_exmatrix;uniform float u_zoom,u_fadedist,u_minfadezoom,u_maxfadezoom,u_fadezoom,u_extra;uniform bool u_skewed;uniform vec2 u_texsize;varying vec2 a;varying float b;void main(){vec2 c,e;c=a_data1.xy;float d,f,g,h,i,j;d=a_data1[2];e=a_data2.st;f=e[0];g=e[1];h=10.;i=2.-step(f,u_zoom)-(1.-step(g,u_zoom));j=clamp((u_fadezoom-d)/u_fadedist,0.,1.);if(u_fadedist>=0.)b=j;else b=1.-j;if(u_maxfadezoom<d)b=0.;if(u_minfadezoom>=d)b=1.;i+=step(b,0.);if(u_skewed){vec4 k=u_exmatrix*vec4(a_offset/64.,0,0);gl_Position=u_matrix*vec4(a_pos+k.xy,0,1);gl_Position.z+=i*gl_Position.w;}else{vec4 k=u_exmatrix*vec4(a_offset/64.,i,0);gl_Position=u_matrix*vec4(a_pos,0,1)+k;}a=c/u_texsize;b*=a_opacity;}","fragment":"precision mediump float;uniform sampler2D u_texture;varying vec2 a;varying float b;void main(){gl_FragColor=texture2D(u_texture,a)*b;}"},
        "sdf": {"vertex":"precision mediump float;attribute vec2 a_pos,a_offset;attribute vec4 a_data1,a_data2,a_color;attribute float a_buffer,a_gamma;uniform highp mat4 u_matrix;uniform mat4 u_exmatrix;uniform float u_zoom,u_fadedist,u_minfadezoom,u_maxfadezoom,u_fadezoom,u_extra;uniform bool u_skewed;uniform vec2 u_texsize;varying vec2 a;varying float b,c,e,f;varying vec4 d;void main(){vec2 g,i;g=a_data1.xy;float h,j,k,l,m,n,o;h=a_data1[2];i=a_data2.st;j=i[0];k=i[1];l=2.-step(j,u_zoom)-(1.-step(k,u_zoom));m=clamp((u_fadezoom-h)/u_fadedist,0.,1.);if(u_fadedist>=0.)b=m;else b=1.-m;if(u_maxfadezoom<h)b=0.;if(u_minfadezoom>=h)b=1.;l+=step(b,0.);if(u_skewed){vec4 n=u_exmatrix*vec4(a_offset/64.,0,0);gl_Position=u_matrix*vec4(a_pos+n.xy,0,1);gl_Position.z+=l*gl_Position.w;}else{vec4 n=u_exmatrix*vec4(a_offset/64.,l,0);gl_Position=u_matrix*vec4(a_pos,0,1)+n;}n=gl_Position.y/gl_Position.w;o=1./(1.-n*u_extra);c=o;a=g/u_texsize;d=a_color;e=a_buffer;f=a_gamma;}","fragment":"precision mediump float;uniform sampler2D u_texture;varying vec2 a;varying float b,c,e,f;varying vec4 d;void main(){float g,h,i;g=f*c;h=texture2D(u_texture,a).a;i=smoothstep(e-g,e+g,h)*b;gl_FragColor=d*i;}"},
        "collisionbox": {"vertex":"precision mediump float;attribute vec2 a_pos,a_extrude,a_data;uniform mat4 u_matrix;uniform float u_scale;varying float a,b;void main(){gl_Position=u_matrix*vec4(a_pos+a_extrude/u_scale,0,1);a=a_data.x;b=a_data.y;}","fragment":"precision mediump float;uniform float u_zoom,u_maxzoom;varying float a,b;void main(){float c=.5;gl_FragColor=vec4(0,1,0,1)*c;if(b>u_zoom)gl_FragColor=vec4(1,0,0,1)*c;if(u_zoom>=a)gl_FragColor=vec4(0,0,0,1)*c*.25;if(b>=u_maxzoom)gl_FragColor=vec4(0,0,1,1)*c*.2;}"}
    };

},{}],36:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');
    var Evented = require('../util/evented');
    var TilePyramid = require('./tile_pyramid');
    var Source = require('./source');
    var urlResolve = require('resolve-url');

    module.exports = GeoJSONSource;

    /**
     * Create a GeoJSON data source instance given an options object
     * @class GeoJSONSource
     * @param {Object} [options]
     * @param {Object|string} options.data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
     * @param {number} [options.maxzoom=14] Maximum zoom to preserve detail at.
     * @param {number} [options.buffer] Tile buffer on each side.
     * @param {number} [options.tolerance] Simplification tolerance (higher means simpler).
     * @example
     * var sourceObj = new mapboxgl.GeoJSONSource({
 *    data: {
 *        "type": "FeatureCollection",
 *        "features": [{
 *            "type": "Feature",
 *            "geometry": {
 *                "type": "Point",
 *                "coordinates": [
 *                    -76.53063297271729,
 *                    39.18174077994108
 *                ]
 *            }
 *        }]
 *    }
 * });
     * map.addSource('some id', sourceObj); // add
     * map.removeSource('some id');  // remove
     */
    function GeoJSONSource(options) {
        console.log(0);
        options = options || {};

        this._data = options.data;

        if (options.maxzoom !== undefined) this.maxzoom = options.maxzoom;

        this.geojsonVtOptions = { maxZoom: this.maxzoom };
        if (options.buffer !== undefined) this.geojsonVtOptions.buffer = options.buffer;
        if (options.tolerance !== undefined) this.geojsonVtOptions.tolerance = options.tolerance;

        this._pyramid = new TilePyramid({
            tileSize: 512,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            cacheSize: 20,
            load: this._loadTile.bind(this),
            abort: this._abortTile.bind(this),
            unload: this._unloadTile.bind(this),
            add: this._addTile.bind(this),
            remove: this._removeTile.bind(this)
        });
    }

    GeoJSONSource.prototype = util.inherit(Evented, /** @lends GeoJSONSource.prototype */{
        minzoom: 0,
        maxzoom: 14,
        _dirty: true,

        /**
         * Update source geojson data and rerender map
         *
         * @param {Object|string} data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
         * @returns {GeoJSONSource} this
         */
        setData: function(data) {
            this._data = data;
            this._dirty = true;

            this.fire('change');

            if (this.map)
                this.update(this.map.transform);

            return this;
        },

        onAdd: function(map) {
            this.map = map;
        },

        loaded: function() {
            return this._loaded && this._pyramid.loaded();
        },

        update: function(transform) {
            if (this._dirty) {
                this._updateData();
            }

            if (this._loaded) {
                this._pyramid.update(this.used, transform);
            }
        },

        reload: function() {
            this._pyramid.reload();
        },

        render: Source._renderTiles,
        featuresAt: Source._vectorFeaturesAt,

        _updateData: function() {
            this._dirty = false;
            var data = this._data;
            if (typeof data === 'string') {
                data = urlResolve(window.location.href, data);
            }
            this.workerID = this.dispatcher.send('parse geojson', {
                data: data,
                tileSize: 512,
                source: this.id,
                geojsonVtOptions: this.geojsonVtOptions
            }, function(err) {

                if (err) {
                    this.fire('error', {error: err});
                    return;
                }
                this._loaded = true;
                this._pyramid.reload();

                this.fire('change');
            }.bind(this));
        },

        _loadTile: function(tile) {
            var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
            var params = {
                uid: tile.uid,
                coord: tile.coord,
                zoom: tile.coord.z,
                maxZoom: this.maxzoom,
                tileSize: 512,
                source: this.id,
                overscaling: overscaling,
                angle: this.map.transform.angle,
                pitch: this.map.transform.pitch,
                collisionDebug: this.map.collisionDebug
            };

            tile.workerID = this.dispatcher.send('load geojson tile', params, function(err, data) {

                tile.unloadVectorData(this.map.painter);

                if (tile.aborted)
                    return;

                if (err) {
                    this.fire('tile.error', {tile: tile});
                    return;
                }

                tile.loadVectorData(data);
                this.fire('tile.load', {tile: tile});

            }.bind(this), this.workerID);
        },

        _abortTile: function(tile) {
            tile.aborted = true;
        },

        _addTile: function(tile) {
            this.fire('tile.add', {tile: tile});
        },

        _removeTile: function(tile) {
            this.fire('tile.remove', {tile: tile});
        },

        _unloadTile: function(tile) {
            tile.unloadVectorData(this.map.painter);
            this.glyphAtlas.removeGlyphs(tile.uid);
            this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
        }
    });

},{"../util/evented":97,"../util/util":103,"./source":39,"./tile_pyramid":42,"resolve-url":152}],37:[function(require,module,exports){
    'use strict';

    var Point = require('point-geometry');
    var VectorTileFeature = require('vector-tile').VectorTileFeature;

    module.exports = GeoJSONWrapper;

// conform to vectortile api
    function GeoJSONWrapper(features) {
        this.features = features;
        this.length = features.length;
    }

    GeoJSONWrapper.prototype.feature = function(i) {
        return new FeatureWrapper(this.features[i]);
    };

    function FeatureWrapper(feature) {
        this.type = feature.type;
        this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry;
        this.properties = feature.tags;
        this.extent = 4096;
    }

    FeatureWrapper.prototype.loadGeometry = function() {
        var rings = this.rawGeometry;
        this.geometry = [];

        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i],
                newRing = [];
            for (var j = 0; j < ring.length; j++) {
                newRing.push(new Point(ring[j][0], ring[j][1]));
            }
            this.geometry.push(newRing);
        }
        return this.geometry;
    };

    FeatureWrapper.prototype.bbox = function() {
        if (!this.geometry) this.loadGeometry();

        var rings = this.geometry,
            x1 = Infinity,
            x2 = -Infinity,
            y1 = Infinity,
            y2 = -Infinity;

        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i];

            for (var j = 0; j < ring.length; j++) {
                var coord = ring[j];

                x1 = Math.min(x1, coord.x);
                x2 = Math.max(x2, coord.x);
                y1 = Math.min(y1, coord.y);
                y2 = Math.max(y2, coord.y);
            }
        }

        return [x1, y1, x2, y2];
    };

    FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON;

},{"point-geometry":150,"vector-tile":154}],38:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');
    var ajax = require('../util/ajax');
    var Evented = require('../util/evented');
    var Source = require('./source');
    var normalizeURL = require('../util/mapbox').normalizeTileURL;

    module.exports = RasterTileSource;

    function RasterTileSource(options) {
        util.extend(this, util.pick(options, ['url', 'tileSize']));

        Source._loadTileJSON.call(this, options);
    }

    RasterTileSource.prototype = util.inherit(Evented, {
        minzoom: 0,
        maxzoom: 22,
        tileSize: 512,
        _loaded: false,

        onAdd: function(map) {
            this.map = map;
        },

        loaded: function() {
            return this._pyramid && this._pyramid.loaded();
        },

        update: function(transform) {
            if (this._pyramid) {
                this._pyramid.update(this.used, transform, this.map.style.rasterFadeDuration);
            }
        },

        reload: function() {
            // noop
        },

        render: Source._renderTiles,

        _loadTile: function(tile) {
            ajax.getImage(normalizeURL(tile.coord.url(this.tiles), this.url), function(err, img) {
                if (tile.aborted)
                    return;

                if (err) {
                    this.fire('tile.error', {tile: tile});
                    return;
                }

                var gl = this.map.painter.gl;
                tile.texture = this.map.painter.getTexture(img.width);
                if (tile.texture) {
                    gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
                } else {
                    tile.texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                    tile.texture.size = img.width;
                }
                gl.generateMipmap(gl.TEXTURE_2D);

                tile.timeAdded = new Date().getTime();
                this.map.animationLoop.set(this.style.rasterFadeDuration);

                tile.source = this;
                tile.loaded = true;

                this.fire('tile.load', {tile: tile});
            }.bind(this));
        },

        _abortTile: function(tile) {
            tile.aborted = true;
        },

        _addTile: function(tile) {
            this.fire('tile.add', {tile: tile});
        },

        _removeTile: function(tile) {
            this.fire('tile.remove', {tile: tile});
        },

        _unloadTile: function(tile) {
            if (tile.texture) this.map.painter.saveTexture(tile.texture);
        },

        featuresAt: function(point, params, callback) {
            callback(null, []);
        }
    });

},{"../util/ajax":91,"../util/evented":97,"../util/mapbox":100,"../util/util":103,"./source":39}],39:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');
    var ajax = require('../util/ajax');
    var browser = require('../util/browser');
    var TilePyramid = require('./tile_pyramid');
    var TileCoord = require('./tile_coord');
    var normalizeURL = require('../util/mapbox').normalizeSourceURL;

    exports._loadTileJSON = function(options) {
        var loaded = function(err, tileJSON) {
            if (err) {
                this.fire('error', {error: err});
                return;
            }

            util.extend(this, util.pick(tileJSON,
                ['tiles', 'minzoom', 'maxzoom', 'attribution']));

            this._pyramid = new TilePyramid({
                tileSize: this.tileSize,
                cacheSize: 20,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: this.reparseOverscaled,
                load: this._loadTile.bind(this),
                abort: this._abortTile.bind(this),
                unload: this._unloadTile.bind(this),
                add: this._addTile.bind(this),
                remove: this._removeTile.bind(this),
                redoPlacement: this._redoTilePlacement ? this._redoTilePlacement.bind(this) : undefined
            });

            this.fire('load');
        }.bind(this);

        if (options.url) {
            ajax.getJSON(normalizeURL(options.url), loaded);
        } else {
            browser.frame(loaded.bind(this, null, options));
        }
    };

    exports._renderTiles = function(layers, painter) {
        if (!this._pyramid)
            return;

        var ids = this._pyramid.renderedIDs();
        for (var i = 0; i < ids.length; i++) {
            var tile = this._pyramid.getTile(ids[i]),
            // coord is different than tile.coord for wrapped tiles since the actual
            // tile object is shared between all the visible copies of that tile.
                coord = TileCoord.fromID(ids[i]),
                z = coord.z,
                x = coord.x,
                y = coord.y,
                w = coord.w;

            // if z > maxzoom then the tile is actually a overscaled maxzoom tile,
            // so calculate the matrix the maxzoom tile would use.
            z = Math.min(z, this.maxzoom);

            x += w * (1 << z);
            tile.calculateMatrices(z, x, y, painter.transform, painter);

            painter.drawTile(tile, layers);
        }
    };

    exports._vectorFeaturesAt = function(coord, params, callback) {
        if (!this._pyramid)
            return callback(null, []);

        var result = this._pyramid.tileAt(coord);
        if (!result)
            return callback(null, []);

        this.dispatcher.send('query features', {
            uid: result.tile.uid,
            x: result.x,
            y: result.y,
            scale: result.scale,
            source: this.id,
            params: params
        }, callback, result.tile.workerID);
    };

    /*
     * Create a tiled data source instance given an options object
     *
     * @param {Object} options
     * @param {string} options.type Either `raster` or `vector`.
     * @param {string} options.url A tile source URL. This should either be `mapbox://{mapid}` or a full `http[s]` url that points to a TileJSON endpoint.
     * @param {Array} options.tiles An array of tile sources. If `url` is not specified, `tiles` can be used instead to specify tile sources, as in the TileJSON spec. Other TileJSON keys such as `minzoom` and `maxzoom` can be specified in a source object if `tiles` is used.
     * @param {string} options.id An optional `id` to assign to the source
     * @param {number} [options.tileSize=512] Optional tile size (width and height in pixels, assuming tiles are square). This option is only configurable for raster sources
     * @param {number} options.cacheSize Optional max number of tiles to cache at any given time
     * @example
     * var sourceObj = new mapboxgl.Source.create({
     *    type: 'vector',
     *    url: 'mapbox://mapbox.mapbox-streets-v5'
     * });
     * map.addSource('some id', sourceObj); // add
     * map.removeSource('some id');  // remove
     */
    exports.create = function(source) {
        // This is not at file scope in order to avoid a circular require.
        var sources = {
            vector: require('./vector_tile_source'),
            raster: require('./raster_tile_source'),
            geojson: require('./geojson_source'),
            video: require('./video_source')
        };

        for (var type in sources) {
            if (source instanceof sources[type]) {
                return source;
            }
        }

        return new sources[source.type](source);
    };

},{"../util/ajax":91,"../util/browser":92,"../util/mapbox":100,"../util/util":103,"./geojson_source":36,"./raster_tile_source":38,"./tile_coord":41,"./tile_pyramid":42,"./vector_tile_source":43,"./video_source":44}],40:[function(require,module,exports){
    'use strict';

    var glmatrix = require('gl-matrix');
    var mat2 = glmatrix.mat2;
    var mat4 = glmatrix.mat4;
    var util = require('../util/util');
    var BufferSet = require('../data/buffer/buffer_set');

    module.exports = Tile;

    /**
     * A tile object is the combination of a Coordinate, which defines
     * its place, as well as a unique ID and data tracking for its content
     *
     * @param {Coordinate} coord
     * @param {number} size
     * @private
     */
    function Tile(coord, size) {
        this.coord = coord;
        this.uid = util.uniqueId();
        this.loaded = false;
        this.uses = 0;
        this.tileSize = size;
    }

    Tile.prototype = {
        // todo unhardcode
        tileExtent: 4096,

        /**
         * Calculate the internal posMatrix that this tile uses to display
         * itself in a map, given a coordinate as (z, x, y) and a transform
         * @param {number} z
         * @param {number} x
         * @param {number} y
         * @param {Object} transform
         * @private
         */
        calculateMatrices: function(z, x, y, transform) {

            // Initialize model-view matrix that converts from the tile coordinates
            // to screen coordinates.
            var tileScale = Math.pow(2, z);
            var scale = transform.worldSize / tileScale;

            // TODO: remove
            this.scale = scale;

            // The position matrix
            this.posMatrix = new Float64Array(16);
            mat4.identity(this.posMatrix);
            mat4.translate(this.posMatrix, this.posMatrix, [x * scale, y * scale, 0]);

            mat4.scale(this.posMatrix, this.posMatrix, [ scale / this.tileExtent, scale / this.tileExtent, 1 ]);
            mat4.multiply(this.posMatrix, transform.getProjMatrix(), this.posMatrix);

            // The extrusion matrix.
            this.exMatrix = mat4.create();
            mat4.ortho(this.exMatrix, 0, transform.width, transform.height, 0, 0, -1);
            //mat4.rotateZ(this.exMatrix, this.exMatrix, -transform.angle);

            // 2x2 matrix for rotating points
            this.rotationMatrix = mat2.create();
            mat2.rotate(this.rotationMatrix, this.rotationMatrix, transform.angle);

            this.posMatrix = new Float32Array(this.posMatrix);
        },

        /**
         * Given a coordinate position, zoom that coordinate to my zoom and
         * scale and return a position in x, y, scale
         * @param {Coordinate} coord
         * @returns {Object} position
         * @private
         */
        positionAt: function(coord, sourceMaxZoom) {
            coord = coord.zoomTo(Math.min(this.coord.z, sourceMaxZoom));
            return {
                x: (coord.column - this.coord.x) * 4096,
                y: (coord.row - this.coord.y) * 4096,
                scale: this.scale
            };
        },

        /**
         * Given a data object with a 'buffers' property, load it into
         * this tile's elementGroups and buffers properties and set loaded
         * to true. If the data is null, like in the case of an empty
         * GeoJSON tile, no-op but still set loaded to true.
         * @param {Object} data
         * @returns {undefined}
         * @private
         */
        loadVectorData: function(data) {
            this.loaded = true;

            // empty GeoJSON tile
            if (!data) return;

            this.buffers = new BufferSet(data.buffers);
            this.elementGroups = data.elementGroups;
            this.tileExtent = data.extent;
        },

        /**
         * given a data object and a GL painter, destroy and re-create
         * all of its buffers.
         * @param {Object} data
         * @param {Object} painter
         * @returns {undefined}
         * @private
         */
        reloadSymbolData: function(data, painter) {

            if (!this.buffers) {
                // the tile has been destroyed
                return;
            }

            this.buffers.glyphVertex.destroy(painter.gl);
            this.buffers.glyphElement.destroy(painter.gl);
            this.buffers.iconVertex.destroy(painter.gl);
            this.buffers.iconElement.destroy(painter.gl);
            this.buffers.collisionBoxVertex.destroy(painter.gl);

            var buffers = new BufferSet(data.buffers);
            this.buffers.glyphVertex = buffers.glyphVertex;
            this.buffers.glyphElement = buffers.glyphElement;
            this.buffers.iconVertex = buffers.iconVertex;
            this.buffers.iconElement = buffers.iconElement;
            this.buffers.collisionBoxVertex = buffers.collisionBoxVertex;

            for (var id in data.elementGroups) {
                this.elementGroups[id] = data.elementGroups[id];
            }
        },

        /**
         * Make sure that this tile doesn't own any data within a given
         * painter, so that it doesn't consume any memory or maintain
         * any references to the painter.
         * @param {Object} painter gl painter object
         * @returns {undefined}
         * @private
         */
        unloadVectorData: function(painter) {
            for (var b in this.buffers) {
                this.buffers[b].destroy(painter.gl);
            }
            this.buffers = null;
        }
    };

},{"../data/buffer/buffer_set":2,"../util/util":103,"gl-matrix":116}],41:[function(require,module,exports){
    'use strict';

    module.exports = TileCoord;

    function TileCoord(z, x, y, w) {
        if (w === undefined) w = 0;
        this.z = z;
        this.x = x;
        this.y = y;
        this.w = w;

        // calculate id
        w *= 2;
        if (w < 0) w = w * -1 - 1;
        var dim = 1 << this.z;
        this.id = ((dim * dim * w + dim * this.y + this.x) * 32) + this.z;
    }

    TileCoord.prototype.toString = function() {
        return this.z + "/" + this.x + "/" + this.y;
    };

// Parse a packed integer id into a TileCoord object
    TileCoord.fromID = function(id) {
        var z = id % 32, dim = 1 << z;
        var xy = ((id - z) / 32);
        var x = xy % dim, y = ((xy - x) / dim) % dim;
        var w = Math.floor(xy / (dim * dim));
        if (w % 2 !== 0) w = w * -1 - 1;
        w /= 2;
        return new TileCoord(z, x, y, w);
    };

// given a list of urls, choose a url template and return a tile URL
    TileCoord.prototype.url = function(urls, sourceMaxZoom) {
        return urls[(this.x + this.y) % urls.length]
            .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))
            .replace('{z}', Math.min(this.z, sourceMaxZoom || this.z))
            .replace('{x}', this.x)
            .replace('{y}', this.y);
    };

// Return the coordinate of the parent tile
    TileCoord.prototype.parent = function(sourceMaxZoom) {
        if (this.z === 0) return null;

        // the id represents an overscaled tile, return the same coordinates with a lower z
        if (this.z > sourceMaxZoom) {
            return new TileCoord(this.z - 1, this.x, this.y, this.w);
        }

        return new TileCoord(this.z - 1, Math.floor(this.x / 2), Math.floor(this.y / 2), this.w);
    };

    TileCoord.prototype.wrapped = function() {
        return new TileCoord(this.z, this.x, this.y, 0);
    };

// Return the coordinates of the tile's children
    TileCoord.prototype.children = function(sourceMaxZoom) {

        if (this.z >= sourceMaxZoom) {
            // return a single tile coord representing a an overscaled tile
            return [new TileCoord(this.z + 1, this.x, this.y, this.w)];
        }

        var z = this.z + 1;
        var x = this.x * 2;
        var y = this.y * 2;
        return [
            new TileCoord(z, x, y, this.w),
            new TileCoord(z, x + 1, y, this.w),
            new TileCoord(z, x, y + 1, this.w),
            new TileCoord(z, x + 1, y + 1, this.w)
        ];
    };

// Taken from polymaps src/Layer.js
// https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383

    function edge(a, b) {
        if (a.row > b.row) { var t = a; a = b; b = t; }
        return {
            x0: a.column,
            y0: a.row,
            x1: b.column,
            y1: b.row,
            dx: b.column - a.column,
            dy: b.row - a.row
        };
    }

    function scanSpans(e0, e1, ymin, ymax, scanLine) {
        var y0 = Math.max(ymin, Math.floor(e1.y0));
        var y1 = Math.min(ymax, Math.ceil(e1.y1));

        // sort edges by x-coordinate
        if ((e0.x0 === e1.x0 && e0.y0 === e1.y0) ?
            (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :
            (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {
            var t = e0; e0 = e1; e1 = t;
        }

        // scan lines!
        var m0 = e0.dx / e0.dy;
        var m1 = e1.dx / e1.dy;
        var d0 = e0.dx > 0; // use y + 1 to compute x0
        var d1 = e1.dx < 0; // use y + 1 to compute x1
        for (var y = y0; y < y1; y++) {
            var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;
            var x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
            scanLine(Math.floor(x1), Math.ceil(x0), y);
        }
    }

    function scanTriangle(a, b, c, ymin, ymax, scanLine) {
        var ab = edge(a, b),
            bc = edge(b, c),
            ca = edge(c, a);

        var t;

        // sort edges by y-length
        if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }
        if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }
        if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }

        // scan span! scan span!
        if (ab.dy) scanSpans(ca, ab, ymin, ymax, scanLine);
        if (bc.dy) scanSpans(ca, bc, ymin, ymax, scanLine);
    }

    TileCoord.cover = function(z, bounds, actualZ) {
        var tiles = 1 << z;
        var t = {};

        function scanLine(x0, x1, y) {
            var x, wx;
            if (y >= 0 && y <= tiles) {
                for (x = x0; x < x1; x++) {
                    wx = (x + tiles) % tiles;
                    var coord = new TileCoord(actualZ, wx, y, Math.floor(x / tiles));
                    t[coord.id] = coord;
                }
            }
        }

        // Divide the screen up in two triangles and scan each of them:
        // +---/
        // | / |
        // /---+
        scanTriangle(bounds[0], bounds[1], bounds[2], 0, tiles, scanLine);
        scanTriangle(bounds[2], bounds[3], bounds[0], 0, tiles, scanLine);

        return Object.keys(t).map(function(id) {
            return t[id];
        });
    };

},{}],42:[function(require,module,exports){
    'use strict';

    var Tile = require('./tile');
    var TileCoord = require('./tile_coord');
    var Point = require('point-geometry');
    var Cache = require('../util/mru_cache');
    var util = require('../util/util');

    module.exports = TilePyramid;

    /**
     * A tile pyramid is a specialized cache and datastructure
     * that contains tiles. It's used by sources to manage their
     * data.
     *
     * @param {Object} options
     * @param {number} options.tileSize
     * @param {number} options.minzoom
     * @param {number} options.maxzoom
     * @private
     */
    function TilePyramid(options) {
        this.tileSize = options.tileSize;
        this.minzoom = options.minzoom;
        this.maxzoom = options.maxzoom;
        this.reparseOverscaled = options.reparseOverscaled;

        this._load = options.load;
        this._abort = options.abort;
        this._unload = options.unload;
        this._add = options.add;
        this._remove = options.remove;
        this._redoPlacement = options.redoPlacement;

        this._tiles = {};
        this._cache = new Cache(options.cacheSize, function(tile) { return this._unload(tile); }.bind(this));
    }

    TilePyramid.prototype = {
        /**
         * Confirm that every tracked tile is loaded.
         * @returns {boolean} whether all tiles are loaded.
         * @private
         */
        loaded: function() {
            for (var t in this._tiles) {
                if (!this._tiles[t].loaded)
                    return false;
            }
            return true;
        },

        /**
         * Return all tile ids ordered with z-order, and cast to numbers
         * @returns {Array<number>} ids
         * @private
         */
        orderedIDs: function() {
            return Object.keys(this._tiles)
                .sort(function(a, b) { return (b % 32) - (a % 32); })
                .map(function(id) { return +id; });
        },

        renderedIDs: function() {
            return this.orderedIDs().filter(function(id) {
                return this._tiles[id].loaded && !this._coveredTiles[id];
            }.bind(this));
        },

        reload: function() {
            this._cache.reset();
            for (var i in this._tiles) {
                this._load(this._tiles[i]);
            }
        },

        /**
         * Get a specific tile by id
         * @param {string|number} id tile id
         * @returns {Object} tile
         * @private
         */
        getTile: function(id) {
            return this._tiles[id];
        },

        /**
         * get the zoom level adjusted for the difference in map and source tilesizes
         * @param {Object} transform
         * @returns {number} zoom level
         * @private
         */
        getZoom: function(transform) {
            return transform.zoom + Math.log(transform.tileSize / this.tileSize) / Math.LN2;
        },

        /**
         * Return a zoom level that will cover all tiles in a given transform
         * @param {Object} transform
         * @returns {number} zoom level
         * @private
         */
        coveringZoomLevel: function(transform) {
            return Math.floor(this.getZoom(transform));
        },

        /**
         * Given a transform, return all coordinates that could cover that
         * transform for a covering zoom level.
         * @param {Object} transform
         * @returns {Array<Tile>} tiles
         * @private
         */
        coveringTiles: function(transform) {
            var z = this.coveringZoomLevel(transform);
            var actualZ = z;

            if (z < this.minzoom) return [];
            if (z > this.maxzoom) z = this.maxzoom;

            var tr = transform,
                tileCenter = tr.locationCoordinate(tr.center)._zoomTo(z),
                centerPoint = new Point(tileCenter.column - 0.5, tileCenter.row - 0.5);

            return TileCoord.cover(z, [
                tr.pointCoordinate(new Point(0, 0))._zoomTo(z),
                tr.pointCoordinate(new Point(tr.width, 0))._zoomTo(z),
                tr.pointCoordinate(new Point(tr.width, tr.height))._zoomTo(z),
                tr.pointCoordinate(new Point(0, tr.height))._zoomTo(z)
            ], this.reparseOverscaled ? actualZ : z).sort(function(a, b) {
                return centerPoint.dist(a) - centerPoint.dist(b);
            });
        },

        /**
         * Recursively find children of the given tile (up to maxCoveringZoom) that are already loaded;
         * adds found tiles to retain object; returns true if children completely cover the tile
         *
         * @param {Coordinate} coord
         * @param {number} maxCoveringZoom
         * @param {boolean} retain
         * @returns {boolean} whether the operation was complete
         * @private
         */
        findLoadedChildren: function(coord, maxCoveringZoom, retain) {
            var complete = true;
            var z = coord.z;
            var coords = coord.children(this.maxzoom);
            for (var i = 0; i < coords.length; i++) {
                var id = coords[i].id;
                if (this._tiles[id] && this._tiles[id].loaded) {
                    retain[id] = true;
                } else {
                    complete = false;
                    if (z < maxCoveringZoom) {
                        // Go further down the hierarchy to find more unloaded children.
                        this.findLoadedChildren(coords[i], maxCoveringZoom, retain);
                    }
                }
            }
            return complete;
        },

        /**
         * Find a loaded parent of the given tile (up to minCoveringZoom);
         * adds the found tile to retain object and returns the tile if found
         *
         * @param {Coordinate} coord
         * @param {number} minCoveringZoom
         * @param {boolean} retain
         * @returns {Tile} tile object
         * @private
         */
        findLoadedParent: function(coord, minCoveringZoom, retain) {
            for (var z = coord.z - 1; z >= minCoveringZoom; z--) {
                coord = coord.parent(this.maxzoom);
                var tile = this._tiles[coord.id];
                if (tile && tile.loaded) {
                    retain[coord.id] = true;
                    return tile;
                }
            }
        },

        /**
         * Removes tiles that are outside the viewport and adds new tiles that
         * are inside the viewport.
         * @private
         */
        update: function(used, transform, fadeDuration) {
            var i;
            var coord;
            var tile;

            // Determine the overzooming/underzooming amounts.
            var zoom = Math.floor(this.getZoom(transform));
            var minCoveringZoom = util.clamp(zoom - 10, this.minzoom, this.maxzoom);
            var maxCoveringZoom = util.clamp(zoom + 1,  this.minzoom, this.maxzoom);

            // Retain is a list of tiles that we shouldn't delete, even if they are not
            // the most ideal tile for the current viewport. This may include tiles like
            // parent or child tiles that are *already* loaded.
            var retain = {};
            var now = new Date().getTime();

            // Covered is a list of retained tiles who's areas are full covered by other,
            // better, retained tiles. They are not drawn separately.
            this._coveredTiles = {};

            var required = used ? this.coveringTiles(transform) : [];
            for (i = 0; i < required.length; i++) {
                coord = required[i];
                tile = this.addTile(coord);

                retain[coord.id] = true;

                if (tile.loaded)
                    continue;

                // The tile we require is not yet loaded.
                // Retain child or parent tiles that cover the same area.
                if (!this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
                    this.findLoadedParent(coord, minCoveringZoom, retain);
                }
            }

            for (var id in retain) {
                coord = TileCoord.fromID(id);
                tile = this._tiles[id];
                if (tile && tile.timeAdded > now - (fadeDuration || 0)) {
                    // This tile is still fading in. Find tiles to cross-fade with it.
                    if (this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
                        this._coveredTiles[id] = true;
                        retain[id] = true;
                    } else {
                        this.findLoadedParent(coord, minCoveringZoom, retain);
                    }
                }
            }

            // Remove the tiles we don't need anymore.
            var remove = util.keysDifference(this._tiles, retain);
            for (i = 0; i < remove.length; i++) {
                this.removeTile(+remove[i]);
            }
        },

        /**
         * Add a tile, given its coordinate, to the pyramid.
         * @param {Coordinate} coord
         * @returns {Coordinate} the coordinate.
         * @private
         */
        addTile: function(coord) {
            var tile = this._tiles[coord.id];
            if (tile)
                return tile;

            var wrapped = coord.wrapped();
            tile = this._tiles[wrapped.id];

            if (!tile) {
                tile = this._cache.get(wrapped.id);
                if (tile && this._redoPlacement) {
                    this._redoPlacement(tile);
                }
            }

            if (!tile) {
                var zoom = coord.z;
                var overscaling = zoom > this.maxzoom ? Math.pow(2, zoom - this.maxzoom) : 1;
                tile = new Tile(wrapped, this.tileSize * overscaling);
                this._load(tile);
            }

            tile.uses++;
            this._tiles[coord.id] = tile;
            this._add(tile, coord);

            return tile;
        },

        /**
         * Remove a tile, given its id, from the pyramid
         * @param {string|number} id tile id
         * @returns {undefined} nothing
         * @private
         */
        removeTile: function(id) {
            var tile = this._tiles[id];
            if (!tile)
                return;

            tile.uses--;
            delete this._tiles[id];
            this._remove(tile);

            if (tile.uses > 0)
                return;

            if (tile.loaded) {
                this._cache.add(tile.coord.wrapped().id, tile);
            } else {
                this._abort(tile);
                this._unload(tile);
            }
        },

        /**
         * Remove all tiles from this pyramid
         * @private
         */
        clearTiles: function() {
            for (var id in this._tiles)
                this.removeTile(id);
            this._cache.reset();
        },

        /**
         * For a given coordinate, search through our current tiles and attempt
         * to find a tile at that point
         * @param {Coordinate} coord
         * @returns {Object} tile
         * @private
         */
        tileAt: function(coord) {
            var ids = this.orderedIDs();
            for (var i = 0; i < ids.length; i++) {
                var tile = this._tiles[ids[i]];
                var pos = tile.positionAt(coord, this.maxzoom);
                if (pos && pos.x >= 0 && pos.x < 4096 && pos.y >= 0 && pos.y < 4096) {
                    // The click is within the viewport. There is only ever one tile in
                    // a layer that has this property.
                    return {
                        tile: tile,
                        x: pos.x,
                        y: pos.y,
                        scale: pos.scale
                    };
                }
            }
        }
    };

},{"../util/mru_cache":101,"../util/util":103,"./tile":40,"./tile_coord":41,"point-geometry":150}],43:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');
    var Evented = require('../util/evented');
    var Source = require('./source');
    var Pako = require('pako');

    module.exports = VectorTileSource;

    function VectorTileSource(options) {
        util.extend(this, util.pick(options, ['url', 'tileSize']));

        if (this.tileSize !== 512) {
            throw new Error('vector tile sources must have a tileSize of 512');
        }

        Source._loadTileJSON.call(this, options);
    }

    VectorTileSource.prototype = util.inherit(Evented, {
        minzoom: 0,
        maxzoom: 22,
        tileSize: 512,
        reparseOverscaled: true,
        _loaded: false,

        onAdd: function(map) {
            this.map = map;
        },

        loaded: function() {
            return this._pyramid && this._pyramid.loaded();
        },

        update: function(transform) {
            if (this._pyramid) {
                this._pyramid.update(this.used, transform);
            }
        },

        reload: function() {
            this._pyramid.reload();
        },

        redoPlacement: function() {
            if (!this._pyramid) {
                return;
            }

            var ids = this._pyramid.orderedIDs();
            for (var i = 0; i < ids.length; i++) {
                var tile = this._pyramid.getTile(ids[i]);
                this._redoTilePlacement(tile);
            }
        },

        render: Source._renderTiles,
        featuresAt: Source._vectorFeaturesAt,

        _loadTile: function(tile) {
            var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
            var params = {
                url: tile.coord.url(this.tiles, this.maxzoom),
                uid: tile.uid,
                coord: tile.coord,
                zoom: tile.coord.z,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize * overscaling,
                source: this.id,
                overscaling: overscaling,
                angle: this.map.transform.angle,
                pitch: this.map.transform.pitch,
                collisionDebug: this.map.collisionDebug
            };

            if (tile.workerID) {
                this.dispatcher.send('reload tile', params, this._tileLoaded.bind(this, tile), tile.workerID);
                console.log("1");
            } else {
                console.log("2");
                var url = params.url.split('/'),
                    z = url[0],
                    x = url[1],
                    y = url[2];
                y = (1 << z) - 1 - y;

                if (!this.db) {
                    this.db = window.sqlitePlugin.openDatabase({
                        name: params.source + '.mbtiles',
                        location: 2,
                        createFromLocation: 1
                    });
                }

                this.db.transaction(function(tx) {
                    tx.executeSql('SELECT tile_data FROM tiles WHERE zoom_level = ? AND tile_column = ? AND tile_row = ?', [z, x, y], function(tx, res) {
                        var tileData = res.rows.item(0).tile_data,
                            tileDataDecoded = window.atob(tileData),
                            tileDataDecodedLength = tileDataDecoded.length,
                            tileDataTypedArray = new Uint8Array(tileDataDecodedLength);
                        for (var i = 0; i < tileDataDecodedLength; ++i) {
                            tileDataTypedArray[i] = tileDataDecoded.charCodeAt(i);
                        }
                        var tileDataInflated = Pako.inflate(tileDataTypedArray);
                        params.tileData = tileDataInflated;
                        tile.workerID = this.dispatcher.send('load tile', params, this._tileLoaded.bind(this, tile));
                    }.bind(this), function(tx, e) {
                        console.log('Database Error: ' + e.message);
                    });
                }.bind(this));

            }
        },

        _tileLoaded: function(tile, err, data) {
            if (tile.aborted)
                return;

            if (err) {
                this.fire('tile.error', {tile: tile});
                return;
            }

            tile.loadVectorData(data);

            if (tile.redoWhenDone) {
                tile.redoWhenDone = false;
                this._redoTilePlacement(tile);
            }

            this.fire('tile.load', {tile: tile});
        },

        _abortTile: function(tile) {
            tile.aborted = true;
            this.dispatcher.send('abort tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
        },

        _addTile: function(tile) {
            this.fire('tile.add', {tile: tile});
        },

        _removeTile: function(tile) {
            this.fire('tile.remove', {tile: tile});
        },

        _unloadTile: function(tile) {
            tile.unloadVectorData(this.map.painter);
            this.glyphAtlas.removeGlyphs(tile.uid);
            this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
        },

        _redoTilePlacement: function(tile) {

            if (!tile.loaded || tile.redoingPlacement) {
                tile.redoWhenDone = true;
                return;
            }

            tile.redoingPlacement = true;

            this.dispatcher.send('redo placement', {
                uid: tile.uid,
                source: this.id,
                angle: this.map.transform.angle,
                pitch: this.map.transform.pitch,
                collisionDebug: this.map.collisionDebug
            }, done.bind(this), tile.workerID);

            function done(_, data) {
                tile.reloadSymbolData(data, this.map.painter);
                this.fire('tile.load', {tile: tile});

                tile.redoingPlacement = false;
                if (tile.redoWhenDone) {
                    this._redoTilePlacement(tile);
                    tile.redoWhenDone = false;
                }
            }
        }
    });

},{"../util/evented":97,"../util/util":103,"./source":39,"pako":131}],44:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');
    var Tile = require('./tile');
    var LatLng = require('../geo/lat_lng');
    var Point = require('point-geometry');
    var Evented = require('../util/evented');
    var Coordinate = require('../geo/coordinate');
    var ajax = require('../util/ajax');

    module.exports = VideoSource;

    /**
     * Create a Video data source instance given an options object
     * @class VideoSource
     * @param {Object} [options]
     * @param {string|Array} options.url A string or array of URL(s) to video files
     * @param {Array} options.coordinates lat,lng coordinates in order clockwise starting at the top left: tl, tr, br, bl
     * @example
     * var sourceObj = new mapboxgl.VideoSource({
 *    url: [
 *        'https://www.mapbox.com/videos/baltimore-smoke.mp4',
 *        'https://www.mapbox.com/videos/baltimore-smoke.webm'
 *    ],
 *    coordinates: [
 *        [39.18579907229748, -76.54335737228394],
 *        [39.1838364847587, -76.52803659439087],
 *        [39.17683392507606, -76.5295386314392],
 *        [39.17876344106642, -76.54520273208618]
 *    ]
 * });
     * map.addSource('some id', sourceObj); // add
     * map.removeSource('some id');  // remove
     */
    function VideoSource(options) {
        this.coordinates = options.coordinates;

        ajax.getVideo(options.url, function(err, video) {
            // @TODO handle errors via event.
            if (err) return;

            this.video = video;
            this.video.loop = true;

            var loopID;

            // start repainting when video starts playing
            this.video.addEventListener('playing', function() {
                loopID = this.map.style.animationLoop.set(Infinity);
                this.map._rerender();
            }.bind(this));

            // stop repainting when video stops
            this.video.addEventListener('pause', function() {
                this.map.style.animationLoop.cancel(loopID);
            }.bind(this));

            this._loaded = true;

            if (this.map) {
                this.video.play();
                this.createTile();
                this.fire('change');
            }
        }.bind(this));
    }

    VideoSource.prototype = util.inherit(Evented, /** @lends VideoSource.prototype */{
        /**
         * Return the HTML video element.
         *
         * @returns {Object}
         */
        getVideo: function() {
            return this.video;
        },

        onAdd: function(map) {
            this.map = map;
            if (this.video) {
                this.video.play();
                this.createTile();
            }
        },

        createTile: function() {
            /*
             * Calculate which mercator tile is suitable for rendering the video in
             * and create a buffer with the corner coordinates. These coordinates
             * may be outside the tile, because raster tiles aren't clipped when rendering.
             */
            var map = this.map;
            var coords = this.coordinates.map(function(latlng) {
                var loc = LatLng.convert(latlng);
                return map.transform.locationCoordinate(loc).zoomTo(0);
            });

            var minX = Infinity;
            var minY = Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;

            for (var i = 0; i < coords.length; i++) {
                minX = Math.min(minX, coords[i].column);
                minY = Math.min(minY, coords[i].row);
                maxX = Math.max(maxX, coords[i].column);
                maxY = Math.max(maxY, coords[i].row);
            }

            var dx = maxX - minX;
            var dy = maxY - minY;
            var dMax = Math.max(dx, dy);
            var center = new Coordinate((minX + maxX) / 2, (minY + maxY) / 2, 0)
                .zoomTo(Math.floor(-Math.log(dMax) / Math.LN2));

            var tileExtent = 4096;
            var tileCoords = coords.map(function(coord) {
                var zoomedCoord = coord.zoomTo(center.zoom);
                return new Point(
                    Math.round((zoomedCoord.column - center.column) * tileExtent),
                    Math.round((zoomedCoord.row - center.row) * tileExtent));
            });

            var gl = map.painter.gl;
            var maxInt16 = 32767;
            var array = new Int16Array([
                tileCoords[0].x, tileCoords[0].y, 0, 0,
                tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
                tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
                tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
            ]);

            this.tile = new Tile();
            this.tile.buckets = {};

            this.tile.boundsBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.tile.boundsBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);

            this.center = center;
        },

        loaded: function() {
            return this.video && this.video.readyState >= 2;
        },

        update: function() {
            // noop
        },

        reload: function() {
            // noop
        },

        render: function(layers, painter) {
            if (!this._loaded) return;
            if (this.video.readyState < 2) return; // not enough data for current position

            var c = this.center;
            this.tile.calculateMatrices(c.zoom, c.column, c.row, this.map.transform, painter);

            var gl = painter.gl;
            if (!this.tile.texture) {
                this.tile.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
            } else {
                gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
            }

            painter.drawLayers(layers, this.tile.posMatrix, this.tile);
        },

        featuresAt: function(point, params, callback) {
            return callback(null, []);
        }
    });

},{"../geo/coordinate":17,"../geo/lat_lng":18,"../util/ajax":91,"../util/evented":97,"../util/util":103,"./tile":40,"point-geometry":150}],45:[function(require,module,exports){
    'use strict';

    var Actor = require('../util/actor');
    var WorkerTile = require('./worker_tile');
    var util = require('../util/util');
    var ajax = require('../util/ajax');
    var vt = require('vector-tile');
    var Protobuf = require('pbf');

    var geojsonvt = require('geojson-vt');
    var GeoJSONWrapper = require('./geojson_wrapper');

    module.exports = function(self) {
        return new Worker(self);
    };

    function Worker(self) {
        this.self = self;
        this.actor = new Actor(self, this);
        this.loading = {};

        this.loaded = {};
        this.layers = [];
        this.geoJSONIndexes = {};
    }

    util.extend(Worker.prototype, {
        'set layers': function(layers) {
            this.layers = layers;
        },

        'load tile': function(params, callback) {
            console.log("load tile");
            var tileData = params.tileData;
            delete params.tileData;

            var source = params.source,
                uid = params.uid;

            if (!this.loading[source])
                this.loading[source] = {};

            var tile = new WorkerTile(params);
            tile.data = new vt.VectorTile(new Protobuf(tileData));
            tile.parse(tile.data, this.layers, this.actor, callback);

            this.loaded[source] = this.loaded[source] || {};
            this.loaded[source][uid] = tile;

            function done(err, data) {
                delete this.loading[source][uid];

                if (err) return callback(err);

                tile.data = new vt.VectorTile(new Protobuf(new Uint8Array(data)));
                tile.parse(tile.data, this.layers, this.actor, callback);

                this.loaded[source] = this.loaded[source] || {};
                this.loaded[source][uid] = tile;
            }
        },

        'reload tile': function(params, callback) {
            var loaded = this.loaded[params.source],
                uid = params.uid;
            if (loaded && loaded[uid]) {
                var tile = loaded[uid];
                tile.parse(tile.data, this.layers, this.actor, callback);
            }
        },

        'abort tile': function(params) {
            var loading = this.loading[params.source],
                uid = params.uid;
            if (loading && loading[uid]) {
                loading[uid].xhr.abort();
                delete loading[uid];
            }
        },

        'remove tile': function(params) {
            var loaded = this.loaded[params.source],
                uid = params.uid;
            if (loaded && loaded[uid]) {
                delete loaded[uid];
            }
        },

        'redo placement': function(params, callback) {
            var loaded = this.loaded[params.source],
                loading = this.loading[params.source],
                uid = params.uid;

            if (loaded && loaded[uid]) {
                var tile = loaded[uid];
                var result = tile.redoPlacement(params.angle, params.pitch, params.collisionDebug);

                if (result.result) {
                    callback(null, result.result, result.transferables);
                }

            } else if (loading && loading[uid]) {
                loading[uid].angle = params.angle;
            }
        },

        'parse geojson': function(params, callback) {
            var indexData = function(err, data) {
                if (err) return callback(err);
                this.geoJSONIndexes[params.source] = geojsonvt(data, params.geojsonVtOptions);
                callback(null);
            }.bind(this);

            // TODO accept params.url for urls instead

            // Not, because of same origin issues, urls must either include an
            // explicit origin or absolute path.
            // ie: /foo/bar.json or http://example.com/bar.json
            // but not ../foo/bar.json
            if (typeof params.data === 'string') {
                ajax.getJSON(params.data, indexData);
            }
            else indexData(null, params.data);
        },

        'load geojson tile': function(params, callback) {
            var source = params.source,
                coord = params.coord;

            // console.time('tile ' + coord.z + ' ' + coord.x + ' ' + coord.y);

            var geoJSONTile = this.geoJSONIndexes[source].getTile(coord.z, coord.x, coord.y);

            // console.timeEnd('tile ' + coord.z + ' ' + coord.x + ' ' + coord.y);

            // if (!geoJSONTile) console.log('not found', this.geoJSONIndexes[source], coord);

            if (!geoJSONTile) return callback(null, null); // nothing in the given tile

            var tile = new WorkerTile(params);
            tile.parse(new GeoJSONWrapper(geoJSONTile.features), this.layers, this.actor, callback);

            this.loaded[source] = this.loaded[source] || {};
            this.loaded[source][params.uid] = tile;
        },

        'query features': function(params, callback) {
            var tile = this.loaded[params.source] && this.loaded[params.source][params.uid];
            if (tile) {
                tile.featureTree.query(params, callback);
            } else {
                callback(null, []);
            }
        }
    });

},{"../util/actor":90,"../util/ajax":91,"../util/util":103,"./geojson_wrapper":37,"./worker_tile":46,"geojson-vt":112,"pbf":148,"vector-tile":154}],46:[function(require,module,exports){
    'use strict';

    var FeatureTree = require('../data/feature_tree');
    var CollisionTile = require('../symbol/collision_tile');
    var BufferSet = require('../data/buffer/buffer_set');
    var createBucket = require('../data/create_bucket');

    module.exports = WorkerTile;

    function WorkerTile(params) {
        this.coord = params.coord;
        this.uid = params.uid;
        this.zoom = params.zoom;
        this.maxZoom = params.maxZoom;
        this.tileSize = params.tileSize;
        this.source = params.source;
        this.overscaling = params.overscaling;
        this.angle = params.angle;
        this.pitch = params.pitch;
        this.collisionDebug = params.collisionDebug;

        this.stacks = {};
    }

    WorkerTile.prototype.parse = function(data, layers, actor, callback) {

        this.status = 'parsing';

        this.featureTree = new FeatureTree(this.coord, this.overscaling);

        var i, k,
            tile = this,
            layer,
            bucket,
            buffers = new BufferSet(),
            collisionTile = new CollisionTile(this.angle, this.pitch),
            buckets = {},
            bucketsInOrder = this.bucketsInOrder = [],
            bucketsBySourceLayer = {};

        // Map non-ref layers to buckets.
        for (i = 0; i < layers.length; i++) {
            layer = layers[i];

            if (layer.source !== this.source)
                continue;

            if (layer.ref)
                continue;

            var minzoom = layer.minzoom;
            if (minzoom && this.zoom < minzoom && minzoom < this.maxZoom)
                continue;

            var maxzoom = layer.maxzoom;
            if (maxzoom && this.zoom >= maxzoom)
                continue;

            var visibility = layer.layout.visibility;
            if (visibility === 'none')
                continue;

            bucket = createBucket(layer, buffers, this.zoom, this.overscaling, this.collisionDebug);
            bucket.layers = [layer.id];

            buckets[bucket.id] = bucket;
            bucketsInOrder.push(bucket);

            if (data.layers) {
                // vectortile
                var sourceLayer = layer['source-layer'];
                if (!bucketsBySourceLayer[sourceLayer])
                    bucketsBySourceLayer[sourceLayer] = {};
                bucketsBySourceLayer[sourceLayer][bucket.id] = bucket;
            } else {
                // geojson tile
                bucketsBySourceLayer[bucket.id] = bucket;
            }
        }

        // Index ref layers.
        for (i = 0; i < layers.length; i++) {
            layer = layers[i];

            if (layer.source !== this.source)
                continue;

            if (!layer.ref)
                continue;

            bucket = buckets[layer.ref];
            if (!bucket)
                continue;

            bucket.layers.push(layer.id);
        }

        var extent = 4096;

        // read each layer, and sort its features into buckets
        if (data.layers) {
            // vectortile
            for (k in bucketsBySourceLayer) {
                layer = data.layers[k];
                if (!layer) continue;
                if (layer.extent) extent = layer.extent;
                sortLayerIntoBuckets(layer, bucketsBySourceLayer[k]);
            }
        } else {
            // geojson
            sortLayerIntoBuckets(data, bucketsBySourceLayer);
        }

        function sortLayerIntoBuckets(layer, buckets) {
            for (var i = 0; i < layer.length; i++) {
                var feature = layer.feature(i);
                for (var key in buckets) {
                    var bucket = buckets[key];
                    if (bucket.filter(feature)) {
                        bucket.features.push(feature);
                    }
                }
            }
        }

        var prevPlacementBucket;
        var remaining = bucketsInOrder.length;

        /*
         *  The async parsing here is a bit tricky.
         *  Some buckets depend on resources that may need to be loaded async (glyphs).
         *  Some buckets need to be parsed in order (to get collision priorities right).
         *
         *  Dependencies calls are initiated first to get those rolling.
         *  Buckets that don't need to be parsed in order, aren't to save time.
         */

        for (i = 0; i < bucketsInOrder.length; i++) {
            bucket = bucketsInOrder[i];

            // Link buckets that need to be parsed in order
            if (bucket.needsPlacement) {
                if (prevPlacementBucket) {
                    prevPlacementBucket.next = bucket;
                } else {
                    bucket.previousPlaced = true;
                }
                prevPlacementBucket = bucket;
            }

            if (bucket.getDependencies) {
                bucket.getDependencies(this, actor, dependenciesDone(bucket));
            }

            // immediately parse buckets where order doesn't matter and no dependencies
            if (!bucket.needsPlacement && !bucket.getDependencies) {
                parseBucket(tile, bucket);
            }
        }

        function dependenciesDone(bucket) {
            return function(err) {
                bucket.dependenciesLoaded = true;
                parseBucket(tile, bucket, err);
            };
        }

        function parseBucket(tile, bucket, skip) {
            if (bucket.getDependencies && !bucket.dependenciesLoaded) return;
            if (bucket.needsPlacement && !bucket.previousPlaced) return;

            if (!skip) {
                var now = Date.now();
                if (bucket.features.length) bucket.addFeatures(collisionTile);
                var time = Date.now() - now;
                if (bucket.interactive) {
                    for (var i = 0; i < bucket.features.length; i++) {
                        var feature = bucket.features[i];
                        tile.featureTree.insert(feature.bbox(), bucket.layers, feature);
                    }
                }
                if (typeof self !== 'undefined') {
                    self.bucketStats = self.bucketStats || {_total: 0};
                    self.bucketStats._total += time;
                    self.bucketStats[bucket.id] = (self.bucketStats[bucket.id] || 0) + time;
                }
            }

            remaining--;

            if (!remaining) {
                done();
                return;
            }

            // try parsing the next bucket, if it is ready
            if (bucket.next) {
                bucket.next.previousPlaced = true;
                parseBucket(tile, bucket.next);
            }
        }

        function done() {

            tile.status = 'done';

            if (tile.redoPlacementAfterDone) {
                var result = tile.redoPlacement(tile.angle, tile.pitch).result;
                buffers.glyphVertex = result.buffers.glyphVertex;
                buffers.iconVertex = result.buffers.iconVertex;
                buffers.collisionBoxVertex = result.buffers.collisionBoxVertex;
            }

            var transferables = [],
                elementGroups = {};

            for (k in buffers) {
                transferables.push(buffers[k].array);
            }

            for (k in buckets) {
                elementGroups[k] = buckets[k].elementGroups;
            }

            callback(null, {
                elementGroups: elementGroups,
                buffers: buffers,
                extent: extent
            }, transferables);
        }
    };

    WorkerTile.prototype.redoPlacement = function(angle, pitch, collisionDebug) {

        if (this.status !== 'done') {
            this.redoPlacementAfterDone = true;
            this.angle = angle;
            return {};
        }

        var buffers = new BufferSet();
        var transferables = [];
        var elementGroups = {};
        var collisionTile = new CollisionTile(angle, pitch);

        var bucketsInOrder = this.bucketsInOrder;
        for (var i = 0; i < bucketsInOrder.length; i++) {
            var bucket = bucketsInOrder[i];

            if (bucket.type === 'symbol') {
                bucket.placeFeatures(collisionTile, buffers, collisionDebug);
                elementGroups[bucket.id] = bucket.elementGroups;
            }
        }

        for (var k in buffers) {
            transferables.push(buffers[k].array);
        }

        return {
            result: {
                elementGroups: elementGroups,
                buffers: buffers
            },
            transferables: transferables
        };

    };

},{"../data/buffer/buffer_set":2,"../data/create_bucket":11,"../data/feature_tree":13,"../symbol/collision_tile":65}],47:[function(require,module,exports){
    'use strict';

    module.exports = AnimationLoop;

    function AnimationLoop() {
        this.n = 0;
        this.times = [];
    }

// Are all animations done?
    AnimationLoop.prototype.stopped = function() {
        this.times = this.times.filter(function(t) {
            return t.time >= (new Date()).getTime();
        });
        return !this.times.length;
    };

// Add a new animation that will run t milliseconds
// Returns an id that can be used to cancel it layer
    AnimationLoop.prototype.set = function(t) {
        this.times.push({ id: this.n, time: t + (new Date()).getTime() });
        return this.n++;
    };

// Cancel an animation
    AnimationLoop.prototype.cancel = function(n) {
        this.times = this.times.filter(function(t) {
            return t.id !== n;
        });
    };

},{}],48:[function(require,module,exports){
    'use strict';

    var Evented = require('../util/evented');
    var ajax = require('../util/ajax');
    var browser = require('../util/browser');

    module.exports = ImageSprite;

    function ImageSprite(base) {
        this.base = base;
        this.retina = browser.devicePixelRatio > 1;

        base = this.base + (this.retina ? '@2x' : '');

        ajax.getJSON(base + '.json', function(err, data) {
            if (err) {
                this.fire('error', {error: err});
                return;
            }

            this.data = data;
            if (this.img) this.fire('load');
        }.bind(this));

        ajax.getImage(base + '.png', function(err, img) {
            if (err) {
                this.fire('error', {error: err});
                return;
            }

            // premultiply the sprite
            var data = img.getData();
            var newdata = img.data = new Uint8Array(data.length);
            for (var i = 0; i < data.length; i += 4) {
                var alpha = data[i + 3] / 255;
                newdata[i + 0] = data[i + 0] * alpha;
                newdata[i + 1] = data[i + 1] * alpha;
                newdata[i + 2] = data[i + 2] * alpha;
                newdata[i + 3] = data[i + 3];
            }

            this.img = img;
            if (this.data) this.fire('load');
        }.bind(this));
    }

    ImageSprite.prototype = Object.create(Evented);

    ImageSprite.prototype.toJSON = function() {
        return this.base;
    };

    ImageSprite.prototype.loaded = function() {
        return !!(this.data && this.img);
    };

    ImageSprite.prototype.resize = function(/*gl*/) {
        if (browser.devicePixelRatio > 1 !== this.retina) {
            var newSprite = new ImageSprite(this.base);
            newSprite.on('load', function() {
                this.img = newSprite.img;
                this.data = newSprite.data;
                this.retina = newSprite.retina;
            }.bind(this));
        }
    };

    function SpritePosition() {}
    SpritePosition.prototype = { x: 0, y: 0, width: 0, height: 0, pixelRatio: 1, sdf: false };

    ImageSprite.prototype.getSpritePosition = function(name) {
        if (!this.loaded()) return new SpritePosition();

        var pos = this.data && this.data[name];
        if (pos && this.img) return pos;

        return new SpritePosition();
    };

},{"../util/ajax":91,"../util/browser":92,"../util/evented":97}],49:[function(require,module,exports){
    'use strict';

    var reference = require('./reference');

    module.exports = {};

    reference.layout.forEach(function(className) {
        var Properties = function(props) {
            for (var p in props) {
                this[p] = props[p];
            }
        };

        var properties = reference[className];
        for (var prop in properties) {
            if (properties[prop].default === undefined) continue;
            Properties.prototype[prop] = properties[prop].default;
        }
        module.exports[className.replace('layout_', '')] = Properties;
    });

},{"./reference":51}],50:[function(require,module,exports){
    'use strict';

    var reference = require('./reference');
    var parseCSSColor = require('csscolorparser').parseCSSColor;

    module.exports = {};

    reference.paint.forEach(function(className) {
        var Calculated = function() {};

        var properties = reference[className];
        for (var p in properties) {
            var prop = properties[p],
                value = prop.default;

            if (value === undefined) continue;
            if (prop.type === 'color') value = parseCSSColor(value);

            Calculated.prototype[p] = value;
        }

        Calculated.prototype.hidden = false;
        module.exports[className.replace('paint_', '')] = Calculated;
    });

},{"./reference":51,"csscolorparser":108}],51:[function(require,module,exports){
    module.exports = require('mapbox-gl-style-spec/reference/latest');

},{"mapbox-gl-style-spec/reference/latest":129}],52:[function(require,module,exports){
    'use strict';

    var Evented = require('../util/evented');
    var styleBatch = require('./style_batch');
    var StyleLayer = require('./style_layer');
    var ImageSprite = require('./image_sprite');
    var GlyphSource = require('../symbol/glyph_source');
    var GlyphAtlas = require('../symbol/glyph_atlas');
    var SpriteAtlas = require('../symbol/sprite_atlas');
    var LineAtlas = require('../render/line_atlas');
    var util = require('../util/util');
    var ajax = require('../util/ajax');
    var normalizeURL = require('../util/mapbox').normalizeStyleURL;
    var browser = require('../util/browser');
    var Dispatcher = require('../util/dispatcher');
    var AnimationLoop = require('./animation_loop');
    var validate = require('mapbox-gl-style-spec/lib/validate/latest');

    module.exports = Style;

    function Style(stylesheet, animationLoop) {
        this.animationLoop = animationLoop || new AnimationLoop();
        this.dispatcher = new Dispatcher(Math.max(browser.hardwareConcurrency - 1, 1), this);
        this.glyphAtlas = new GlyphAtlas(1024, 1024);
        this.spriteAtlas = new SpriteAtlas(512, 512);
        this.spriteAtlas.resize(browser.devicePixelRatio);
        this.lineAtlas = new LineAtlas(256, 512);

        this._layers = {};
        this._order  = [];
        this._groups = [];
        this.sources = {};

        this.zoomHistory = {};

        util.bindAll([
            '_forwardSourceEvent',
            '_forwardTileEvent',
            '_redoPlacement'
        ], this);

        var loaded = function(err, stylesheet) {
            if (err) {
                this.fire('error', {error: err});
                return;
            }

            var valid = validate(stylesheet);
            if (valid.length) {
                valid.forEach(function(e) {
                    throw new Error(e.message);
                });
            }

            this._loaded = true;
            this.stylesheet = stylesheet;

            var sources = stylesheet.sources;
            for (var id in sources) {
                this.addSource(id, sources[id]);
            }

            if (stylesheet.sprite) {
                this.sprite = new ImageSprite(stylesheet.sprite);
                this.sprite.on('load', this.fire.bind(this, 'change'));
            }

            this.glyphSource = new GlyphSource(stylesheet.glyphs, this.glyphAtlas);
            this._resolve();
            this.fire('load');
        }.bind(this);

        if (typeof stylesheet === 'string') {
            ajax.getJSON(normalizeURL(stylesheet), loaded);
        } else {
            browser.frame(loaded.bind(this, null, stylesheet));
        }
    }

    Style.prototype = util.inherit(Evented, {
        _loaded: false,

        loaded: function() {
            if (!this._loaded)
                return false;

            for (var id in this.sources)
                if (!this.sources[id].loaded())
                    return false;

            if (this.sprite && !this.sprite.loaded())
                return false;

            return true;
        },

        _resolve: function() {
            var id, layer;

            this._layers = {};
            this._order  = [];

            for (var i = 0; i < this.stylesheet.layers.length; i++) {
                layer = new StyleLayer(this.stylesheet.layers[i], this.stylesheet.constants || {});
                this._layers[layer.id] = layer;
                this._order.push(layer.id);
            }

            // Resolve layout properties.
            for (id in this._layers) {
                this._layers[id].resolveLayout();
            }

            // Resolve reference and paint properties.
            for (id in this._layers) {
                this._layers[id].resolveReference(this._layers);
                this._layers[id].resolvePaint();
            }

            this._groupLayers();
            this._broadcastLayers();
        },

        _groupLayers: function() {
            var group;

            this._groups = [];

            // Split into groups of consecutive top-level layers with the same source.
            for (var i = 0; i < this._order.length; ++i) {
                var layer = this._layers[this._order[i]];

                if (!group || layer.source !== group.source) {
                    group = [];
                    group.source = layer.source;
                    this._groups.push(group);
                }

                group.push(layer);
            }
        },

        _broadcastLayers: function() {
            var ordered = [];

            for (var id in this._layers) {
                ordered.push(this._layers[id].json());
            }

            this.dispatcher.broadcast('set layers', ordered);
        },

        _cascade: function(classes, options) {
            if (!this._loaded) return;

            options = options || {
                transition: true
            };

            for (var id in this._layers) {
                this._layers[id].cascade(classes, options,
                        this.stylesheet.transition || {},
                    this.animationLoop);
            }

            this.fire('change');
        },

        _recalculate: function(z) {
            for (var id in this.sources)
                this.sources[id].used = false;

            this._updateZoomHistory(z);

            this.rasterFadeDuration = 300;
            for (id in this._layers) {
                var layer = this._layers[id];

                if (layer.recalculate(z, this.zoomHistory) && layer.source) {
                    this.sources[layer.source].used = true;
                }
            }

            var maxZoomTransitionDuration = 300;
            if (Math.floor(this.z) !== Math.floor(z)) {
                this.animationLoop.set(maxZoomTransitionDuration);
            }

            this.z = z;
            this.fire('zoom');
        },

        _updateZoomHistory: function(z) {

            var zh = this.zoomHistory;

            if (zh.lastIntegerZoom === undefined) {
                // first time
                zh.lastIntegerZoom = Math.floor(z);
                zh.lastIntegerZoomTime = 0;
                zh.lastZoom = z;
            }

            // check whether an integer zoom level as passed since the last frame
            // and if yes, record it with the time. Used for transitioning patterns.
            if (Math.floor(zh.lastZoom) < Math.floor(z)) {
                zh.lastIntegerZoom = Math.floor(z);
                zh.lastIntegerZoomTime = Date.now();

            } else if (Math.floor(zh.lastZoom) > Math.floor(z)) {
                zh.lastIntegerZoom = Math.floor(z + 1);
                zh.lastIntegerZoomTime = Date.now();
            }

            zh.lastZoom = z;
        },

        /**
         * Apply multiple style mutations in a batch
         * @param {function} work Function which accepts the StyleBatch interface
         * @private
         */
        batch: function(work) {
            styleBatch(this, work);
        },

        addSource: function(id, source) {
            this.batch(function(batch) {
                batch.addSource(id, source);
            });

            return this;
        },

        /**
         * Remove a source from this stylesheet, given its id.
         * @param {string} id id of the source to remove
         * @returns {Style} this style
         * @throws {Error} if no source is found with the given ID
         * @private
         */
        removeSource: function(id) {
            this.batch(function(batch) {
                batch.removeSource(id);
            });

            return this;
        },

        /**
         * Get a source by id.
         * @param {string} id id of the desired source
         * @returns {Object} source
         * @private
         */
        getSource: function(id) {
            return this.sources[id];
        },

        /**
         * Add a layer to the map style. The layer will be inserted before the layer with
         * ID `before`, or appended if `before` is omitted.
         * @param {StyleLayer|Object} layer
         * @param {string=} before  ID of an existing layer to insert before
         * @fires layer.add
         * @returns {Style} `this`
         * @private
         */
        addLayer: function(layer, before) {
            this.batch(function(batch) {
                batch.addLayer(layer, before);
            });

            return this;
        },

        /**
         * Remove a layer from this stylesheet, given its id.
         * @param {string} id id of the layer to remove
         * @returns {Style} this style
         * @throws {Error} if no layer is found with the given ID
         * @private
         */
        removeLayer: function(id) {
            this.batch(function(batch) {
                batch.removeLayer(id);
            });

            return this;
        },

        /**
         * Get a layer by id.
         * @param {string} id id of the desired layer
         * @returns {Layer} layer
         * @private
         */
        getLayer: function(id) {
            return this._layers[id];
        },

        /**
         * If a layer has a `ref` property that makes it derive some values
         * from another layer, return that referent layer. Otherwise,
         * returns the layer itself.
         * @param {string} id the layer's id
         * @returns {Layer} the referent layer or the layer itself
         * @private
         */
        getReferentLayer: function(id) {
            var layer = this.getLayer(id);
            if (layer.ref) {
                layer = this.getLayer(layer.ref);
            }
            return layer;
        },

        setFilter: function(layer, filter) {
            this.batch(function(batch) {
                batch.setFilter(layer, filter);
            });

            return this;
        },

        /**
         * Get a layer's filter object
         * @param {string} layer the layer to inspect
         * @returns {*} the layer's filter, if any
         * @private
         */
        getFilter: function(layer) {
            return this.getReferentLayer(layer).filter;
        },

        setLayoutProperty: function(layer, name, value) {
            this.batch(function(batch) {
                batch.setLayoutProperty(layer, name, value);
            });

            return this;
        },

        /**
         * Get a layout property's value from a given layer
         * @param {string} layer the layer to inspect
         * @param {string} name the name of the layout property
         * @returns {*} the property value
         * @private
         */
        getLayoutProperty: function(layer, name) {
            return this.getReferentLayer(layer).getLayoutProperty(name);
        },

        setPaintProperty: function(layer, name, value, klass) {
            this.batch(function(batch) {
                batch.setPaintProperty(layer, name, value, klass);
            });

            return this;
        },

        getPaintProperty: function(layer, name, klass) {
            return this.getLayer(layer).getPaintProperty(name, klass);
        },

        featuresAt: function(coord, params, callback) {
            var features = [];
            var error = null;

            if (params.layer) {
                params.layer = { id: params.layer };
            }

            util.asyncEach(Object.keys(this.sources), function(id, callback) {
                var source = this.sources[id];
                source.featuresAt(coord, params, function(err, result) {
                    if (result) features = features.concat(result);
                    if (err) error = err;
                    callback();
                });
            }.bind(this), function() {
                if (error) return callback(error);

                callback(null, features
                    .filter(function(feature) {
                        return this._layers[feature.layer] !== undefined;
                    }.bind(this))
                    .map(function(feature) {
                        feature.layer = this._layers[feature.layer].json();
                        return feature;
                    }.bind(this)));
            }.bind(this));
        },

        _remove: function() {
            this.dispatcher.remove();
        },

        _reloadSource: function(id) {
            this.sources[id].reload();
        },

        _updateSources: function(transform) {
            for (var id in this.sources) {
                this.sources[id].update(transform);
            }
        },

        _redoPlacement: function() {
            for (var id in this.sources) {
                if (this.sources[id].redoPlacement) this.sources[id].redoPlacement();
            }
        },

        _forwardSourceEvent: function(e) {
            this.fire('source.' + e.type, util.extend({source: e.target}, e));
        },

        _forwardTileEvent: function(e) {
            this.fire(e.type, util.extend({source: e.target}, e));
        },

        // Callbacks from web workers

        'get sprite json': function(params, callback) {
            var sprite = this.sprite;
            if (sprite.loaded()) {
                callback(null, { sprite: sprite.data, retina: sprite.retina });
            } else {
                sprite.on('load', function() {
                    callback(null, { sprite: sprite.data, retina: sprite.retina });
                });
            }
        },

        'get icons': function(params, callback) {
            var sprite = this.sprite;
            var spriteAtlas = this.spriteAtlas;
            if (sprite.loaded()) {
                spriteAtlas.setSprite(sprite);
                spriteAtlas.addIcons(params.icons, callback);
            } else {
                sprite.on('load', function() {
                    spriteAtlas.setSprite(sprite);
                    spriteAtlas.addIcons(params.icons, callback);
                });
            }
        },

        'get glyphs': function(params, callback) {
            this.glyphSource.getSimpleGlyphs(params.fontstack, params.codepoints, params.uid, callback);
        }
    });

},{"../render/line_atlas":33,"../symbol/glyph_atlas":67,"../symbol/glyph_source":68,"../symbol/sprite_atlas":74,"../util/ajax":91,"../util/browser":92,"../util/dispatcher":94,"../util/evented":97,"../util/mapbox":100,"../util/util":103,"./animation_loop":47,"./image_sprite":48,"./style_batch":53,"./style_layer":57,"mapbox-gl-style-spec/lib/validate/latest":127}],53:[function(require,module,exports){
    'use strict';

    var Source = require('../source/source');
    var StyleLayer = require('./style_layer');

    function styleBatch(style, work) {
        if (!style._loaded) {
            throw new Error('Style is not done loading');
        }

        var batch = Object.create(styleBatch.prototype);

        batch._style = style;
        batch._groupLayers = false;
        batch._broadcastLayers = false;
        batch._reloadSources = {};
        batch._events = [];
        batch._change = false;

        work(batch);

        if (batch._groupLayers) {
            batch._style._groupLayers();
        }

        if (batch._broadcastLayers) {
            batch._style._broadcastLayers();
        }

        Object.keys(batch._reloadSources).forEach(function(sourceId) {
            batch._style._reloadSource(sourceId);
        });

        batch._events.forEach(function(args) {
            batch._style.fire.apply(batch._style, args);
        });

        if (batch._change) {
            batch._style.fire('change');
        }
    }

    styleBatch.prototype = {

        addLayer: function(layer, before) {
            if (this._style._layers[layer.id] !== undefined) {
                throw new Error('There is already a layer with this ID');
            }
            if (!(layer instanceof StyleLayer)) {
                layer = new StyleLayer(layer, this._style.stylesheet.constants || {});
            }
            this._style._layers[layer.id] = layer;
            this._style._order.splice(before ? this._style._order.indexOf(before) : Infinity, 0, layer.id);
            layer.resolveLayout();
            layer.resolveReference(this._style._layers);
            layer.resolvePaint();

            this._groupLayers = true;
            this._broadcastLayers = true;
            if (layer.source) {
                this._reloadSources[layer.source] = true;
            }
            this._events.push(['layer.add', {layer: layer}]);
            this._change = true;

            return this;
        },

        removeLayer: function(id) {
            var layer = this._style._layers[id];
            if (layer === undefined) {
                throw new Error('There is no layer with this ID');
            }
            for (var i in this._style._layers) {
                if (this._style._layers[i].ref === id) {
                    this.removeLayer(i);
                }
            }
            delete this._style._layers[id];
            this._style._order.splice(this._style._order.indexOf(id), 1);

            this._groupLayers = true;
            this._broadcastLayers = true;
            this._events.push(['layer.remove', {layer: layer}]);
            this._change = true;

            return this;
        },

        setPaintProperty: function(layer, name, value, klass) {
            this._style.getLayer(layer).setPaintProperty(name, value, klass);
            this._change = true;

            return this;
        },

        setLayoutProperty: function(layer, name, value) {
            layer = this._style.getReferentLayer(layer);
            layer.setLayoutProperty(name, value);

            this._broadcastLayers = true;
            if (layer.source) {
                this._reloadSources[layer.source] = true;
            }
            this._change = true;

            return this;
        },

        setFilter: function(layer, filter) {
            layer = this._style.getReferentLayer(layer);
            layer.filter = filter;

            this._broadcastLayers = true;
            if (layer.source) {
                this._reloadSources[layer.source] = true;
            }
            this._change = true;

            return this;
        },

        addSource: function(id, source) {
            if (!this._style._loaded) {
                throw new Error('Style is not done loading');
            }
            if (this._style.sources[id] !== undefined) {
                throw new Error('There is already a source with this ID');
            }
            source = Source.create(source);
            this._style.sources[id] = source;
            source.id = id;
            source.style = this._style;
            source.dispatcher = this._style.dispatcher;
            source.glyphAtlas = this._style.glyphAtlas;
            source
                .on('load', this._style._forwardSourceEvent)
                .on('error', this._style._forwardSourceEvent)
                .on('change', this._style._forwardSourceEvent)
                .on('tile.add', this._style._forwardTileEvent)
                .on('tile.load', this._style._forwardTileEvent)
                .on('tile.error', this._style._forwardTileEvent)
                .on('tile.remove', this._style._forwardTileEvent);

            this._events.push(['source.add', {source: source}]);
            this._change = true;

            return this;
        },

        removeSource: function(id) {
            if (this._style.sources[id] === undefined) {
                throw new Error('There is no source with this ID');
            }
            var source = this._style.sources[id];
            delete this._style.sources[id];
            source
                .off('load', this._style._forwardSourceEvent)
                .off('error', this._style._forwardSourceEvent)
                .off('change', this._style._forwardSourceEvent)
                .off('tile.add', this._style._forwardTileEvent)
                .off('tile.load', this._style._forwardTileEvent)
                .off('tile.error', this._style._forwardTileEvent)
                .off('tile.remove', this._style._forwardTileEvent);

            this._events.push(['source.remove', {source: source}]);
            this._change = true;

            return this;
        }
    };

    module.exports = styleBatch;

},{"../source/source":39,"./style_layer":57}],54:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');

    exports.resolve = function(value, constants) {
        function resolve(value) {
            return typeof value === 'string' && value[0] === '@' ? constants[value] : value;
        }

        var i;

        value = resolve(value);

        if (Array.isArray(value)) {
            value = value.slice();

            for (i = 0; i < value.length; i++) {
                if (value[i] in constants) {
                    value[i] = resolve(value[i]);
                }
            }
        }

        if (value.stops) {
            value = util.extend({}, value);
            value.stops = value.stops.slice();

            for (i = 0; i < value.stops.length; i++) {
                if (value.stops[i][1] in constants) {
                    value.stops[i] = [
                        value.stops[i][0],
                        resolve(value.stops[i][1])
                    ];
                }
            }
        }

        return value;
    };

    exports.resolveAll = function (properties, constants) {
        if (!constants)
            return properties;

        var result = {};

        for (var key in properties) {
            result[key] = exports.resolve(properties[key], constants);
        }

        return result;
    };

},{"../util/util":103}],55:[function(require,module,exports){
    'use strict';

    var parseCSSColor = require('csscolorparser').parseCSSColor;
    var mapboxGLFunction = require('mapbox-gl-function');
    var util = require('../util/util');

    module.exports = StyleDeclaration;

    function StyleDeclaration(reference, value) {
        this.type = reference.type;
        this.transitionable = reference.transition;

        // immutable representation of value. used for comparison
        this.json = JSON.stringify(value);

        if (this.type !== 'color') {
            this.value = value;
        } else if (value.stops) {
            this.value = prepareColorFunction(value);
        } else {
            this.value = parseColor(value);
        }

        if (reference.function === 'interpolated') {
            this.calculate = mapboxGLFunction.interpolated(this.value);
        } else {
            this.calculate = mapboxGLFunction['piecewise-constant'](this.value);
            if (reference.transition) {
                this.calculate = transitioned(this.calculate);
            }
        }
    }

    function transitioned(calculate) {
        return function(z, zh, duration) {
            var fraction = z % 1;
            var t = Math.min((Date.now() - zh.lastIntegerZoomTime) / duration, 1);
            var fromScale = 1;
            var toScale = 1;
            var mix, from, to;

            if (z > zh.lastIntegerZoom) {
                mix = fraction + (1 - fraction) * t;
                fromScale *= 2;
                from = calculate(z - 1);
                to = calculate(z);
            } else {
                mix = 1 - (1 - t) * fraction;
                to = calculate(z);
                from = calculate(z + 1);
                fromScale /= 2;
            }

            return {
                from: from,
                fromScale: fromScale,
                to: to,
                toScale: toScale,
                t: mix
            };
        };
    }

    var colorCache = {};

    function parseColor(value) {
        if (colorCache[value]) return colorCache[value];
        var color = prepareColor(parseCSSColor(value));
        colorCache[value] = color;
        return color;
    }

    function prepareColor(c) {
        return [c[0] / 255, c[1] / 255, c[2] / 255, c[3] / 1];
    }

    function prepareColorFunction(f) {
        return util.extend({}, f, {stops: f.stops.map(function(stop) {
            return [stop[0], parseColor(stop[1])];
        })});
    }

},{"../util/util":103,"csscolorparser":108,"mapbox-gl-function":126}],56:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');
    var reference = require('./reference');
    var StyleConstant = require('./style_constant');
    var StyleDeclaration = require('./style_declaration');

    var lookup = {
        paint: {},
        layout: {}
    };

    reference.layer.type.values.forEach(function(type) {
        lookup.paint[type] = makeConstructor(reference['paint_' + type]);
        lookup.layout[type] = makeConstructor(reference['layout_' + type]);
    });

    function makeConstructor(reference) {
        function StyleDeclarationSet(properties, constants) {
            this._values = {};
            this._transitions = {};

            this._constants = constants;

            for (var k in properties) {
                this[k] = StyleConstant.resolve(properties[k], this._constants);
            }
        }

        Object.keys(reference).forEach(function(k) {
            var property = reference[k];

            Object.defineProperty(StyleDeclarationSet.prototype, k, {
                set: function(v) {
                    this._values[k] = new StyleDeclaration(property, StyleConstant.resolve(v, this._constants));
                },
                get: function() {
                    return this._values[k].value;
                }
            });

            if (property.transition) {
                Object.defineProperty(StyleDeclarationSet.prototype, k + '-transition', {
                    set: function(v) {
                        this._transitions[k] = v;
                    },
                    get: function() {
                        return this._transitions[k];
                    }
                });
            }
        });

        StyleDeclarationSet.prototype.values = function() {
            return this._values;
        };

        StyleDeclarationSet.prototype.transition = function(k, global) {
            var t = this._transitions[k] || {};
            return {
                duration: util.coalesce(t.duration, global.duration, 300),
                delay: util.coalesce(t.delay, global.delay, 0)
            };
        };

        StyleDeclarationSet.prototype.json = function() {
            var result = {};

            for (var v in this._values) {
                result[v] = this._values[v].value;
            }

            for (var t in this._transitions) {
                result[t + '-transition'] = this._transitions[v];
            }

            return result;
        };

        return StyleDeclarationSet;
    }

    module.exports = function(renderType, layerType, properties, constants) {
        return new lookup[renderType][layerType](properties, constants);
    };

},{"../util/util":103,"./reference":51,"./style_constant":54,"./style_declaration":55}],57:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');
    var StyleConstant = require('./style_constant');
    var StyleTransition = require('./style_transition');
    var StyleDeclarationSet = require('./style_declaration_set');
    var LayoutProperties = require('./layout_properties');
    var PaintProperties = require('./paint_properties');

    module.exports = StyleLayer;

    function StyleLayer(layer, constants) {
        this._layer = layer;
        this._constants = constants;

        this.id = layer.id;
        this.ref = layer.ref;

        // Resolved and cascaded paint properties.
        this._resolved = {}; // class name -> StyleDeclarationSet
        this._cascaded = {}; // property name -> StyleTransition

        this.assign(layer);
    }

    StyleLayer.prototype = {
        resolveLayout: function() {
            if (!this.ref) {
                this.layout = new LayoutProperties[this.type](
                    StyleConstant.resolveAll(this._layer.layout, this._constants));

                if (this.layout['symbol-placement'] === 'line') {
                    if (!this.layout.hasOwnProperty('text-rotation-alignment')) {
                        this.layout['text-rotation-alignment'] = 'map';
                    }
                    if (!this.layout.hasOwnProperty('icon-rotation-alignment')) {
                        this.layout['icon-rotation-alignment'] = 'map';
                    }
                    this.layout['symbol-avoid-edges'] = true;
                }
            }
        },

        setLayoutProperty: function(name, value) {
            this.layout[name] = StyleConstant.resolve(value, this._constants);
        },

        getLayoutProperty: function(name) {
            return this.layout[name];
        },

        resolveReference: function(layers) {
            if (this.ref) {
                this.assign(layers[this.ref]);
            }
        },

        resolvePaint: function() {
            for (var p in this._layer) {
                var match = p.match(/^paint(?:\.(.*))?$/);
                if (!match)
                    continue;
                this._resolved[match[1] || ''] =
                    new StyleDeclarationSet('paint', this.type, this._layer[p], this._constants);
            }
        },

        setPaintProperty: function(name, value, klass) {
            var declarations = this._resolved[klass || ''];
            if (!declarations) {
                declarations = this._resolved[klass || ''] =
                    new StyleDeclarationSet('paint', this.type, {}, this._constants);
            }
            declarations[name] = value;
        },

        getPaintProperty: function(name, klass) {
            var declarations = this._resolved[klass || ''];
            if (!declarations)
                return undefined;
            return declarations[name];
        },

        cascade: function(classes, options, globalTrans, animationLoop) {
            for (var klass in this._resolved) {
                if (klass !== "" && !classes[klass])
                    continue;

                var declarations = this._resolved[klass],
                    values = declarations.values();

                for (var k in values) {
                    var newDeclaration = values[k];
                    var oldTransition = options.transition ? this._cascaded[k] : undefined;

                    // Only create a new transition if the declaration changed
                    if (!oldTransition || oldTransition.declaration.json !== newDeclaration.json) {
                        var newStyleTrans = declarations.transition(k, globalTrans);
                        var newTransition = this._cascaded[k] =
                            new StyleTransition(newDeclaration, oldTransition, newStyleTrans);

                        // Run the animation loop until the end of the transition
                        if (!newTransition.instant()) {
                            newTransition.loopID = animationLoop.set(newTransition.endTime - (new Date()).getTime());
                        }

                        if (oldTransition) {
                            animationLoop.cancel(oldTransition.loopID);
                        }
                    }
                }
            }
        },

        recalculate: function(z, zoomHistory) {
            var type = this.type,
                calculated = this.paint = new PaintProperties[type]();

            for (var k in this._cascaded) {
                calculated[k] = this._cascaded[k].at(z, zoomHistory);
            }

            this.hidden = (this.minzoom && z < this.minzoom) ||
                (this.maxzoom && z >= this.maxzoom) ||
                // include visibility check for non-bucketed background layers
                (this.layout.visibility === 'none');

            if (type === 'symbol') {
                if ((calculated['text-opacity'] === 0 || !this.layout['text-field']) &&
                    (calculated['icon-opacity'] === 0 || !this.layout['icon-image'])) {
                    this.hidden = true;
                } else {
                    premultiplyLayer(calculated, 'text');
                    premultiplyLayer(calculated, 'icon');
                }

            } else if (calculated[type + '-opacity'] === 0) {
                this.hidden = true;
            } else {
                premultiplyLayer(calculated, type);
            }

            if (this._cascaded['line-dasharray']) {
                // If the line is dashed, scale the dash lengths by the line
                // width at the previous round zoom level.
                var dashArray = calculated['line-dasharray'];
                var lineWidth = this._cascaded['line-width'] ?
                    this._cascaded['line-width'].at(Math.floor(z), Infinity) :
                    calculated['line-width'];

                dashArray.fromScale *= lineWidth;
                dashArray.toScale *= lineWidth;
            }

            return !this.hidden;
        },

        assign: function(layer) {
            util.extend(this, util.pick(layer,
                ['type', 'source', 'source-layer',
                    'minzoom', 'maxzoom', 'filter',
                    'layout']));
        },

        json: function() {
            return util.extend({},
                this._layer,
                util.pick(this,
                    ['type', 'source', 'source-layer',
                        'minzoom', 'maxzoom', 'filter',
                        'layout', 'paint']));
        }
    };

    function premultiplyLayer(layer, type) {
        var colorProp = type + '-color',
            haloProp = type + '-halo-color',
            outlineProp = type + '-outline-color',
            color = layer[colorProp],
            haloColor = layer[haloProp],
            outlineColor = layer[outlineProp],
            opacity = layer[type + '-opacity'];

        var colorOpacity = color && (opacity * color[3]);
        var haloOpacity = haloColor && (opacity * haloColor[3]);
        var outlineOpacity = outlineColor && (opacity * outlineColor[3]);

        if (colorOpacity !== undefined && colorOpacity < 1) {
            layer[colorProp] = util.premultiply([color[0], color[1], color[2], colorOpacity]);
        }
        if (haloOpacity !== undefined && haloOpacity < 1) {
            layer[haloProp] = util.premultiply([haloColor[0], haloColor[1], haloColor[2], haloOpacity]);
        }
        if (outlineOpacity !== undefined && outlineOpacity < 1) {
            layer[outlineProp] = util.premultiply([outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity]);
        }
    }

},{"../util/util":103,"./layout_properties":49,"./paint_properties":50,"./style_constant":54,"./style_declaration_set":56,"./style_transition":58}],58:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');
    var interpolate = require('../util/interpolate');

    module.exports = StyleTransition;

    /*
     * Represents a transition between two declarations
     */
    function StyleTransition(declaration, oldTransition, value) {

        this.declaration = declaration;
        this.startTime = this.endTime = (new Date()).getTime();

        var type = declaration.type;
        if ((type === 'string' || type === 'array') && declaration.transitionable) {
            this.interp = interpZoomTransitioned;
        } else {
            this.interp = interpolate[type];
        }

        this.oldTransition = oldTransition;
        this.duration = value.duration || 0;
        this.delay = value.delay || 0;

        if (!this.instant()) {
            this.endTime = this.startTime + this.duration + this.delay;
            this.ease = util.easeCubicInOut;
        }

        if (oldTransition && oldTransition.endTime <= this.startTime) {
            // Old transition is done running, so we can
            // delete its reference to its old transition.

            delete oldTransition.oldTransition;
        }
    }

    StyleTransition.prototype.instant = function() {
        return !this.oldTransition || !this.interp || (this.duration === 0 && this.delay === 0);
    };

    /*
     * Return the value of the transitioning property at zoom level `z` and optional time `t`
     */
    StyleTransition.prototype.at = function(z, zoomHistory, t) {

        var value = this.declaration.calculate(z, zoomHistory, this.duration);

        if (this.instant()) return value;

        t = t || Date.now();

        if (t < this.endTime) {
            var oldValue = this.oldTransition.at(z, zoomHistory, this.startTime);
            var eased = this.ease((t - this.startTime - this.delay) / this.duration);
            value = this.interp(oldValue, value, eased);
        }

        return value;

    };

    function interpZoomTransitioned(from, to, t) {
        return {
            from: from.to,
            fromScale: from.toScale,
            to: to.to,
            toScale: to.toScale,
            t: t
        };
    }

},{"../util/interpolate":99,"../util/util":103}],59:[function(require,module,exports){
    'use strict';

    var Point = require('point-geometry');

    module.exports = Anchor;

    function Anchor(x, y, angle, segment) {
        this.x = x;
        this.y = y;
        this.angle = angle;

        if (segment !== undefined) {
            this.segment = segment;
        }
    }

    Anchor.prototype = Object.create(Point.prototype);

    Anchor.prototype.clone = function() {
        return new Anchor(this.x, this.y, this.angle, this.segment);
    };

},{"point-geometry":150}],60:[function(require,module,exports){
    'use strict';

    module.exports = BinPack;
    function BinPack(width, height) {
        this.width = width;
        this.height = height;
        this.free = [{ x: 0, y: 0, w: width, h: height }];
    }

    /**
     * Simple algorithm to recursively merge the newly released cell with its
     * neighbor. This doesn't merge more than two cells at a time, and fails
     * for complicated merges.
     * @private
     */
    BinPack.prototype.release = function(rect) {
        for (var i = 0; i < this.free.length; i++) {
            var free = this.free[i];

            if (free.y === rect.y && free.h === rect.h && free.x + free.w === rect.x) {
                free.w += rect.w;

            } else if (free.x === rect.x && free.w === rect.w && free.y + free.h === rect.y) {
                free.h += rect.h;

            } else if (rect.y === free.y && rect.h === free.h && rect.x + rect.w === free.x) {
                free.x = rect.x;
                free.w += rect.w;

            } else if (rect.x === free.x && rect.w === free.w && rect.y + rect.h === free.y) {
                free.y = rect.y;
                free.h += rect.h;

            } else continue;

            this.free.splice(i, 1);
            this.release(free);
            return;

        }
        this.free.push(rect);
    };

    BinPack.prototype.allocate = function(width, height) {
        // Find the smallest free rect angle
        var rect = { x: Infinity, y: Infinity, w: Infinity, h: Infinity };
        var smallest = -1;
        for (var i = 0; i < this.free.length; i++) {
            var ref = this.free[i];
            if (width <= ref.w && height <= ref.h && ref.y <= rect.y && ref.x <= rect.x) {
                rect = ref;
                smallest = i;
            }
        }

        if (smallest < 0) {
            // There's no space left for this char.
            return { x: -1, y: -1 };
        }

        this.free.splice(smallest, 1);

        // Shorter/Longer Axis Split Rule (SAS)
        // http://clb.demon.fi/files/RectangleBinPack.pdf p. 15
        // Ignore the dimension of R and just split long the shorter dimension
        // See Also: http://www.cs.princeton.edu/~chazelle/pubs/blbinpacking.pdf
        if (rect.w < rect.h) {
            // split horizontally
            // +--+---+
            // |__|___|  <-- b1
            // +------+  <-- b2
            if (rect.w > width) this.free.push({ x: rect.x + width, y: rect.y, w: rect.w - width, h: height });
            if (rect.h > height) this.free.push({ x: rect.x, y: rect.y + height, w: rect.w, h: rect.h - height });
        } else {
            // split vertically
            // +--+---+
            // |__|   | <-- b1
            // +--|---+ <-- b2
            if (rect.w > width) this.free.push({ x: rect.x + width, y: rect.y, w: rect.w - width, h: rect.h });
            if (rect.h > height) this.free.push({ x: rect.x, y: rect.y + height, w: width, h: rect.h - height });
        }

        return { x: rect.x, y: rect.y, w: width, h: height };
    };

},{}],61:[function(require,module,exports){
    'use strict';

    module.exports = checkMaxAngle;

    /**
     * Labels placed around really sharp angles aren't readable. Check if any
     * part of the potential label has a combined angle that is too big.
     *
     * @param {Array<Point>} line
     * @param {Anchor} anchor The point on the line around which the label is anchored.
     * @param {number} labelLength The length of the label in geometry units.
     * @param {number} windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.
     * @param {number} maxAngle The maximum combined angle that any window along the label is allowed to have.
     *
     * @returns {boolean} whether the label should be placed
     * @private
     */
    function checkMaxAngle(line, anchor, labelLength, windowSize, maxAngle) {

        // horizontal labels always pass
        if (anchor.segment === undefined) return true;

        var p = anchor;
        var index = anchor.segment + 1;
        var anchorDistance = 0;

        // move backwards along the line to the first segment the label appears on
        while (anchorDistance > -labelLength / 2) {
            index--;

            // there isn't enough room for the label after the beginning of the line
            if (index < 0) return false;

            anchorDistance -= line[index].dist(p);
            p = line[index];
        }

        anchorDistance += line[index].dist(line[index + 1]);
        index++;

        // store recent corners and their total angle difference
        var recentCorners = [];
        var recentAngleDelta = 0;

        // move forwards by the length of the label and check angles along the way
        while (anchorDistance < labelLength / 2) {
            var prev = line[index - 1];
            var current = line[index];
            var next = line[index + 1];

            // there isn't enough room for the label before the end of the line
            if (!next) return false;

            var angleDelta = prev.angleTo(current) - current.angleTo(next);
            // restrict angle to -pi..pi range
            angleDelta = ((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI;

            recentCorners.push({
                distance: anchorDistance,
                angleDelta: angleDelta
            });
            recentAngleDelta += angleDelta;

            // remove corners that are far enough away from the list of recent anchors
            while (anchorDistance - recentCorners[0].distance > windowSize) {
                recentAngleDelta -= recentCorners.shift().angleDelta;
            }

            // the sum of angles within the window area exceeds the maximum allowed value. check fails.
            if (Math.abs(recentAngleDelta) > maxAngle) return false;

            index++;
            anchorDistance += current.dist(next);
        }

        // no part of the line had an angle greater than the maximum allowed. check passes.
        return true;
    }

},{}],62:[function(require,module,exports){
    'use strict';

    var Point = require('point-geometry');

    module.exports = clipLine;

    /**
     * Returns the part of a multiline that intersects with the provided rectangular box.
     *
     * @param {Array<Array<Point>>} lines
     * @param {number} x1 the left edge of the box
     * @param {number} y1 the top edge of the box
     * @param {number} x2 the right edge of the box
     * @param {number} y2 the bottom edge of the box
     * @returns {Array<Array<Point>>} lines
     * @private
     */
    function clipLine(lines, x1, y1, x2, y2) {
        var clippedLines = [];

        for (var l = 0; l < lines.length; l++) {
            var line = lines[l];
            var clippedLine;

            for (var i = 0; i < line.length - 1; i++) {
                var p0 = line[i];
                var p1 = line[i + 1];


                if (p0.x < x1 && p1.x < x1) {
                    continue;
                } else if (p0.x < x1) {
                    p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)));
                } else if (p1.x < x1) {
                    p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)));
                }

                if (p0.y < y1 && p1.y < y1) {
                    continue;
                } else if (p0.y < y1) {
                    p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1);
                } else if (p1.y < y1) {
                    p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1);
                }

                if (p0.x >= x2 && p1.x >= x2) {
                    continue;
                } else if (p0.x >= x2) {
                    p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)));
                } else if (p1.x >= x2) {
                    p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)));
                }

                if (p0.y >= y2 && p1.y >= y2) {
                    continue;
                } else if (p0.y >= y2) {
                    p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2);
                } else if (p1.y >= y2) {
                    p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2);
                }

                if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {
                    clippedLine = [p0];
                    clippedLines.push(clippedLine);
                }

                clippedLine.push(p1);
            }
        }

        return clippedLines;
    }

},{"point-geometry":150}],63:[function(require,module,exports){
    'use strict';

    module.exports = CollisionBox;

    /**
     * A collision box represents an area of the map that that is covered by a
     * label. CollisionFeature uses one or more of these collision boxes to
     * represent all the area covered by a single label. They are used to
     * prevent collisions between labels.
     *
     * A collision box actually represents a 3d volume. The first two dimensions,
     * x and y, are specified with `anchor` along with `x1`, `y1`, `x2`, `y2`.
     * The third dimension, zoom, is limited by `maxScale` which determines
     * how far in the z dimensions the box extends.
     *
     * As you zoom in on a map, all points on the map get further and further apart
     * but labels stay roughly the same size. Labels cover less real world area on
     * the map at higher zoom levels than they do at lower zoom levels. This is why
     * areas are are represented with an anchor point and offsets from that point
     * instead of just using four absolute points.
     *
     * Line labels are represented by a set of these boxes spaced out along a line.
     * When you zoom in, line labels cover less real world distance along the line
     * than they used to. Collision boxes near the edges that used to cover label
     * no longer do. If a box doesn't cover the label anymore it should be ignored
     * when doing collision checks. `maxScale` is how much you can scale the map
     * before the label isn't within the box anymore.
     * For example
     * lower zoom:
     * https://cloud.githubusercontent.com/assets/1421652/8060094/4d975f76-0e91-11e5-84b1-4edeb30a5875.png
     * slightly higher zoom:
     * https://cloud.githubusercontent.com/assets/1421652/8060061/26ae1c38-0e91-11e5-8c5a-9f380bf29f0a.png
     * In the zoomed in image the two grey boxes on either side don't cover the
     * label anymore. Their maxScale is smaller than the current scale.
     *
     *
     * @class CollisionBox
     * @param {Point} anchorPoint The anchor point the box is centered around.
     * @param {number} x1 The distance from the anchor to the left edge.
     * @param {number} y1 The distance from the anchor to the top edge.
     * @param {number} x2 The distance from the anchor to the right edge.
     * @param {number} y2 The distance from the anchor to the bottom edge.
     * @param {number} maxScale The maximum scale this box can block other boxes at.
     * @private
     */
    function CollisionBox(anchorPoint, x1, y1, x2, y2, maxScale) {
        // the box is centered around the anchor point
        this.anchorPoint = anchorPoint;

        // distances to the edges from the anchor
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;

        // the box is only valid for scales < maxScale.
        // The box does not block other boxes at scales >= maxScale;
        this.maxScale = maxScale;

        // the scale at which the label can first be shown
        this.placementScale = 0;

        // rotated and scaled bbox used for indexing
        this[0] = this[1] = this[2] = this[3] = 0;
    }

},{}],64:[function(require,module,exports){
    'use strict';

    var CollisionBox = require('./collision_box');
    var Point = require('point-geometry');

    module.exports = CollisionFeature;

    /**
     * A CollisionFeature represents the area of the tile covered by a single label.
     * It is used with CollisionTile to check if the label overlaps with any
     * previous labels. A CollisionFeature is mostly just a set of CollisionBox
     * objects.
     *
     * @class CollisionFeature
     * @param {Array<Point>} line The geometry the label is placed on.
     * @param {Anchor} anchor The point along the line around which the label is anchored.
     * @param {Object} shaped The text or icon shaping results.
     * @param {number} boxScale A magic number used to convert from glyph metrics units to geometry units.
     * @param {number} padding The amount of padding to add around the label edges.
     * @param {boolean} alignLine Whether the label is aligned with the line or the viewport.
     *
     * @private
     */
    function CollisionFeature(line, anchor, shaped, boxScale, padding, alignLine) {

        var y1 = shaped.top * boxScale - padding;
        var y2 = shaped.bottom * boxScale + padding;
        var x1 = shaped.left * boxScale - padding;
        var x2 = shaped.right * boxScale + padding;

        this.boxes = [];

        if (alignLine) {

            var height = y2 - y1;
            var length = x2 - x1;

            if (height <= 0) return;

            // set minimum box height to avoid very many small labels
            height = Math.max(10 * boxScale, height);

            this._addLineCollisionBoxes(line, anchor, length, height);

        } else {
            this.boxes.push(new CollisionBox(new Point(anchor.x, anchor.y), x1, y1, x2, y2, Infinity));
        }
    }

    /**
     * Create a set of CollisionBox objects for a line.
     *
     * @param {Array<Point>} line
     * @param {Anchor} anchor
     * @param {number} labelLength The length of the label in geometry units.
     * @param {number} boxSize The size of the collision boxes that will be created.
     *
     * @private
     */
    CollisionFeature.prototype._addLineCollisionBoxes = function(line, anchor, labelLength, boxSize) {
        var step = boxSize / 2;
        var nBoxes = Math.floor(labelLength / step);

        // offset the center of the first box by half a box so that the edge of the
        // box is at the edge of the label.
        var firstBoxOffset = -boxSize / 2;

        var bboxes = this.boxes;

        var p = anchor;
        var index = anchor.segment + 1;
        var anchorDistance = firstBoxOffset;

        // move backwards along the line to the first segment the label appears on
        do {
            index--;

            // there isn't enough room for the label after the beginning of the line
            // checkMaxAngle should have already caught this
            if (index < 0) return bboxes;

            anchorDistance -= line[index].dist(p);
            p = line[index];
        } while (anchorDistance > -labelLength / 2);

        var segmentLength = line[index].dist(line[index + 1]);

        for (var i = 0; i < nBoxes; i++) {
            // the distance the box will be from the anchor
            var boxDistanceToAnchor = -labelLength / 2 + i * step;

            // the box is not on the current segment. Move to the next segment.
            while (anchorDistance + segmentLength < boxDistanceToAnchor) {
                anchorDistance += segmentLength;
                index++;

                // There isn't enough room before the end of the line.
                if (index + 1 >= line.length) return bboxes;

                segmentLength = line[index].dist(line[index + 1]);
            }

            // the distance the box will be from the beginning of the segment
            var segmentBoxDistance = boxDistanceToAnchor - anchorDistance;

            var p0 = line[index];
            var p1 = line[index + 1];
            var boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0);

            var distanceToInnerEdge = Math.max(Math.abs(boxDistanceToAnchor - firstBoxOffset) - step / 2, 0);
            var maxScale = labelLength / 2 / distanceToInnerEdge;

            bboxes.push(new CollisionBox(boxAnchorPoint, -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2, maxScale));
        }

        return bboxes;
    };

},{"./collision_box":63,"point-geometry":150}],65:[function(require,module,exports){
    'use strict';

    var rbush = require('rbush');

    module.exports = CollisionTile;

    /**
     * A collision tile used to prevent symbols from overlapping. It keep tracks of
     * where previous symbols have been placed and is used to check if a new
     * symbol overlaps with any previously added symbols.
     *
     * @class CollisionTile
     * @param {number} angle
     * @param {number} pitch
     * @private
     */
    function CollisionTile(angle, pitch) {
        this.tree = rbush();
        this.angle = angle;

        var sin = Math.sin(angle),
            cos = Math.cos(angle);
        this.rotationMatrix = [cos, -sin, sin, cos];

        // Stretch boxes in y direction to account for the map tilt.
        this.yStretch = 1 / Math.cos(pitch / 180 * Math.PI);

        // The amount the map is squished depends on the y position.
        // Sort of account for this by making all boxes a bit bigger.
        this.yStretch = Math.pow(this.yStretch, 1.3);
    }

    CollisionTile.prototype.minScale = 0.25;
    CollisionTile.prototype.maxScale = 2;


    /**
     * Find the scale at which the collisionFeature can be shown without
     * overlapping with other features.
     *
     * @param {CollisionFeature} collisionFeature
     * @returns {number} placementScale
     * @private
     */
    CollisionTile.prototype.placeCollisionFeature = function(collisionFeature) {

        var minPlacementScale = this.minScale;
        var rotationMatrix = this.rotationMatrix;
        var yStretch = this.yStretch;

        for (var b = 0; b < collisionFeature.boxes.length; b++) {

            var box = collisionFeature.boxes[b];

            var anchorPoint = box.anchorPoint.matMult(rotationMatrix);
            var x = anchorPoint.x;
            var y = anchorPoint.y;

            box[0] = x + box.x1;
            box[1] = y + box.y1 * yStretch;
            box[2] = x + box.x2;
            box[3] = y + box.y2 * yStretch;

            var blockingBoxes = this.tree.search(box);

            for (var i = 0; i < blockingBoxes.length; i++) {
                var blocking = blockingBoxes[i];
                var blockingAnchorPoint = blocking.anchorPoint.matMult(rotationMatrix);

                // Find the lowest scale at which the two boxes can fit side by side without overlapping.
                // Original algorithm:
                var s1 = (blocking.x1 - box.x2) / (x - blockingAnchorPoint.x); // scale at which new box is to the left of old box
                var s2 = (blocking.x2 - box.x1) / (x - blockingAnchorPoint.x); // scale at which new box is to the right of old box
                var s3 = (blocking.y1 - box.y2) * yStretch / (y - blockingAnchorPoint.y); // scale at which new box is to the top of old box
                var s4 = (blocking.y2 - box.y1) * yStretch / (y - blockingAnchorPoint.y); // scale at which new box is to the bottom of old box

                if (isNaN(s1) || isNaN(s2)) s1 = s2 = 1;
                if (isNaN(s3) || isNaN(s4)) s3 = s4 = 1;

                var collisionFreeScale = Math.min(Math.max(s1, s2), Math.max(s3, s4));

                if (collisionFreeScale > blocking.maxScale) {
                    // After a box's maxScale the label has shrunk enough that the box is no longer needed to cover it,
                    // so unblock the new box at the scale that the old box disappears.
                    collisionFreeScale = blocking.maxScale;
                }

                if (collisionFreeScale > box.maxScale) {
                    // If the box can only be shown after it is visible, then the box can never be shown.
                    // But the label can be shown after this box is not visible.
                    collisionFreeScale = box.maxScale;
                }

                if (collisionFreeScale > minPlacementScale &&
                    collisionFreeScale >= blocking.placementScale) {
                    // If this collision occurs at a lower scale than previously found collisions
                    // and the collision occurs while the other label is visible

                    // this this is the lowest scale at which the label won't collide with anything
                    minPlacementScale = collisionFreeScale;
                }

                if (minPlacementScale >= this.maxScale) return minPlacementScale;
            }
        }

        return minPlacementScale;
    };

    /**
     * Remember this collisionFeature and what scale it was placed at to block
     * later features from overlapping with it.
     *
     * @param {CollisionFeature} collisionFeature
     * @param {number} minPlacementScale
     * @private
     */
    CollisionTile.prototype.insertCollisionFeature = function(collisionFeature, minPlacementScale) {

        var boxes = collisionFeature.boxes;
        for (var k = 0; k < boxes.length; k++) {
            boxes[k].placementScale = minPlacementScale;
        }

        if (minPlacementScale < this.maxScale) {
            this.tree.load(boxes);
        }
    };

},{"rbush":151}],66:[function(require,module,exports){
    'use strict';

    var interpolate = require('../util/interpolate');
    var Anchor = require('../symbol/anchor');
    var checkMaxAngle = require('./check_max_angle');

    module.exports = getAnchors;

    function getAnchors(line, spacing, maxAngle, shapedText, glyphSize, boxScale, overscaling) {

        // Resample a line to get anchor points for labels and check that each
        // potential label passes text-max-angle check and has enough froom to fit
        // on the line.

        var angleWindowSize = shapedText ?
            3 / 5 * glyphSize * boxScale :
            0;

        // Offset the first anchor by half the label length (or half the spacing distance for icons).
        // Add a bit of extra offset to avoid collisions at T intersections.
        var labelLength = shapedText ? shapedText.right - shapedText.left : spacing;
        var extraOffset = glyphSize * 2;
        var offset = ((labelLength / 2 + extraOffset) * boxScale * overscaling) % spacing;

        return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength * boxScale, false);
    }


    function resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, placeAtMiddle) {

        var distance = 0,
            markedDistance = offset ? offset - spacing : 0;

        var anchors = [];

        for (var i = 0; i < line.length - 1; i++) {

            var a = line[i],
                b = line[i + 1];

            var segmentDist = a.dist(b),
                angle = b.angleTo(a);

            while (markedDistance + spacing < distance + segmentDist) {
                markedDistance += spacing;

                var t = (markedDistance - distance) / segmentDist,
                    x = interpolate(a.x, b.x, t),
                    y = interpolate(a.y, b.y, t);

                if (x >= 0 && x < 4096 && y >= 0 && y < 4096) {
                    x = Math.round(x);
                    y = Math.round(y);
                    var anchor = new Anchor(x, y, angle, i);

                    if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {
                        anchors.push(anchor);
                    }
                }
            }

            distance += segmentDist;
        }

        if (!placeAtMiddle && !anchors.length) {
            // The first attempt at finding anchors at which labels can be placed failed.
            // Try again, but this time just try placing one anchor at the middle of the line.
            // This has the most effect for short lines in overscaled tiles, since the
            // initial offset used in overscaled tiles is calculated to align labels with positions in
            // parent tiles instead of placing the label as close to the beginning as possible.
            anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, true);
        }

        return anchors;
    }

},{"../symbol/anchor":59,"../util/interpolate":99,"./check_max_angle":61}],67:[function(require,module,exports){
    'use strict';

    var BinPack = require('./bin_pack');

    module.exports = GlyphAtlas;
    function GlyphAtlas(width, height) {
        this.width = width;
        this.height = height;

        this.bin = new BinPack(width, height);
        this.index = {};
        this.ids = {};
        this.data = new Uint8Array(width * height);
    }

    GlyphAtlas.prototype = {
        get debug() {
            return 'canvas' in this;
        },
        set debug(value) {
            if (value && !this.canvas) {
                this.canvas = document.createElement('canvas');
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                document.body.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');
            } else if (!value && this.canvas) {
                this.canvas.parentNode.removeChild(this.canvas);
                delete this.ctx;
                delete this.canvas;
            }
        }
    };

    GlyphAtlas.prototype.getGlyphs = function() {
        var glyphs = {},
            split,
            name,
            id;

        for (var key in this.ids) {
            split = key.split('#');
            name = split[0];
            id = split[1];

            if (!glyphs[name]) glyphs[name] = [];
            glyphs[name].push(id);
        }

        return glyphs;
    };

    GlyphAtlas.prototype.getRects = function() {
        var rects = {},
            split,
            name,
            id;

        for (var key in this.ids) {
            split = key.split('#');
            name = split[0];
            id = split[1];

            if (!rects[name]) rects[name] = {};
            rects[name][id] = this.index[key];
        }

        return rects;
    };

    GlyphAtlas.prototype.removeGlyphs = function(id) {
        for (var key in this.ids) {

            var ids = this.ids[key];

            var pos = ids.indexOf(id);
            if (pos >= 0) ids.splice(pos, 1);
            this.ids[key] = ids;

            if (!ids.length) {
                var rect = this.index[key];

                var target = this.data;
                for (var y = 0; y < rect.h; y++) {
                    var y1 = this.width * (rect.y + y) + rect.x;
                    for (var x = 0; x < rect.w; x++) {
                        target[y1 + x] = 0;
                    }
                }

                this.dirty = true;

                this.bin.release(rect);

                delete this.index[key];
                delete this.ids[key];
            }
        }


        this.updateTexture(this.gl);
    };

    GlyphAtlas.prototype.addGlyph = function(id, name, glyph, buffer) {
        if (!glyph) {
            // console.warn('missing glyph', code, String.fromCharCode(code));
            return null;
        }
        var key = name + "#" + glyph.id;

        // The glyph is already in this texture.
        if (this.index[key]) {
            if (this.ids[key].indexOf(id) < 0) {
                this.ids[key].push(id);
            }
            return this.index[key];
        }

        // The glyph bitmap has zero width.
        if (!glyph.bitmap) {
            return null;
        }

        var bufferedWidth = glyph.width + buffer * 2;
        var bufferedHeight = glyph.height + buffer * 2;

        // Add a 1px border around every image.
        var padding = 1;
        var packWidth = bufferedWidth + 2 * padding;
        var packHeight = bufferedHeight + 2 * padding;

        // Increase to next number divisible by 4, but at least 1.
        // This is so we can scale down the texture coordinates and pack them
        // into 2 bytes rather than 4 bytes.
        packWidth += (4 - packWidth % 4);
        packHeight += (4 - packHeight % 4);

        var rect = this.bin.allocate(packWidth, packHeight);
        if (rect.x < 0) {
            console.warn('glyph bitmap overflow');
            return { glyph: glyph, rect: null };
        }

        this.index[key] = rect;
        this.ids[key] = [id];

        var target = this.data;
        var source = glyph.bitmap;
        for (var y = 0; y < bufferedHeight; y++) {
            var y1 = this.width * (rect.y + y + padding) + rect.x + padding;
            var y2 = bufferedWidth * y;
            for (var x = 0; x < bufferedWidth; x++) {
                target[y1 + x] = source[y2 + x];
            }
        }

        this.dirty = true;

        return rect;
    };

    GlyphAtlas.prototype.bind = function(gl) {
        this.gl = gl;
        if (!this.texture) {
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);

        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
        }
    };

    GlyphAtlas.prototype.updateTexture = function(gl) {
        this.bind(gl);
        if (this.dirty) {

            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);

            // DEBUG
            if (this.ctx) {
                var data = this.ctx.getImageData(0, 0, this.width, this.height);
                for (var i = 0, j = 0; i < this.data.length; i++, j += 4) {
                    data.data[j] = this.data[i];
                    data.data[j + 1] = this.data[i];
                    data.data[j + 2] = this.data[i];
                    data.data[j + 3] = 255;
                }
                this.ctx.putImageData(data, 0, 0);

                this.ctx.strokeStyle = 'red';
                for (var k = 0; k < this.bin.free.length; k++) {
                    var free = this.bin.free[k];
                    this.ctx.strokeRect(free.x, free.y, free.w, free.h);
                }
            }
            // END DEBUG

            this.dirty = false;
        }
    };

},{"./bin_pack":60}],68:[function(require,module,exports){
    'use strict';

    var normalizeURL = require('../util/mapbox').normalizeGlyphsURL;
    var getArrayBuffer = require('../util/ajax').getArrayBuffer;
    var Glyphs = require('../util/glyphs');
    var Protobuf = require('pbf');

    module.exports = GlyphSource;

    /**
     * A glyph source has a URL from which to load new glyphs and owns a GlyphAtlas
     * that stores currently-loaded glyphs.
     *
     * @param {string} url glyph template url
     * @param {Object} glyphAtlas glyph atlas object
     * @private
     */
    function GlyphSource(url, glyphAtlas) {
        this.url = url && normalizeURL(url);
        this.glyphAtlas = glyphAtlas;
        this.stacks = [];
        this.loading = {};
    }

    GlyphSource.prototype.getSimpleGlyphs = function(fontstack, glyphIDs, uid, callback) {

        if (this.stacks[fontstack] === undefined) this.stacks[fontstack] = {};

        var glyphs = {};

        var stack = this.stacks[fontstack];
        var glyphAtlas = this.glyphAtlas;

        // the number of pixels the sdf bitmaps are padded by
        var buffer = 3;

        var missing = {};
        var remaining = 0;
        var range;

        for (var i = 0; i < glyphIDs.length; i++) {
            var glyphID = glyphIDs[i];
            range = Math.floor(glyphID / 256);

            if (stack[range]) {
                var glyph = stack[range].glyphs[glyphID];
                var rect  = glyphAtlas.addGlyph(uid, fontstack, glyph, buffer);
                if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
            } else {
                if (missing[range] === undefined) {
                    missing[range] = [];
                    remaining++;
                }
                missing[range].push(glyphID);
            }
        }

        if (!remaining) callback(undefined, glyphs);

        var onRangeLoaded = function(err, range, data) {
            // TODO not be silent about errors
            if (!err) {
                var stack = this.stacks[fontstack][range] = data.stacks[0];
                for (var i = 0; i < missing[range].length; i++) {
                    var glyphID = missing[range][i];
                    var glyph = stack.glyphs[glyphID];
                    var rect  = glyphAtlas.addGlyph(uid, fontstack, glyph, buffer);
                    if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
                }
            }
            remaining--;
            if (!remaining) callback(undefined, glyphs);
        }.bind(this);

        for (var r in missing) {
            this.loadRange(fontstack, r, onRangeLoaded);
        }
    };

// A simplified representation of the glyph containing only the properties needed for shaping.
    function SimpleGlyph(glyph, rect, buffer) {
        var padding = 1;
        this.advance = glyph.advance;
        this.left = glyph.left - buffer - padding;
        this.top = glyph.top + buffer + padding;
        this.rect = rect;
    }

    GlyphSource.prototype.loadRange = function(fontstack, range, callback) {

        if (range * 256 > 65535) return callback('gyphs > 65535 not supported');

        if (this.loading[fontstack] === undefined) this.loading[fontstack] = {};
        var loading = this.loading[fontstack];

        if (loading[range]) {
            loading[range].push(callback);
        } else {
            loading[range] = [callback];

            var rangeName = (range * 256) + '-' + (range * 256 + 255);
            var url = glyphUrl(fontstack, rangeName, this.url);

            getArrayBuffer(url, function(err, data) {
                var glyphs = !err && new Glyphs(new Protobuf(new Uint8Array(data)));
                for (var i = 0; i < loading[range].length; i++) {
                    loading[range][i](err, range, glyphs);
                }
                delete loading[range];
            });
        }
    };

    /**
     * Use CNAME sharding to load a specific glyph range over a randomized
     * but consistent subdomain.
     * @param {string} fontstack comma-joined fonts
     * @param {string} range comma-joined range
     * @param {url} url templated url
     * @param {string} [subdomains=abc] subdomains as a string where each letter is one.
     * @returns {string} a url to load that section of glyphs
     * @private
     */
    function glyphUrl(fontstack, range, url, subdomains) {
        subdomains = subdomains || 'abc';

        return url
            .replace('{s}', subdomains[fontstack.length % subdomains.length])
            .replace('{fontstack}', fontstack)
            .replace('{range}', range);
    }

},{"../util/ajax":91,"../util/glyphs":98,"../util/mapbox":100,"pbf":148}],69:[function(require,module,exports){
    'use strict';

    module.exports = function (features, textFeatures, geometries) {

        var leftIndex = {},
            rightIndex = {},
            mergedFeatures = [],
            mergedGeom = [],
            mergedTexts = [],
            mergedIndex = 0,
            k;

        function add(k) {
            mergedFeatures.push(features[k]);
            mergedGeom.push(geometries[k]);
            mergedTexts.push(textFeatures[k]);
            mergedIndex++;
        }

        function mergeFromRight(leftKey, rightKey, geom) {
            var i = rightIndex[leftKey];
            delete rightIndex[leftKey];
            rightIndex[rightKey] = i;

            mergedGeom[i][0].pop();
            mergedGeom[i][0] = mergedGeom[i][0].concat(geom[0]);
            return i;
        }

        function mergeFromLeft(leftKey, rightKey, geom) {
            var i = leftIndex[rightKey];
            delete leftIndex[rightKey];
            leftIndex[leftKey] = i;

            mergedGeom[i][0].shift();
            mergedGeom[i][0] = geom[0].concat(mergedGeom[i][0]);
            return i;
        }

        function getKey(text, geom, onRight) {
            var point = onRight ? geom[0][geom[0].length - 1] : geom[0][0];
            return text + ':' + point.x + ':' + point.y;
        }

        for (k = 0; k < features.length; k++) {
            var geom = geometries[k],
                text = textFeatures[k];

            if (!text) {
                add(k);
                continue;
            }

            var leftKey = getKey(text, geom),
                rightKey = getKey(text, geom, true);

            if ((leftKey in rightIndex) && (rightKey in leftIndex) && (rightIndex[leftKey] !== leftIndex[rightKey])) {
                // found lines with the same text adjacent to both ends of the current line, merge all three
                var j = mergeFromLeft(leftKey, rightKey, geom);
                var i = mergeFromRight(leftKey, rightKey, mergedGeom[j]);

                delete leftIndex[leftKey];
                delete rightIndex[rightKey];

                rightIndex[getKey(text, mergedGeom[i], true)] = i;
                mergedGeom[j] = null;

            } else if (leftKey in rightIndex) {
                // found mergeable line adjacent to the start of the current line, merge
                mergeFromRight(leftKey, rightKey, geom);

            } else if (rightKey in leftIndex) {
                // found mergeable line adjacent to the end of the current line, merge
                mergeFromLeft(leftKey, rightKey, geom);

            } else {
                // no adjacent lines, add as a new item
                add(k);
                leftIndex[leftKey] = mergedIndex - 1;
                rightIndex[rightKey] = mergedIndex - 1;
            }
        }

        return {
            features: mergedFeatures,
            textFeatures: mergedTexts,
            geometries: mergedGeom
        };
    };

},{}],70:[function(require,module,exports){
    'use strict';

    var Point = require('point-geometry');

    module.exports = {
        getIconQuads: getIconQuads,
        getGlyphQuads: getGlyphQuads
    };

    var minScale = 0.5; // underscale by 1 zoom level

    /**
     * A textured quad for rendering a single icon or glyph.
     *
     * The zoom range the glyph can be shown is defined by minScale and maxScale.
     *
     * @param {Point} anchorPoint the point the symbol is anchored around
     * @param {Point} tl The offset of the top left corner from the anchor.
     * @param {Point} tr The offset of the top right corner from the anchor.
     * @param {Point} bl The offset of the bottom left corner from the anchor.
     * @param {Point} br The offset of the bottom right corner from the anchor.
     * @param {Object} tex The texture coordinates.
     * @param {number} angle The angle of the label at it's center, not the angle of this quad.
     * @param {number} minScale The minimum scale, relative to the tile's intended scale, that the glyph can be shown at.
     * @param {number} maxScale The maximum scale, relative to the tile's intended scale, that the glyph can be shown at.
     *
     * @class SymbolQuad
     * @private
     */
    function SymbolQuad(anchorPoint, tl, tr, bl, br, tex, angle, minScale, maxScale) {
        this.anchorPoint = anchorPoint;
        this.tl = tl;
        this.tr = tr;
        this.bl = bl;
        this.br = br;
        this.tex = tex;
        this.angle = angle;
        this.minScale = minScale;
        this.maxScale = maxScale;
    }

    /**
     * Create the quads used for rendering an icon.
     *
     * @param {Anchor} anchor
     * @param {PositionedIcon} shapedIcon
     * @param {number} boxScale A magic number for converting glyph metric units to geometry units.
     * @param {Array<Array<Point>>} line
     * @param {LayoutProperties} layout
     * @param {boolean} alongLine Whether the icon should be placed along the line.
     * @returns {Array<SymbolQuad>}
     * @private
     */
    function getIconQuads(anchor, shapedIcon, boxScale, line, layout, alongLine) {

        var rect = shapedIcon.image.rect;

        var border = 1;
        var left = shapedIcon.left - border;
        var right = left + rect.w;
        var top = shapedIcon.top - border;
        var bottom = top + rect.h;
        var tl = new Point(left, top);
        var tr = new Point(right, top);
        var br = new Point(right, bottom);
        var bl = new Point(left, bottom);

        var angle = layout['icon-rotate'] * Math.PI / 180;
        if (alongLine) {
            var prev = line[anchor.segment];
            angle += Math.atan2(anchor.y - prev.y, anchor.x - prev.x);
        }

        if (angle) {
            var sin = Math.sin(angle),
                cos = Math.cos(angle),
                matrix = [cos, -sin, sin, cos];

            tl = tl.matMult(matrix);
            tr = tr.matMult(matrix);
            bl = bl.matMult(matrix);
            br = br.matMult(matrix);
        }

        return [new SymbolQuad(new Point(anchor.x, anchor.y), tl, tr, bl, br, shapedIcon.image.rect, 0, minScale, Infinity)];
    }

    /**
     * Create the quads used for rendering a text label.
     *
     * @param {Anchor} anchor
     * @param {Shaping} shaping
     * @param {number} boxScale A magic number for converting from glyph metric units to geometry units.
     * @param {Array<Array<Point>>} line
     * @param {LayoutProperties} layout
     * @param {boolean} alongLine Whether the label should be placed along the line.
     * @returns {Array<SymbolQuad>}
     * @private
     */
    function getGlyphQuads(anchor, shaping, boxScale, line, layout, alongLine) {

        var textRotate = layout['text-rotate'] * Math.PI / 180;
        var keepUpright = layout['text-keep-upright'];

        var positionedGlyphs = shaping.positionedGlyphs;
        var quads = [];

        for (var k = 0; k < positionedGlyphs.length; k++) {
            var positionedGlyph = positionedGlyphs[k];
            var glyph = positionedGlyph.glyph;
            var rect = glyph.rect;

            if (!rect) continue;

            var centerX = (positionedGlyph.x + glyph.advance / 2) * boxScale;

            var glyphInstances;
            var labelMinScale = minScale;
            if (alongLine) {
                glyphInstances = [];
                labelMinScale = getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, true);
                if (keepUpright) {
                    labelMinScale = Math.min(labelMinScale, getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, false));
                }

            } else {
                glyphInstances = [{
                    anchorPoint: new Point(anchor.x, anchor.y),
                    offset: 0,
                    angle: 0,
                    maxScale: Infinity,
                    minScale: minScale
                }];
            }

            var x1 = positionedGlyph.x + glyph.left,
                y1 = positionedGlyph.y - glyph.top,
                x2 = x1 + rect.w,
                y2 = y1 + rect.h,

                otl = new Point(x1, y1),
                otr = new Point(x2, y1),
                obl = new Point(x1, y2),
                obr = new Point(x2, y2);

            for (var i = 0; i < glyphInstances.length; i++) {

                var instance = glyphInstances[i],
                    tl = otl,
                    tr = otr,
                    bl = obl,
                    br = obr,
                    angle = instance.angle + textRotate;

                if (angle) {
                    var sin = Math.sin(angle),
                        cos = Math.cos(angle),
                        matrix = [cos, -sin, sin, cos];

                    tl = tl.matMult(matrix);
                    tr = tr.matMult(matrix);
                    bl = bl.matMult(matrix);
                    br = br.matMult(matrix);
                }

                // Prevent label from extending past the end of the line
                var glyphMinScale = Math.max(instance.minScale, labelMinScale);

                var glyphAngle = (anchor.angle + textRotate + instance.offset + 2 * Math.PI) % (2 * Math.PI);
                quads.push(new SymbolQuad(instance.anchorPoint, tl, tr, bl, br, rect, glyphAngle, glyphMinScale, instance.maxScale));

            }
        }

        return quads;
    }

    /**
     * We can only render glyph quads that slide along a straight line. To draw
     * curved lines we need an instance of a glyph for each segment it appears on.
     * This creates all the instances of a glyph that are necessary to render a label.
     *
     * We need a
     * @param {Array<Object>} glyphInstances An empty array that glyphInstances are added to.
     * @param {Anchor} anchor
     * @param {number} offset The glyph's offset from the center of the label.
     * @param {Array<Point>} line
     * @param {number} segment The index of the segment of the line on which the anchor exists.
     * @param {boolean} forward If true get the glyphs that come later on the line, otherwise get the glyphs that come earlier.
     *
     * @returns {Array<Object>} glyphInstances
     * @private
     */
    function getSegmentGlyphs(glyphs, anchor, offset, line, segment, forward) {
        var upsideDown = !forward;

        if (offset < 0) forward = !forward;

        if (forward) segment++;

        var newAnchorPoint = new Point(anchor.x, anchor.y);
        var end = line[segment];
        var prevScale = Infinity;

        offset = Math.abs(offset);

        var placementScale = minScale;

        while (true) {
            var distance = newAnchorPoint.dist(end);
            var scale = offset / distance;

            // Get the angle of the line segment
            var angle = Math.atan2(end.y - newAnchorPoint.y, end.x - newAnchorPoint.x);
            if (!forward) angle += Math.PI;
            if (upsideDown) angle += Math.PI;

            glyphs.push({
                anchorPoint: newAnchorPoint,
                offset: upsideDown ? Math.PI : 0,
                minScale: scale,
                maxScale: prevScale,
                angle: (angle + 2 * Math.PI) % (2 * Math.PI)
            });

            if (scale <= placementScale) break;

            newAnchorPoint = end;

            // skip duplicate nodes
            while (newAnchorPoint.equals(end)) {
                segment += forward ? 1 : -1;
                end = line[segment];
                if (!end) {
                    return scale;
                }
            }

            var unit = end.sub(newAnchorPoint)._unit();
            newAnchorPoint = newAnchorPoint.sub(unit._mult(distance));

            prevScale = scale;
        }

        return placementScale;
    }

},{"point-geometry":150}],71:[function(require,module,exports){
    'use strict';

    var resolveTokens = require('../util/token');

    module.exports = resolveIcons;

// For an array of features determine what icons need to be loaded.
    function resolveIcons(features, layoutProperties) {
        var icons = [];

        for (var i = 0, fl = features.length; i < fl; i++) {
            var text = resolveTokens(features[i].properties, layoutProperties['icon-image']);
            if (!text) continue;

            if (icons.indexOf(text) < 0) {
                icons.push(text);
            }
        }

        return icons;
    }

},{"../util/token":102}],72:[function(require,module,exports){
    'use strict';

    var resolveTokens = require('../util/token');

    module.exports = resolveText;

    /**
     * For an array of features determine what glyph ranges need to be loaded
     * and apply any text preprocessing. The remaining users of text should
     * use the `textFeatures` key returned by this function rather than accessing
     * feature text directly.
     * @private
     */
    function resolveText(features, layoutProperties, glyphs) {
        var textFeatures = [];
        var codepoints = [];

        for (var i = 0, fl = features.length; i < fl; i++) {
            var text = resolveTokens(features[i].properties, layoutProperties['text-field']);
            if (!text) {
                textFeatures[i] = null;
                continue;
            }
            text = text.toString();

            var transform = layoutProperties['text-transform'];
            if (transform === 'uppercase') {
                text = text.toLocaleUpperCase();
            } else if (transform === 'lowercase') {
                text = text.toLocaleLowerCase();
            }

            for (var j = 0, jl = text.length; j < jl; j++) {
                codepoints.push(text.charCodeAt(j));
            }

            // Track indexes of features with text.
            textFeatures[i] = text;
        }

        // get a list of unique codepoints we are missing
        codepoints = uniq(codepoints, glyphs);

        return {
            textFeatures: textFeatures,
            codepoints: codepoints
        };
    }

    function uniq(ids, alreadyHave) {
        var u = [];
        var last;
        ids.sort(sortNumbers);
        for (var i = 0; i < ids.length; i++) {
            if (ids[i] !== last) {
                last = ids[i];
                if (!alreadyHave[last]) u.push(ids[i]);
            }
        }
        return u;
    }

    function sortNumbers(a, b) {
        return a - b;
    }

},{"../util/token":102}],73:[function(require,module,exports){
    'use strict';

    module.exports = {
        shapeText: shapeText,
        shapeIcon: shapeIcon
    };


// The position of a glyph relative to the text's anchor point.
    function PositionedGlyph(codePoint, x, y, glyph) {
        this.codePoint = codePoint;
        this.x = x;
        this.y = y;
        this.glyph = glyph;
    }

// A collection of positioned glyphs and some metadata
    function Shaping(positionedGlyphs, top, bottom, left, right) {
        this.positionedGlyphs = positionedGlyphs;
        this.top = top;
        this.bottom = bottom;
        this.left = left;
        this.right = right;
    }

    function shapeText(text, glyphs, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {

        var positionedGlyphs = [];
        var shaping = new Shaping(positionedGlyphs, translate[1], translate[1], translate[0], translate[0]);

        // the y offset *should* be part of the font metadata
        var yOffset = -17;

        var x = translate[0];
        var y = translate[1] + yOffset;

        for (var i = 0; i < text.length; i++) {
            var codePoint = text.charCodeAt(i);
            var glyph = glyphs[codePoint];

            if (!glyph) continue;

            positionedGlyphs.push(new PositionedGlyph(codePoint, x, y, glyph));
            x += glyph.advance + spacing;
        }

        if (!positionedGlyphs.length) return false;

        linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify);

        return shaping;
    }

    var breakable = { 32: true }; // Currently only breaks at regular spaces

    function linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify) {
        var lastSafeBreak = null;

        var lengthBeforeCurrentLine = 0;
        var lineStartIndex = 0;
        var line = 0;

        var maxLineLength = 0;

        var positionedGlyphs = shaping.positionedGlyphs;

        if (maxWidth) {
            for (var i = 0; i < positionedGlyphs.length; i++) {
                var positionedGlyph = positionedGlyphs[i];

                positionedGlyph.x -= lengthBeforeCurrentLine;
                positionedGlyph.y += lineHeight * line;

                if (positionedGlyph.x > maxWidth && lastSafeBreak !== null) {

                    var lineLength = positionedGlyphs[lastSafeBreak + 1].x;
                    maxLineLength = Math.max(lineLength, maxLineLength);

                    for (var k = lastSafeBreak + 1; k <= i; k++) {
                        positionedGlyphs[k].y += lineHeight;
                        positionedGlyphs[k].x -= lineLength;
                    }

                    if (justify) {
                        justifyLine(positionedGlyphs, glyphs, lineStartIndex, lastSafeBreak - 1, justify);
                    }

                    lineStartIndex = lastSafeBreak + 1;
                    lastSafeBreak = null;
                    lengthBeforeCurrentLine += lineLength;
                    line++;
                }

                if (breakable[positionedGlyph.codePoint]) {
                    lastSafeBreak = i;
                }
            }
        }

        var lastPositionedGlyph = positionedGlyphs[positionedGlyphs.length - 1];
        var lastLineLength = lastPositionedGlyph.x + glyphs[lastPositionedGlyph.codePoint].advance;
        maxLineLength = Math.max(maxLineLength, lastLineLength);

        var height = (line + 1) * lineHeight;

        justifyLine(positionedGlyphs, glyphs, lineStartIndex, positionedGlyphs.length - 1, justify);
        align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line);

        // Calculate the bounding box
        shaping.top += -verticalAlign * height;
        shaping.bottom = shaping.top + height;
        shaping.left += -horizontalAlign * maxLineLength;
        shaping.right = shaping.left + maxLineLength;
    }

    function justifyLine(positionedGlyphs, glyphs, start, end, justify) {
        var lastAdvance = glyphs[positionedGlyphs[end].codePoint].advance;
        var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;

        for (var j = start; j <= end; j++) {
            positionedGlyphs[j].x -= lineIndent;
        }

    }

    function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line) {
        var shiftX = (justify - horizontalAlign) * maxLineLength;
        var shiftY = (-verticalAlign * (line + 1) + 0.5) * lineHeight;

        for (var j = 0; j < positionedGlyphs.length; j++) {
            positionedGlyphs[j].x += shiftX;
            positionedGlyphs[j].y += shiftY;
        }
    }


    function shapeIcon(image, layout) {
        if (!image || !image.rect) return null;

        var dx = layout['icon-offset'][0];
        var dy = layout['icon-offset'][1];
        var x1 = dx - image.width / 2;
        var x2 = x1 + image.width;
        var y1 = dy - image.height / 2;
        var y2 = y1 + image.height;

        return new PositionedIcon(image, y1, y2, x1, x2);
    }

    function PositionedIcon(image, top, bottom, left, right) {
        this.image = image;
        this.top = top;
        this.bottom = bottom;
        this.left = left;
        this.right = right;
    }

},{}],74:[function(require,module,exports){
    'use strict';

    var BinPack = require('./bin_pack');

    module.exports = SpriteAtlas;
    function SpriteAtlas(width, height) {
        this.width = width;
        this.height = height;

        this.bin = new BinPack(width, height);
        this.images = {};
        this.data = false;
        this.texture = 0; // WebGL ID
        this.filter = 0; // WebGL ID
        this.pixelRatio = 1;
        this.dirty = true;
    }

    SpriteAtlas.prototype = {
        get debug() {
            return 'canvas' in this;
        },
        set debug(value) {
            if (value && !this.canvas) {
                this.canvas = document.createElement('canvas');
                this.canvas.width = this.width * this.pixelRatio;
                this.canvas.height = this.height * this.pixelRatio;
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.width = this.width + 'px';
                document.body.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');
            } else if (!value && this.canvas) {
                this.canvas.parentNode.removeChild(this.canvas);
                delete this.ctx;
                delete this.canvas;
            }
        }
    };

    SpriteAtlas.prototype.resize = function(newRatio) {
        if (this.pixelRatio === newRatio) return false;

        var oldRatio = this.pixelRatio;
        this.pixelRatio = newRatio;

        if (this.canvas) {
            this.canvas.width = this.width * this.pixelRatio;
            this.canvas.height = this.height * this.pixelRatio;
        }

        if (this.data) {
            var oldData = this.data;

            this.data = false;
            this.allocate();
            this.texture = false;

            var oldWidth = this.width * oldRatio;
            var oldHeight = this.height * oldRatio;
            var newWidth = this.width * newRatio;
            var newHeight = this.height * newRatio;

            // Basic image scaling. TODO: Replace this with better image scaling.
            var newImage = this.data;
            var oldImage = oldData;

            for (var y = 0; y < newHeight; y++) {
                var oldYOffset = Math.floor((y * oldHeight) / newHeight) * oldWidth;
                var newYOffset = y * newWidth;
                for (var x = 0; x < newWidth; x++) {
                    var oldX = Math.floor((x * oldWidth) / newWidth);
                    newImage[newYOffset + x] = oldImage[oldYOffset + oldX];
                }
            }

            oldData = null;
            this.dirty = true;
        }

        return this.dirty;
    };

    function copyBitmap(src, srcStride, srcX, srcY, dst, dstStride, dstX, dstY, width, height, wrap) {
        var srcI = srcY * srcStride + srcX;
        var dstI = dstY * dstStride + dstX;
        var x, y;

        if (wrap) {
            // add 1 pixel wrapped padding on each side of the image
            dstI -= dstStride;
            for (y = -1; y <= height; y++, srcI = ((y + height) % height + srcY) * srcStride + srcX, dstI += dstStride) {
                for (x = -1; x <= width; x++) {
                    dst[dstI + x] = src[srcI + ((x + width) % width)];
                }
            }

        } else {
            for (y = 0; y < height; y++, srcI += srcStride, dstI += dstStride) {
                for (x = 0; x < width; x++) {
                    dst[dstI + x] = src[srcI + x];
                }
            }
        }
    }

    SpriteAtlas.prototype.allocateImage = function(pixelWidth, pixelHeight) {

        // Increase to next number divisible by 4, but at least 1.
        // This is so we can scale down the texture coordinates and pack them
        // into 2 bytes rather than 4 bytes.
        // Pad icons to prevent them from polluting neighbours during linear interpolation
        var padding = 2;
        var packWidth = pixelWidth + padding + (4 - (pixelWidth + padding) % 4);
        var packHeight = pixelHeight + padding + (4 - (pixelHeight + padding) % 4);// + 4;

        // We have to allocate a new area in the bin, and store an empty image in it.
        // Add a 1px border around every image.
        var rect = this.bin.allocate(packWidth, packHeight);
        if (rect.w === 0) {
            return rect;
        }

        rect.originalWidth = pixelWidth;
        rect.originalHeight = pixelHeight;

        return rect;
    };

    SpriteAtlas.prototype.getImage = function(name, wrap) {
        if (this.images[name]) {
            return this.images[name];
        }

        if (!this.sprite) {
            return null;
        }

        var pos = this.sprite.getSpritePosition(name);
        if (!pos.width || !pos.height) {
            return null;
        }

        var width = pos.width / pos.pixelRatio;
        var height = pos.height / pos.pixelRatio;
        var rect = this.allocateImage(width, height);
        if (rect.w === 0) {
            return rect;
        }

        var image = new AtlasImage(rect, width, height, pos.sdf);
        this.images[name] = image;

        this.copy(rect, pos, wrap);

        return image;
    };


    SpriteAtlas.prototype.getPosition = function(name, repeating) {
        var image = this.getImage(name, repeating);
        var rect = image && image.rect;

        if (!rect) {
            return null;
        }

        // When the image is repeating, get the correct position of the image, rather than the
        // one rounded up to 4 pixels.
        var width = repeating ? image.width : rect.w;
        var height = repeating ? image.height : rect.h;
        var padding = 1;

        return {
            size: [width, height],
            tl: [(rect.x + padding)         / this.width, (rect.y + padding)          / this.height],
            br: [(rect.x + padding + width) / this.width, (rect.y + padding + height) / this.height]
        };
    };


    SpriteAtlas.prototype.allocate = function() {
        if (!this.data) {
            var w = Math.floor(this.width * this.pixelRatio);
            var h = Math.floor(this.height * this.pixelRatio);
            this.data = new Uint32Array(w * h);
            for (var i = 0; i < this.data.length; i++) {
                this.data[i] = 0;
            }
        }
    };


    SpriteAtlas.prototype.copy = function(dst, src, wrap) {
        // if (!sprite->raster) return;
        if (!this.sprite.img.data) return;
        var srcImg = new Uint32Array(this.sprite.img.data.buffer);

        this.allocate();
        var dstImg = this.data;

        var padding = 1;

        copyBitmap(
            /* source buffer */  srcImg,
            /* source stride */  this.sprite.img.width,
            /* source x */       src.x,
            /* source y */       src.y,
            /* dest buffer */    dstImg,
            /* dest stride */    this.width * this.pixelRatio,
            /* dest x */         (dst.x + padding) * this.pixelRatio,
            /* dest y */         (dst.y + padding) * this.pixelRatio,
            /* icon dimension */ src.width,
            /* icon dimension */ src.height,
            /* wrap */ wrap
        );

        this.dirty = true;
    };

    SpriteAtlas.prototype.setSprite = function(sprite) {
        this.sprite = sprite;
    };

    SpriteAtlas.prototype.addIcons = function(icons, callback) {
        for (var i = 0; i < icons.length; i++) {
            this.getImage(icons[i]);
        }

        callback(null, this.images);
    };

    SpriteAtlas.prototype.bind = function(gl, linear) {
        var first = false;
        if (!this.texture) {
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            first = true;
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
        }

        var filterVal = linear ? gl.LINEAR : gl.NEAREST;
        if (filterVal !== this.filter) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterVal);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterVal);
            this.filter = filterVal;
        }

        if (this.dirty) {
            this.allocate();

            if (first) {
                gl.texImage2D(
                    gl.TEXTURE_2D, // enum target
                    0, // ind level
                    gl.RGBA, // ind internalformat
                        this.width * this.pixelRatio, // GLsizei width
                        this.height * this.pixelRatio, // GLsizei height
                    0, // ind border
                    gl.RGBA, // enum format
                    gl.UNSIGNED_BYTE, // enum type
                    new Uint8Array(this.data.buffer) // Object data
                );
            } else {
                gl.texSubImage2D(
                    gl.TEXTURE_2D, // enum target
                    0, // int level
                    0, // int xoffset
                    0, // int yoffset
                        this.width * this.pixelRatio, // long width
                        this.height * this.pixelRatio, // long height
                    gl.RGBA, // enum format
                    gl.UNSIGNED_BYTE, // enum type
                    new Uint8Array(this.data.buffer) // Object pixels
                );
            }

            this.dirty = false;

            // DEBUG
            if (this.ctx) {
                var data = this.ctx.getImageData(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);
                data.data.set(new Uint8ClampedArray(this.data.buffer));
                this.ctx.putImageData(data, 0, 0);

                this.ctx.strokeStyle = 'red';
                for (var k = 0; k < this.bin.free.length; k++) {
                    var free = this.bin.free[k];
                    this.ctx.strokeRect(free.x * this.pixelRatio, free.y * this.pixelRatio, free.w * this.pixelRatio, free.h * this.pixelRatio);
                }
            }
            // END DEBUG
        }
    };

    function AtlasImage(rect, width, height, sdf) {
        this.rect = rect;
        this.width = width;
        this.height = height;
        this.sdf = sdf;
    }

},{"./bin_pack":60}],75:[function(require,module,exports){
    'use strict';

    var util = require('../util/util');
    var interpolate = require('../util/interpolate');
    var browser = require('../util/browser');
    var LatLng = require('../geo/lat_lng');
    var LatLngBounds = require('../geo/lat_lng_bounds');
    var Point = require('point-geometry');

    /**
     * Options common to Map#jumpTo, Map#easeTo, and Map#flyTo, controlling the destination
     * location, zoom level, bearing and pitch. All properties are options; unspecified
     * options will default to the current value for that property.
     *
     * @typedef {Object} CameraOptions
     * @property {Array} center Latitude and longitude (passed as `[lat, lng]`)
     * @property {number} zoom Map zoom level
     * @property {number} bearing Map rotation bearing in degrees counter-clockwise from north
     * @property {number} pitch The angle at which the camera is looking at the ground
     */

    /**
     * Options common to map movement methods that involve animation, such as Map#panBy and
     * Map#easeTo, controlling the duration of the animation and easing function. All properties
     * are optional.
     *
     * @typedef {Object} AnimationOptions
     * @property {number} duration Number in milliseconds
     * @property {Function} easing
     * @property {Array} offset point, origin of movement relative to map center
     * @property {boolean} animate When set to false, no animation happens
     */

    var Camera = module.exports = function() {};

    util.extend(Camera.prototype, /** @lends Map.prototype */{
        /**
         * Get the current view geographical point.
         * @returns {LatLng}
         */
        getCenter: function() { return this.transform.center; },

        /**
         * Sets a map location. Equivalent to `jumpTo({center: center})`.
         *
         * @param {Array} center Latitude and longitude (passed as `[lat, lng]`)
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         * @example
         * map.setCenter([-74, 38]);
         */
        setCenter: function(center) {
            this.jumpTo({center: center});
            return this;
        },

        /**
         * Pan by a certain number of pixels
         *
         * @param {Array} offset [x, y]
         * @param {AnimationOptions} [options]
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        panBy: function(offset, options) {
            this.panTo(this.transform.center, util.extend({offset: Point.convert(offset).mult(-1)}, options));
            return this;
        },

        /**
         * Pan to a certain location with easing
         *
         * @param {Object} latlng a `LatLng` object
         * @param {AnimationOptions} [options]
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        panTo: function(latlng, options) {
            this.stop();

            latlng = LatLng.convert(latlng);

            options = util.extend({
                duration: 500,
                easing: util.ease,
                offset: [0, 0]
            }, options);

            var tr = this.transform,
                offset = Point.convert(options.offset).rotate(-tr.angle),
                from = tr.point,
                to = tr.project(latlng).sub(offset);

            if (!options.noMoveStart) {
                this.fire('movestart');
            }

            this._ease(function(k) {
                tr.center = tr.unproject(from.add(to.sub(from).mult(k)));
                this.fire('move');
            }, function() {
                this.fire('moveend');
            }, options);

            return this;
        },


        /**
         * Get the current zoom
         * @returns {number}
         */
        getZoom: function() { return this.transform.zoom; },

        /**
         * Sets a map zoom. Equivalent to `jumpTo({zoom: zoom})`.
         *
         * @param {number} zoom Map zoom level
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         * @example
         * // zoom the map to 5
         * map.setZoom(5);
         */
        setZoom: function(zoom) {
            this.jumpTo({zoom: zoom});
            return this;
        },

        /**
         * Zooms to a certain zoom level with easing.
         *
         * @param {number} zoom
         * @param {AnimationOptions} [options]
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        zoomTo: function(zoom, options) {
            this.stop();

            options = util.extend({
                duration: 500
            }, options);

            options.easing = this._updateEasing(options.duration, zoom, options.easing);

            var tr = this.transform,
                around = tr.center,
                startZoom = tr.zoom;

            if (options.around) {
                around = LatLng.convert(options.around);
            } else if (options.offset) {
                around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
            }

            if (options.animate === false) options.duration = 0;

            if (!this.zooming) {
                this.zooming = true;
                this.fire('movestart');
            }

            this._ease(function(k) {
                tr.setZoomAround(interpolate(startZoom, zoom, k), around);
                this.fire('move').fire('zoom');
            }, function() {
                this.ease = null;
                if (options.duration >= 200) {
                    this.zooming = false;
                    this.fire('moveend');
                }
            }, options);

            if (options.duration < 200) {
                clearTimeout(this._onZoomEnd);
                this._onZoomEnd = setTimeout(function() {
                    this.zooming = false;
                    this.fire('moveend');
                }.bind(this), 200);
            }

            return this;
        },

        /**
         * Zoom in by 1 level
         *
         * @param {AnimationOptions} [options]
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        zoomIn: function(options) {
            this.zoomTo(this.getZoom() + 1, options);
            return this;
        },

        /**
         * Zoom out by 1 level
         *
         * @param {AnimationOptions} [options]
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        zoomOut: function(options) {
            this.zoomTo(this.getZoom() - 1, options);
            return this;
        },


        /**
         * Get the current bearing in degrees
         * @returns {number}
         */
        getBearing: function() { return this.transform.bearing; },

        /**
         * Sets a map rotation. Equivalent to `jumpTo({bearing: bearing})`.
         *
         * @param {number} bearing Map rotation bearing in degrees counter-clockwise from north
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         * @example
         * // rotate the map to 90 degrees
         * map.setBearing(90);
         */
        setBearing: function(bearing) {
            this.jumpTo({bearing: bearing});
            return this;
        },

        /**
         * Rotate bearing by a certain number of degrees with easing
         *
         * @param {number} bearing
         * @param {AnimationOptions} [options]
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        rotateTo: function(bearing, options) {
            this.stop();

            options = util.extend({
                duration: 500,
                easing: util.ease
            }, options);

            var tr = this.transform,
                start = this.getBearing(),
                around = tr.center;

            if (options.around) {
                around = LatLng.convert(options.around);
            } else if (options.offset) {
                around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
            }

            bearing = this._normalizeBearing(bearing, start);

            this.rotating = true;
            this.fire('movestart');

            this._ease(function(k) {
                tr.setBearingAround(interpolate(start, bearing, k), around);
                this.fire('move').fire('rotate');
            }, function() {
                this.rotating = false;
                this.fire('moveend');
            }, options);

            return this;
        },

        /**
         * Sets map bearing to 0 (north) with easing
         *
         * @param {AnimationOptions} [options]
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        resetNorth: function(options) {
            this.rotateTo(0, util.extend({duration: 1000}, options));
            return this;
        },

        /**
         * Animates map bearing to 0 (north) if it's already close to it.
         *
         * @param {AnimationOptions} [options]
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        snapToNorth: function(options) {
            if (Math.abs(this.getBearing()) < this.options.bearingSnap) {
                return this.resetNorth(options);
            }
            return this;
        },

        /**
         * Get the current angle in degrees
         * @returns {number}
         */
        getPitch: function() { return this.transform.pitch; },

        /**
         * Sets a map angle. Equivalent to `jumpTo({pitch: pitch})`.
         *
         * @param {number} pitch The angle at which the camera is looking at the ground
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        setPitch: function(pitch) {
            this.jumpTo({pitch: pitch});
            return this;
        },


        /**
         * Zoom to contain certain geographical bounds
         *
         * @param {Array} bounds [[minLat, minLng], [maxLat, maxLng]]
         * @param {Object} options
         * @param {number} [options.speed=1.2] How fast animation occurs
         * @param {number} [options.curve=1.42] How much zooming out occurs during animation
         * @param {Function} options.easing
         * @param {number} options.padding how much padding there is around the given bounds on each side in pixels
         * @param {number} options.maxZoom
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        fitBounds: function(bounds, options) {

            options = util.extend({
                padding: 0,
                offset: [0, 0],
                maxZoom: Infinity
            }, options);

            bounds = LatLngBounds.convert(bounds);

            var offset = Point.convert(options.offset),
                tr = this.transform,
                nw = tr.project(bounds.getNorthWest()),
                se = tr.project(bounds.getSouthEast()),
                size = se.sub(nw),
                scaleX = (tr.width - options.padding * 2 - Math.abs(offset.x) * 2) / size.x,
                scaleY = (tr.height - options.padding * 2 - Math.abs(offset.y) * 2) / size.y;

            options.center = tr.unproject(nw.add(se).div(2));
            options.zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
            options.bearing = 0;

            return options.linear ?
                this.easeTo(options) :
                this.flyTo(options);
        },

        /**
         * Change any combination of center, zoom, bearing, and pitch, without
         * a transition. The map will retain the current values for any options
         * not included in `options`.
         *
         * @param {CameraOptions} options map view options
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        jumpTo: function(options) {
            this.stop();

            var tr = this.transform,
                zoomChanged = false,
                bearingChanged = false,
                pitchChanged = false;

            if ('center' in options) {
                tr.center = LatLng.convert(options.center);
            }

            if ('zoom' in options && tr.zoom !== +options.zoom) {
                zoomChanged = true;
                tr.zoom = +options.zoom;
            }

            if ('bearing' in options && tr.bearing !== +options.bearing) {
                bearingChanged = true;
                tr.bearing = +options.bearing;
            }

            if ('pitch' in options && tr.pitch !== +options.pitch) {
                pitchChanged = true;
                tr.pitch = +options.pitch;
            }

            this.fire('movestart')
                .fire('move');

            if (zoomChanged) {
                this.fire('zoom');
            }

            if (bearingChanged) {
                this.fire('rotate');
            }

            if (pitchChanged) {
                this.fire('pitch');
            }

            return this.fire('moveend');
        },

        /**
         * Easing animation to a specified location/zoom/bearing
         *
         * @param {CameraOptions~AnimationOptions} options map view and animation options
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        easeTo: function(options) {
            this.stop();

            options = util.extend({
                offset: [0, 0],
                duration: 500,
                easing: util.ease
            }, options);

            var tr = this.transform,
                offset = Point.convert(options.offset).rotate(-tr.angle),
                from = tr.point,
                startZoom = this.getZoom(),
                startBearing = this.getBearing(),
                startPitch = this.getPitch(),

                zoom = 'zoom' in options ? +options.zoom : startZoom,
                bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing,
                pitch = 'pitch' in options ? +options.pitch : startPitch,

                scale = tr.zoomScale(zoom - startZoom),
                to = 'center' in options ? tr.project(LatLng.convert(options.center)).sub(offset.div(scale)) : from,
                around = LatLng.convert(options.around);

            if (zoom !== startZoom) {
                this.zooming = true;
            }
            if (startBearing !== bearing) {
                this.rotating = true;
            }

            if (this.zooming && !around) {
                around = tr.pointLocation(tr.centerPoint.add(to.sub(from).div(1 - 1 / scale)));
            }

            this.fire('movestart');

            this._ease(function (k) {
                if (this.zooming) {
                    tr.setZoomAround(interpolate(startZoom, zoom, k), around);
                } else {
                    tr.center = tr.unproject(from.add(to.sub(from).mult(k)));
                }

                if (this.rotating) {
                    tr.bearing = interpolate(startBearing, bearing, k);
                }

                if (pitch !== startPitch) {
                    tr.pitch = interpolate(startPitch, pitch, k);
                }

                this.fire('move');
                if (this.zooming) {
                    this.fire('zoom');
                }
                if (this.rotating) {
                    this.fire('rotate');
                }
            }, function() {
                this.zooming = false;
                this.rotating = false;
                this.fire('moveend');
            }, options);

            return this;
        },

        /**
         * Flying animation to a specified location/zoom/bearing with automatic curve
         *
         * @param {CameraOptions} options map view options
         * @param {number} [options.speed=1.2] How fast animation occurs
         * @param {number} [options.curve=1.42] How much zooming out occurs during animation
         * @param {Function} [options.easing]
         * @fires movestart
         * @fires moveend
         * @returns {this}
         * @example
         * // fly with default options to null island
         * map.flyTo({center: [0, 0], zoom: 9});
         * // using flyTo options
         * map.flyTo({
     *   center: [0, 0],
     *   zoom: 9,
     *   speed: 0.2,
     *   curve: 1,
     *   easing: function(t) {
     *     return t;
     *   }
     * });
         */
        flyTo: function(options) {
            this.stop();

            options = util.extend({
                offset: [0, 0],
                speed: 1.2,
                curve: 1.42,
                easing: util.ease
            }, options);

            var tr = this.transform,
                offset = Point.convert(options.offset),
                startZoom = this.getZoom(),
                startBearing = this.getBearing();

            var center = 'center' in options ? LatLng.convert(options.center) : this.getCenter();
            var zoom = 'zoom' in options ?  +options.zoom : startZoom;
            var bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;

            var scale = tr.zoomScale(zoom - startZoom),
                from = tr.point,
                to = tr.project(center).sub(offset.div(scale));

            var startWorldSize = tr.worldSize,
                rho = options.curve,
                V = options.speed,

                w0 = Math.max(tr.width, tr.height),
                w1 = w0 / scale,
                u1 = to.sub(from).mag(),
                rho2 = rho * rho;

            function r(i) {
                var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
                return Math.log(Math.sqrt(b * b + 1) - b);
            }

            function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
            function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
            function tanh(n) { return sinh(n) / cosh(n); }

            var r0 = r(0),
                w = function (s) { return (cosh(r0) / cosh(r0 + rho * s)); },
                u = function (s) { return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1; },
                S = (r(1) - r0) / rho;

            if (Math.abs(u1) < 0.000001) {
                if (Math.abs(w0 - w1) < 0.000001) return this;

                var k = w1 < w0 ? -1 : 1;
                S = Math.abs(Math.log(w1 / w0)) / rho;

                u = function() { return 0; };
                w = function(s) { return Math.exp(k * rho * s); };
            }

            options.duration = 1000 * S / V;

            this.zooming = true;
            if (startBearing !== bearing) this.rotating = true;

            this.fire('movestart');

            this._ease(function (k) {
                var s = k * S,
                    us = u(s);

                tr.zoom = startZoom + tr.scaleZoom(1 / w(s));
                tr.center = tr.unproject(from.add(to.sub(from).mult(us)), startWorldSize);

                if (bearing !== startBearing) {
                    tr.bearing = interpolate(startBearing, bearing, k);
                }

                this.fire('move').fire('zoom');
                if (bearing !== startBearing) {
                    this.fire('rotate');
                }
            }, function() {
                this.zooming = false;
                this.rotating = false;
                this.fire('moveend');
            }, options);

            return this;
        },

        isEasing: function() {
            return !!this._abortFn;
        },

        /**
         * Stop current animation
         *
         * @returns {Map} `this`
         */
        stop: function() {
            if (this._abortFn) {
                this._abortFn.call(this);
                this._finishEase();
            }
            return this;
        },

        _ease: function(frame, finish, options) {
            this._finishFn = finish;
            this._abortFn = browser.timed(function (t) {
                frame.call(this, options.easing(t));
                if (t === 1) {
                    this._finishEase();
                }
            }, options.animate === false ? 0 : options.duration, this);
        },

        _finishEase: function() {
            delete this._abortFn;
            // The finish function might emit events which trigger new eases, which
            // set a new _finishFn. Ensure we don't delete it unintentionally.
            var finish = this._finishFn;
            delete this._finishFn;
            finish.call(this);
        },

        // convert bearing so that it's numerically close to the current one so that it interpolates properly
        _normalizeBearing: function(bearing, currentBearing) {
            bearing = util.wrap(bearing, -180, 180);
            var diff = Math.abs(bearing - currentBearing);
            if (Math.abs(bearing - 360 - currentBearing) < diff) bearing -= 360;
            if (Math.abs(bearing + 360 - currentBearing) < diff) bearing += 360;
            return bearing;
        },

        _updateEasing: function(duration, zoom, bezier) {
            var easing;

            if (this.ease) {
                var ease = this.ease,
                    t = (Date.now() - ease.start) / ease.duration,
                    speed = ease.easing(t + 0.01) - ease.easing(t),

                // Quick hack to make new bezier that is continuous with last
                    x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01,
                    y = Math.sqrt(0.27 * 0.27 - x * x);

                easing = util.bezier(x, y, 0.25, 1);
            } else {
                easing = bezier ? util.bezier.apply(util, bezier) : util.ease;
            }

            // store information on current easing
            this.ease = {
                start: (new Date()).getTime(),
                to: Math.pow(2, zoom),
                duration: duration,
                easing: easing
            };

            return easing;
        }
    });

},{"../geo/lat_lng":18,"../geo/lat_lng_bounds":19,"../util/browser":92,"../util/interpolate":99,"../util/util":103,"point-geometry":150}],76:[function(require,module,exports){
    'use strict';

    var Control = require('./control');
    var DOM = require('../../util/dom');
    var util = require('../../util/util');

    module.exports = Attribution;

    /**
     * Creates an attribution control
     * @class Attribution
     * @example
     * map.addControl(new mapboxgl.Attribution());
     */
    function Attribution() {}

    Attribution.prototype = util.inherit(Control, {
        options: {
            position: 'bottom-right'
        },

        onAdd: function(map) {
            var className = 'mapboxgl-ctrl-attrib',
                container = this._container = DOM.create('div', className, map.getContainer());

            this._update();
            map.on('source.load', this._update.bind(this));
            map.on('source.change', this._update.bind(this));
            map.on('source.remove', this._update.bind(this));
            map.on('moveend', this._updateEditLink.bind(this));

            return container;
        },

        _update: function() {
            var attributions = [];

            if (this._map.style) {
                for (var id in this._map.style.sources) {
                    var source = this._map.style.sources[id];
                    if (source.attribution && attributions.indexOf(source.attribution) < 0) {
                        attributions.push(source.attribution);
                    }
                }
            }

            this._container.innerHTML = attributions.join(' | ');
            this._editLink = this._container.getElementsByClassName('mapbox-improve-map')[0];
            this._updateEditLink();
        },

        _updateEditLink: function() {
            if (this._editLink) {
                var center = this._map.getCenter();
                this._editLink.href = 'https://www.mapbox.com/map-feedback/#/' +
                    center.lng + '/' + center.lat + '/' + Math.round(this._map.getZoom() + 1);
            }
        }
    });

},{"../../util/dom":95,"../../util/util":103,"./control":77}],77:[function(require,module,exports){
    'use strict';

    module.exports = Control;

    /**
     * A base class for map-related interface elements.
     *
     * @class Control
     */
    function Control() {}

    Control.prototype = {
        /**
         * Add this control to the map, returning the control itself
         * for chaining. This will insert the control's DOM element into
         * the map's DOM element if the control has a `position` specified.
         *
         * @param {Map} map
         * @returns {Control} `this`
         */
        addTo: function(map) {
            this._map = map;
            var container = this._container = this.onAdd(map);
            if (this.options && this.options.position) {
                var pos = this.options.position;
                var corner = map._controlCorners[pos];
                container.className += ' mapboxgl-ctrl';
                if (pos.indexOf('bottom') !== -1) {
                    corner.insertBefore(container, corner.firstChild);
                } else {
                    corner.appendChild(container);
                }
            }

            return this;
        },

        /**
         * Remove this control from the map it has been added to.
         *
         * @returns {Control} `this`
         */
        remove: function() {
            this._container.parentNode.removeChild(this._container);
            if (this.onRemove) this.onRemove(this._map);
            this._map = null;
            return this;
        }
    };

},{}],78:[function(require,module,exports){
    'use strict';

    var Control = require('./control');
    var DOM = require('../../util/dom');
    var util = require('../../util/util');

    module.exports = Navigation;

    /**
     * Creates a navigation control with zoom buttons and a compass
     * @class Navigation
     * @param {Object} [options]
     * @param {string} [options.position=top-right] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
     * @example
     * map.addControl(new mapboxgl.Navigation({position: 'top-left'})); // position is optional
     */
    function Navigation(options) {
        util.setOptions(this, options);
    }

    Navigation.prototype = util.inherit(Control, {
        options: {
            position: 'top-right'
        },

        onAdd: function(map) {
            var className = 'mapboxgl-ctrl';

            var container = this._container = DOM.create('div', className + '-group', map.getContainer());

            this._zoomInButton = this._createButton(className + '-icon ' + className + '-zoom-in', map.zoomIn.bind(map));
            this._zoomOutButton = this._createButton(className + '-icon ' + className + '-zoom-out', map.zoomOut.bind(map));
            this._compass = this._createButton(className + '-compass', map.resetNorth.bind(map));

            var compassCanvas = this._compassCanvas = DOM.create('canvas', className + '-compass-canvas', this._compass);
            compassCanvas.style.cssText = 'width:30px; height:30px;';
            compassCanvas.width = 26 * 2;
            compassCanvas.height = 26 * 2;

            this._compass.addEventListener('mousedown', this._onCompassDown.bind(this));
            this._onCompassMove = this._onCompassMove.bind(this);
            this._onCompassUp = this._onCompassUp.bind(this);

            this._compassCtx = compassCanvas.getContext('2d');

            map.on('rotate', this._drawNorth.bind(this));
            this._drawNorth();

            return container;
        },

        _onCompassDown: function(e) {
            DOM.disableDrag();

            document.addEventListener('mousemove', this._onCompassMove);
            document.addEventListener('mouseup', this._onCompassUp);
            this._prevX = e.screenX;

            e.stopPropagation();
        },

        _onCompassMove: function(e) {
            var x = e.screenX,
                d = x < 2 ? -5 : // left edge of the screen, continue rotating
                        x > window.screen.width - 2 ? 5 : // right edge
                    (x - this._prevX) / 4;

            this._map.setBearing(this._map.getBearing() - d);
            this._prevX = e.screenX;
            this._moved = true;

            e.preventDefault();
        },

        _onCompassUp: function() {
            document.removeEventListener('mousemove', this._onCompassMove);
            document.removeEventListener('mouseup', this._onCompassUp);
            DOM.enableDrag();

            if (this._moved) {
                this._moved = false;
                DOM.suppressClick();
            }

            this._map.snapToNorth();
        },

        _createButton: function(className, fn) {
            var a = DOM.create('button', className, this._container);
            a.addEventListener('click', function() { fn(); });
            return a;
        },

        _drawNorth: function() {
            var rad = 20,
                width = 8,
                center = 26,
                angle = this._map.transform.angle + (Math.PI / 2),
                ctx = this._compassCtx;

            this._compassCanvas.width = this._compassCanvas.width;

            ctx.translate(center, center);
            ctx.rotate(angle);

            ctx.beginPath();
            ctx.fillStyle = '#000';
            ctx.lineTo(0, -width);
            ctx.lineTo(-rad, 0);
            ctx.lineTo(0, width);
            ctx.fill();

            ctx.beginPath();
            ctx.fillStyle = '#bbb';
            ctx.moveTo(0, 0);
            ctx.lineTo(0, width);
            ctx.lineTo(rad, 0);
            ctx.lineTo(0, -width);
            ctx.fill();

            ctx.beginPath();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.moveTo(0, -width);
            ctx.lineTo(0, width);
            ctx.stroke();
        }
    });

},{"../../util/dom":95,"../../util/util":103,"./control":77}],79:[function(require,module,exports){
    'use strict';

    var DOM = require('../../util/dom'),
        LatLngBounds = require('../../geo/lat_lng_bounds'),
        util = require('../../util/util');

    module.exports = BoxZoom;


    function BoxZoom(map) {
        this._map = map;
        this._el = map.getCanvasContainer();
        this._container = map.getContainer();

        util.bindHandlers(this);
    }

    BoxZoom.prototype = {
        enable: function () {
            this._el.addEventListener('mousedown', this._onMouseDown, false);
        },

        disable: function () {
            this._el.removeEventListener('mousedown', this._onMouseDown);
        },

        _onMouseDown: function (e) {
            if (e.shiftKey || (e.which === 1 && e.button === 1)) {
                document.addEventListener('mousemove', this._onMouseMove, false);
                document.addEventListener('keydown', this._onKeyDown, false);
                document.addEventListener('mouseup', this._onMouseUp, false);

                this._startPos = DOM.mousePos(this._el, e);
                this.active = true;
            }
        },

        _onMouseMove: function (e) {
            var p0 = this._startPos,
                p1 = DOM.mousePos(this._el, e);

            if (!this._box) {
                this._box = DOM.create('div', 'mapboxgl-boxzoom', this._container);
                this._container.classList.add('mapboxgl-crosshair');

                DOM.disableDrag();

                this._map.fire('boxzoomstart');
            }

            var minX = Math.min(p0.x, p1.x),
                maxX = Math.max(p0.x, p1.x),
                minY = Math.min(p0.y, p1.y),
                maxY = Math.max(p0.y, p1.y);

            DOM.setTransform(this._box, 'translate(' + minX + 'px,' + minY + 'px)');

            this._box.style.width = (maxX - minX) + 'px';
            this._box.style.height = (maxY - minY) + 'px';
        },

        _onMouseUp: function (e) {
            var p0 = this._startPos,
                p1 = DOM.mousePos(this._el, e),
                bounds = new LatLngBounds(this._map.unproject(p0), this._map.unproject(p1));

            this._finish();

            this._map
                .fitBounds(bounds, {linear: true})
                .fire('boxzoomend', {boxZoomBounds: bounds});
        },

        _onKeyDown: function (e) {
            if (e.keyCode === 27) {
                this._finish();
                this._map.fire('boxzoomcancel');
            }
        },

        _finish: function () {
            if (!this._box) return;

            this.active = false;

            document.removeEventListener('mousemove', this._onMouseMove, false);
            document.removeEventListener('keydown', this._onKeyDown, false);
            document.removeEventListener('mouseup', this._onMouseUp, false);

            this._container.classList.remove('mapboxgl-crosshair');

            this._box.parentNode.removeChild(this._box);
            this._box = null;

            DOM.enableDrag();
        }
    };

},{"../../geo/lat_lng_bounds":19,"../../util/dom":95,"../../util/util":103}],80:[function(require,module,exports){
    'use strict';

    module.exports = DoubleClickZoom;

    function DoubleClickZoom(map) {
        this._map = map;
        this._onDblClick = this._onDblClick.bind(this);
    }

    DoubleClickZoom.prototype = {
        enable: function () {
            this._map.on('dblclick', this._onDblClick);
        },

        disable: function () {
            this._map.off('dblclick', this._onDblClick);
        },

        _onDblClick: function (e) {
            this._map.zoomTo(Math.round(this._map.getZoom()) + 1, {around: e.latLng});
        }
    };

},{}],81:[function(require,module,exports){
    'use strict';

    var DOM = require('../../util/dom'),
        util = require('../../util/util');

    module.exports = DragPan;


    var inertiaLinearity = 0.25,
        inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
        inertiaMaxSpeed = 3000, // px/s
        inertiaDeceleration = 4000; // px/s^2


    function DragPan(map) {
        this._map = map;
        this._el = map.getCanvasContainer();

        util.bindHandlers(this);
    }

    DragPan.prototype = {
        enable: function () {
            this._el.addEventListener('mousedown', this._onDown, false);
            this._el.addEventListener('touchstart', this._onDown, false);
        },

        disable: function () {
            this._el.removeEventListener('mousedown', this._onDown);
            this._el.removeEventListener('touchstart', this._onDown);
        },

        _onDown: function (e) {
            this._startPos = this._pos = DOM.mousePos(this._el, e);

            this._inertia = [[Date.now(), this._pos]];

            if (!e.touches) {
                document.addEventListener('mousemove', this._onMove, false);
                document.addEventListener('mouseup', this._onMouseUp, false);

            } else if (e.touches.length === 1) {
                document.addEventListener('touchmove', this._onMove, false);
                document.addEventListener('touchend', this._onTouchEnd, false);
            }
        },

        _onMove: function (e) {
            var map = this._map;
            if (map.boxZoom.active || map.dragRotate.active || (e.touches && e.touches.length > 1)) return;

            var pos = DOM.mousePos(this._el, e),
                inertia = this._inertia,
                now = Date.now();

            inertia.push([now, pos]);
            while (inertia.length > 2 && now - inertia[0][0] > 50) inertia.shift();

            map.stop();
            map.transform.setLocationAtPoint(map.transform.pointLocation(this._pos), pos);
            map.fire('move');

            this._pos = pos;

            e.preventDefault();
        },

        _onUp: function () {
            var inertia = this._inertia;

            if (inertia.length < 2) {
                this._map.fire('moveend');
                return;
            }

            var last = inertia[inertia.length - 1],
                first = inertia[0],
                flingOffset = last[1].sub(first[1]),
                flingDuration = (last[0] - first[0]) / 1000,

            // calculate px/s velocity & adjust for increased initial animation speed when easing out
                velocity = flingOffset.mult(inertiaLinearity / flingDuration),
                speed = velocity.mag(); // px/s

            if (speed > inertiaMaxSpeed) {
                speed = inertiaMaxSpeed;
                velocity._unit()._mult(speed);
            }

            var duration = speed / (inertiaDeceleration * inertiaLinearity),
                offset = velocity.mult(-duration / 2);

            this._map.panBy(offset, {
                duration: duration * 1000,
                easing: inertiaEasing,
                noMoveStart: true
            });
        },

        _onMouseUp: function () {
            this._onUp();
            document.removeEventListener('mousemove', this._onMove, false);
            document.removeEventListener('mouseup', this._onMouseUp, false);
        },

        _onTouchEnd: function () {
            this._onUp();
            document.removeEventListener('touchmove', this._onMove);
            document.removeEventListener('touchend', this._onTouchEnd);
        }
    };

},{"../../util/dom":95,"../../util/util":103}],82:[function(require,module,exports){
    'use strict';

    var DOM = require('../../util/dom'),
        Point = require('point-geometry'),
        util = require('../../util/util');

    module.exports = DragRotate;


    function DragRotate(map) {
        this._map = map;
        this._el = map.getCanvasContainer();

        util.bindHandlers(this);
    }

    DragRotate.prototype = {
        enable: function () {
            this._el.addEventListener('contextmenu', this._onContextMenu, false);
        },

        disable: function () {
            this._el.removeEventListener('contextmenu', this._onContextMenu);
        },

        _onContextMenu: function (e) {
            this._map.stop();
            this.active = true;
            this._startPos = this._pos = DOM.mousePos(this._el, e);

            document.addEventListener('mousemove', this._onMouseMove, false);
            document.addEventListener('mouseup', this._onMouseUp, false);

            e.preventDefault();
        },

        _onMouseMove: function (e) {

            var p0 = this._startPos,
                p1 = this._pos,
                p2 = DOM.mousePos(this._el, e),

                map = this._map,
                center = map.transform.centerPoint, // Center of rotation
                startToCenter = p0.sub(center),
                startToCenterDist = startToCenter.mag();

            if (!map.rotating) {
                map.fire('movestart');
                map.rotating = true;
            }

            // If the first click was too close to the center, move the center of rotation by 200 pixels
            // in the direction of the click.
            if (startToCenterDist < 200) {
                center = p0.add(new Point(-200, 0)._rotate(startToCenter.angle()));
            }

            var bearingDiff = p1.sub(center).angleWith(p2.sub(center)) / Math.PI * 180;
            map.transform.bearing = map.getBearing() - bearingDiff;

            map.fire('move').fire('rotate');

            clearTimeout(this._timeout);
            this._timeout = setTimeout(this._onTimeout, 200);

            this._pos = p2;
        },

        _onTimeout: function () {
            var map = this._map;

            map.rotating = false;
            map.snapToNorth();

            if (!map.rotating) {
                map._rerender();
                map.fire('moveend');
            }
        },

        _onMouseUp: function () {
            this.active = false;

            document.removeEventListener('mousemove', this._onMouseMove, false);
            document.removeEventListener('mouseup', this._onMouseUp, false);
        }
    };

},{"../../util/dom":95,"../../util/util":103,"point-geometry":150}],83:[function(require,module,exports){
    'use strict';

    module.exports = Keyboard;


    var panDelta = 80,
        rotateDelta = 2;

    /**
     * The `Keyboard` handler responds to keyboard input by zooming, rotating, or panning the
     * map. The following keyboard shortcuts are supported:
     *  * `=` / `+`: increase zoom level by 1
     *  * `Shift-=` / `Shift-+`: increase zoom level by 2
     *  * `-`: decrease zoom level by 1
     *  * `Shift--`: decrease zoom level by 2
     *  * Arrow keys: pan by 80 pixels
     *  * `Shift+⇢`: increase rotation by 2 degrees
     *  * `Shift+⇠`: decrease rotation by 2 degrees
     * @class Keyboard
     * @example
     *   // Disable the keyboard handler
     *   map.keyboard.disable();
     * @example
     *   // Enable the keyboard handler
     *   map.keyboard.enable();
     */
    function Keyboard(map) {
        this._map = map;
        this._el = map.getCanvasContainer();

        this._onKeyDown = this._onKeyDown.bind(this);
    }

    Keyboard.prototype = {
        enable: function () {
            this._el.addEventListener('keydown', this._onKeyDown, false);
        },

        disable: function () {
            this._el.removeEventListener('keydown', this._onKeyDown);
        },

        _onKeyDown: function (e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;

            var map = this._map;

            switch (e.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                    map.zoomTo(Math.round(map.getZoom()) + (e.shiftKey ? 2 : 1));
                    break;

                case 189:
                case 109:
                case 173:
                    map.zoomTo(Math.round(map.getZoom()) - (e.shiftKey ? 2 : 1));
                    break;

                case 37:
                    if (e.shiftKey) {
                        map.setBearing(map.getBearing() - rotateDelta);
                    } else {
                        map.panBy([-panDelta, 0]);
                    }
                    break;

                case 39:
                    if (e.shiftKey) {
                        map.setBearing(map.getBearing() + rotateDelta);
                    } else {
                        map.panBy([panDelta, 0]);
                    }
                    break;

                case 38:
                    map.panBy([0, -panDelta]);
                    break;

                case 40:
                    map.panBy([0, panDelta]);
                    break;
            }
        }
    };

},{}],84:[function(require,module,exports){
    'use strict';

    var DOM = require('../../util/dom'),
        util = require('../../util/util');

    module.exports = Pinch;


    function Pinch(map) {
        this._map = map;
        this._el = map.getCanvasContainer();

        util.bindHandlers(this);
    }

    Pinch.prototype = {
        enable: function () {
            this._el.addEventListener('touchstart', this._onStart, false);
        },

        disable: function () {
            this._el.removeEventListener('touchstart', this._onStart);
        },

        _onStart: function (e) {
            if (e.touches.length !== 2) return;

            var p0 = DOM.mousePos(this._el, e.touches[0]),
                p1 = DOM.mousePos(this._el, e.touches[1]);

            this._startVec = p0.sub(p1);
            this._startScale = this._map.transform.scale;
            this._startBearing = this._map.transform.bearing;

            document.addEventListener('touchmove', this._onMove, false);
            document.addEventListener('touchend', this._onEnd, false);
        },

        _onMove: function (e) {
            if (e.touches.length !== 2) return;

            var p0 = DOM.mousePos(this._el, e.touches[0]),
                p1 = DOM.mousePos(this._el, e.touches[1]),
                p = p0.add(p1).div(2),
                vec = p0.sub(p1),
                scale = vec.mag() / this._startVec.mag(),
                bearing = vec.angleWith(this._startVec) * 180 / Math.PI,
                map = this._map;

            map.easeTo({
                zoom: map.transform.scaleZoom(this._startScale * scale),
                bearing: this._startBearing + bearing,
                duration: 0,
                around: map.unproject(p)
            });

            e.preventDefault();
        },

        _onEnd: function () {
            this._map.snapToNorth();

            document.removeEventListener('touchmove', this._onMove);
            document.removeEventListener('touchend', this._onEnd);
        }
    };

},{"../../util/dom":95,"../../util/util":103}],85:[function(require,module,exports){
    'use strict';

    var DOM = require('../../util/dom'),
        browser = require('../../util/browser'),
        util = require('../../util/util');

    module.exports = ScrollZoom;


    var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '',
        firefox = ua.indexOf('firefox') !== -1,
        safari = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') === -1;


    function ScrollZoom(map) {
        this._map = map;
        this._el = map.getCanvasContainer();

        util.bindHandlers(this);
    }

    ScrollZoom.prototype = {
        enable: function () {
            this._el.addEventListener('wheel', this._onWheel, false);
            this._el.addEventListener('mousewheel', this._onWheel, false);
        },

        disable: function () {
            this._el.removeEventListener('wheel', this._onWheel);
            this._el.removeEventListener('mousewheel', this._onWheel);
        },

        _onWheel: function (e) {
            var value;

            if (e.type === 'wheel') {
                value = e.deltaY;
                // Firefox doubles the values on retina screens...
                if (firefox && e.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) value /= browser.devicePixelRatio;
                if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) value *= 40;

            } else if (e.type === 'mousewheel') {
                value = -e.wheelDeltaY;
                if (safari) value = value / 3;
            }

            var now = (window.performance || Date).now(),
                timeDelta = now - (this._time || 0);

            this._pos = DOM.mousePos(this._el, e);
            this._time = now;

            if (value !== 0 && (value % 4.000244140625) === 0) {
                // This one is definitely a mouse wheel event.
                this._type = 'wheel';
                // Normalize this value to match trackpad.
                value = Math.floor(value / 4);

            } else if (value !== 0 && Math.abs(value) < 4) {
                // This one is definitely a trackpad event because it is so small.
                this._type = 'trackpad';

            } else if (timeDelta > 400) {
                // This is likely a new scroll action.
                this._type = null;
                this._lastValue = value;

                // Start a timeout in case this was a singular event, and dely it by up to 40ms.
                this._timeout = setTimeout(this._onTimeout, 40);

            } else if (!this._type) {
                // This is a repeating event, but we don't know the type of event just yet.
                // If the delta per time is small, we assume it's a fast trackpad; otherwise we switch into wheel mode.
                this._type = (Math.abs(timeDelta * value) < 200) ? 'trackpad' : 'wheel';

                // Make sure our delayed event isn't fired again, because we accumulate
                // the previous event (which was less than 40ms ago) into this event.
                if (this._timeout) {
                    clearTimeout(this._timeout);
                    this._timeout = null;
                    value += this._lastValue;
                }
            }

            // Slow down zoom if shift key is held for more precise zooming
            if (e.shiftKey && value) value = value / 4;

            // Only fire the callback if we actually know what type of scrolling device the user uses.
            if (this._type) this._zoom(-value);

            e.preventDefault();
        },

        _onTimeout: function () {
            this._type = 'wheel';
            this._zoom(-this._lastValue);
        },

        _zoom: function (delta) {
            var map = this._map;

            // Scale by sigmoid of scroll wheel delta.
            var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));
            if (delta < 0 && scale !== 0) scale = 1 / scale;

            var fromScale = map.ease ? map.ease.to : map.transform.scale,
                targetZoom = map.transform.scaleZoom(fromScale * scale);

            map.zoomTo(targetZoom, {
                duration: 0,
                around: map.unproject(this._pos)
            });
        }
    };

},{"../../util/browser":92,"../../util/dom":95,"../../util/util":103}],86:[function(require,module,exports){
    'use strict';

    /*
     * Adds positional coordinates to URL hashes. Passed as an option to the map object
     *
     * @class mapboxgl.Hash
     * @returns {Hash} `this`
     */
    module.exports = Hash;

    var util = require('../util/util');

    function Hash() {
        util.bindAll([
            '_onHashChange',
            '_updateHash'
        ], this);
    }

    Hash.prototype = {
        /* Map element to listen for coordinate changes
         *
         * @param {Object} map
         * @returns {Hash} `this`
         */
        addTo: function(map) {
            this._map = map;
            window.addEventListener('hashchange', this._onHashChange, false);
            this._map.on('moveend', this._updateHash);
            return this;
        },

        /* Removes hash
         *
         * @returns {Popup} `this`
         */
        remove: function() {
            window.removeEventListener('hashchange', this._onHashChange, false);
            this._map.off('moveend', this._updateHash);
            delete this._map;
            return this;
        },

        _onHashChange: function() {
            var loc = location.hash.replace('#', '').split('/');
            if (loc.length >= 3) {
                this._map.jumpTo({
                    center: [+loc[1], +loc[2]],
                    zoom: +loc[0],
                    bearing: +(loc[3] || 0)
                });
                return true;
            }
            return false;
        },

        _updateHash: function() {
            var center = this._map.getCenter(),
                zoom = this._map.getZoom(),
                bearing = this._map.getBearing(),
                precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),

                hash = '#' + (Math.round(zoom * 100) / 100) +
                    '/' + center.lat.toFixed(precision) +
                    '/' + center.lng.toFixed(precision) +
                    (bearing ? '/' + (Math.round(bearing * 10) / 10) : '');

            window.history.replaceState('', '', hash);
        }
    };

},{"../util/util":103}],87:[function(require,module,exports){
    'use strict';

    var handlers = {
        scrollZoom: require('./handler/scroll_zoom'),
        boxZoom: require('./handler/box_zoom'),
        dragRotate: require('./handler/drag_rotate'),
        dragPan: require('./handler/drag_pan'),
        keyboard: require('./handler/keyboard'),
        doubleClickZoom: require('./handler/dblclick_zoom'),
        pinch: require('./handler/pinch')
    };

    var DOM = require('../util/dom'),
        util = require('../util/util');

    module.exports = Interaction;

    /**
     * Mouse move event.
     *
     * @event mousemove
     * @memberof Map
     * @type {Object}
     * @property {Point} point the pixel location of the event
     * @property {LatLng} point the geographic location of the event
     * @property {Event} originalEvent the original DOM event
     */

    /**
     * Click event.
     *
     * @event click
     * @memberof Map
     * @type {Object}
     * @property {Point} point the pixel location of the event
     * @property {LatLng} point the geographic location of the event
     * @property {Event} originalEvent the original DOM event
     */

    /**
     * Double click event.
     *
     * @event dblclick
     * @memberof Map
     * @type {Object}
     * @property {Point} point the pixel location of the event
     * @property {LatLng} point the geographic location of the event
     * @property {Event} originalEvent the original DOM event
     */

    function Interaction(map) {
        this._map = map;
        this._el = map.getCanvasContainer();

        for (var name in handlers) {
            map[name] = new handlers[name](map);
        }

        util.bindHandlers(this);
    }

    Interaction.prototype = {
        enable: function () {
            var options = this._map.options,
                el = this._el;

            for (var name in handlers) {
                if (options[name]) this._map[name].enable();
            }

            el.addEventListener('mousedown', this._onMouseDown, false);
            el.addEventListener('touchstart', this._onTouchStart, false);
            el.addEventListener('click', this._onClick, false);
            el.addEventListener('mousemove', this._onMouseMove, false);
            el.addEventListener('dblclick', this._onDblClick, false);
        },

        disable: function () {
            var options = this._map.options,
                el = this._el;

            for (var name in handlers) {
                if (options[name]) this._map[name].disable();
            }

            el.removeEventListener('mousedown', this._onMouseDown);
            el.removeEventListener('touchstart', this._onTouchStart);
            el.removeEventListener('click', this._onClick);
            el.removeEventListener('mousemove', this._onMouseMove);
            el.removeEventListener('dblclick', this._onDblClick);
        },

        _onMouseDown: function (e) {
            this._startPos = DOM.mousePos(this._el, e);
        },

        _onTouchStart: function (e) {
            if (!e.touches || e.touches.length > 1) return;

            if (!this._tapped) {
                this._tapped = setTimeout(this._onTimeout, 300);

            } else {
                clearTimeout(this._tapped);
                this._tapped = null;
                this._fireEvent('dblclick', e);
            }
        },

        _onTimeout: function () {
            this._tapped = null;
        },

        _onMouseMove: function (e) {
            var map = this._map,
                el = this._el;

            if (map.dragPan.active || map.dragRotate.active) return;

            var target = e.toElement || e.target;
            while (target && target !== el) target = target.parentNode;
            if (target !== el) return;

            this._fireEvent('mousemove', e);
        },

        _onClick: function (e) {
            var pos = DOM.mousePos(this._el, e);

            if (pos.equals(this._startPos)) {
                this._fireEvent('click', e);
            }
        },

        _onDblClick: function (e) {
            this._fireEvent('dblclick', e);
            e.preventDefault();
        },

        _fireEvent: function (type, e) {
            var pos = DOM.mousePos(this._el, e);

            this._map.fire(type, {
                latLng: this._map.unproject(pos),
                point: pos,
                originalEvent: e
            });
        }
    };

},{"../util/dom":95,"../util/util":103,"./handler/box_zoom":79,"./handler/dblclick_zoom":80,"./handler/drag_pan":81,"./handler/drag_rotate":82,"./handler/keyboard":83,"./handler/pinch":84,"./handler/scroll_zoom":85}],88:[function(require,module,exports){
    'use strict';

    var Canvas = require('../util/canvas');
    var util = require('../util/util');
    var browser = require('../util/browser');
    var Evented = require('../util/evented');
    var DOM = require('../util/dom');

    var Style = require('../style/style');
    var AnimationLoop = require('../style/animation_loop');
    var Painter = require('../render/painter');

    var Transform = require('../geo/transform');
    var Hash = require('./hash');

    var Interaction = require('./interaction');

    var Camera = require('./camera');
    var LatLng = require('../geo/lat_lng');
    var LatLngBounds = require('../geo/lat_lng_bounds');
    var Point = require('point-geometry');
    var Attribution = require('./control/attribution');

    /**
     * Options common to Map#addClass, Map#removeClass, and Map#setClasses, controlling
     * whether or not to smoothly transition property changes triggered by the class change.
     *
     * @typedef {Object} StyleOptions
     * @property {boolean} transition
     */

    /**
     * Creates a map instance.
     * @class Map
     * @param {Object} options
     * @param {string} options.container HTML element to initialize the map in (or element id as string)
     * @param {number} [options.minZoom=0] Minimum zoom of the map
     * @param {number} [options.maxZoom=20] Maximum zoom of the map
     * @param {Object} options.style Map style and data source definition (either a JSON object or a JSON URL), described in the [style reference](https://mapbox.com/mapbox-gl-style-spec/)
     * @param {boolean} [options.hash=false] If `true`, the map will track and update the page URL according to map position
     * @param {boolean} [options.interactive=true] If `false`, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input
     * @param {number} [options.bearingSnap=7] Snap to north threshold in degrees.
     * @param {Array} options.classes Style class names with which to initialize the map
     * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
     * @param {boolean} [options.preserveDrawingBuffer=false] If `true`, The maps canvas can be exported to a PNG using `map.getCanvas().toDataURL();`. This is false by default as a performance optimization.
     * @example
     * var map = new mapboxgl.Map({
 *   container: 'map',
 *   center: [37.772537, -122.420679],
 *   zoom: 13,
 *   style: style_object,
 *   hash: true
 * });
     */
    var Map = module.exports = function(options) {

        options = this.options = util.inherit(this.options, options);

        this.animationLoop = new AnimationLoop();
        this.transform = new Transform(options.minZoom, options.maxZoom);

        if (options.maxBounds) {
            var b = LatLngBounds.convert(options.maxBounds);
            this.transform.latRange = [b.getSouth(), b.getNorth()];
            this.transform.lngRange = [b.getWest(), b.getEast()];
        }

        util.bindAll([
            '_forwardStyleEvent',
            '_forwardSourceEvent',
            '_forwardLayerEvent',
            '_forwardTileEvent',
            '_onStyleLoad',
            '_onStyleChange',
            '_onSourceAdd',
            '_onSourceRemove',
            '_onSourceUpdate',
            'update',
            'render'
        ], this);

        this._setupContainer();
        this._setupPainter();

        this.on('move', this.update);
        this.on('zoom', this.update.bind(this, true));
        this.on('moveend', function() {
            this.animationLoop.set(300); // text fading
            this._rerender();
        }.bind(this));

        if (typeof window !== 'undefined') {
            window.addEventListener('resize', function () {
                this.stop().resize().update();
            }.bind(this), false);
        }

        this.interaction = new Interaction(this);

        if (options.interactive) {
            this.interaction.enable();
        }

        this._hash = options.hash && (new Hash()).addTo(this);
        // don't set position from options if set through hash
        if (!this._hash || !this._hash._onHashChange()) {
            this.jumpTo(options);
        }

        this.sources = {};
        this.stacks = {};
        this._classes = {};

        this.resize();

        if (options.classes) this.setClasses(options.classes);
        if (options.style) this.setStyle(options.style);
        if (options.attributionControl) this.addControl(new Attribution());
    };

    util.extend(Map.prototype, Evented);
    util.extend(Map.prototype, Camera.prototype);
    util.extend(Map.prototype, /** @lends Map.prototype */{

        options: {
            center: [0, 0],
            zoom: 0,
            bearing: 0,
            pitch: 0,

            minZoom: 0,
            maxZoom: 20,

            interactive: true,

            scrollZoom: true,
            boxZoom: true,
            dragRotate: true,
            dragPan: true,
            keyboard: true,
            doubleClickZoom: true,
            pinch: true,

            bearingSnap: 7,

            hash: false,

            attributionControl: true,

            failIfMajorPerformanceCaveat: false,
            preserveDrawingBuffer: false
        },

        addControl: function(control) {
            control.addTo(this);
            return this;
        },

        /**
         * Adds a style class to a map
         *
         * @param {string} klass name of style class
         * @param {StyleOptions} [options]
         * @fires change
         * @returns {Map} `this`
         */
        addClass: function(klass, options) {
            if (this._classes[klass]) return;
            this._classes[klass] = true;
            if (this.style) this.style._cascade(this._classes, options);
        },

        /**
         * Removes a style class from a map
         *
         * @param {string} klass name of style class
         * @param {StyleOptions} [options]
         * @fires change
         * @returns {Map} `this`
         */
        removeClass: function(klass, options) {
            if (!this._classes[klass]) return;
            delete this._classes[klass];
            if (this.style) this.style._cascade(this._classes, options);
        },

        /**
         * Helper method to add more than one class
         *
         * @param {Array<string>} klasses An array of class names
         * @param {StyleOptions} [options]
         * @fires change
         * @returns {Map} `this`
         */
        setClasses: function(klasses, options) {
            this._classes = {};
            for (var i = 0; i < klasses.length; i++) {
                this._classes[klasses[i]] = true;
            }
            if (this.style) this.style._cascade(this._classes, options);
        },

        /**
         * Check whether a style class is active
         *
         * @param {string} klass Name of style class
         * @returns {boolean}
         */
        hasClass: function(klass) {
            return !!this._classes[klass];
        },

        /**
         * Return an array of the current active style classes
         *
         * @returns {boolean}
         */
        getClasses: function() {
            return Object.keys(this._classes);
        },

        /**
         * Detect the map's new width and height and resize it.
         *
         * @returns {Map} `this`
         */
        resize: function() {
            var width = 0, height = 0;

            if (this._container) {
                width = this._container.offsetWidth || 400;
                height = this._container.offsetHeight || 300;
            }

            this._canvas.resize(width, height);

            this.transform.width = width;
            this.transform.height = height;
            this.transform._constrain();

            this.painter.resize(width, height);

            return this
                .fire('movestart')
                .fire('move')
                .fire('resize')
                .fire('moveend');
        },

        /**
         * Get the map's geographical bounds
         *
         * @returns {LatLngBounds}
         */
        getBounds: function() {
            return new LatLngBounds(
                this.transform.pointLocation(new Point(0, 0)),
                this.transform.pointLocation(this.transform.size));
        },

        /**
         * Get pixel coordinates (relative to map container) given a geographical location
         *
         * @param {LatLng} latlng
         * @returns {Object} `x` and `y` coordinates
         */
        project: function(latlng) {
            return this.transform.locationPoint(LatLng.convert(latlng));
        },

        /**
         * Get geographical coordinates given pixel coordinates
         *
         * @param {Array<number>} point [x, y] pixel coordinates
         * @returns {LatLng}
         */
        unproject: function(point) {
            return this.transform.pointLocation(Point.convert(point));
        },

        /**
         * Get all features at a point ([x, y])
         *
         * @param {Array<number>} point [x, y] pixel coordinates
         * @param {Object} params
         * @param {number} [params.radius=0] Optional. Radius in pixels to search in
         * @param {string} params.layer Optional. Only return features from a given layer
         * @param {string} params.type Optional. Either `raster` or `vector`
         * @param {featuresAtCallback} callback function that returns the response
         *
         * @callback featuresAtCallback
         * @param {Object|null} err Error _If any_
         * @param {Array} features Displays a JSON array of features given the passed parameters of `featuresAt`
         *
         * @returns {Map} `this`
         *
         * @example
         * map.featuresAt([10, 20], { radius: 10 }, function(err, features) {
     *   console.log(features);
     * });
         */
        featuresAt: function(point, params, callback) {
            var coord = this.transform.pointCoordinate(Point.convert(point));
            this.style.featuresAt(coord, params, callback);
            return this;
        },

        /**
         * Apply multiple style mutations in a batch
         *
         * map.batch(function (batch) {
     *     batch.addLayer(layer1);
     *     batch.addLayer(layer2);
     *     ...
     *     batch.addLayer(layerN);
     * });
         *
         * @param {function} work Function which accepts the StyleBatch interface
         */
        batch: function(work) {
            this.style.batch(work);

            this.style._cascade(this._classes);
            this.update(true);
        },

        /**
         * Replaces the map's style object
         *
         * @param {Object} style A style object formatted as JSON
         * @returns {Map} `this`
         */
        setStyle: function(style) {
            if (this.style) {
                this.style
                    .off('load', this._onStyleLoad)
                    .off('error', this._forwardStyleEvent)
                    .off('change', this._onStyleChange)
                    .off('source.add', this._onSourceAdd)
                    .off('source.remove', this._onSourceRemove)
                    .off('source.load', this._onSourceUpdate)
                    .off('source.error', this._forwardSourceEvent)
                    .off('source.change', this._onSourceUpdate)
                    .off('layer.add', this._forwardLayerEvent)
                    .off('layer.remove', this._forwardLayerEvent)
                    .off('tile.add', this._forwardTileEvent)
                    .off('tile.remove', this._forwardTileEvent)
                    .off('tile.load', this.update)
                    .off('tile.error', this._forwardTileEvent)
                    ._remove();

                this.off('rotate', this.style._redoPlacement);
                this.off('pitch', this.style._redoPlacement);
            }

            if (!style) {
                this.style = null;
                return this;
            } else if (style instanceof Style) {
                this.style = style;
            } else {
                this.style = new Style(style, this.animationLoop);
            }

            this.style
                .on('load', this._onStyleLoad)
                .on('error', this._forwardStyleEvent)
                .on('change', this._onStyleChange)
                .on('source.add', this._onSourceAdd)
                .on('source.remove', this._onSourceRemove)
                .on('source.load', this._onSourceUpdate)
                .on('source.error', this._forwardSourceEvent)
                .on('source.change', this._onSourceUpdate)
                .on('layer.add', this._forwardLayerEvent)
                .on('layer.remove', this._forwardLayerEvent)
                .on('tile.add', this._forwardTileEvent)
                .on('tile.remove', this._forwardTileEvent)
                .on('tile.load', this.update)
                .on('tile.error', this._forwardTileEvent);

            this.on('rotate', this.style._redoPlacement);
            this.on('pitch', this.style._redoPlacement);

            return this;
        },

        /**
         * Add a source to the map style.
         *
         * @param {string} id ID of the source. Must not be used by any existing source.
         * @param {Object} source source specification, following the
         * [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/#sources)
         * @fires source.add
         * @returns {Map} `this`
         */
        addSource: function(id, source) {
            this.style.addSource(id, source);
            return this;
        },

        /**
         * Remove an existing source from the map style.
         *
         * @param {string} id ID of the source to remove
         * @fires source.remove
         * @returns {Map} `this`
         */
        removeSource: function(id) {
            this.style.removeSource(id);
            return this;
        },

        /**
         * Return the style source object with the given `id`.
         *
         * @param {string} id source ID
         * @returns {Object}
         */
        getSource: function(id) {
            return this.style.getSource(id);
        },

        /**
         * Add a layer to the map style. The layer will be inserted before the layer with
         * ID `before`, or appended if `before` is omitted.
         * @param {StyleLayer|Object} layer
         * @param {string=} before  ID of an existing layer to insert before
         * @fires layer.add
         * @returns {Map} `this`
         */
        addLayer: function(layer, before) {
            this.style.addLayer(layer, before);
            this.style._cascade(this._classes);
            return this;
        },

        /**
         * Remove the layer with the given `id` from the map. Any layers which refer to the
         * specified layer via a `ref` property are also removed.
         *
         * @param {string} id layer id
         * @fires layer.remove
         * @returns {Map} this
         */
        removeLayer: function(id) {
            this.style.removeLayer(id);
            this.style._cascade(this._classes);
            return this;
        },

        /**
         * Set the filter for a given style layer.
         *
         * @param {string} layer ID of a layer
         * @param {Array} filter filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#filter)
         * @returns {Map} `this`
         */
        setFilter: function(layer, filter) {
            this.style.setFilter(layer, filter);
            return this;
        },

        /**
         * Get the filter for a given style layer.
         *
         * @param {string} layer ID of a layer
         * @returns {Array} filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#filter)
         */
        getFilter: function(layer) {
            return this.style.getFilter(layer);
        },

        /**
         * Set the value of a paint property in a given style layer.
         *
         * @param {string} layer ID of a layer
         * @param {string} name name of a paint property
         * @param {*} value value for the paint propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
         * @param {string=} klass optional class specifier for the property
         * @returns {Map} `this`
         */
        setPaintProperty: function(layer, name, value, klass) {
            this.style.setPaintProperty(layer, name, value, klass);
            this.style._cascade(this._classes);
            this.update(true);
            return this;
        },

        /**
         * Get the value of a paint property in a given style layer.
         *
         * @param {string} layer ID of a layer
         * @param {string} name name of a paint property
         * @param {string=} klass optional class specifier for the property
         * @returns {*} value for the paint propery
         */
        getPaintProperty: function(layer, name, klass) {
            return this.style.getPaintProperty(layer, name, klass);
        },

        /**
         * Set the value of a layout property in a given style layer.
         *
         * @param {string} layer ID of a layer
         * @param {string} name name of a layout property
         * @param {*} value value for the layout propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
         * @returns {Map} `this`
         */
        setLayoutProperty: function(layer, name, value) {
            this.style.setLayoutProperty(layer, name, value);
            return this;
        },

        /**
         * Get the value of a layout property in a given style layer.
         *
         * @param {string} layer ID of a layer
         * @param {string} name name of a layout property
         * @param {string=} klass optional class specifier for the property
         * @returns {*} value for the layout propery
         */
        getLayoutProperty: function(layer, name) {
            return this.style.getLayoutProperty(layer, name);
        },

        /**
         * Get the Map's container as an HTML element
         * @returns {HTMLElement} container
         */
        getContainer: function() {
            return this._container;
        },

        /**
         * Get the container for the map `canvas` element.
         *
         * If you want to add non-GL overlays to the map, you should append them to this element. This
         * is the element to which event bindings for map interactivity such as panning and zooming are
         * attached. It will receive bubbled events for child elements such as the `canvas`, but not for
         * map controls.
         *
         * @returns {HTMLElement} container
         */
        getCanvasContainer: function() {
            return this._canvasContainer;
        },

        /**
         * Get the Map's canvas as an HTML canvas
         * @returns {HTMLElement} canvas
         */
        getCanvas: function() {
            return this._canvas.getElement();
        },

        _setupContainer: function() {
            var id = this.options.container;

            var container = this._container = typeof id === 'string' ? document.getElementById(id) : id;
            container.classList.add('mapboxgl-map');

            var canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);
            if (this.options.interactive) {
                canvasContainer.classList.add('mapboxgl-interactive');
            }
            this._canvas = new Canvas(this, canvasContainer);

            var controlContainer = DOM.create('div', 'mapboxgl-control-container', container);
            var corners = this._controlCorners = {};
            ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(function (pos) {
                corners[pos] = DOM.create('div', 'mapboxgl-ctrl-' + pos, controlContainer);
            });
        },

        _setupPainter: function() {
            var gl = this._canvas.getWebGLContext({
                failIfMajorPerformanceCaveat: this.options.failIfMajorPerformanceCaveat,
                preserveDrawingBuffer: this.options.preserveDrawingBuffer
            });

            if (!gl) {
                console.error('Failed to initialize WebGL');
                return;
            }

            this.painter = new Painter(gl, this.transform);
        },

        _contextLost: function(event) {
            event.preventDefault();
            if (this._frameId) {
                browser.cancelFrame(this._frameId);
            }
        },

        _contextRestored: function() {
            this._setupPainter();
            this.resize();
            this.update();
        },

        /**
         * Is this map fully loaded? If the style isn't loaded
         * or it has a change to the sources or style that isn't
         * propagated to its style, return false.
         *
         * @returns {boolean} whether the map is loaded
         */
        loaded: function() {
            if (this._styleDirty || this._sourcesDirty)
                return false;
            if (this.style && !this.style.loaded())
                return false;
            return true;
        },

        /**
         * Update this map's style and re-render the map.
         *
         * @param {Object} updateStyle new style
         * @returns {Map} this
         */
        update: function(updateStyle) {
            if (!this.style) return this;

            this._styleDirty = this._styleDirty || updateStyle;
            this._sourcesDirty = true;

            this._rerender();

            return this;
        },

        /**
         * Call when a (re-)render of the map is required, e.g. when the
         * user panned or zoomed,f or new data is available.
         * @returns {Map} this
         */
        render: function() {
            if (this.style && this._styleDirty) {
                this._styleDirty = false;
                this.style._recalculate(this.transform.zoom);
            }

            if (this.style && this._sourcesDirty && !this._sourcesDirtyTimeout) {
                this._sourcesDirty = false;
                this._sourcesDirtyTimeout = setTimeout(function() {
                    this._sourcesDirtyTimeout = null;
                }.bind(this), 50);
                this.style._updateSources(this.transform);
            }

            this.painter.render(this.style, {
                debug: this.debug,
                vertices: this.vertices,
                rotating: this.rotating,
                zooming: this.zooming
            });

            this.fire('render');

            if (this.loaded() && !this._loaded) {
                this._loaded = true;
                this.fire('load');
            }

            this._frameId = null;

            if (!this.animationLoop.stopped()) {
                this._styleDirty = true;
            }

            if (this._sourcesDirty || this._repaint || !this.animationLoop.stopped()) {
                this._rerender();
            }

            return this;
        },

        /**
         * Destroys the map's underlying resources, including web workers.
         * @returns {Map} this
         */
        remove: function() {
            if (this._hash) this._hash.remove();
            browser.cancelFrame(this._frameId);
            clearTimeout(this._sourcesDirtyTimeout);
            this.setStyle(null);
            return this;
        },

        _rerender: function() {
            if (this.style && !this._frameId) {
                this._frameId = browser.frame(this.render);
            }
        },

        _forwardStyleEvent: function(e) {
            this.fire('style.' + e.type, util.extend({style: e.target}, e));
        },

        _forwardSourceEvent: function(e) {
            this.fire(e.type, util.extend({style: e.target}, e));
        },

        _forwardLayerEvent: function(e) {
            this.fire(e.type, util.extend({style: e.target}, e));
        },

        _forwardTileEvent: function(e) {
            this.fire(e.type, util.extend({style: e.target}, e));
        },

        _onStyleLoad: function(e) {
            this.style._cascade(this._classes, {transition: false});
            this._forwardStyleEvent(e);
        },

        _onStyleChange: function(e) {
            this.update(true);
            this._forwardStyleEvent(e);
        },

        _onSourceAdd: function(e) {
            var source = e.source;
            if (source.onAdd)
                source.onAdd(this);
            this._forwardSourceEvent(e);
        },

        _onSourceRemove: function(e) {
            var source = e.source;
            if (source.onRemove)
                source.onRemove(this);
            this._forwardSourceEvent(e);
        },

        _onSourceUpdate: function(e) {
            this.update();
            this._forwardSourceEvent(e);
        }
    });

    util.extendAll(Map.prototype, /** @lends Map.prototype */{

        /**
         * Enable debugging mode
         *
         * @name debug
         * @type {boolean}
         */
        _debug: false,
        get debug() { return this._debug; },
        set debug(value) { this._debug = value; this.update(); },

        /**
         * Show collision boxes: useful for debugging label placement
         * in styles.
         *
         * @name collisionDebug
         * @type {boolean}
         */
        _collisionDebug: false,
        get collisionDebug() { return this._collisionDebug; },
        set collisionDebug(value) {
            this._collisionDebug = value;
            for (var i in this.style.sources) {
                this.style.sources[i].reload();
            }
            this.update();
        },

        /**
         * Enable continuous repaint to analyze performance
         *
         * @name repaint
         * @type {boolean}
         */
        _repaint: false,
        get repaint() { return this._repaint; },
        set repaint(value) { this._repaint = value; this.update(); },

        // show vertices
        _vertices: false,
        get vertices() { return this._vertices; },
        set vertices(value) { this._vertices = value; this.update(); }
    });

},{"../geo/lat_lng":18,"../geo/lat_lng_bounds":19,"../geo/transform":20,"../render/painter":34,"../style/animation_loop":47,"../style/style":52,"../util/browser":92,"../util/canvas":93,"../util/dom":95,"../util/evented":97,"../util/util":103,"./camera":75,"./control/attribution":76,"./hash":86,"./interaction":87,"point-geometry":150}],89:[function(require,module,exports){
    'use strict';

    module.exports = Popup;

    var util = require('../util/util');
    var Evented = require('../util/evented');
    var DOM = require('../util/dom');
    var LatLng = require('../geo/lat_lng');

    /**
     * Creates a popup component
     * @class Popup
     * @param {Object} options
     * @param {boolean} options.closeButton
     * @param {boolean} options.closeOnClick
     * @example
     * var tooltip = new mapboxgl.Popup()
     *   .setLatLng(map.unproject(e.point))
     *   .setHTML("<h1>Hello World!</h1>")
     *   .addTo(map);
     */
    function Popup(options) {
        util.setOptions(this, options);
        util.bindAll([
                '_updatePosition',
                '_onClickClose'],
            this);
    }

    Popup.prototype = util.inherit(Evented, /** @lends Popup.prototype */{
        options: {
            closeButton: true,
            closeOnClick: true
        },

        /**
         * Attaches the popup to a map
         * @param {Map} map
         * @returns {Popup} `this`
         */
        addTo: function(map) {
            this._map = map;
            this._map.on('move', this._updatePosition);
            if (this.options.closeOnClick) {
                this._map.on('click', this._onClickClose);
            }
            this._update();
            return this;
        },

        /**
         * Removes the popup from the map
         * @example
         * var popup = new mapboxgl.Popup().addTo(map);
         * popup.remove();
         * @returns {Popup} `this`
         */
        remove: function() {
            if (this._container) {
                this._container.parentNode.removeChild(this._container);
            }

            if (this._map) {
                this._map.off('move', this._updatePosition);
                this._map.off('click', this._onClickClose);
                delete this._map;
            }

            return this;
        },

        /**
         * Get the current coordinates of popup element relative to map
         * @returns {LatLng}
         */
        getLatLng: function() {
            return this._latLng;
        },

        /**
         * Set the coordinates of a popup element to a map
         * @param {LatLng} latlng
         * @returns {Popup} `this`
         */
        setLatLng: function(latlng) {
            this._latLng = LatLng.convert(latlng);
            this._update();
            return this;
        },

        /**
         * Fill a popup element with text only content
         * @param {string} text
         * @returns {Popup} `this`
         */
        setText: function(text) {
            this._content = document.createTextNode(text);
            this._updateContent();
            return this;
        },

        /**
         * Fill a popup element with HTML content
         * @param {string} html
         * @returns {Popup} `this`
         */
        setHTML: function(html) {
            this._content = document.createDocumentFragment();

            var temp = document.createElement('body'), child;
            temp.innerHTML = html;
            while (true) {
                child = temp.firstChild;
                if (!child) break;
                this._content.appendChild(child);
            }

            this._updateContent();
            return this;
        },

        _update: function() {
            if (!this._map) { return; }

            if (!this._container) {
                this._container = DOM.create('div', 'mapboxgl-popup', this._map.getContainer());

                this._tip     = DOM.create('div', 'mapboxgl-popup-tip',     this._container);
                this._wrapper = DOM.create('div', 'mapboxgl-popup-content', this._container);

                if (this.options.closeButton) {
                    this._closeButton = DOM.create('button', 'mapboxgl-popup-close-button', this._wrapper);
                    this._closeButton.innerHTML = '&#215;';
                    this._closeButton.addEventListener('click', this._onClickClose);
                }
            }

            this._updateContent();
            this._updatePosition();
        },

        _updateContent: function() {
            if (!this._content || !this._container) { return; }

            var node = this._wrapper;

            while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
            }

            if (this.options.closeButton) {
                node.appendChild(this._closeButton);
            }

            node.appendChild(this._content);
        },

        _updatePosition: function() {
            if (!this._latLng || !this._container) { return; }

            var pos = this._map.project(this._latLng).round(),
                anchor = this.options.anchor;

            if (!anchor) {
                var width = this._container.offsetWidth,
                    height = this._container.offsetHeight;

                if (pos.y < height) {
                    anchor = ['top'];
                } else if (pos.y > this._map.transform.height - height) {
                    anchor = ['bottom'];
                } else {
                    anchor = [];
                }

                if (pos.x < width / 2) {
                    anchor.push('left');
                } else if (pos.x > this._map.transform.width - width / 2) {
                    anchor.push('right');
                }

                if (anchor.length === 0) {
                    anchor = 'bottom';
                } else {
                    anchor = anchor.join('-');
                }

                this.options.anchor = anchor;
            }

            var anchorTranslate = {
                'top': 'translate(-50%,0)',
                'top-left': 'translate(0,0)',
                'top-right': 'translate(-100%,0)',
                'bottom': 'translate(-50%,-100%)',
                'bottom-left': 'translate(0,-100%)',
                'bottom-right': 'translate(-100%,-100%)',
                'left': 'translate(0,-50%)',
                'right': 'translate(-100%,-50%)'
            };

            var classList = this._container.classList;
            for (var key in anchorTranslate) {
                classList.remove('mapboxgl-popup-anchor-' + key);
            }
            classList.add('mapboxgl-popup-anchor-' + anchor);

            DOM.setTransform(this._container, anchorTranslate[anchor] + ' translate(' + pos.x + 'px,' + pos.y + 'px)');
        },

        _onClickClose: function() {
            this.remove();
        }
    });

},{"../geo/lat_lng":18,"../util/dom":95,"../util/evented":97,"../util/util":103}],90:[function(require,module,exports){
    'use strict';

    module.exports = Actor;

    /**
     * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)
     * that maintains the relationship between asynchronous tasks and the objects
     * that spin them off - in this case, tasks like parsing parts of styles,
     * owned by the styles
     *
     * @param {WebWorker} target
     * @param {WebWorker} parent
     * @private
     */
    function Actor(target, parent) {
        this.target = target;
        this.parent = parent;
        this.callbacks = {};
        this.callbackID = 0;
        this.receive = this.receive.bind(this);
        this.target.addEventListener('message', this.receive, false);
    }

    Actor.prototype.receive = function(message) {
        var data = message.data,
            callback;

        if (data.type === '<response>') {
            callback = this.callbacks[data.id];
            delete this.callbacks[data.id];
            callback(data.error || null, data.data);
        } else if (typeof data.id !== 'undefined') {
            var id = data.id;
            this.parent[data.type](data.data, function(err, data, buffers) {
                this.postMessage({
                    type: '<response>',
                    id: String(id),
                    error: err ? String(err) : null,
                    data: data
                }, buffers);
            }.bind(this));
        } else {
            this.parent[data.type](data.data);
        }
    };

    Actor.prototype.send = function(type, data, callback, buffers) {
        var id = null;
        if (callback) this.callbacks[id = this.callbackID++] = callback;
        this.postMessage({ type: type, id: String(id), data: data }, buffers);
    };

    /**
     * Wrapped postMessage API that abstracts around IE's lack of
     * `transferList` support.
     *
     * @param {Object} message
     * @param {Object} transferList
     * @private
     */
    Actor.prototype.postMessage = function(message, transferList) {
        try {
            this.target.postMessage(message, transferList);
        } catch (e) {
            this.target.postMessage(message); // No support for transferList on IE
        }
    };

},{}],91:[function(require,module,exports){
    'use strict';

    exports.getJSON = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onerror = function(e) {
            callback(e);
        };
        xhr.onload = function() {
            if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
                var data;
                try {
                    data = JSON.parse(xhr.response);
                } catch (err) {
                    return callback(err);
                }
                callback(null, data);
            } else {
                callback(new Error(xhr.statusText));
            }
        };
        xhr.send();
        return xhr;
    };

    exports.getArrayBuffer = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onerror = function(e) {
            callback(e);
        };
        xhr.onload = function() {
            if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
                callback(null, xhr.response);
            } else {
                callback(new Error(xhr.statusText));
            }
        };
        xhr.send();
        return xhr;
    };

    function sameOrigin(url) {
        var a = document.createElement('a');
        a.href = url;
        return a.protocol === document.location.protocol && a.host === document.location.host;
    }

    exports.getImage = function(url, callback) {
        var img = new Image();
        if (!sameOrigin(url)) {
            img.crossOrigin = 'Anonymous';
        }
        img.onload = function() {
            callback(null, img);
        };
        img.src = url;
        img.getData = function() {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            context.drawImage(img, 0, 0);
            return context.getImageData(0, 0, img.width, img.height).data;
        };
        return img;
    };

    exports.getVideo = function(urls, callback) {
        var video = document.createElement('video');
        video.onloadstart = function() {
            callback(null, video);
        };
        for (var i = 0; i < urls.length; i++) {
            var s = document.createElement('source');
            if (!sameOrigin(urls[i])) {
                video.crossOrigin = 'Anonymous';
            }
            s.src = urls[i];
            video.appendChild(s);
        }
        video.getData = function() { return video; };
        return video;
    };

},{}],92:[function(require,module,exports){
    'use strict';

    var Canvas = require('./canvas');

    var frame = window.requestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame;

    exports.frame = function(fn) {
        return frame(fn);
    };

    var cancel = window.cancelAnimationFrame ||
        window.mozCancelAnimationFrame ||
        window.webkitCancelAnimationFrame ||
        window.msCancelAnimationFrame;

    exports.cancelFrame = function(id) {
        cancel(id);
    };

    exports.timed = function (fn, dur, ctx) {
        if (!dur) {
            fn.call(ctx, 1);
            return null;
        }

        var abort = false,
            start = window.performance ? window.performance.now() : Date.now();

        function tick(now) {
            if (abort) return;
            if (!window.performance) now = Date.now();

            if (now >= start + dur) {
                fn.call(ctx, 1);
            } else {
                fn.call(ctx, (now - start) / dur);
                exports.frame(tick);
            }
        }

        exports.frame(tick);

        return function() { abort = true; };
    };

    /**
     * Test whether the basic JavaScript and DOM features required for Mapbox GL are present.
     * @param {Object} options
     * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
     * @return {boolean} Returns true if Mapbox GL should be expected to work, and false if not.
     * @memberof mapboxgl
     * @static
     */
    exports.supported = function(options) {

        var supports = [

            function() { return typeof window !== 'undefined'; },

            function() { return typeof document !== 'undefined'; },

            function () {
                return !!(Array.prototype &&
                    Array.prototype.every &&
                    Array.prototype.filter &&
                    Array.prototype.forEach &&
                    Array.prototype.indexOf &&
                    Array.prototype.lastIndexOf &&
                    Array.prototype.map &&
                    Array.prototype.some &&
                    Array.prototype.reduce &&
                    Array.prototype.reduceRight &&
                    Array.isArray);
            },

            function() {
                return !!(Function.prototype && Function.prototype.bind) &&
                    !!(Object.keys &&
                        Object.create &&
                        Object.getPrototypeOf &&
                        Object.getOwnPropertyNames &&
                        Object.isSealed &&
                        Object.isFrozen &&
                        Object.isExtensible &&
                        Object.getOwnPropertyDescriptor &&
                        Object.defineProperty &&
                        Object.defineProperties &&
                        Object.seal &&
                        Object.freeze &&
                        Object.preventExtensions);
            },

            function() {
                return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
            },

            function() {
                return new Canvas().supportsWebGLContext((options && options.failIfMajorPerformanceCaveat) || false);
            },

            function() { return 'Worker' in window; }
        ];

        for (var i = 0; i < supports.length; i++) {
            if (!supports[i]()) return false;
        }
        return true;
    };

    exports.hardwareConcurrency = navigator.hardwareConcurrency || 8;

    Object.defineProperty(exports, 'devicePixelRatio', {
        get: function() { return window.devicePixelRatio; }
    });

},{"./canvas":93}],93:[function(require,module,exports){
    'use strict';

    var util = require('../util');

    module.exports = Canvas;

    function Canvas(parent, container) {
        this.canvas = document.createElement('canvas');

        if (parent && container) {
            this.canvas.style.position = 'absolute';
            this.canvas.classList.add('mapboxgl-canvas');
            this.canvas.addEventListener('webglcontextlost', parent._contextLost.bind(parent), false);
            this.canvas.addEventListener('webglcontextrestored', parent._contextRestored.bind(parent), false);
            this.canvas.setAttribute('tabindex', 0);
            container.appendChild(this.canvas);
        }
    }

    Canvas.prototype.resize = function(width, height) {
        var pixelRatio = window.devicePixelRatio || 1;

        // Request the required canvas size taking the pixelratio into account.
        this.canvas.width = pixelRatio * width;
        this.canvas.height = pixelRatio * height;

        // Maintain the same canvas size, potentially downscaling it for HiDPI displays
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
    };

    var requiredContextAttributes = {
        antialias: false,
        alpha: true,
        stencil: true,
        depth: false
    };

    Canvas.prototype.getWebGLContext = function(attributes) {
        attributes = util.extend({}, attributes, requiredContextAttributes);

        return this.canvas.getContext('webgl', attributes) ||
            this.canvas.getContext('experimental-webgl', attributes);
    };

    Canvas.prototype.supportsWebGLContext = function(failIfMajorPerformanceCaveat) {
        var attributes = util.extend({
            failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat
        }, requiredContextAttributes);

        if ('probablySupportsContext' in this.canvas) {
            return this.canvas.probablySupportsContext('webgl', attributes) ||
                this.canvas.probablySupportsContext('experimental-webgl', attributes);
        } else if ('supportsContext' in this.canvas) {
            return this.canvas.supportsContext('webgl', attributes) ||
                this.canvas.supportsContext('experimental-webgl', attributes);
        }

        return !!window.WebGLRenderingContext && !!this.getWebGLContext(failIfMajorPerformanceCaveat);
    };

    Canvas.prototype.getElement = function() {
        return this.canvas;
    };

},{"../util":103}],94:[function(require,module,exports){
    'use strict';

    var Actor = require('../actor');
    var WebWorkify = require('webworkify');

    module.exports = Dispatcher;

    function Dispatcher(length, parent) {
        this.actors = [];
        this.currentActor = 0;
        for (var i = 0; i < length; i++) {
            var worker = new WebWorkify(require('../../source/worker'));
            var actor = new Actor(worker, parent);
            actor.name = "Worker " + i;
            this.actors.push(actor);
        }
    }

    Dispatcher.prototype = {
        broadcast: function(type, data) {
            for (var i = 0; i < this.actors.length; i++) {
                this.actors[i].send(type, data);
            }
        },

        send: function(type, data, callback, targetID, buffers) {
            if (typeof targetID !== 'number' || isNaN(targetID)) {
                // Use round robin to send requests to web workers.
                targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
            }

            this.actors[targetID].send(type, data, callback, buffers);
            return targetID;
        },

        remove: function() {
            for (var i = 0; i < this.actors.length; i++) {
                this.actors[i].target.terminate();
            }
            this.actors = [];
        }
    };

},{"../../source/worker":45,"../actor":90,"webworkify":158}],95:[function(require,module,exports){
    'use strict';

    var Point = require('point-geometry');

    exports.create = function (tagName, className, container) {
        var el = document.createElement(tagName);
        if (className) el.className = className;
        if (container) container.appendChild(el);
        return el;
    };

    var docStyle = document.documentElement.style;

    function testProp(props) {
        for (var i = 0; i < props.length; i++) {
            if (props[i] in docStyle) {
                return props[i];
            }
        }
    }

    var selectProp = testProp(['userSelect', 'MozUserSelect', 'WebkitUserSelect', 'msUserSelect']),
        userSelect;
    exports.disableDrag = function () {
        if (selectProp) {
            userSelect = docStyle[selectProp];
            docStyle[selectProp] = 'none';
        }
    };
    exports.enableDrag = function () {
        if (selectProp) {
            docStyle[selectProp] = userSelect;
        }
    };

    var transformProp = testProp(['transform', 'WebkitTransform']);
    exports.setTransform = function(el, value) {
        el.style[transformProp] = value;
    };

// Suppress the next click, but only if it's immediate.
    function suppressClick(e) {
        e.preventDefault();
        e.stopPropagation();
        window.removeEventListener('click', suppressClick, true);
    }
    exports.suppressClick = function() {
        window.addEventListener('click', suppressClick, true);
        window.setTimeout(function() {
            window.removeEventListener('click', suppressClick, true);
        }, 0);
    };

    exports.mousePos = function (el, e) {
        var rect = el.getBoundingClientRect();
        e = e.touches ? e.touches[0] : e;
        return new Point(
                e.clientX - rect.left - el.clientLeft,
                e.clientY - rect.top - el.clientTop);
    };

},{"point-geometry":150}],96:[function(require,module,exports){
    'use strict';

    module.exports = {
        HTTP_URL: 'http://a.tiles.mapbox.com',
        HTTPS_URL: 'https://a.tiles.mapbox.com',
        FORCE_HTTPS: true,
        REQUIRE_ACCESS_TOKEN: true
    };

},{}],97:[function(require,module,exports){
    'use strict';

    var util = require('./util');

    /**
     * Methods mixed in to other classes for event capabilities.
     * @mixin Evented
     */
    var Evented = {

        /**
         * Subscribe to a specified event with a listener function the latter gets the data object that was passed to `fire` and additionally `target` and `type` properties
         *
         * @param {string} type Event type
         * @param {Function} listener Function to be called when the event is fired
         */
        on: function(type, fn) {
            this._events = this._events || {};
            this._events[type] = this._events[type] || [];
            this._events[type].push(fn);

            return this;
        },

        /**
         * Remove a event listener
         *
         * @param {string} [type] Event type. If none is specified, remove all listeners
         * @param {Function} [listener] Function to be called when the event is fired. If none is specified all listeners are removed
         */
        off: function(type, fn) {
            if (!type) {
                // clear all listeners if no arguments specified
                delete this._events;
                return this;
            }

            if (!this.listens(type)) return this;

            if (fn) {
                var idx = this._events[type].indexOf(fn);
                if (idx >= 0) {
                    this._events[type].splice(idx, 1);
                }
                if (!this._events[type].length) {
                    delete this._events[type];
                }
            } else {
                delete this._events[type];
            }

            return this;
        },

        /**
         * Call a function once when an event has fired
         *
         * @param {string} type Event type.
         * @param {Function} listener Function to be called once when the event is fired
         */
        once: function(type, fn) {
            var wrapper = function(data) {
                this.off(type, wrapper);
                fn.call(this, data);
            }.bind(this);
            this.on(type, wrapper);
            return this;
        },

        /**
         * Fire event of a given string type with the given data object
         *
         * @param {string} type Event type
         * @param {Object} [data] Optional data passed down to the event object
         * @returns {Object} `this`
         */
        fire: function(type, data) {
            if (!this.listens(type)) return this;

            data = util.extend({}, data);
            util.extend(data, {type: type, target: this});

            // make sure adding/removing listeners inside other listeners won't cause infinite loop
            var listeners = this._events[type].slice();

            for (var i = 0; i < listeners.length; i++) {
                listeners[i].call(this, data);
            }

            return this;
        },

        /**
         * Check if an event is registered to a type
         * @param {string} type Event type
         * @returns {boolean} `true` if there is at least one registered listener for events of type `type`
         */
        listens: function(type) {
            return !!(this._events && this._events[type]);
        }
    };

    module.exports = Evented;

},{"./util":103}],98:[function(require,module,exports){
    'use strict';

    module.exports = Glyphs;

    function Glyphs(pbf, end) {
        this.stacks = pbf.readFields(readFontstacks, [], end);
    }

    function readFontstacks(tag, stacks, pbf) {
        if (tag === 1) {
            var fontstack = pbf.readMessage(readFontstack, {glyphs: {}});
            stacks.push(fontstack);
        }
    }

    function readFontstack(tag, fontstack, pbf) {
        if (tag === 1) fontstack.name = pbf.readString();
        else if (tag === 2) fontstack.range = pbf.readString();
        else if (tag === 3) {
            var glyph = pbf.readMessage(readGlyph, {});
            fontstack.glyphs[glyph.id] = glyph;
        }
    }

    function readGlyph(tag, glyph, pbf) {
        if (tag === 1) glyph.id = pbf.readVarint();
        else if (tag === 2) glyph.bitmap = pbf.readBytes();
        else if (tag === 3) glyph.width = pbf.readVarint();
        else if (tag === 4) glyph.height = pbf.readVarint();
        else if (tag === 5) glyph.left = pbf.readSVarint();
        else if (tag === 6) glyph.top = pbf.readSVarint();
        else if (tag === 7) glyph.advance = pbf.readVarint();
    }

},{}],99:[function(require,module,exports){
    'use strict';

    module.exports = interpolate;

    function interpolate(a, b, t) {
        return (a * (1 - t)) + (b * t);
    }

    interpolate.number = interpolate;

    interpolate.vec2 = function(from, to, t) {
        return [
            interpolate(from[0], to[0], t),
            interpolate(from[1], to[1], t)
        ];
    };

    /*
     * Interpolate between two colors given as 4-element arrays.
     *
     * @param {Color} from
     * @param {Color} to
     * @param {number} t interpolation factor between 0 and 1
     * @returns {Color} interpolated color
     */
    interpolate.color = function(from, to, t) {
        return [
            interpolate(from[0], to[0], t),
            interpolate(from[1], to[1], t),
            interpolate(from[2], to[2], t),
            interpolate(from[3], to[3], t)
        ];
    };

    interpolate.array = function(from, to, t) {
        return from.map(function(d, i) {
            return interpolate(d, to[i], t);
        });
    };

},{}],100:[function(require,module,exports){
    'use strict';

    var config = require('./config');
    var browser = require('./browser');

    function normalizeURL(url, pathPrefix, accessToken) {
        accessToken = accessToken || config.ACCESS_TOKEN;

        if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {
            throw new Error('An API access token is required to use Mapbox GL. ' +
                'See https://www.mapbox.com/developers/api/#access-tokens');
        }

        var https = config.FORCE_HTTPS ||
            (typeof document !== 'undefined' && document.location.protocol === 'https:');

        url = url.replace(/^mapbox:\/\//, (https ? config.HTTPS_URL : config.HTTP_URL) + pathPrefix);
        url += url.indexOf('?') !== -1 ? '&access_token=' : '?access_token=';

        if (config.REQUIRE_ACCESS_TOKEN) {
            if (accessToken[0] === 's') {
                throw new Error('Use a public access token (pk.*) with Mapbox GL JS, not a secret access token (sk.*). ' +
                    'See https://www.mapbox.com/developers/api/#access-tokens');
            }

            url += accessToken;
        }

        return url;
    }

    module.exports.normalizeStyleURL = function(url, accessToken) {
        var user = url.match(/^mapbox:\/\/([^.]+)/);
        if (!user)
            return url;

        return normalizeURL(url, '/styles/v1/' + user[1] + '/', accessToken);
    };

    module.exports.normalizeSourceURL = function(url, accessToken) {
        if (!url.match(/^mapbox:\/\//))
            return url;

        url = normalizeURL(url + '.json', '/v4/', accessToken);

        // TileJSON requests need a secure flag appended to their URLs so
        // that the server knows to send SSL-ified resource references.
        if (url.indexOf('https') === 0)
            url += '&secure';

        return url;
    };

    module.exports.normalizeGlyphsURL = function(url, accessToken) {
        if (!url.match(/^mapbox:\/\//))
            return url;

        return normalizeURL(url, '/v4/', accessToken);
    };

    module.exports.normalizeTileURL = function(url, sourceUrl) {
        if (!sourceUrl || !sourceUrl.match(/^mapbox:\/\//))
            return url;
        return url.replace(/\.((?:png|jpg)\d*)(?=$|\?)/, browser.devicePixelRatio >= 2 ? '@2x.$1' : '.$1');
    };

},{"./browser":92,"./config":96}],101:[function(require,module,exports){
    'use strict';

    /**
     * A [most-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
     * with hash lookup made possible by keeping a list of keys in parallel to
     * an array of dictionary of values
     *
     * @param {number} max number of permitted values
     * @param {Function} onRemove callback called with items when they expire
     * @private
     */
    module.exports = MRUCache;
    function MRUCache(max, onRemove) {
        this.max = max;
        this.onRemove = onRemove;
        this.reset();
    }

    /**
     * Clear the cache
     *
     * @returns {MRUCache} this cache
     * @private
     */
    MRUCache.prototype.reset = function() {
        for (var key in this.list) {
            this.onRemove(this.list[key]);
        }

        this.list = {};
        this.order = [];

        return this;
    };

    /**
     * Add a key, value combination to the cache, trimming its size if this pushes
     * it over max length.
     *
     * @param {string} key lookup key for the item
     * @param {*} data any value
     *
     * @returns {MRUCache} this cache
     * @private
     */
    MRUCache.prototype.add = function(key, data) {
        this.list[key] = data;
        this.order.push(key);

        if (this.order.length > this.max) {
            var removedData = this.get(this.order[0]);
            if (removedData) this.onRemove(removedData);
        }

        return this;
    };

    /**
     * Determine whether the value attached to `key` is present
     *
     * @param {string} key the key to be looked-up
     * @returns {boolean} whether the cache has this value
     * @private
     */
    MRUCache.prototype.has = function(key) {
        return key in this.list;
    };

    /**
     * List all keys in the cache
     *
     * @returns {Array<string>} an array of keys in this cache.
     * @private
     */
    MRUCache.prototype.keys = function() {
        return this.order;
    };

    /**
     * Get the value attached to a specific key. If the key is not found,
     * returns `null`
     *
     * @param {string} key the key to look up
     * @returns {*} the data, or null if it isn't found
     * @private
     */
    MRUCache.prototype.get = function(key) {
        if (!this.has(key)) { return null; }

        var data = this.list[key];

        delete this.list[key];
        this.order.splice(this.order.indexOf(key), 1);

        return data;
    };

},{}],102:[function(require,module,exports){
    'use strict';

    module.exports = resolveTokens;

    /**
     * Replace tokens in a string template with values in an object
     *
     * @param {Object} properties a key/value relationship between tokens and replacements
     * @param {string} text the template string
     * @returns {string} the template with tokens replaced
     * @private
     */
    function resolveTokens(properties, text) {
        return text.replace(/{([^{}()\[\]<>$=:;.,^]+)}/g, function(match, key) {
            return key in properties ? properties[key] : '';
        });
    }

},{}],103:[function(require,module,exports){
    'use strict';

    var UnitBezier = require('unitbezier');

    /**
     * Given a value `t` that varies between 0 and 1, return
     * an interpolation function that eases between 0 and 1 in a pleasing
     * cubic in-out fashion.
     *
     * @param {number} t input
     * @returns {number} input
     * @private
     */
    exports.easeCubicInOut = function (t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        var t2 = t * t,
            t3 = t2 * t;
        return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
    };

    /**
     * Given given (x, y), (x1, y1) control points for a bezier curve,
     * return a function that interpolates along that curve.
     *
     * @param {number} p1x control point 1 x coordinate
     * @param {number} p1y control point 1 y coordinate
     * @param {number} p2x control point 2 x coordinate
     * @param {number} p2y control point 2 y coordinate
     * @returns {Function} interpolator: receives number value, returns
     * number value.
     * @private
     */
    exports.bezier = function(p1x, p1y, p2x, p2y) {
        var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
        return function(t) {
            return bezier.solve(t);
        };
    };

    /**
     * A default bezier-curve powered easing function with
     * control points (0.25, 0.1) and (0.25, 1)
     *
     * @param {number} t
     * @returns {number} output
     * @private
     */
    exports.ease = exports.bezier(0.25, 0.1, 0.25, 1);

    /**
     * Given a four-element array of numbers that represents a color in
     * RGBA, return a version for which the RGB components are multiplied
     * by the A (alpha) component
     *
     * @param {Array<number>} c color array
     * @returns {Array<number>} premultiplied color array
     * @private
     */
    exports.premultiply = function (c) {
        c[0] *= c[3];
        c[1] *= c[3];
        c[2] *= c[3];
        return c;
    };

    /**
     * constrain n to the given range via min + max
     *
     * @param {number} n value
     * @param {number} min the minimum value to be returned
     * @param {number} max the maximum value to be returned
     * @returns {number} the clamped value
     * @private
     */
    exports.clamp = function (n, min, max) {
        return Math.min(max, Math.max(min, n));
    };

    /*
     * constrain n to the given range via modular arithmetic
     * @param {number} n
     * @param {number} min
     * @param {number} max
     * @returns {number} constrained number
     * @private
     */
    exports.wrap = function (n, min, max) {
        var d = max - min;
        return n === max ? n : ((n - min) % d + d) % d + min;
    };

    /*
     * return the first non-null and non-undefined argument to this function.
     * @returns {*} argument
     * @private
     */
    exports.coalesce = function() {
        for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg !== null && arg !== undefined)
                return arg;
        }
    };

    /*
     * Call an asynchronous function on an array of arguments,
     * calling `callback` once all calls complete.
     *
     * @param {Array<*>} array input to each call of the async function.
     * @param {Function} fn an async function with signature (data, callback)
     * @param {Function} callback a callback run after all async work is done.
     * called with no arguments
     * @returns {undefined}
     * @private
     */
    exports.asyncEach = function (array, fn, callback) {
        var remaining = array.length;
        if (remaining === 0) return callback();
        function check() { if (--remaining === 0) callback(); }
        for (var i = 0; i < array.length; i++) fn(array[i], check);
    };

    /*
     * Compute the difference between the keys in one object and the keys
     * in another object.
     *
     * @param {Object} obj
     * @param {Object} other
     * @returns {Array<string>} keys difference
     * @private
     */
    exports.keysDifference = function (obj, other) {
        var difference = [];
        for (var i in obj) {
            if (!(i in other)) {
                difference.push(i);
            }
        }
        return difference;
    };

    /**
     * Given a destination object and optionally many source objects,
     * copy all properties from the source objects into the destination.
     * The last source object given overrides properties from previous
     * source objects.
     * @param {Object} dest destination object
     * @param {...Object} sources sources from which properties are pulled
     * @returns {Object} dest
     * @private
     */
    exports.extend = function (dest) {
        for (var i = 1; i < arguments.length; i++) {
            var src = arguments[i];
            for (var k in src) {
                dest[k] = src[k];
            }
        }
        return dest;
    };

    /**
     * Extend a destination object with all properties of the src object,
     * using defineProperty instead of simple assignment.
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     * @private
     */
    exports.extendAll = function (dest, src) {
        for (var i in src) {
            Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));
        }
        return dest;
    };

    /**
     * Extend a parent's prototype with all properties in a properties
     * object.
     *
     * @param {Object} parent
     * @param {Object} props
     * @returns {Object}
     * @private
     */
    exports.inherit = function (parent, props) {
        var parentProto = typeof parent === 'function' ? parent.prototype : parent,
            proto = Object.create(parentProto);
        exports.extendAll(proto, props);
        return proto;
    };

    /**
     * Given an object and a number of properties as strings, return version
     * of that object with only those properties.
     *
     * @param {Object} src the object
     * @param {Array<string>} properties an array of property names chosen
     * to appear on the resulting object.
     * @returns {Object} object with limited properties.
     * @example
     * var foo = { name: 'Charlie', age: 10 };
     * var justName = pick(foo, ['name']);
     * // justName = { name: 'Charlie' }
     * @private
     */
    exports.pick = function (src, properties) {
        var result = {};
        for (var i = 0; i < properties.length; i++) {
            var k = properties[i];
            if (k in src) {
                result[k] = src[k];
            }
        }
        return result;
    };

    var id = 1;

    /**
     * Return a unique numeric id, starting at 1 and incrementing with
     * each call.
     *
     * @returns {number} unique numeric id.
     * @private
     */
    exports.uniqueId = function () {
        return id++;
    };

    /**
     * Create a version of `fn` that only fires once every `time` millseconds.
     *
     * @param {Function} fn the function to be throttled
     * @param {number} time millseconds required between function calls
     * @param {*} context the value of `this` with which the function is called
     * @returns {Function} debounced function
     * @private
     */
    exports.throttle = function (fn, time, context) {
        var lock, args, wrapperFn, later;

        later = function () {
            // reset lock and call if queued
            lock = false;
            if (args) {
                wrapperFn.apply(context, args);
                args = false;
            }
        };

        wrapperFn = function () {
            if (lock) {
                // called too soon, queue to call later
                args = arguments;

            } else {
                // call and lock until later
                fn.apply(context, arguments);
                setTimeout(later, time);
                lock = true;
            }
        };

        return wrapperFn;
    };

    /**
     * Create a version of `fn` that is only called `time` milliseconds
     * after its last invocation
     *
     * @param {Function} fn the function to be debounced
     * @param {number} time millseconds after which the function will be invoked
     * @returns {Function} debounced function
     * @private
     */
    exports.debounce = function(fn, time) {
        var timer, args;

        return function() {
            args = arguments;
            clearTimeout(timer);

            timer = setTimeout(function() {
                fn.apply(null, args);
            }, time);
        };
    };

    /**
     * Given an array of member function names as strings, replace all of them
     * with bound versions that will always refer to `context` as `this`. This
     * is useful for classes where otherwise event bindings would reassign
     * `this` to the evented object or some other value: this lets you ensure
     * the `this` value always.
     *
     * @param {Array<string>} fns list of member function names
     * @param {*} context the context value
     * @returns {undefined} changes functions in-place
     * @example
     * function MyClass() {
 *   bindAll(['ontimer'], this);
 *   this.name = 'Tom';
 * }
     * MyClass.prototype.ontimer = function() {
 *   alert(this.name);
 * };
     * var myClass = new MyClass();
     * setTimeout(myClass.ontimer, 100);
     * @private
     */
    exports.bindAll = function(fns, context) {
        fns.forEach(function(fn) {
            context[fn] = context[fn].bind(context);
        });
    };

    exports.bindHandlers = function(context) {
        for (var i in context) {
            if (typeof context[i] === 'function' && i.indexOf('_on') === 0) {
                context[i] = context[i].bind(context);
            }
        }
    };

    /**
     * Set the 'options' property on `obj` with properties
     * from the `options` argument. Properties in the `options`
     * object will override existing properties.
     *
     * @param {Object} obj destination object
     * @param {Object} options object of override options
     * @returns {Object} derived options object.
     * @private
     */
    exports.setOptions = function(obj, options) {
        if (!obj.hasOwnProperty('options')) {
            obj.options = obj.options ? Object.create(obj.options) : {};
        }
        for (var i in options) {
            obj.options[i] = options[i];
        }
        return obj.options;
    };

},{"unitbezier":153}],104:[function(require,module,exports){
    if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function () {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
        }
    }

},{}],105:[function(require,module,exports){
// shim for using process in browser

    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                currentQueue[queueIndex].run();
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };

// v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

// TODO(shtylman)
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };

},{}],106:[function(require,module,exports){
    module.exports = function isBuffer(arg) {
        return arg && typeof arg === 'object'
            && typeof arg.copy === 'function'
            && typeof arg.fill === 'function'
            && typeof arg.readUInt8 === 'function';
    }
},{}],107:[function(require,module,exports){
    (function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        var formatRegExp = /%[sdj%]/g;
        exports.format = function(f) {
            if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                }
                return objects.join(' ');
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%') return '%';
                if (i >= len) return x;
                switch (x) {
                    case '%s': return String(args[i++]);
                    case '%d': return Number(args[i++]);
                    case '%j':
                        try {
                            return JSON.stringify(args[i++]);
                        } catch (_) {
                            return '[Circular]';
                        }
                    default:
                        return x;
                }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                    str += ' ' + x;
                } else {
                    str += ' ' + inspect(x);
                }
            }
            return str;
        };


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
        exports.deprecate = function(fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
                return function() {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                };
            }

            if (process.noDeprecation === true) {
                return fn;
            }

            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (process.throwDeprecation) {
                        throw new Error(msg);
                    } else if (process.traceDeprecation) {
                        console.trace(msg);
                    } else {
                        console.error(msg);
                    }
                    warned = true;
                }
                return fn.apply(this, arguments);
            }

            return deprecated;
        };


        var debugs = {};
        var debugEnviron;
        exports.debuglog = function(set) {
            if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || '';
            set = set.toUpperCase();
            if (!debugs[set]) {
                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                        var msg = exports.format.apply(exports, arguments);
                        console.error('%s %d: %s', set, pid, msg);
                    };
                } else {
                    debugs[set] = function() {};
                }
            }
            return debugs[set];
        };


        /**
         * Echos the value of a value. Trys to print the value out
         * in the best way possible given the different types.
         *
         * @param {Object} obj The object to print out.
         * @param {Object} opts Optional options object that alters the output.
         */
        /* legacy: obj, showHidden, depth, colors*/
        function inspect(obj, opts) {
            // default options
            var ctx = {
                seen: [],
                stylize: stylizeNoColor
            };
            // legacy...
            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];
            if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts;
            } else if (opts) {
                // got an "options" object
                exports._extend(ctx, opts);
            }
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
        }
        exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
        inspect.colors = {
            'bold' : [1, 22],
            'italic' : [3, 23],
            'underline' : [4, 24],
            'inverse' : [7, 27],
            'white' : [37, 39],
            'grey' : [90, 39],
            'black' : [30, 39],
            'blue' : [34, 39],
            'cyan' : [36, 39],
            'green' : [32, 39],
            'magenta' : [35, 39],
            'red' : [31, 39],
            'yellow' : [33, 39]
        };

// Don't use 'blue' not visible on cmd.exe
        inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            // "name": intentionally not styling
            'regexp': 'red'
        };


        function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
                return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                    '\u001b[' + inspect.colors[style][1] + 'm';
            } else {
                return str;
            }
        }


        function stylizeNoColor(str, styleType) {
            return str;
        }


        function arrayToHash(array) {
            var hash = {};

            array.forEach(function(val, idx) {
                hash[val] = true;
            });

            return hash;
        }


        function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                // Filter out the util module, it's inspect function is special
                value.inspect !== exports.inspect &&
                // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
                return primitive;
            }

            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
            }

            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (isError(value)
                && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                return formatError(value);
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
                if (isFunction(value)) {
                    var name = value.name ? ': ' + value.name : '';
                    return ctx.stylize('[Function' + name + ']', 'special');
                }
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                }
                if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), 'date');
                }
                if (isError(value)) {
                    return formatError(value);
                }
            }

            var base = '', array = false, braces = ['{', '}'];

            // Make Array say that they are Array
            if (isArray(value)) {
                array = true;
                braces = ['[', ']'];
            }

            // Make functions say that they are functions
            if (isFunction(value)) {
                var n = value.name ? ': ' + value.name : '';
                base = ' [Function' + n + ']';
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value);
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value);
            }

            // Make error with message first say the error
            if (isError(value)) {
                base = ' ' + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                } else {
                    return ctx.stylize('[Object]', 'special');
                }
            }

            ctx.seen.push(value);

            var output;
            if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
                output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
            }

            ctx.seen.pop();

            return reduceToSingleString(output, base, braces);
        }


        function formatPrimitive(ctx, value) {
            if (isUndefined(value))
                return ctx.stylize('undefined', 'undefined');
            if (isString(value)) {
                var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"') + '\'';
                return ctx.stylize(simple, 'string');
            }
            if (isNumber(value))
                return ctx.stylize('' + value, 'number');
            if (isBoolean(value))
                return ctx.stylize('' + value, 'boolean');
            // For some reason typeof null is "object", so special case here.
            if (isNull(value))
                return ctx.stylize('null', 'null');
        }


        function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
        }


        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        String(i), true));
                } else {
                    output.push('');
                }
            }
            keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        key, true));
                }
            });
            return output;
        }


        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
            if (desc.get) {
                if (desc.set) {
                    str = ctx.stylize('[Getter/Setter]', 'special');
                } else {
                    str = ctx.stylize('[Getter]', 'special');
                }
            } else {
                if (desc.set) {
                    str = ctx.stylize('[Setter]', 'special');
                }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
                name = '[' + key + ']';
            }
            if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                        str = formatValue(ctx, desc.value, null);
                    } else {
                        str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf('\n') > -1) {
                        if (array) {
                            str = str.split('\n').map(function(line) {
                                return '  ' + line;
                            }).join('\n').substr(2);
                        } else {
                            str = '\n' + str.split('\n').map(function(line) {
                                return '   ' + line;
                            }).join('\n');
                        }
                    }
                } else {
                    str = ctx.stylize('[Circular]', 'special');
                }
            }
            if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                    return str;
                }
                name = JSON.stringify('' + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, 'name');
                } else {
                    name = name.replace(/'/g, "\\'")
                        .replace(/\\"/g, '"')
                        .replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, 'string');
                }
            }

            return name + ': ' + str;
        }


        function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf('\n') >= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
            }, 0);

            if (length > 60) {
                return braces[0] +
                    (base === '' ? '' : base + '\n ') +
                    ' ' +
                    output.join(',\n  ') +
                    ' ' +
                    braces[1];
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
        }


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
        function isArray(ar) {
            return Array.isArray(ar);
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
            return typeof arg === 'boolean';
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
            return typeof arg === 'number';
        }
        exports.isNumber = isNumber;

        function isString(arg) {
            return typeof arg === 'string';
        }
        exports.isString = isString;

        function isSymbol(arg) {
            return typeof arg === 'symbol';
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;

        function isError(e) {
            return isObject(e) &&
                (objectToString(e) === '[object Error]' || e instanceof Error);
        }
        exports.isError = isError;

        function isFunction(arg) {
            return typeof arg === 'function';
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
            return arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' ||  // ES6 symbol
                typeof arg === 'undefined';
        }
        exports.isPrimitive = isPrimitive;

        exports.isBuffer = require('./support/isBuffer');

        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }


        function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
        }


        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
            'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
        function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
        }


// log is just a thin wrapper to console.log that prepends a timestamp
        exports.log = function() {
            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
        };


        /**
         * Inherit the prototype methods from one constructor into another.
         *
         * The Function.prototype.inherits from lang.js rewritten as a standalone
         * function (not on Function.prototype). NOTE: If this file is to be loaded
         * during bootstrapping this function needs to be rewritten using some native
         * functions as prototype setup using normal JavaScript does not work as
         * expected during bootstrapping (see mirror.js in r114903).
         *
         * @param {function} ctor Constructor function which needs to inherit the
         *     prototype.
         * @param {function} superCtor Constructor function to inherit prototype from.
         */
        exports.inherits = require('inherits');

        exports._extend = function(origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin;

            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
                origin[keys[i]] = add[keys[i]];
            }
            return origin;
        };

        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }

    }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":106,"_process":105,"inherits":104}],108:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
    var kCSSColorTable = {
        "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
        "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
        "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
        "beige": [245,245,220,1], "bisque": [255,228,196,1],
        "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
        "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
        "brown": [165,42,42,1], "burlywood": [222,184,135,1],
        "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
        "chocolate": [210,105,30,1], "coral": [255,127,80,1],
        "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
        "crimson": [220,20,60,1], "cyan": [0,255,255,1],
        "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
        "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
        "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
        "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
        "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
        "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
        "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
        "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
        "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
        "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
        "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
        "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
        "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
        "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
        "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
        "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
        "gray": [128,128,128,1], "green": [0,128,0,1],
        "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
        "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
        "indianred": [205,92,92,1], "indigo": [75,0,130,1],
        "ivory": [255,255,240,1], "khaki": [240,230,140,1],
        "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
        "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
        "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
        "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
        "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
        "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
        "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
        "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
        "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
        "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
        "limegreen": [50,205,50,1], "linen": [250,240,230,1],
        "magenta": [255,0,255,1], "maroon": [128,0,0,1],
        "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
        "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
        "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
        "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
        "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
        "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
        "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
        "navy": [0,0,128,1], "oldlace": [253,245,230,1],
        "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
        "orange": [255,165,0,1], "orangered": [255,69,0,1],
        "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
        "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
        "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
        "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
        "pink": [255,192,203,1], "plum": [221,160,221,1],
        "powderblue": [176,224,230,1], "purple": [128,0,128,1],
        "red": [255,0,0,1], "rosybrown": [188,143,143,1],
        "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
        "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
        "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
        "sienna": [160,82,45,1], "silver": [192,192,192,1],
        "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
        "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
        "snow": [255,250,250,1], "springgreen": [0,255,127,1],
        "steelblue": [70,130,180,1], "tan": [210,180,140,1],
        "teal": [0,128,128,1], "thistle": [216,191,216,1],
        "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
        "violet": [238,130,238,1], "wheat": [245,222,179,1],
        "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
        "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

    function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
        return i < 0 ? 0 : i > 255 ? 255 : i;
    }

    function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
        return f < 0 ? 0 : f > 1 ? 1 : f;
    }

    function parse_css_int(str) {  // int or percentage.
        if (str[str.length - 1] === '%')
            return clamp_css_byte(parseFloat(str) / 100 * 255);
        return clamp_css_byte(parseInt(str));
    }

    function parse_css_float(str) {  // float or percentage.
        if (str[str.length - 1] === '%')
            return clamp_css_float(parseFloat(str) / 100);
        return clamp_css_float(parseFloat(str));
    }

    function css_hue_to_rgb(m1, m2, h) {
        if (h < 0) h += 1;
        else if (h > 1) h -= 1;

        if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
        if (h * 2 < 1) return m2;
        if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
        return m1;
    }

    function parseCSSColor(css_str) {
        // Remove all whitespace, not compliant, but should just be more accepting.
        var str = css_str.replace(/ /g, '').toLowerCase();

        // Color keywords (and transparent) lookup.
        if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

        // #abc and #abc123 syntax.
        if (str[0] === '#') {
            if (str.length === 4) {
                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
                return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
                        (iv & 0xf0) | ((iv & 0xf0) >> 4),
                        (iv & 0xf) | ((iv & 0xf) << 4),
                    1];
            } else if (str.length === 7) {
                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
                if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
                return [(iv & 0xff0000) >> 16,
                        (iv & 0xff00) >> 8,
                        iv & 0xff,
                    1];
            }

            return null;
        }

        var op = str.indexOf('('), ep = str.indexOf(')');
        if (op !== -1 && ep + 1 === str.length) {
            var fname = str.substr(0, op);
            var params = str.substr(op+1, ep-(op+1)).split(',');
            var alpha = 1;  // To allow case fallthrough.
            switch (fname) {
                case 'rgba':
                    if (params.length !== 4) return null;
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'rgb':
                    if (params.length !== 3) return null;
                    return [parse_css_int(params[0]),
                        parse_css_int(params[1]),
                        parse_css_int(params[2]),
                        alpha];
                case 'hsla':
                    if (params.length !== 4) return null;
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'hsl':
                    if (params.length !== 3) return null;
                    var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
                    // NOTE(deanm): According to the CSS spec s/l should only be
                    // percentages, but we don't bother and let float or percentage.
                    var s = parse_css_float(params[1]);
                    var l = parse_css_float(params[2]);
                    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                    var m1 = l * 2 - m2;
                    return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                        clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                        clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                        alpha];
                default:
                    return null;
            }
        }

        return null;
    }

    try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],109:[function(require,module,exports){
    'use strict';

    var VectorTileFeatureTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];

    function infix(operator) {
        return function(_, key, value) {
            if (key === '$type') {
                return 't' + operator + VectorTileFeatureTypes.indexOf(value);
            } else {
                return 'p[' + JSON.stringify(key) + ']' + operator + JSON.stringify(value);
            }
        };
    }

    function strictInfix(operator) {
        var nonstrictInfix = infix(operator);
        return function(_, key, value) {
            if (key === '$type') {
                return nonstrictInfix(_, key, value);
            } else {
                return 'typeof(p[' + JSON.stringify(key) + ']) === typeof(' + JSON.stringify(value) + ') && ' +
                    nonstrictInfix(_, key, value);
            }
        };
    }

    var operators = {
        '==': infix('==='),
        '!=': infix('!=='),
        '>': strictInfix('>'),
        '<': strictInfix('<'),
        '<=': strictInfix('<='),
        '>=': strictInfix('>='),
        'in': function(_, key) {
            return Array.prototype.slice.call(arguments, 2).map(function(value) {
                return '(' + operators['=='](_, key, value) + ')';
            }).join('||') || 'false';
        },
        '!in': function() {
            return '!(' + operators.in.apply(this, arguments) + ')';
        },
        'any': function() {
            return Array.prototype.slice.call(arguments, 1).map(function(filter) {
                return '(' + compile(filter) + ')';
            }).join('||') || 'false';
        },
        'all': function() {
            return Array.prototype.slice.call(arguments, 1).map(function(filter) {
                return '(' + compile(filter) + ')';
            }).join('&&') || 'true';
        },
        'none': function() {
            return '!(' + operators.any.apply(this, arguments) + ')';
        }
    };

    function compile(filter) {
        return operators[filter[0]].apply(filter, filter);
    }

    function truth() {
        return true;
    }

    /**
     * Given a filter expressed as nested arrays, return a new function
     * that evaluates whether a given feature (with a .properties or .tags property)
     * passes its test.
     *
     * @param {Array} filter mapbox gl filter
     * @returns {Function} filter-evaluating function
     */
    module.exports = function (filter) {
        if (!filter) return truth;
        var filterStr = 'var p = f.properties || f.tags || {}, t = f.type; return ' + compile(filter) + ';';
        // jshint evil: true
        return new Function('f', filterStr);
    };

},{}],110:[function(require,module,exports){
    'use strict';

    module.exports = clip;

    /* clip features between two axis-parallel lines:
     *     |        |
     *  ___|___     |     /
     * /   |   \____|____/
     *     |        |
     */

    function clip(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

        k1 /= scale;
        k2 /= scale;

        if (minAll >= k1 && maxAll <= k2) return features; // trivial accept
        else if (minAll > k2 || maxAll < k1) return null; // trivial reject

        var clipped = [];

        for (var i = 0; i < features.length; i++) {

            var feature = features[i],
                geometry = feature.geometry,
                type = feature.type,
                min, max;

            min = feature.min[axis];
            max = feature.max[axis];

            if (min >= k1 && max <= k2) { // trivial accept
                clipped.push(feature);
                continue;
            } else if (min > k2 || max < k1) continue; // trivial reject

            var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

            if (slices.length) {
                // if a feature got clipped, it will likely get clipped on the next zoom level as well,
                // so there's no need to recalculate bboxes
                clipped.push({
                    geometry: slices,
                    type: type,
                    tags: features[i].tags || null,
                    min: feature.min,
                    max: feature.max
                });
            }
        }

        return clipped.length ? clipped : null;
    }

    function clipPoints(geometry, k1, k2, axis) {
        var slice = [];

        for (var i = 0; i < geometry.length; i++) {
            var a = geometry[i],
                ak = a[axis];

            if (ak >= k1 && ak <= k2) slice.push(a);
        }
        return slice;
    }

    function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

        var slices = [];

        for (var i = 0; i < geometry.length; i++) {

            var ak = 0,
                bk = 0,
                b = null,
                points = geometry[i],
                area = points.area,
                dist = points.dist,
                len = points.length,
                a, j, last;

            var slice = [];

            for (j = 0; j < len - 1; j++) {
                a = b || points[j];
                b = points[j + 1];
                ak = bk || a[axis];
                bk = b[axis];

                if (ak < k1) {

                    if ((bk > k2)) { // ---|-----|-->
                        slice.push(intersect(a, b, k1), intersect(a, b, k2));
                        if (!closed) slice = newSlice(slices, slice, area, dist);

                    } else if (bk >= k1) slice.push(intersect(a, b, k1)); // ---|-->  |

                } else if (ak > k2) {

                    if ((bk < k1)) { // <--|-----|---
                        slice.push(intersect(a, b, k2), intersect(a, b, k1));
                        if (!closed) slice = newSlice(slices, slice, area, dist);

                    } else if (bk <= k2) slice.push(intersect(a, b, k2)); // |  <--|---

                } else {

                    slice.push(a);

                    if (bk < k1) { // <--|---  |
                        slice.push(intersect(a, b, k1));
                        if (!closed) slice = newSlice(slices, slice, area, dist);

                    } else if (bk > k2) { // |  ---|-->
                        slice.push(intersect(a, b, k2));
                        if (!closed) slice = newSlice(slices, slice, area, dist);
                    }
                    // | --> |
                }
            }

            // add the last point
            a = points[len - 1];
            ak = a[axis];
            if (ak >= k1 && ak <= k2) slice.push(a);

            // close the polygon if its endpoints are not the same after clipping

            last = slice[slice.length - 1];
            if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) slice.push(slice[0]);

            // add the final slice
            newSlice(slices, slice, area, dist);
        }

        return slices;
    }

    function newSlice(slices, slice, area, dist) {
        if (slice.length) {
            // we don't recalculate the area/length of the unclipped geometry because the case where it goes
            // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
            slice.area = area;
            slice.dist = dist;

            slices.push(slice);
        }
        return [];
    }

},{}],111:[function(require,module,exports){
    'use strict';

    module.exports = convert;

    var simplify = require('./simplify');

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

    function convert(data, tolerance) {
        var features = [];

        if (data.type === 'FeatureCollection') {
            for (var i = 0; i < data.features.length; i++) {
                convertFeature(features, data.features[i], tolerance);
            }
        } else if (data.type === 'Feature') {
            convertFeature(features, data, tolerance);

        } else {
            // single geometry or a geometry collection
            convertFeature(features, {geometry: data}, tolerance);
        }
        return features;
    }

    function convertFeature(features, feature, tolerance) {
        var geom = feature.geometry,
            type = geom.type,
            coords = geom.coordinates,
            tags = feature.properties,
            i, j, rings;

        if (type === 'Point') {
            features.push(create(tags, 1, [projectPoint(coords)]));

        } else if (type === 'MultiPoint') {
            features.push(create(tags, 1, project(coords)));

        } else if (type === 'LineString') {
            features.push(create(tags, 2, [project(coords, tolerance)]));

        } else if (type === 'MultiLineString' || type === 'Polygon') {
            rings = [];
            for (i = 0; i < coords.length; i++) {
                rings.push(project(coords[i], tolerance));
            }
            features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

        } else if (type === 'MultiPolygon') {
            rings = [];
            for (i = 0; i < coords.length; i++) {
                for (j = 0; j < coords[i].length; j++) {
                    rings.push(project(coords[i][j], tolerance));
                }
            }
            features.push(create(tags, 3, rings));

        } else if (type === 'GeometryCollection') {
            for (i = 0; i < geom.geometries.length; i++) {
                convertFeature(features, {
                    geometry: geom.geometries[i],
                    properties: tags
                }, tolerance);
            }

        } else {
            throw new Error('Input data is not a valid GeoJSON object.');
        }
    }

    function create(tags, type, geometry) {
        var feature = {
            geometry: geometry,
            type: type,
            tags: tags || null,
            min: [2, 1], // initial bbox values;
            max: [-1, 0]  // note that coords are usually in [0..1] range
        };
        calcBBox(feature);
        return feature;
    }

    function project(lonlats, tolerance) {
        var projected = [];
        for (var i = 0; i < lonlats.length; i++) {
            projected.push(projectPoint(lonlats[i]));
        }
        if (tolerance) {
            simplify(projected, tolerance);
            calcSize(projected);
        }
        return projected;
    }

    function projectPoint(p) {
        var sin = Math.sin(p[1] * Math.PI / 180),
            x = (p[0] / 360 + 0.5),
            y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

        y = y < -1 ? -1 :
                y > 1 ? 1 : y;

        return [x, y, 0];
    }

// calculate area and length of the poly
    function calcSize(points) {
        var area = 0,
            dist = 0;

        for (var i = 0, a, b; i < points.length - 1; i++) {
            a = b || points[i];
            b = points[i + 1];

            area += a[0] * b[1] - b[0] * a[1];

            // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
            dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
        }
        points.area = Math.abs(area / 2);
        points.dist = dist;
    }

// calculate the feature bounding box for faster clipping later
    function calcBBox(feature) {
        var geometry = feature.geometry,
            min = feature.min,
            max = feature.max;

        if (feature.type === 1) calcRingBBox(min, max, geometry);
        else for (var i = 0; i < geometry.length; i++) calcRingBBox(min, max, geometry[i]);

        return feature;
    }

    function calcRingBBox(min, max, points) {
        for (var i = 0, p; i < points.length; i++) {
            p = points[i];
            min[0] = Math.min(p[0], min[0]);
            max[0] = Math.max(p[0], max[0]);
            min[1] = Math.min(p[1], min[1]);
            max[1] = Math.max(p[1], max[1]);
        }
    }

},{"./simplify":113}],112:[function(require,module,exports){
    'use strict';

    module.exports = geojsonvt;

    var convert = require('./convert'), // GeoJSON conversion and preprocessing
        clip = require('./clip'),       // stripe clipping algorithm
        wrap = require('./wrap'),       // date line processing
        createTile = require('./tile'); // final simplified tile generation


    function geojsonvt(data, options) {
        return new GeoJSONVT(data, options);
    }

    function GeoJSONVT(data, options) {
        options = this.options = extend(Object.create(this.options), options);

        var debug = options.debug;

        if (debug) console.time('preprocess data');

        var z2 = 1 << options.maxZoom, // 2^z
            features = convert(data, options.tolerance / (z2 * options.extent));

        this.tiles = {};

        if (debug) {
            console.timeEnd('preprocess data');
            console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
            console.time('generate tiles');
            this.stats = {};
            this.total = 0;
        }

        features = wrap(features, options.buffer / options.extent, intersectX);

        // start slicing from the top tile down
        this.splitTile(features, 0, 0, 0);

        if (debug) {
            console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);
            console.timeEnd('generate tiles');
            console.log('tiles generated:', this.total, JSON.stringify(this.stats));
        }
    }

    GeoJSONVT.prototype.options = {
        maxZoom: 14,            // max zoom to preserve detail on
        indexMaxZoom: 5,        // max zoom in the tile index
        indexMaxPoints: 100000, // max number of points per tile in the tile index
        tolerance: 3,           // simplification tolerance (higher means simpler)
        extent: 4096,           // tile extent
        buffer: 64,             // tile buffer on each side
        debug: 0                // logging level (0, 1 or 2)
    };

    GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {

        var stack = [features, z, x, y],
            options = this.options,
            debug = options.debug,
            extent = options.extent,
            buffer = options.buffer;

        // avoid recursion by using a processing queue
        while (stack.length) {
            features = stack.shift();
            z = stack.shift();
            x = stack.shift();
            y = stack.shift();

            var z2 = 1 << z,
                id = toID(z, x, y),
                tile = this.tiles[id],
                tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * extent);

            if (!tile) {
                if (debug > 1) console.time('creation');

                tile = this.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);

                if (debug) {
                    if (debug > 1) {
                        console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                            z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                        console.timeEnd('creation');
                    }
                    var key = 'z' + z;
                    this.stats[key] = (this.stats[key] || 0) + 1;
                    this.total++;
                }
            }

            // save reference to original geometry in tile so that we can drill down later if we stop now
            tile.source = features;

            // stop tiling if the tile is degenerate
            if (isClippedSquare(tile.features, extent, buffer)) continue;

            // if it's the first-pass tiling
            if (!cz) {
                // stop tiling if we reached max zoom, or if the tile is too simple
                if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;

                // if a drilldown to a specific tile
            } else {
                // stop tiling if we reached base zoom or our target tile zoom
                if (z === options.maxZoom || z === cz) continue;

                // stop tiling if it's not an ancestor of the target tile
                var m = 1 << (cz - z);
                if (x !== Math.floor(cx / m) && y !== Math.floor(cy / m)) continue;
            }

            // if we slice further down, no need to keep source geometry
            tile.source = null;

            if (debug > 1) console.time('clipping');

            // values we'll use for clipping
            var k1 = 0.5 * buffer / extent,
                k2 = 0.5 - k1,
                k3 = 0.5 + k1,
                k4 = 1 + k1,
                tl, bl, tr, br, left, right;

            tl = bl = tr = br = null;

            left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
            right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

            if (left) {
                tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
                bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
            }

            if (right) {
                tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
                br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
            }

            if (debug > 1) console.timeEnd('clipping');

            if (tl) stack.push(tl, z + 1, x * 2,     y * 2);
            if (bl) stack.push(bl, z + 1, x * 2,     y * 2 + 1);
            if (tr) stack.push(tr, z + 1, x * 2 + 1, y * 2);
            if (br) stack.push(br, z + 1, x * 2 + 1, y * 2 + 1);
        }
    };

    GeoJSONVT.prototype.getTile = function (z, x, y) {
        var options = this.options,
            extent = options.extent,
            debug = options.debug;

        var z2 = 1 << z;
        x = ((x % z2) + z2) % z2; // wrap tile x coordinate

        var id = toID(z, x, y);
        if (this.tiles[id]) return transformTile(this.tiles[id], extent);

        if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);

        var z0 = z,
            x0 = x,
            y0 = y,
            parent;

        while (!parent && z0 > 0) {
            z0--;
            x0 = Math.floor(x0 / 2);
            y0 = Math.floor(y0 / 2);
            parent = this.tiles[toID(z0, x0, y0)];
        }

        if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);

        // if we found a parent tile containing the original geometry, we can drill down from it
        if (parent.source) {
            if (isClippedSquare(parent.features, options.extent, options.buffer)) return transformTile(parent, extent);

            if (debug > 1) console.time('drilling down');
            this.splitTile(parent.source, z0, x0, y0, z, x, y);
            if (debug > 1) console.timeEnd('drilling down');
        }

        return transformTile(this.tiles[id], extent);
    };

    function transformTile(tile, extent) {
        if (!tile || tile.transformed) return tile;

        var z2 = tile.z2,
            tx = tile.x,
            ty = tile.y,
            i, j, k;

        for (i = 0; i < tile.features.length; i++) {
            var feature = tile.features[i],
                geom = feature.geometry,
                type = feature.type;

            if (type === 1) {
                for (j = 0; j < geom.length; j++) geom[j] = transformPoint(geom[j], extent, z2, tx, ty);

            } else {
                for (j = 0; j < geom.length; j++) {
                    var ring = geom[j];
                    for (k = 0; k < ring.length; k++) ring[k] = transformPoint(ring[k], extent, z2, tx, ty);
                }
            }
        }

        tile.transformed = true;

        return tile;
    }

    function transformPoint(p, extent, z2, tx, ty) {
        var x = Math.round(extent * (p[0] * z2 - tx)),
            y = Math.round(extent * (p[1] * z2 - ty));
        return [x, y];
    }

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
    function isClippedSquare(features, extent, buffer) {
        if (features.length !== 1) return false;

        var feature = features[0];
        if (feature.type !== 3 || feature.geometry.length > 1) return false;

        for (var i = 0; i < feature.geometry[0].length; i++) {
            var p = feature.geometry[0][i];
            if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
                (p[1] !== -buffer && p[1] !== extent + buffer)) return false;
        }
        return true;
    }

    function toID(z, x, y) {
        return (((1 << z) * y + x) * 32) + z;
    }

    function intersectX(a, b, x) {
        return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
    }
    function intersectY(a, b, y) {
        return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
    }

    function extend(dest, src) {
        for (var i in src) dest[i] = src[i];
        return dest;
    }

},{"./clip":110,"./convert":111,"./tile":114,"./wrap":115}],113:[function(require,module,exports){
    'use strict';

    module.exports = simplify;

// calculate simplification data using optimized Douglas-Peucker algorithm

    function simplify(points, tolerance) {

        var sqTolerance = tolerance * tolerance,
            len = points.length,
            first = 0,
            last = len - 1,
            stack = [],
            i, maxSqDist, sqDist, index;

        // always retain the endpoints (1 is the max value)
        points[first][2] = 1;
        points[last][2] = 1;

        // avoid recursion by using a stack
        while (last) {

            maxSqDist = 0;

            for (i = first + 1; i < last; i++) {
                sqDist = getSqSegDist(points[i], points[first], points[last]);

                if (sqDist > maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }

            if (maxSqDist > sqTolerance) {
                points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
                stack.push(first);
                stack.push(index);
                first = index;

            } else {
                last = stack.pop();
                first = stack.pop();
            }
        }
    }

// square distance from a point to a segment
    function getSqSegDist(p, a, b) {

        var x = a[0], y = a[1],
            bx = b[0], by = b[1],
            px = p[0], py = p[1],
            dx = bx - x,
            dy = by - y;

        if (dx !== 0 || dy !== 0) {

            var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

            if (t > 1) {
                x = bx;
                y = by;

            } else if (t > 0) {
                x += dx * t;
                y += dy * t;
            }
        }

        dx = px - x;
        dy = py - y;

        return dx * dx + dy * dy;
    }

},{}],114:[function(require,module,exports){
    'use strict';

    module.exports = createTile;

    function createTile(features, z2, tx, ty, tolerance, noSimplify) {
        var tile = {
            features: [],
            numPoints: 0,
            numSimplified: 0,
            numFeatures: 0,
            source: null,
            x: tx,
            y: ty,
            z2: z2,
            transformed: false,
            min: [2, 1],
            max: [-1, 0]
        };
        for (var i = 0; i < features.length; i++) {
            tile.numFeatures++;
            addFeature(tile, features[i], tolerance, noSimplify);

            var min = features[i].min,
                max = features[i].max;

            if (min[0] < tile.min[0]) tile.min[0] = min[0];
            if (min[1] < tile.min[1]) tile.min[1] = min[1];
            if (max[0] > tile.max[0]) tile.max[0] = max[0];
            if (max[1] > tile.max[1]) tile.max[1] = max[1];
        }
        return tile;
    }

    function addFeature(tile, feature, tolerance, noSimplify) {

        var geom = feature.geometry,
            type = feature.type,
            simplified = [],
            sqTolerance = tolerance * tolerance,
            i, j, ring, p;

        if (type === 1) {
            for (i = 0; i < geom.length; i++) {
                simplified.push(geom[i]);
                tile.numPoints++;
                tile.numSimplified++;
            }

        } else {

            // simplify and transform projected coordinates for tile geometry
            for (i = 0; i < geom.length; i++) {
                ring = geom[i];

                // filter out tiny polylines & polygons
                if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                    (type === 3 && ring.area < sqTolerance))) {
                    tile.numPoints += ring.length;
                    continue;
                }

                var simplifiedRing = [];

                for (j = 0; j < ring.length; j++) {
                    p = ring[j];
                    // keep points with importance > tolerance
                    if (noSimplify || p[2] > sqTolerance) {
                        simplifiedRing.push(p);
                        tile.numSimplified++;
                    }
                    tile.numPoints++;
                }

                simplified.push(simplifiedRing);
            }
        }

        if (simplified.length) {
            tile.features.push({
                geometry: simplified,
                type: type,
                tags: feature.tags || null
            });
        }
    }

},{}],115:[function(require,module,exports){
    'use strict';

    var clip = require('./clip');

    module.exports = wrap;

    function wrap(features, buffer, intersectX) {
        var merged = features,
            left  = clip(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
            right = clip(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

        if (left || right) {
            merged = clip(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

            if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center
            if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center
        }

        return merged;
    }

    function shiftFeatureCoords(features, offset) {
        var newFeatures = [];

        for (var i = 0; i < features.length; i++) {
            var feature = features[i],
                type = feature.type;

            var newGeometry;

            if (type === 1) {
                newGeometry = shiftCoords(feature.geometry, offset);
            } else {
                newGeometry = [];
                for (var j = 0; j < feature.geometry.length; j++) {
                    newGeometry.push(shiftCoords(feature.geometry[j], offset));
                }
            }

            newFeatures.push({
                geometry: newGeometry,
                type: type,
                tags: feature.tags,
                min: [feature.min[0] + offset, feature.min[1]],
                max: [feature.max[0] + offset, feature.max[1]]
            });
        }

        return newFeatures;
    }

    function shiftCoords(points, offset) {
        var newPoints = [];
        newPoints.area = points.area;
        newPoints.dist = points.dist;

        for (var i = 0; i < points.length; i++) {
            newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
        }
        return newPoints;
    }

},{"./clip":110}],116:[function(require,module,exports){
    /**
     * @fileoverview gl-matrix - High performance matrix and vector operations
     * @author Brandon Jones
     * @author Colin MacKenzie IV
     * @version 2.3.0
     */

    /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE. */
// END HEADER

    exports.glMatrix = require("./gl-matrix/common.js");
    exports.mat2 = require("./gl-matrix/mat2.js");
    exports.mat2d = require("./gl-matrix/mat2d.js");
    exports.mat3 = require("./gl-matrix/mat3.js");
    exports.mat4 = require("./gl-matrix/mat4.js");
    exports.quat = require("./gl-matrix/quat.js");
    exports.vec2 = require("./gl-matrix/vec2.js");
    exports.vec3 = require("./gl-matrix/vec3.js");
    exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":117,"./gl-matrix/mat2.js":118,"./gl-matrix/mat2d.js":119,"./gl-matrix/mat3.js":120,"./gl-matrix/mat4.js":121,"./gl-matrix/quat.js":122,"./gl-matrix/vec2.js":123,"./gl-matrix/vec3.js":124,"./gl-matrix/vec4.js":125}],117:[function(require,module,exports){
    /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE. */

    /**
     * @class Common utilities
     * @name glMatrix
     */
    var glMatrix = {};

// Constants
    glMatrix.EPSILON = 0.000001;
    glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
    glMatrix.RANDOM = Math.random;

    /**
     * Sets the type of array used when creating new vectors and matrices
     *
     * @param {Type} type Array type, such as Float32Array or Array
     */
    glMatrix.setMatrixArrayType = function(type) {
        GLMAT_ARRAY_TYPE = type;
    }

    var degree = Math.PI / 180;

    /**
     * Convert Degree To Radian
     *
     * @param {Number} Angle in Degrees
     */
    glMatrix.toRadian = function(a){
        return a * degree;
    }

    module.exports = glMatrix;

},{}],118:[function(require,module,exports){
    /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE. */

    var glMatrix = require("./common.js");

    /**
     * @class 2x2 Matrix
     * @name mat2
     */
    var mat2 = {};

    /**
     * Creates a new identity mat2
     *
     * @returns {mat2} a new 2x2 matrix
     */
    mat2.create = function() {
        var out = new glMatrix.ARRAY_TYPE(4);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
    };

    /**
     * Creates a new mat2 initialized with values from an existing matrix
     *
     * @param {mat2} a matrix to clone
     * @returns {mat2} a new 2x2 matrix
     */
    mat2.clone = function(a) {
        var out = new glMatrix.ARRAY_TYPE(4);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        return out;
    };

    /**
     * Copy the values from one mat2 to another
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the source matrix
     * @returns {mat2} out
     */
    mat2.copy = function(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        return out;
    };

    /**
     * Set a mat2 to the identity matrix
     *
     * @param {mat2} out the receiving matrix
     * @returns {mat2} out
     */
    mat2.identity = function(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
    };

    /**
     * Transpose the values of a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the source matrix
     * @returns {mat2} out
     */
    mat2.transpose = function(out, a) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (out === a) {
            var a1 = a[1];
            out[1] = a[2];
            out[2] = a1;
        } else {
            out[0] = a[0];
            out[1] = a[2];
            out[2] = a[1];
            out[3] = a[3];
        }

        return out;
    };

    /**
     * Inverts a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the source matrix
     * @returns {mat2} out
     */
    mat2.invert = function(out, a) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
            det = a0 * a3 - a2 * a1;

        if (!det) {
            return null;
        }
        det = 1.0 / det;

        out[0] =  a3 * det;
        out[1] = -a1 * det;
        out[2] = -a2 * det;
        out[3] =  a0 * det;

        return out;
    };

    /**
     * Calculates the adjugate of a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the source matrix
     * @returns {mat2} out
     */
    mat2.adjoint = function(out, a) {
        // Caching this value is nessecary if out == a
        var a0 = a[0];
        out[0] =  a[3];
        out[1] = -a[1];
        out[2] = -a[2];
        out[3] =  a0;

        return out;
    };

    /**
     * Calculates the determinant of a mat2
     *
     * @param {mat2} a the source matrix
     * @returns {Number} determinant of a
     */
    mat2.determinant = function (a) {
        return a[0] * a[3] - a[2] * a[1];
    };

    /**
     * Multiplies two mat2's
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the first operand
     * @param {mat2} b the second operand
     * @returns {mat2} out
     */
    mat2.multiply = function (out, a, b) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = a0 * b0 + a2 * b1;
        out[1] = a1 * b0 + a3 * b1;
        out[2] = a0 * b2 + a2 * b3;
        out[3] = a1 * b2 + a3 * b3;
        return out;
    };

    /**
     * Alias for {@link mat2.multiply}
     * @function
     */
    mat2.mul = mat2.multiply;

    /**
     * Rotates a mat2 by the given angle
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2} out
     */
    mat2.rotate = function (out, a, rad) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
            s = Math.sin(rad),
            c = Math.cos(rad);
        out[0] = a0 *  c + a2 * s;
        out[1] = a1 *  c + a3 * s;
        out[2] = a0 * -s + a2 * c;
        out[3] = a1 * -s + a3 * c;
        return out;
    };

    /**
     * Scales the mat2 by the dimensions in the given vec2
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the matrix to rotate
     * @param {vec2} v the vec2 to scale the matrix by
     * @returns {mat2} out
     **/
    mat2.scale = function(out, a, v) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
            v0 = v[0], v1 = v[1];
        out[0] = a0 * v0;
        out[1] = a1 * v0;
        out[2] = a2 * v1;
        out[3] = a3 * v1;
        return out;
    };

    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):
     *
     *     mat2.identity(dest);
     *     mat2.rotate(dest, dest, rad);
     *
     * @param {mat2} out mat2 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2} out
     */
    mat2.fromRotation = function(out, rad) {
        var s = Math.sin(rad),
            c = Math.cos(rad);
        out[0] = c;
        out[1] = s;
        out[2] = -s;
        out[3] = c;
        return out;
    }

    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat2.identity(dest);
     *     mat2.scale(dest, dest, vec);
     *
     * @param {mat2} out mat2 receiving operation result
     * @param {vec2} v Scaling vector
     * @returns {mat2} out
     */
    mat2.fromScaling = function(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = v[1];
        return out;
    }

    /**
     * Returns a string representation of a mat2
     *
     * @param {mat2} mat matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    mat2.str = function (a) {
        return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
    };

    /**
     * Returns Frobenius norm of a mat2
     *
     * @param {mat2} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    mat2.frob = function (a) {
        return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
    };

    /**
     * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
     * @param {mat2} L the lower triangular matrix
     * @param {mat2} D the diagonal matrix
     * @param {mat2} U the upper triangular matrix
     * @param {mat2} a the input matrix to factorize
     */

    mat2.LDU = function (L, D, U, a) {
        L[2] = a[2]/a[0];
        U[0] = a[0];
        U[1] = a[1];
        U[3] = a[3] - L[2] * U[1];
        return [L, D, U];
    };


    module.exports = mat2;

},{"./common.js":117}],119:[function(require,module,exports){
    /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE. */

    var glMatrix = require("./common.js");

    /**
     * @class 2x3 Matrix
     * @name mat2d
     *
     * @description
     * A mat2d contains six elements defined as:
     * <pre>
     * [a, c, tx,
     *  b, d, ty]
     * </pre>
     * This is a short form for the 3x3 matrix:
     * <pre>
     * [a, c, tx,
     *  b, d, ty,
     *  0, 0, 1]
     * </pre>
     * The last row is ignored so the array is shorter and operations are faster.
     */
    var mat2d = {};

    /**
     * Creates a new identity mat2d
     *
     * @returns {mat2d} a new 2x3 matrix
     */
    mat2d.create = function() {
        var out = new glMatrix.ARRAY_TYPE(6);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        out[4] = 0;
        out[5] = 0;
        return out;
    };

    /**
     * Creates a new mat2d initialized with values from an existing matrix
     *
     * @param {mat2d} a matrix to clone
     * @returns {mat2d} a new 2x3 matrix
     */
    mat2d.clone = function(a) {
        var out = new glMatrix.ARRAY_TYPE(6);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        return out;
    };

    /**
     * Copy the values from one mat2d to another
     *
     * @param {mat2d} out the receiving matrix
     * @param {mat2d} a the source matrix
     * @returns {mat2d} out
     */
    mat2d.copy = function(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        return out;
    };

    /**
     * Set a mat2d to the identity matrix
     *
     * @param {mat2d} out the receiving matrix
     * @returns {mat2d} out
     */
    mat2d.identity = function(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        out[4] = 0;
        out[5] = 0;
        return out;
    };

    /**
     * Inverts a mat2d
     *
     * @param {mat2d} out the receiving matrix
     * @param {mat2d} a the source matrix
     * @returns {mat2d} out
     */
    mat2d.invert = function(out, a) {
        var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
            atx = a[4], aty = a[5];

        var det = aa * ad - ab * ac;
        if(!det){
            return null;
        }
        det = 1.0 / det;

        out[0] = ad * det;
        out[1] = -ab * det;
        out[2] = -ac * det;
        out[3] = aa * det;
        out[4] = (ac * aty - ad * atx) * det;
        out[5] = (ab * atx - aa * aty) * det;
        return out;
    };

    /**
     * Calculates the determinant of a mat2d
     *
     * @param {mat2d} a the source matrix
     * @returns {Number} determinant of a
     */
    mat2d.determinant = function (a) {
        return a[0] * a[3] - a[1] * a[2];
    };

    /**
     * Multiplies two mat2d's
     *
     * @param {mat2d} out the receiving matrix
     * @param {mat2d} a the first operand
     * @param {mat2d} b the second operand
     * @returns {mat2d} out
     */
    mat2d.multiply = function (out, a, b) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
            b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
        out[0] = a0 * b0 + a2 * b1;
        out[1] = a1 * b0 + a3 * b1;
        out[2] = a0 * b2 + a2 * b3;
        out[3] = a1 * b2 + a3 * b3;
        out[4] = a0 * b4 + a2 * b5 + a4;
        out[5] = a1 * b4 + a3 * b5 + a5;
        return out;
    };

    /**
     * Alias for {@link mat2d.multiply}
     * @function
     */
    mat2d.mul = mat2d.multiply;

    /**
     * Rotates a mat2d by the given angle
     *
     * @param {mat2d} out the receiving matrix
     * @param {mat2d} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2d} out
     */
    mat2d.rotate = function (out, a, rad) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
            s = Math.sin(rad),
            c = Math.cos(rad);
        out[0] = a0 *  c + a2 * s;
        out[1] = a1 *  c + a3 * s;
        out[2] = a0 * -s + a2 * c;
        out[3] = a1 * -s + a3 * c;
        out[4] = a4;
        out[5] = a5;
        return out;
    };

    /**
     * Scales the mat2d by the dimensions in the given vec2
     *
     * @param {mat2d} out the receiving matrix
     * @param {mat2d} a the matrix to translate
     * @param {vec2} v the vec2 to scale the matrix by
     * @returns {mat2d} out
     **/
    mat2d.scale = function(out, a, v) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
            v0 = v[0], v1 = v[1];
        out[0] = a0 * v0;
        out[1] = a1 * v0;
        out[2] = a2 * v1;
        out[3] = a3 * v1;
        out[4] = a4;
        out[5] = a5;
        return out;
    };

    /**
     * Translates the mat2d by the dimensions in the given vec2
     *
     * @param {mat2d} out the receiving matrix
     * @param {mat2d} a the matrix to translate
     * @param {vec2} v the vec2 to translate the matrix by
     * @returns {mat2d} out
     **/
    mat2d.translate = function(out, a, v) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
            v0 = v[0], v1 = v[1];
        out[0] = a0;
        out[1] = a1;
        out[2] = a2;
        out[3] = a3;
        out[4] = a0 * v0 + a2 * v1 + a4;
        out[5] = a1 * v0 + a3 * v1 + a5;
        return out;
    };

    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):
     *
     *     mat2d.identity(dest);
     *     mat2d.rotate(dest, dest, rad);
     *
     * @param {mat2d} out mat2d receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat2d} out
     */
    mat2d.fromRotation = function(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out[0] = c;
        out[1] = s;
        out[2] = -s;
        out[3] = c;
        out[4] = 0;
        out[5] = 0;
        return out;
    }

    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat2d.identity(dest);
     *     mat2d.scale(dest, dest, vec);
     *
     * @param {mat2d} out mat2d receiving operation result
     * @param {vec2} v Scaling vector
     * @returns {mat2d} out
     */
    mat2d.fromScaling = function(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = v[1];
        out[4] = 0;
        out[5] = 0;
        return out;
    }

    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat2d.identity(dest);
     *     mat2d.translate(dest, dest, vec);
     *
     * @param {mat2d} out mat2d receiving operation result
     * @param {vec2} v Translation vector
     * @returns {mat2d} out
     */
    mat2d.fromTranslation = function(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        out[4] = v[0];
        out[5] = v[1];
        return out;
    }

    /**
     * Returns a string representation of a mat2d
     *
     * @param {mat2d} a matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    mat2d.str = function (a) {
        return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
            a[3] + ', ' + a[4] + ', ' + a[5] + ')';
    };

    /**
     * Returns Frobenius norm of a mat2d
     *
     * @param {mat2d} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    mat2d.frob = function (a) {
        return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
    };

    module.exports = mat2d;

},{"./common.js":117}],120:[function(require,module,exports){
    /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE. */

    var glMatrix = require("./common.js");

    /**
     * @class 3x3 Matrix
     * @name mat3
     */
    var mat3 = {};

    /**
     * Creates a new identity mat3
     *
     * @returns {mat3} a new 3x3 matrix
     */
    mat3.create = function() {
        var out = new glMatrix.ARRAY_TYPE(9);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 1;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
    };

    /**
     * Copies the upper-left 3x3 values into the given mat3.
     *
     * @param {mat3} out the receiving 3x3 matrix
     * @param {mat4} a   the source 4x4 matrix
     * @returns {mat3} out
     */
    mat3.fromMat4 = function(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[4];
        out[4] = a[5];
        out[5] = a[6];
        out[6] = a[8];
        out[7] = a[9];
        out[8] = a[10];
        return out;
    };

    /**
     * Creates a new mat3 initialized with values from an existing matrix
     *
     * @param {mat3} a matrix to clone
     * @returns {mat3} a new 3x3 matrix
     */
    mat3.clone = function(a) {
        var out = new glMatrix.ARRAY_TYPE(9);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        return out;
    };

    /**
     * Copy the values from one mat3 to another
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    mat3.copy = function(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        return out;
    };

    /**
     * Set a mat3 to the identity matrix
     *
     * @param {mat3} out the receiving matrix
     * @returns {mat3} out
     */
    mat3.identity = function(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 1;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
    };

    /**
     * Transpose the values of a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    mat3.transpose = function(out, a) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (out === a) {
            var a01 = a[1], a02 = a[2], a12 = a[5];
            out[1] = a[3];
            out[2] = a[6];
            out[3] = a01;
            out[5] = a[7];
            out[6] = a02;
            out[7] = a12;
        } else {
            out[0] = a[0];
            out[1] = a[3];
            out[2] = a[6];
            out[3] = a[1];
            out[4] = a[4];
            out[5] = a[7];
            out[6] = a[2];
            out[7] = a[5];
            out[8] = a[8];
        }

        return out;
    };

    /**
     * Inverts a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    mat3.invert = function(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2],
            a10 = a[3], a11 = a[4], a12 = a[5],
            a20 = a[6], a21 = a[7], a22 = a[8],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
            det = a00 * b01 + a01 * b11 + a02 * b21;

        if (!det) {
            return null;
        }
        det = 1.0 / det;

        out[0] = b01 * det;
        out[1] = (-a22 * a01 + a02 * a21) * det;
        out[2] = (a12 * a01 - a02 * a11) * det;
        out[3] = b11 * det;
        out[4] = (a22 * a00 - a02 * a20) * det;
        out[5] = (-a12 * a00 + a02 * a10) * det;
        out[6] = b21 * det;
        out[7] = (-a21 * a00 + a01 * a20) * det;
        out[8] = (a11 * a00 - a01 * a10) * det;
        return out;
    };

    /**
     * Calculates the adjugate of a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the source matrix
     * @returns {mat3} out
     */
    mat3.adjoint = function(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2],
            a10 = a[3], a11 = a[4], a12 = a[5],
            a20 = a[6], a21 = a[7], a22 = a[8];

        out[0] = (a11 * a22 - a12 * a21);
        out[1] = (a02 * a21 - a01 * a22);
        out[2] = (a01 * a12 - a02 * a11);
        out[3] = (a12 * a20 - a10 * a22);
        out[4] = (a00 * a22 - a02 * a20);
        out[5] = (a02 * a10 - a00 * a12);
        out[6] = (a10 * a21 - a11 * a20);
        out[7] = (a01 * a20 - a00 * a21);
        out[8] = (a00 * a11 - a01 * a10);
        return out;
    };

    /**
     * Calculates the determinant of a mat3
     *
     * @param {mat3} a the source matrix
     * @returns {Number} determinant of a
     */
    mat3.determinant = function (a) {
        var a00 = a[0], a01 = a[1], a02 = a[2],
            a10 = a[3], a11 = a[4], a12 = a[5],
            a20 = a[6], a21 = a[7], a22 = a[8];

        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
    };

    /**
     * Multiplies two mat3's
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the first operand
     * @param {mat3} b the second operand
     * @returns {mat3} out
     */
    mat3.multiply = function (out, a, b) {
        var a00 = a[0], a01 = a[1], a02 = a[2],
            a10 = a[3], a11 = a[4], a12 = a[5],
            a20 = a[6], a21 = a[7], a22 = a[8],

            b00 = b[0], b01 = b[1], b02 = b[2],
            b10 = b[3], b11 = b[4], b12 = b[5],
            b20 = b[6], b21 = b[7], b22 = b[8];

        out[0] = b00 * a00 + b01 * a10 + b02 * a20;
        out[1] = b00 * a01 + b01 * a11 + b02 * a21;
        out[2] = b00 * a02 + b01 * a12 + b02 * a22;

        out[3] = b10 * a00 + b11 * a10 + b12 * a20;
        out[4] = b10 * a01 + b11 * a11 + b12 * a21;
        out[5] = b10 * a02 + b11 * a12 + b12 * a22;

        out[6] = b20 * a00 + b21 * a10 + b22 * a20;
        out[7] = b20 * a01 + b21 * a11 + b22 * a21;
        out[8] = b20 * a02 + b21 * a12 + b22 * a22;
        return out;
    };

    /**
     * Alias for {@link mat3.multiply}
     * @function
     */
    mat3.mul = mat3.multiply;

    /**
     * Translate a mat3 by the given vector
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to translate
     * @param {vec2} v vector to translate by
     * @returns {mat3} out
     */
    mat3.translate = function(out, a, v) {
        var a00 = a[0], a01 = a[1], a02 = a[2],
            a10 = a[3], a11 = a[4], a12 = a[5],
            a20 = a[6], a21 = a[7], a22 = a[8],
            x = v[0], y = v[1];

        out[0] = a00;
        out[1] = a01;
        out[2] = a02;

        out[3] = a10;
        out[4] = a11;
        out[5] = a12;

        out[6] = x * a00 + y * a10 + a20;
        out[7] = x * a01 + y * a11 + a21;
        out[8] = x * a02 + y * a12 + a22;
        return out;
    };

    /**
     * Rotates a mat3 by the given angle
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat3} out
     */
    mat3.rotate = function (out, a, rad) {
        var a00 = a[0], a01 = a[1], a02 = a[2],
            a10 = a[3], a11 = a[4], a12 = a[5],
            a20 = a[6], a21 = a[7], a22 = a[8],

            s = Math.sin(rad),
            c = Math.cos(rad);

        out[0] = c * a00 + s * a10;
        out[1] = c * a01 + s * a11;
        out[2] = c * a02 + s * a12;

        out[3] = c * a10 - s * a00;
        out[4] = c * a11 - s * a01;
        out[5] = c * a12 - s * a02;

        out[6] = a20;
        out[7] = a21;
        out[8] = a22;
        return out;
    };

    /**
     * Scales the mat3 by the dimensions in the given vec2
     *
     * @param {mat3} out the receiving matrix
     * @param {mat3} a the matrix to rotate
     * @param {vec2} v the vec2 to scale the matrix by
     * @returns {mat3} out
     **/
    mat3.scale = function(out, a, v) {
        var x = v[0], y = v[1];

        out[0] = x * a[0];
        out[1] = x * a[1];
        out[2] = x * a[2];

        out[3] = y * a[3];
        out[4] = y * a[4];
        out[5] = y * a[5];

        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        return out;
    };

    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat3.identity(dest);
     *     mat3.translate(dest, dest, vec);
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {vec2} v Translation vector
     * @returns {mat3} out
     */
    mat3.fromTranslation = function(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 1;
        out[5] = 0;
        out[6] = v[0];
        out[7] = v[1];
        out[8] = 1;
        return out;
    }

    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):
     *
     *     mat3.identity(dest);
     *     mat3.rotate(dest, dest, rad);
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat3} out
     */
    mat3.fromRotation = function(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);

        out[0] = c;
        out[1] = s;
        out[2] = 0;

        out[3] = -s;
        out[4] = c;
        out[5] = 0;

        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
    }

    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat3.identity(dest);
     *     mat3.scale(dest, dest, vec);
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {vec2} v Scaling vector
     * @returns {mat3} out
     */
    mat3.fromScaling = function(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;

        out[3] = 0;
        out[4] = v[1];
        out[5] = 0;

        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
    }

    /**
     * Copies the values from a mat2d into a mat3
     *
     * @param {mat3} out the receiving matrix
     * @param {mat2d} a the matrix to copy
     * @returns {mat3} out
     **/
    mat3.fromMat2d = function(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = 0;

        out[3] = a[2];
        out[4] = a[3];
        out[5] = 0;

        out[6] = a[4];
        out[7] = a[5];
        out[8] = 1;
        return out;
    };

    /**
     * Calculates a 3x3 matrix from the given quaternion
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {quat} q Quaternion to create matrix from
     *
     * @returns {mat3} out
     */
    mat3.fromQuat = function (out, q) {
        var x = q[0], y = q[1], z = q[2], w = q[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            yx = y * x2,
            yy = y * y2,
            zx = z * x2,
            zy = z * y2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        out[0] = 1 - yy - zz;
        out[3] = yx - wz;
        out[6] = zx + wy;

        out[1] = yx + wz;
        out[4] = 1 - xx - zz;
        out[7] = zy - wx;

        out[2] = zx - wy;
        out[5] = zy + wx;
        out[8] = 1 - xx - yy;

        return out;
    };

    /**
     * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
     *
     * @param {mat3} out mat3 receiving operation result
     * @param {mat4} a Mat4 to derive the normal matrix from
     *
     * @returns {mat3} out
     */
    mat3.normalFromMat4 = function (out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det) {
            return null;
        }
        det = 1.0 / det;

        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

        return out;
    };

    /**
     * Returns a string representation of a mat3
     *
     * @param {mat3} mat matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    mat3.str = function (a) {
        return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
            a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
            a[6] + ', ' + a[7] + ', ' + a[8] + ')';
    };

    /**
     * Returns Frobenius norm of a mat3
     *
     * @param {mat3} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    mat3.frob = function (a) {
        return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
    };


    module.exports = mat3;

},{"./common.js":117}],121:[function(require,module,exports){
    /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE. */

    var glMatrix = require("./common.js");

    /**
     * @class 4x4 Matrix
     * @name mat4
     */
    var mat4 = {};

    /**
     * Creates a new identity mat4
     *
     * @returns {mat4} a new 4x4 matrix
     */
    mat4.create = function() {
        var out = new glMatrix.ARRAY_TYPE(16);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
    };

    /**
     * Creates a new mat4 initialized with values from an existing matrix
     *
     * @param {mat4} a matrix to clone
     * @returns {mat4} a new 4x4 matrix
     */
    mat4.clone = function(a) {
        var out = new glMatrix.ARRAY_TYPE(16);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
    };

    /**
     * Copy the values from one mat4 to another
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    mat4.copy = function(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
    };

    /**
     * Set a mat4 to the identity matrix
     *
     * @param {mat4} out the receiving matrix
     * @returns {mat4} out
     */
    mat4.identity = function(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
    };

    /**
     * Transpose the values of a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    mat4.transpose = function(out, a) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (out === a) {
            var a01 = a[1], a02 = a[2], a03 = a[3],
                a12 = a[6], a13 = a[7],
                a23 = a[11];

            out[1] = a[4];
            out[2] = a[8];
            out[3] = a[12];
            out[4] = a01;
            out[6] = a[9];
            out[7] = a[13];
            out[8] = a02;
            out[9] = a12;
            out[11] = a[14];
            out[12] = a03;
            out[13] = a13;
            out[14] = a23;
        } else {
            out[0] = a[0];
            out[1] = a[4];
            out[2] = a[8];
            out[3] = a[12];
            out[4] = a[1];
            out[5] = a[5];
            out[6] = a[9];
            out[7] = a[13];
            out[8] = a[2];
            out[9] = a[6];
            out[10] = a[10];
            out[11] = a[14];
            out[12] = a[3];
            out[13] = a[7];
            out[14] = a[11];
            out[15] = a[15];
        }

        return out;
    };

    /**
     * Inverts a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    mat4.invert = function(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det) {
            return null;
        }
        det = 1.0 / det;

        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

        return out;
    };

    /**
     * Calculates the adjugate of a mat4
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */
    mat4.adjoint = function(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
        out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
        out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
        out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
        out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
        out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
        out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
        out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
        out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
        out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
        out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
        out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
        out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
        out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
        out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
        out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
        return out;
    };

    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} a the source matrix
     * @returns {Number} determinant of a
     */
    mat4.determinant = function (a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32;

        // Calculate the determinant
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    };

    /**
     * Multiplies two mat4's
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the first operand
     * @param {mat4} b the second operand
     * @returns {mat4} out
     */
    mat4.multiply = function (out, a, b) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        // Cache only the current line of the second matrix
        var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
        out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
        out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
        out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
        return out;
    };

    /**
     * Alias for {@link mat4.multiply}
     * @function
     */
    mat4.mul = mat4.multiply;

    /**
     * Translate a mat4 by the given vector
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to translate
     * @param {vec3} v vector to translate by
     * @returns {mat4} out
     */
    mat4.translate = function (out, a, v) {
        var x = v[0], y = v[1], z = v[2],
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23;

        if (a === out) {
            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
            a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
            a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
            a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

            out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
            out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
            out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

            out[12] = a00 * x + a10 * y + a20 * z + a[12];
            out[13] = a01 * x + a11 * y + a21 * z + a[13];
            out[14] = a02 * x + a12 * y + a22 * z + a[14];
            out[15] = a03 * x + a13 * y + a23 * z + a[15];
        }

        return out;
    };

    /**
     * Scales the mat4 by the dimensions in the given vec3
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to scale
     * @param {vec3} v the vec3 to scale the matrix by
     * @returns {mat4} out
     **/
    mat4.scale = function(out, a, v) {
        var x = v[0], y = v[1], z = v[2];

        out[0] = a[0] * x;
        out[1] = a[1] * x;
        out[2] = a[2] * x;
        out[3] = a[3] * x;
        out[4] = a[4] * y;
        out[5] = a[5] * y;
        out[6] = a[6] * y;
        out[7] = a[7] * y;
        out[8] = a[8] * z;
        out[9] = a[9] * z;
        out[10] = a[10] * z;
        out[11] = a[11] * z;
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
    };

    /**
     * Rotates a mat4 by the given angle around the given axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @param {vec3} axis the axis to rotate around
     * @returns {mat4} out
     */
    mat4.rotate = function (out, a, rad, axis) {
        var x = axis[0], y = axis[1], z = axis[2],
            len = Math.sqrt(x * x + y * y + z * z),
            s, c, t,
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23,
            b00, b01, b02,
            b10, b11, b12,
            b20, b21, b22;

        if (Math.abs(len) < glMatrix.EPSILON) { return null; }

        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;

        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;

        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        // Construct the elements of the rotation matrix
        b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
        b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
        b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

        // Perform rotation-specific matrix multiplication
        out[0] = a00 * b00 + a10 * b01 + a20 * b02;
        out[1] = a01 * b00 + a11 * b01 + a21 * b02;
        out[2] = a02 * b00 + a12 * b01 + a22 * b02;
        out[3] = a03 * b00 + a13 * b01 + a23 * b02;
        out[4] = a00 * b10 + a10 * b11 + a20 * b12;
        out[5] = a01 * b10 + a11 * b11 + a21 * b12;
        out[6] = a02 * b10 + a12 * b11 + a22 * b12;
        out[7] = a03 * b10 + a13 * b11 + a23 * b12;
        out[8] = a00 * b20 + a10 * b21 + a20 * b22;
        out[9] = a01 * b20 + a11 * b21 + a21 * b22;
        out[10] = a02 * b20 + a12 * b21 + a22 * b22;
        out[11] = a03 * b20 + a13 * b21 + a23 * b22;

        if (a !== out) { // If the source and destination differ, copy the unchanged last row
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
        }
        return out;
    };

    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    mat4.rotateX = function (out, a, rad) {
        var s = Math.sin(rad),
            c = Math.cos(rad),
            a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7],
            a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];

        if (a !== out) { // If the source and destination differ, copy the unchanged rows
            out[0]  = a[0];
            out[1]  = a[1];
            out[2]  = a[2];
            out[3]  = a[3];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
        }

        // Perform axis-specific matrix multiplication
        out[4] = a10 * c + a20 * s;
        out[5] = a11 * c + a21 * s;
        out[6] = a12 * c + a22 * s;
        out[7] = a13 * c + a23 * s;
        out[8] = a20 * c - a10 * s;
        out[9] = a21 * c - a11 * s;
        out[10] = a22 * c - a12 * s;
        out[11] = a23 * c - a13 * s;
        return out;
    };

    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    mat4.rotateY = function (out, a, rad) {
        var s = Math.sin(rad),
            c = Math.cos(rad),
            a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3],
            a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];

        if (a !== out) { // If the source and destination differ, copy the unchanged rows
            out[4]  = a[4];
            out[5]  = a[5];
            out[6]  = a[6];
            out[7]  = a[7];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
        }

        // Perform axis-specific matrix multiplication
        out[0] = a00 * c - a20 * s;
        out[1] = a01 * c - a21 * s;
        out[2] = a02 * c - a22 * s;
        out[3] = a03 * c - a23 * s;
        out[8] = a00 * s + a20 * c;
        out[9] = a01 * s + a21 * c;
        out[10] = a02 * s + a22 * c;
        out[11] = a03 * s + a23 * c;
        return out;
    };

    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    mat4.rotateZ = function (out, a, rad) {
        var s = Math.sin(rad),
            c = Math.cos(rad),
            a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3],
            a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7];

        if (a !== out) { // If the source and destination differ, copy the unchanged last row
            out[8]  = a[8];
            out[9]  = a[9];
            out[10] = a[10];
            out[11] = a[11];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
        }

        // Perform axis-specific matrix multiplication
        out[0] = a00 * c + a10 * s;
        out[1] = a01 * c + a11 * s;
        out[2] = a02 * c + a12 * s;
        out[3] = a03 * c + a13 * s;
        out[4] = a10 * c - a00 * s;
        out[5] = a11 * c - a01 * s;
        out[6] = a12 * c - a02 * s;
        out[7] = a13 * c - a03 * s;
        return out;
    };

    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, dest, vec);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {vec3} v Translation vector
     * @returns {mat4} out
     */
    mat4.fromTranslation = function(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;
        return out;
    }

    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.scale(dest, dest, vec);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {vec3} v Scaling vector
     * @returns {mat4} out
     */
    mat4.fromScaling = function(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = v[1];
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = v[2];
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
    }

    /**
     * Creates a matrix from a given angle around a given axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotate(dest, dest, rad, axis);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @param {vec3} axis the axis to rotate around
     * @returns {mat4} out
     */
    mat4.fromRotation = function(out, rad, axis) {
        var x = axis[0], y = axis[1], z = axis[2],
            len = Math.sqrt(x * x + y * y + z * z),
            s, c, t;

        if (Math.abs(len) < glMatrix.EPSILON) { return null; }

        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;

        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;

        // Perform rotation-specific matrix multiplication
        out[0] = x * x * t + c;
        out[1] = y * x * t + z * s;
        out[2] = z * x * t - y * s;
        out[3] = 0;
        out[4] = x * y * t - z * s;
        out[5] = y * y * t + c;
        out[6] = z * y * t + x * s;
        out[7] = 0;
        out[8] = x * z * t + y * s;
        out[9] = y * z * t - x * s;
        out[10] = z * z * t + c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
    }

    /**
     * Creates a matrix from the given angle around the X axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotateX(dest, dest, rad);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    mat4.fromXRotation = function(out, rad) {
        var s = Math.sin(rad),
            c = Math.cos(rad);

        // Perform axis-specific matrix multiplication
        out[0]  = 1;
        out[1]  = 0;
        out[2]  = 0;
        out[3]  = 0;
        out[4] = 0;
        out[5] = c;
        out[6] = s;
        out[7] = 0;
        out[8] = 0;
        out[9] = -s;
        out[10] = c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
    }

    /**
     * Creates a matrix from the given angle around the Y axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotateY(dest, dest, rad);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    mat4.fromYRotation = function(out, rad) {
        var s = Math.sin(rad),
            c = Math.cos(rad);

        // Perform axis-specific matrix multiplication
        out[0]  = c;
        out[1]  = 0;
        out[2]  = -s;
        out[3]  = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = s;
        out[9] = 0;
        out[10] = c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
    }

    /**
     * Creates a matrix from the given angle around the Z axis
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.rotateZ(dest, dest, rad);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {Number} rad the angle to rotate the matrix by
     * @returns {mat4} out
     */
    mat4.fromZRotation = function(out, rad) {
        var s = Math.sin(rad),
            c = Math.cos(rad);

        // Perform axis-specific matrix multiplication
        out[0]  = c;
        out[1]  = s;
        out[2]  = 0;
        out[3]  = 0;
        out[4] = -s;
        out[5] = c;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
    }

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat4} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @returns {mat4} out
     */
    mat4.fromRotationTranslation = function (out, q, v) {
        // Quaternion math
        var x = q[0], y = q[1], z = q[2], w = q[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        out[0] = 1 - (yy + zz);
        out[1] = xy + wz;
        out[2] = xz - wy;
        out[3] = 0;
        out[4] = xy - wz;
        out[5] = 1 - (xx + zz);
        out[6] = yz + wx;
        out[7] = 0;
        out[8] = xz + wy;
        out[9] = yz - wx;
        out[10] = 1 - (xx + yy);
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;

        return out;
    };

    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *     mat4.scale(dest, scale)
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat4} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @param {vec3} s Scaling vector
     * @returns {mat4} out
     */
    mat4.fromRotationTranslationScale = function (out, q, v, s) {
        // Quaternion math
        var x = q[0], y = q[1], z = q[2], w = q[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2,
            sx = s[0],
            sy = s[1],
            sz = s[2];

        out[0] = (1 - (yy + zz)) * sx;
        out[1] = (xy + wz) * sx;
        out[2] = (xz - wy) * sx;
        out[3] = 0;
        out[4] = (xy - wz) * sy;
        out[5] = (1 - (xx + zz)) * sy;
        out[6] = (yz + wx) * sy;
        out[7] = 0;
        out[8] = (xz + wy) * sz;
        out[9] = (yz - wx) * sz;
        out[10] = (1 - (xx + yy)) * sz;
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;

        return out;
    };

    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     mat4.translate(dest, origin);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *     mat4.scale(dest, scale)
     *     mat4.translate(dest, negativeOrigin);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {quat4} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @param {vec3} s Scaling vector
     * @param {vec3} o The origin vector around which to scale and rotate
     * @returns {mat4} out
     */
    mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
        // Quaternion math
        var x = q[0], y = q[1], z = q[2], w = q[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2,

            sx = s[0],
            sy = s[1],
            sz = s[2],

            ox = o[0],
            oy = o[1],
            oz = o[2];

        out[0] = (1 - (yy + zz)) * sx;
        out[1] = (xy + wz) * sx;
        out[2] = (xz - wy) * sx;
        out[3] = 0;
        out[4] = (xy - wz) * sy;
        out[5] = (1 - (xx + zz)) * sy;
        out[6] = (yz + wx) * sy;
        out[7] = 0;
        out[8] = (xz + wy) * sz;
        out[9] = (yz - wx) * sz;
        out[10] = (1 - (xx + yy)) * sz;
        out[11] = 0;
        out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
        out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
        out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
        out[15] = 1;

        return out;
    };

    mat4.fromQuat = function (out, q) {
        var x = q[0], y = q[1], z = q[2], w = q[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            yx = y * x2,
            yy = y * y2,
            zx = z * x2,
            zy = z * y2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        out[0] = 1 - yy - zz;
        out[1] = yx + wz;
        out[2] = zx - wy;
        out[3] = 0;

        out[4] = yx - wz;
        out[5] = 1 - xx - zz;
        out[6] = zy + wx;
        out[7] = 0;

        out[8] = zx + wy;
        out[9] = zy - wx;
        out[10] = 1 - xx - yy;
        out[11] = 0;

        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;

        return out;
    };

    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {Number} left Left bound of the frustum
     * @param {Number} right Right bound of the frustum
     * @param {Number} bottom Bottom bound of the frustum
     * @param {Number} top Top bound of the frustum
     * @param {Number} near Near bound of the frustum
     * @param {Number} far Far bound of the frustum
     * @returns {mat4} out
     */
    mat4.frustum = function (out, left, right, bottom, top, near, far) {
        var rl = 1 / (right - left),
            tb = 1 / (top - bottom),
            nf = 1 / (near - far);
        out[0] = (near * 2) * rl;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = (near * 2) * tb;
        out[6] = 0;
        out[7] = 0;
        out[8] = (right + left) * rl;
        out[9] = (top + bottom) * tb;
        out[10] = (far + near) * nf;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = (far * near * 2) * nf;
        out[15] = 0;
        return out;
    };

    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} fovy Vertical field of view in radians
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */
    mat4.perspective = function (out, fovy, aspect, near, far) {
        var f = 1.0 / Math.tan(fovy / 2),
            nf = 1 / (near - far);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = (far + near) * nf;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = (2 * far * near) * nf;
        out[15] = 0;
        return out;
    };

    /**
     * Generates a perspective projection matrix with the given field of view.
     * This is primarily useful for generating projection matrices to be used
     * with the still experiemental WebVR API.
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */
    mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
        var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
            downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
            leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
            rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
            xScale = 2.0 / (leftTan + rightTan),
            yScale = 2.0 / (upTan + downTan);

        out[0] = xScale;
        out[1] = 0.0;
        out[2] = 0.0;
        out[3] = 0.0;
        out[4] = 0.0;
        out[5] = yScale;
        out[6] = 0.0;
        out[7] = 0.0;
        out[8] = -((leftTan - rightTan) * xScale * 0.5);
        out[9] = ((upTan - downTan) * yScale * 0.5);
        out[10] = far / (near - far);
        out[11] = -1.0;
        out[12] = 0.0;
        out[13] = 0.0;
        out[14] = (far * near) / (near - far);
        out[15] = 0.0;
        return out;
    }

    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */
    mat4.ortho = function (out, left, right, bottom, top, near, far) {
        var lr = 1 / (left - right),
            bt = 1 / (bottom - top),
            nf = 1 / (near - far);
        out[0] = -2 * lr;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = -2 * bt;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 2 * nf;
        out[11] = 0;
        out[12] = (left + right) * lr;
        out[13] = (top + bottom) * bt;
        out[14] = (far + near) * nf;
        out[15] = 1;
        return out;
    };

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing up
     * @returns {mat4} out
     */
    mat4.lookAt = function (out, eye, center, up) {
        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
            eyex = eye[0],
            eyey = eye[1],
            eyez = eye[2],
            upx = up[0],
            upy = up[1],
            upz = up[2],
            centerx = center[0],
            centery = center[1],
            centerz = center[2];

        if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
            Math.abs(eyey - centery) < glMatrix.EPSILON &&
            Math.abs(eyez - centerz) < glMatrix.EPSILON) {
            return mat4.identity(out);
        }

        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;

        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        out[0] = x0;
        out[1] = y0;
        out[2] = z0;
        out[3] = 0;
        out[4] = x1;
        out[5] = y1;
        out[6] = z1;
        out[7] = 0;
        out[8] = x2;
        out[9] = y2;
        out[10] = z2;
        out[11] = 0;
        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        out[15] = 1;

        return out;
    };

    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} mat matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    mat4.str = function (a) {
        return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
            a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
            a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
            a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
    };

    /**
     * Returns Frobenius norm of a mat4
     *
     * @param {mat4} a the matrix to calculate Frobenius norm of
     * @returns {Number} Frobenius norm
     */
    mat4.frob = function (a) {
        return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
    };


    module.exports = mat4;

},{"./common.js":117}],122:[function(require,module,exports){
    /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE. */

    var glMatrix = require("./common.js");
    var mat3 = require("./mat3.js");
    var vec3 = require("./vec3.js");
    var vec4 = require("./vec4.js");

    /**
     * @class Quaternion
     * @name quat
     */
    var quat = {};

    /**
     * Creates a new identity quat
     *
     * @returns {quat} a new quaternion
     */
    quat.create = function() {
        var out = new glMatrix.ARRAY_TYPE(4);
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
    };

    /**
     * Sets a quaternion to represent the shortest rotation from one
     * vector to another.
     *
     * Both vectors are assumed to be unit length.
     *
     * @param {quat} out the receiving quaternion.
     * @param {vec3} a the initial vector
     * @param {vec3} b the destination vector
     * @returns {quat} out
     */
    quat.rotationTo = (function() {
        var tmpvec3 = vec3.create();
        var xUnitVec3 = vec3.fromValues(1,0,0);
        var yUnitVec3 = vec3.fromValues(0,1,0);

        return function(out, a, b) {
            var dot = vec3.dot(a, b);
            if (dot < -0.999999) {
                vec3.cross(tmpvec3, xUnitVec3, a);
                if (vec3.length(tmpvec3) < 0.000001)
                    vec3.cross(tmpvec3, yUnitVec3, a);
                vec3.normalize(tmpvec3, tmpvec3);
                quat.setAxisAngle(out, tmpvec3, Math.PI);
                return out;
            } else if (dot > 0.999999) {
                out[0] = 0;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
                return out;
            } else {
                vec3.cross(tmpvec3, a, b);
                out[0] = tmpvec3[0];
                out[1] = tmpvec3[1];
                out[2] = tmpvec3[2];
                out[3] = 1 + dot;
                return quat.normalize(out, out);
            }
        };
    })();

    /**
     * Sets the specified quaternion with values corresponding to the given
     * axes. Each axis is a vec3 and is expected to be unit length and
     * perpendicular to all other specified axes.
     *
     * @param {vec3} view  the vector representing the viewing direction
     * @param {vec3} right the vector representing the local "right" direction
     * @param {vec3} up    the vector representing the local "up" direction
     * @returns {quat} out
     */
    quat.setAxes = (function() {
        var matr = mat3.create();

        return function(out, view, right, up) {
            matr[0] = right[0];
            matr[3] = right[1];
            matr[6] = right[2];

            matr[1] = up[0];
            matr[4] = up[1];
            matr[7] = up[2];

            matr[2] = -view[0];
            matr[5] = -view[1];
            matr[8] = -view[2];

            return quat.normalize(out, quat.fromMat3(out, matr));
        };
    })();

    /**
     * Creates a new quat initialized with values from an existing quaternion
     *
     * @param {quat} a quaternion to clone
     * @returns {quat} a new quaternion
     * @function
     */
    quat.clone = vec4.clone;

    /**
     * Creates a new quat initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {quat} a new quaternion
     * @function
     */
    quat.fromValues = vec4.fromValues;

    /**
     * Copy the values from one quat to another
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the source quaternion
     * @returns {quat} out
     * @function
     */
    quat.copy = vec4.copy;

    /**
     * Set the components of a quat to the given values
     *
     * @param {quat} out the receiving quaternion
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {quat} out
     * @function
     */
    quat.set = vec4.set;

    /**
     * Set a quat to the identity quaternion
     *
     * @param {quat} out the receiving quaternion
     * @returns {quat} out
     */
    quat.identity = function(out) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
    };

    /**
     * Sets a quat from the given angle and rotation axis,
     * then returns it.
     *
     * @param {quat} out the receiving quaternion
     * @param {vec3} axis the axis around which to rotate
     * @param {Number} rad the angle in radians
     * @returns {quat} out
     **/
    quat.setAxisAngle = function(out, axis, rad) {
        rad = rad * 0.5;
        var s = Math.sin(rad);
        out[0] = s * axis[0];
        out[1] = s * axis[1];
        out[2] = s * axis[2];
        out[3] = Math.cos(rad);
        return out;
    };

    /**
     * Adds two quat's
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @returns {quat} out
     * @function
     */
    quat.add = vec4.add;

    /**
     * Multiplies two quat's
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @returns {quat} out
     */
    quat.multiply = function(out, a, b) {
        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
            bx = b[0], by = b[1], bz = b[2], bw = b[3];

        out[0] = ax * bw + aw * bx + ay * bz - az * by;
        out[1] = ay * bw + aw * by + az * bx - ax * bz;
        out[2] = az * bw + aw * bz + ax * by - ay * bx;
        out[3] = aw * bw - ax * bx - ay * by - az * bz;
        return out;
    };

    /**
     * Alias for {@link quat.multiply}
     * @function
     */
    quat.mul = quat.multiply;

    /**
     * Scales a quat by a scalar number
     *
     * @param {quat} out the receiving vector
     * @param {quat} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {quat} out
     * @function
     */
    quat.scale = vec4.scale;

    /**
     * Rotates a quaternion by the given angle about the X axis
     *
     * @param {quat} out quat receiving operation result
     * @param {quat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */
    quat.rotateX = function (out, a, rad) {
        rad *= 0.5;

        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
            bx = Math.sin(rad), bw = Math.cos(rad);

        out[0] = ax * bw + aw * bx;
        out[1] = ay * bw + az * bx;
        out[2] = az * bw - ay * bx;
        out[3] = aw * bw - ax * bx;
        return out;
    };

    /**
     * Rotates a quaternion by the given angle about the Y axis
     *
     * @param {quat} out quat receiving operation result
     * @param {quat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */
    quat.rotateY = function (out, a, rad) {
        rad *= 0.5;

        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
            by = Math.sin(rad), bw = Math.cos(rad);

        out[0] = ax * bw - az * by;
        out[1] = ay * bw + aw * by;
        out[2] = az * bw + ax * by;
        out[3] = aw * bw - ay * by;
        return out;
    };

    /**
     * Rotates a quaternion by the given angle about the Z axis
     *
     * @param {quat} out quat receiving operation result
     * @param {quat} a quat to rotate
     * @param {number} rad angle (in radians) to rotate
     * @returns {quat} out
     */
    quat.rotateZ = function (out, a, rad) {
        rad *= 0.5;

        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
            bz = Math.sin(rad), bw = Math.cos(rad);

        out[0] = ax * bw + ay * bz;
        out[1] = ay * bw - ax * bz;
        out[2] = az * bw + aw * bz;
        out[3] = aw * bw - az * bz;
        return out;
    };

    /**
     * Calculates the W component of a quat from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quat to calculate W component of
     * @returns {quat} out
     */
    quat.calculateW = function (out, a) {
        var x = a[0], y = a[1], z = a[2];

        out[0] = x;
        out[1] = y;
        out[2] = z;
        out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
        return out;
    };

    /**
     * Calculates the dot product of two quat's
     *
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @returns {Number} dot product of a and b
     * @function
     */
    quat.dot = vec4.dot;

    /**
     * Performs a linear interpolation between two quat's
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {quat} out
     * @function
     */
    quat.lerp = vec4.lerp;

    /**
     * Performs a spherical linear interpolation between two quat
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {quat} out
     */
    quat.slerp = function (out, a, b, t) {
        // benchmarks:
        //    http://jsperf.com/quaternion-slerp-implementations

        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
            bx = b[0], by = b[1], bz = b[2], bw = b[3];

        var        omega, cosom, sinom, scale0, scale1;

        // calc cosine
        cosom = ax * bx + ay * by + az * bz + aw * bw;
        // adjust signs (if necessary)
        if ( cosom < 0.0 ) {
            cosom = -cosom;
            bx = - bx;
            by = - by;
            bz = - bz;
            bw = - bw;
        }
        // calculate coefficients
        if ( (1.0 - cosom) > 0.000001 ) {
            // standard case (slerp)
            omega  = Math.acos(cosom);
            sinom  = Math.sin(omega);
            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
        } else {
            // "from" and "to" quaternions are very close 
            //  ... so we can do a linear interpolation
            scale0 = 1.0 - t;
            scale1 = t;
        }
        // calculate final values
        out[0] = scale0 * ax + scale1 * bx;
        out[1] = scale0 * ay + scale1 * by;
        out[2] = scale0 * az + scale1 * bz;
        out[3] = scale0 * aw + scale1 * bw;

        return out;
    };

    /**
     * Performs a spherical linear interpolation with two control points
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a the first operand
     * @param {quat} b the second operand
     * @param {quat} c the third operand
     * @param {quat} d the fourth operand
     * @param {Number} t interpolation amount
     * @returns {quat} out
     */
    quat.sqlerp = (function () {
        var temp1 = quat.create();
        var temp2 = quat.create();

        return function (out, a, b, c, d, t) {
            quat.slerp(temp1, a, d, t);
            quat.slerp(temp2, b, c, t);
            quat.slerp(out, temp1, temp2, 2 * t * (1 - t));

            return out;
        };
    }());

    /**
     * Calculates the inverse of a quat
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quat to calculate inverse of
     * @returns {quat} out
     */
    quat.invert = function(out, a) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
            dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
            invDot = dot ? 1.0/dot : 0;

        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

        out[0] = -a0*invDot;
        out[1] = -a1*invDot;
        out[2] = -a2*invDot;
        out[3] = a3*invDot;
        return out;
    };

    /**
     * Calculates the conjugate of a quat
     * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quat to calculate conjugate of
     * @returns {quat} out
     */
    quat.conjugate = function (out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        out[2] = -a[2];
        out[3] = a[3];
        return out;
    };

    /**
     * Calculates the length of a quat
     *
     * @param {quat} a vector to calculate length of
     * @returns {Number} length of a
     * @function
     */
    quat.length = vec4.length;

    /**
     * Alias for {@link quat.length}
     * @function
     */
    quat.len = quat.length;

    /**
     * Calculates the squared length of a quat
     *
     * @param {quat} a vector to calculate squared length of
     * @returns {Number} squared length of a
     * @function
     */
    quat.squaredLength = vec4.squaredLength;

    /**
     * Alias for {@link quat.squaredLength}
     * @function
     */
    quat.sqrLen = quat.squaredLength;

    /**
     * Normalize a quat
     *
     * @param {quat} out the receiving quaternion
     * @param {quat} a quaternion to normalize
     * @returns {quat} out
     * @function
     */
    quat.normalize = vec4.normalize;

    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     *
     * NOTE: The resultant quaternion is not normalized, so you should be sure
     * to renormalize the quaternion yourself where necessary.
     *
     * @param {quat} out the receiving quaternion
     * @param {mat3} m rotation matrix
     * @returns {quat} out
     * @function
     */
    quat.fromMat3 = function(out, m) {
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".
        var fTrace = m[0] + m[4] + m[8];
        var fRoot;

        if ( fTrace > 0.0 ) {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0);  // 2w
            out[3] = 0.5 * fRoot;
            fRoot = 0.5/fRoot;  // 1/(4w)
            out[0] = (m[5]-m[7])*fRoot;
            out[1] = (m[6]-m[2])*fRoot;
            out[2] = (m[1]-m[3])*fRoot;
        } else {
            // |w| <= 1/2
            var i = 0;
            if ( m[4] > m[0] )
                i = 1;
            if ( m[8] > m[i*3+i] )
                i = 2;
            var j = (i+1)%3;
            var k = (i+2)%3;

            fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
            out[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
            out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
            out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
        }

        return out;
    };

    /**
     * Returns a string representation of a quatenion
     *
     * @param {quat} vec vector to represent as a string
     * @returns {String} string representation of the vector
     */
    quat.str = function (a) {
        return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
    };

    module.exports = quat;

},{"./common.js":117,"./mat3.js":120,"./vec3.js":124,"./vec4.js":125}],123:[function(require,module,exports){
    /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE. */

    var glMatrix = require("./common.js");

    /**
     * @class 2 Dimensional Vector
     * @name vec2
     */
    var vec2 = {};

    /**
     * Creates a new, empty vec2
     *
     * @returns {vec2} a new 2D vector
     */
    vec2.create = function() {
        var out = new glMatrix.ARRAY_TYPE(2);
        out[0] = 0;
        out[1] = 0;
        return out;
    };

    /**
     * Creates a new vec2 initialized with values from an existing vector
     *
     * @param {vec2} a vector to clone
     * @returns {vec2} a new 2D vector
     */
    vec2.clone = function(a) {
        var out = new glMatrix.ARRAY_TYPE(2);
        out[0] = a[0];
        out[1] = a[1];
        return out;
    };

    /**
     * Creates a new vec2 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @returns {vec2} a new 2D vector
     */
    vec2.fromValues = function(x, y) {
        var out = new glMatrix.ARRAY_TYPE(2);
        out[0] = x;
        out[1] = y;
        return out;
    };

    /**
     * Copy the values from one vec2 to another
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the source vector
     * @returns {vec2} out
     */
    vec2.copy = function(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        return out;
    };

    /**
     * Set the components of a vec2 to the given values
     *
     * @param {vec2} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @returns {vec2} out
     */
    vec2.set = function(out, x, y) {
        out[0] = x;
        out[1] = y;
        return out;
    };

    /**
     * Adds two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @returns {vec2} out
     */
    vec2.add = function(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        return out;
    };

    /**
     * Subtracts vector b from vector a
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @returns {vec2} out
     */
    vec2.subtract = function(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        return out;
    };

    /**
     * Alias for {@link vec2.subtract}
     * @function
     */
    vec2.sub = vec2.subtract;

    /**
     * Multiplies two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @returns {vec2} out
     */
    vec2.multiply = function(out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        return out;
    };

    /**
     * Alias for {@link vec2.multiply}
     * @function
     */
    vec2.mul = vec2.multiply;

    /**
     * Divides two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @returns {vec2} out
     */
    vec2.divide = function(out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        return out;
    };

    /**
     * Alias for {@link vec2.divide}
     * @function
     */
    vec2.div = vec2.divide;

    /**
     * Returns the minimum of two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @returns {vec2} out
     */
    vec2.min = function(out, a, b) {
        out[0] = Math.min(a[0], b[0]);
        out[1] = Math.min(a[1], b[1]);
        return out;
    };

    /**
     * Returns the maximum of two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @returns {vec2} out
     */
    vec2.max = function(out, a, b) {
        out[0] = Math.max(a[0], b[0]);
        out[1] = Math.max(a[1], b[1]);
        return out;
    };

    /**
     * Scales a vec2 by a scalar number
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec2} out
     */
    vec2.scale = function(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        return out;
    };

    /**
     * Adds two vec2's after scaling the second operand by a scalar value
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @param {Number} scale the amount to scale b by before adding
     * @returns {vec2} out
     */
    vec2.scaleAndAdd = function(out, a, b, scale) {
        out[0] = a[0] + (b[0] * scale);
        out[1] = a[1] + (b[1] * scale);
        return out;
    };

    /**
     * Calculates the euclidian distance between two vec2's
     *
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @returns {Number} distance between a and b
     */
    vec2.distance = function(a, b) {
        var x = b[0] - a[0],
            y = b[1] - a[1];
        return Math.sqrt(x*x + y*y);
    };

    /**
     * Alias for {@link vec2.distance}
     * @function
     */
    vec2.dist = vec2.distance;

    /**
     * Calculates the squared euclidian distance between two vec2's
     *
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @returns {Number} squared distance between a and b
     */
    vec2.squaredDistance = function(a, b) {
        var x = b[0] - a[0],
            y = b[1] - a[1];
        return x*x + y*y;
    };

    /**
     * Alias for {@link vec2.squaredDistance}
     * @function
     */
    vec2.sqrDist = vec2.squaredDistance;

    /**
     * Calculates the length of a vec2
     *
     * @param {vec2} a vector to calculate length of
     * @returns {Number} length of a
     */
    vec2.length = function (a) {
        var x = a[0],
            y = a[1];
        return Math.sqrt(x*x + y*y);
    };

    /**
     * Alias for {@link vec2.length}
     * @function
     */
    vec2.len = vec2.length;

    /**
     * Calculates the squared length of a vec2
     *
     * @param {vec2} a vector to calculate squared length of
     * @returns {Number} squared length of a
     */
    vec2.squaredLength = function (a) {
        var x = a[0],
            y = a[1];
        return x*x + y*y;
    };

    /**
     * Alias for {@link vec2.squaredLength}
     * @function
     */
    vec2.sqrLen = vec2.squaredLength;

    /**
     * Negates the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a vector to negate
     * @returns {vec2} out
     */
    vec2.negate = function(out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        return out;
    };

    /**
     * Returns the inverse of the components of a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a vector to invert
     * @returns {vec2} out
     */
    vec2.inverse = function(out, a) {
        out[0] = 1.0 / a[0];
        out[1] = 1.0 / a[1];
        return out;
    };

    /**
     * Normalize a vec2
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a vector to normalize
     * @returns {vec2} out
     */
    vec2.normalize = function(out, a) {
        var x = a[0],
            y = a[1];
        var len = x*x + y*y;
        if (len > 0) {
            //TODO: evaluate use of glm_invsqrt here?
            len = 1 / Math.sqrt(len);
            out[0] = a[0] * len;
            out[1] = a[1] * len;
        }
        return out;
    };

    /**
     * Calculates the dot product of two vec2's
     *
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @returns {Number} dot product of a and b
     */
    vec2.dot = function (a, b) {
        return a[0] * b[0] + a[1] * b[1];
    };

    /**
     * Computes the cross product of two vec2's
     * Note that the cross product must by definition produce a 3D vector
     *
     * @param {vec3} out the receiving vector
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @returns {vec3} out
     */
    vec2.cross = function(out, a, b) {
        var z = a[0] * b[1] - a[1] * b[0];
        out[0] = out[1] = 0;
        out[2] = z;
        return out;
    };

    /**
     * Performs a linear interpolation between two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the first operand
     * @param {vec2} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec2} out
     */
    vec2.lerp = function (out, a, b, t) {
        var ax = a[0],
            ay = a[1];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        return out;
    };

    /**
     * Generates a random vector with the given scale
     *
     * @param {vec2} out the receiving vector
     * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
     * @returns {vec2} out
     */
    vec2.random = function (out, scale) {
        scale = scale || 1.0;
        var r = glMatrix.RANDOM() * 2.0 * Math.PI;
        out[0] = Math.cos(r) * scale;
        out[1] = Math.sin(r) * scale;
        return out;
    };

    /**
     * Transforms the vec2 with a mat2
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the vector to transform
     * @param {mat2} m matrix to transform with
     * @returns {vec2} out
     */
    vec2.transformMat2 = function(out, a, m) {
        var x = a[0],
            y = a[1];
        out[0] = m[0] * x + m[2] * y;
        out[1] = m[1] * x + m[3] * y;
        return out;
    };

    /**
     * Transforms the vec2 with a mat2d
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the vector to transform
     * @param {mat2d} m matrix to transform with
     * @returns {vec2} out
     */
    vec2.transformMat2d = function(out, a, m) {
        var x = a[0],
            y = a[1];
        out[0] = m[0] * x + m[2] * y + m[4];
        out[1] = m[1] * x + m[3] * y + m[5];
        return out;
    };

    /**
     * Transforms the vec2 with a mat3
     * 3rd vector component is implicitly '1'
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the vector to transform
     * @param {mat3} m matrix to transform with
     * @returns {vec2} out
     */
    vec2.transformMat3 = function(out, a, m) {
        var x = a[0],
            y = a[1];
        out[0] = m[0] * x + m[3] * y + m[6];
        out[1] = m[1] * x + m[4] * y + m[7];
        return out;
    };

    /**
     * Transforms the vec2 with a mat4
     * 3rd vector component is implicitly '0'
     * 4th vector component is implicitly '1'
     *
     * @param {vec2} out the receiving vector
     * @param {vec2} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec2} out
     */
    vec2.transformMat4 = function(out, a, m) {
        var x = a[0],
            y = a[1];
        out[0] = m[0] * x + m[4] * y + m[12];
        out[1] = m[1] * x + m[5] * y + m[13];
        return out;
    };

    /**
     * Perform some operation over an array of vec2s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */
    vec2.forEach = (function() {
        var vec = vec2.create();

        return function(a, stride, offset, count, fn, arg) {
            var i, l;
            if(!stride) {
                stride = 2;
            }

            if(!offset) {
                offset = 0;
            }

            if(count) {
                l = Math.min((count * stride) + offset, a.length);
            } else {
                l = a.length;
            }

            for(i = offset; i < l; i += stride) {
                vec[0] = a[i]; vec[1] = a[i+1];
                fn(vec, vec, arg);
                a[i] = vec[0]; a[i+1] = vec[1];
            }

            return a;
        };
    })();

    /**
     * Returns a string representation of a vector
     *
     * @param {vec2} vec vector to represent as a string
     * @returns {String} string representation of the vector
     */
    vec2.str = function (a) {
        return 'vec2(' + a[0] + ', ' + a[1] + ')';
    };

    module.exports = vec2;

},{"./common.js":117}],124:[function(require,module,exports){
    /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE. */

    var glMatrix = require("./common.js");

    /**
     * @class 3 Dimensional Vector
     * @name vec3
     */
    var vec3 = {};

    /**
     * Creates a new, empty vec3
     *
     * @returns {vec3} a new 3D vector
     */
    vec3.create = function() {
        var out = new glMatrix.ARRAY_TYPE(3);
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        return out;
    };

    /**
     * Creates a new vec3 initialized with values from an existing vector
     *
     * @param {vec3} a vector to clone
     * @returns {vec3} a new 3D vector
     */
    vec3.clone = function(a) {
        var out = new glMatrix.ARRAY_TYPE(3);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        return out;
    };

    /**
     * Creates a new vec3 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @returns {vec3} a new 3D vector
     */
    vec3.fromValues = function(x, y, z) {
        var out = new glMatrix.ARRAY_TYPE(3);
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return out;
    };

    /**
     * Copy the values from one vec3 to another
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the source vector
     * @returns {vec3} out
     */
    vec3.copy = function(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        return out;
    };

    /**
     * Set the components of a vec3 to the given values
     *
     * @param {vec3} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @returns {vec3} out
     */
    vec3.set = function(out, x, y, z) {
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return out;
    };

    /**
     * Adds two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    vec3.add = function(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        out[2] = a[2] + b[2];
        return out;
    };

    /**
     * Subtracts vector b from vector a
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    vec3.subtract = function(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        out[2] = a[2] - b[2];
        return out;
    };

    /**
     * Alias for {@link vec3.subtract}
     * @function
     */
    vec3.sub = vec3.subtract;

    /**
     * Multiplies two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    vec3.multiply = function(out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        out[2] = a[2] * b[2];
        return out;
    };

    /**
     * Alias for {@link vec3.multiply}
     * @function
     */
    vec3.mul = vec3.multiply;

    /**
     * Divides two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    vec3.divide = function(out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        out[2] = a[2] / b[2];
        return out;
    };

    /**
     * Alias for {@link vec3.divide}
     * @function
     */
    vec3.div = vec3.divide;

    /**
     * Returns the minimum of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    vec3.min = function(out, a, b) {
        out[0] = Math.min(a[0], b[0]);
        out[1] = Math.min(a[1], b[1]);
        out[2] = Math.min(a[2], b[2]);
        return out;
    };

    /**
     * Returns the maximum of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    vec3.max = function(out, a, b) {
        out[0] = Math.max(a[0], b[0]);
        out[1] = Math.max(a[1], b[1]);
        out[2] = Math.max(a[2], b[2]);
        return out;
    };

    /**
     * Scales a vec3 by a scalar number
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec3} out
     */
    vec3.scale = function(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        out[2] = a[2] * b;
        return out;
    };

    /**
     * Adds two vec3's after scaling the second operand by a scalar value
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {Number} scale the amount to scale b by before adding
     * @returns {vec3} out
     */
    vec3.scaleAndAdd = function(out, a, b, scale) {
        out[0] = a[0] + (b[0] * scale);
        out[1] = a[1] + (b[1] * scale);
        out[2] = a[2] + (b[2] * scale);
        return out;
    };

    /**
     * Calculates the euclidian distance between two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} distance between a and b
     */
    vec3.distance = function(a, b) {
        var x = b[0] - a[0],
            y = b[1] - a[1],
            z = b[2] - a[2];
        return Math.sqrt(x*x + y*y + z*z);
    };

    /**
     * Alias for {@link vec3.distance}
     * @function
     */
    vec3.dist = vec3.distance;

    /**
     * Calculates the squared euclidian distance between two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} squared distance between a and b
     */
    vec3.squaredDistance = function(a, b) {
        var x = b[0] - a[0],
            y = b[1] - a[1],
            z = b[2] - a[2];
        return x*x + y*y + z*z;
    };

    /**
     * Alias for {@link vec3.squaredDistance}
     * @function
     */
    vec3.sqrDist = vec3.squaredDistance;

    /**
     * Calculates the length of a vec3
     *
     * @param {vec3} a vector to calculate length of
     * @returns {Number} length of a
     */
    vec3.length = function (a) {
        var x = a[0],
            y = a[1],
            z = a[2];
        return Math.sqrt(x*x + y*y + z*z);
    };

    /**
     * Alias for {@link vec3.length}
     * @function
     */
    vec3.len = vec3.length;

    /**
     * Calculates the squared length of a vec3
     *
     * @param {vec3} a vector to calculate squared length of
     * @returns {Number} squared length of a
     */
    vec3.squaredLength = function (a) {
        var x = a[0],
            y = a[1],
            z = a[2];
        return x*x + y*y + z*z;
    };

    /**
     * Alias for {@link vec3.squaredLength}
     * @function
     */
    vec3.sqrLen = vec3.squaredLength;

    /**
     * Negates the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to negate
     * @returns {vec3} out
     */
    vec3.negate = function(out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        out[2] = -a[2];
        return out;
    };

    /**
     * Returns the inverse of the components of a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to invert
     * @returns {vec3} out
     */
    vec3.inverse = function(out, a) {
        out[0] = 1.0 / a[0];
        out[1] = 1.0 / a[1];
        out[2] = 1.0 / a[2];
        return out;
    };

    /**
     * Normalize a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to normalize
     * @returns {vec3} out
     */
    vec3.normalize = function(out, a) {
        var x = a[0],
            y = a[1],
            z = a[2];
        var len = x*x + y*y + z*z;
        if (len > 0) {
            //TODO: evaluate use of glm_invsqrt here?
            len = 1 / Math.sqrt(len);
            out[0] = a[0] * len;
            out[1] = a[1] * len;
            out[2] = a[2] * len;
        }
        return out;
    };

    /**
     * Calculates the dot product of two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} dot product of a and b
     */
    vec3.dot = function (a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    };

    /**
     * Computes the cross product of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */
    vec3.cross = function(out, a, b) {
        var ax = a[0], ay = a[1], az = a[2],
            bx = b[0], by = b[1], bz = b[2];

        out[0] = ay * bz - az * by;
        out[1] = az * bx - ax * bz;
        out[2] = ax * by - ay * bx;
        return out;
    };

    /**
     * Performs a linear interpolation between two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec3} out
     */
    vec3.lerp = function (out, a, b, t) {
        var ax = a[0],
            ay = a[1],
            az = a[2];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        out[2] = az + t * (b[2] - az);
        return out;
    };

    /**
     * Performs a hermite interpolation with two control points
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {vec3} c the third operand
     * @param {vec3} d the fourth operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec3} out
     */
    vec3.hermite = function (out, a, b, c, d, t) {
        var factorTimes2 = t * t,
            factor1 = factorTimes2 * (2 * t - 3) + 1,
            factor2 = factorTimes2 * (t - 2) + t,
            factor3 = factorTimes2 * (t - 1),
            factor4 = factorTimes2 * (3 - 2 * t);

        out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
        out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
        out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

        return out;
    };

    /**
     * Performs a bezier interpolation with two control points
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @param {vec3} c the third operand
     * @param {vec3} d the fourth operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec3} out
     */
    vec3.bezier = function (out, a, b, c, d, t) {
        var inverseFactor = 1 - t,
            inverseFactorTimesTwo = inverseFactor * inverseFactor,
            factorTimes2 = t * t,
            factor1 = inverseFactorTimesTwo * inverseFactor,
            factor2 = 3 * t * inverseFactorTimesTwo,
            factor3 = 3 * factorTimes2 * inverseFactor,
            factor4 = factorTimes2 * t;

        out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
        out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
        out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

        return out;
    };

    /**
     * Generates a random vector with the given scale
     *
     * @param {vec3} out the receiving vector
     * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
     * @returns {vec3} out
     */
    vec3.random = function (out, scale) {
        scale = scale || 1.0;

        var r = glMatrix.RANDOM() * 2.0 * Math.PI;
        var z = (glMatrix.RANDOM() * 2.0) - 1.0;
        var zScale = Math.sqrt(1.0-z*z) * scale;

        out[0] = Math.cos(r) * zScale;
        out[1] = Math.sin(r) * zScale;
        out[2] = z * scale;
        return out;
    };

    /**
     * Transforms the vec3 with a mat4.
     * 4th vector component is implicitly '1'
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec3} out
     */
    vec3.transformMat4 = function(out, a, m) {
        var x = a[0], y = a[1], z = a[2],
            w = m[3] * x + m[7] * y + m[11] * z + m[15];
        w = w || 1.0;
        out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
        out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
        out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
        return out;
    };

    /**
     * Transforms the vec3 with a mat3.
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m the 3x3 matrix to transform with
     * @returns {vec3} out
     */
    vec3.transformMat3 = function(out, a, m) {
        var x = a[0], y = a[1], z = a[2];
        out[0] = x * m[0] + y * m[3] + z * m[6];
        out[1] = x * m[1] + y * m[4] + z * m[7];
        out[2] = x * m[2] + y * m[5] + z * m[8];
        return out;
    };

    /**
     * Transforms the vec3 with a quat
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {quat} q quaternion to transform with
     * @returns {vec3} out
     */
    vec3.transformQuat = function(out, a, q) {
        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

        var x = a[0], y = a[1], z = a[2],
            qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return out;
    };

    /**
     * Rotate a 3D vector around the x-axis
     * @param {vec3} out The receiving vec3
     * @param {vec3} a The vec3 point to rotate
     * @param {vec3} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @returns {vec3} out
     */
    vec3.rotateX = function(out, a, b, c){
        var p = [], r=[];
        //Translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];

        //perform rotation
        r[0] = p[0];
        r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
        r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

        //translate to correct position
        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];

        return out;
    };

    /**
     * Rotate a 3D vector around the y-axis
     * @param {vec3} out The receiving vec3
     * @param {vec3} a The vec3 point to rotate
     * @param {vec3} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @returns {vec3} out
     */
    vec3.rotateY = function(out, a, b, c){
        var p = [], r=[];
        //Translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];

        //perform rotation
        r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
        r[1] = p[1];
        r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

        //translate to correct position
        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];

        return out;
    };

    /**
     * Rotate a 3D vector around the z-axis
     * @param {vec3} out The receiving vec3
     * @param {vec3} a The vec3 point to rotate
     * @param {vec3} b The origin of the rotation
     * @param {Number} c The angle of rotation
     * @returns {vec3} out
     */
    vec3.rotateZ = function(out, a, b, c){
        var p = [], r=[];
        //Translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];

        //perform rotation
        r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
        r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
        r[2] = p[2];

        //translate to correct position
        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];

        return out;
    };

    /**
     * Perform some operation over an array of vec3s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */
    vec3.forEach = (function() {
        var vec = vec3.create();

        return function(a, stride, offset, count, fn, arg) {
            var i, l;
            if(!stride) {
                stride = 3;
            }

            if(!offset) {
                offset = 0;
            }

            if(count) {
                l = Math.min((count * stride) + offset, a.length);
            } else {
                l = a.length;
            }

            for(i = offset; i < l; i += stride) {
                vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
                fn(vec, vec, arg);
                a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
            }

            return a;
        };
    })();

    /**
     * Get the angle between two 3D vectors
     * @param {vec3} a The first operand
     * @param {vec3} b The second operand
     * @returns {Number} The angle in radians
     */
    vec3.angle = function(a, b) {

        var tempA = vec3.fromValues(a[0], a[1], a[2]);
        var tempB = vec3.fromValues(b[0], b[1], b[2]);

        vec3.normalize(tempA, tempA);
        vec3.normalize(tempB, tempB);

        var cosine = vec3.dot(tempA, tempB);

        if(cosine > 1.0){
            return 0;
        } else {
            return Math.acos(cosine);
        }
    };

    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} vec vector to represent as a string
     * @returns {String} string representation of the vector
     */
    vec3.str = function (a) {
        return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
    };

    module.exports = vec3;

},{"./common.js":117}],125:[function(require,module,exports){
    /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE. */

    var glMatrix = require("./common.js");

    /**
     * @class 4 Dimensional Vector
     * @name vec4
     */
    var vec4 = {};

    /**
     * Creates a new, empty vec4
     *
     * @returns {vec4} a new 4D vector
     */
    vec4.create = function() {
        var out = new glMatrix.ARRAY_TYPE(4);
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        return out;
    };

    /**
     * Creates a new vec4 initialized with values from an existing vector
     *
     * @param {vec4} a vector to clone
     * @returns {vec4} a new 4D vector
     */
    vec4.clone = function(a) {
        var out = new glMatrix.ARRAY_TYPE(4);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        return out;
    };

    /**
     * Creates a new vec4 initialized with the given values
     *
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {vec4} a new 4D vector
     */
    vec4.fromValues = function(x, y, z, w) {
        var out = new glMatrix.ARRAY_TYPE(4);
        out[0] = x;
        out[1] = y;
        out[2] = z;
        out[3] = w;
        return out;
    };

    /**
     * Copy the values from one vec4 to another
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the source vector
     * @returns {vec4} out
     */
    vec4.copy = function(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        return out;
    };

    /**
     * Set the components of a vec4 to the given values
     *
     * @param {vec4} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @param {Number} w W component
     * @returns {vec4} out
     */
    vec4.set = function(out, x, y, z, w) {
        out[0] = x;
        out[1] = y;
        out[2] = z;
        out[3] = w;
        return out;
    };

    /**
     * Adds two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    vec4.add = function(out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        out[2] = a[2] + b[2];
        out[3] = a[3] + b[3];
        return out;
    };

    /**
     * Subtracts vector b from vector a
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    vec4.subtract = function(out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        out[2] = a[2] - b[2];
        out[3] = a[3] - b[3];
        return out;
    };

    /**
     * Alias for {@link vec4.subtract}
     * @function
     */
    vec4.sub = vec4.subtract;

    /**
     * Multiplies two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    vec4.multiply = function(out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        out[2] = a[2] * b[2];
        out[3] = a[3] * b[3];
        return out;
    };

    /**
     * Alias for {@link vec4.multiply}
     * @function
     */
    vec4.mul = vec4.multiply;

    /**
     * Divides two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    vec4.divide = function(out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        out[2] = a[2] / b[2];
        out[3] = a[3] / b[3];
        return out;
    };

    /**
     * Alias for {@link vec4.divide}
     * @function
     */
    vec4.div = vec4.divide;

    /**
     * Returns the minimum of two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    vec4.min = function(out, a, b) {
        out[0] = Math.min(a[0], b[0]);
        out[1] = Math.min(a[1], b[1]);
        out[2] = Math.min(a[2], b[2]);
        out[3] = Math.min(a[3], b[3]);
        return out;
    };

    /**
     * Returns the maximum of two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {vec4} out
     */
    vec4.max = function(out, a, b) {
        out[0] = Math.max(a[0], b[0]);
        out[1] = Math.max(a[1], b[1]);
        out[2] = Math.max(a[2], b[2]);
        out[3] = Math.max(a[3], b[3]);
        return out;
    };

    /**
     * Scales a vec4 by a scalar number
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec4} out
     */
    vec4.scale = function(out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        out[2] = a[2] * b;
        out[3] = a[3] * b;
        return out;
    };

    /**
     * Adds two vec4's after scaling the second operand by a scalar value
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @param {Number} scale the amount to scale b by before adding
     * @returns {vec4} out
     */
    vec4.scaleAndAdd = function(out, a, b, scale) {
        out[0] = a[0] + (b[0] * scale);
        out[1] = a[1] + (b[1] * scale);
        out[2] = a[2] + (b[2] * scale);
        out[3] = a[3] + (b[3] * scale);
        return out;
    };

    /**
     * Calculates the euclidian distance between two vec4's
     *
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {Number} distance between a and b
     */
    vec4.distance = function(a, b) {
        var x = b[0] - a[0],
            y = b[1] - a[1],
            z = b[2] - a[2],
            w = b[3] - a[3];
        return Math.sqrt(x*x + y*y + z*z + w*w);
    };

    /**
     * Alias for {@link vec4.distance}
     * @function
     */
    vec4.dist = vec4.distance;

    /**
     * Calculates the squared euclidian distance between two vec4's
     *
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {Number} squared distance between a and b
     */
    vec4.squaredDistance = function(a, b) {
        var x = b[0] - a[0],
            y = b[1] - a[1],
            z = b[2] - a[2],
            w = b[3] - a[3];
        return x*x + y*y + z*z + w*w;
    };

    /**
     * Alias for {@link vec4.squaredDistance}
     * @function
     */
    vec4.sqrDist = vec4.squaredDistance;

    /**
     * Calculates the length of a vec4
     *
     * @param {vec4} a vector to calculate length of
     * @returns {Number} length of a
     */
    vec4.length = function (a) {
        var x = a[0],
            y = a[1],
            z = a[2],
            w = a[3];
        return Math.sqrt(x*x + y*y + z*z + w*w);
    };

    /**
     * Alias for {@link vec4.length}
     * @function
     */
    vec4.len = vec4.length;

    /**
     * Calculates the squared length of a vec4
     *
     * @param {vec4} a vector to calculate squared length of
     * @returns {Number} squared length of a
     */
    vec4.squaredLength = function (a) {
        var x = a[0],
            y = a[1],
            z = a[2],
            w = a[3];
        return x*x + y*y + z*z + w*w;
    };

    /**
     * Alias for {@link vec4.squaredLength}
     * @function
     */
    vec4.sqrLen = vec4.squaredLength;

    /**
     * Negates the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to negate
     * @returns {vec4} out
     */
    vec4.negate = function(out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        out[2] = -a[2];
        out[3] = -a[3];
        return out;
    };

    /**
     * Returns the inverse of the components of a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to invert
     * @returns {vec4} out
     */
    vec4.inverse = function(out, a) {
        out[0] = 1.0 / a[0];
        out[1] = 1.0 / a[1];
        out[2] = 1.0 / a[2];
        out[3] = 1.0 / a[3];
        return out;
    };

    /**
     * Normalize a vec4
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a vector to normalize
     * @returns {vec4} out
     */
    vec4.normalize = function(out, a) {
        var x = a[0],
            y = a[1],
            z = a[2],
            w = a[3];
        var len = x*x + y*y + z*z + w*w;
        if (len > 0) {
            len = 1 / Math.sqrt(len);
            out[0] = x * len;
            out[1] = y * len;
            out[2] = z * len;
            out[3] = w * len;
        }
        return out;
    };

    /**
     * Calculates the dot product of two vec4's
     *
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @returns {Number} dot product of a and b
     */
    vec4.dot = function (a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    };

    /**
     * Performs a linear interpolation between two vec4's
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the first operand
     * @param {vec4} b the second operand
     * @param {Number} t interpolation amount between the two inputs
     * @returns {vec4} out
     */
    vec4.lerp = function (out, a, b, t) {
        var ax = a[0],
            ay = a[1],
            az = a[2],
            aw = a[3];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        out[2] = az + t * (b[2] - az);
        out[3] = aw + t * (b[3] - aw);
        return out;
    };

    /**
     * Generates a random vector with the given scale
     *
     * @param {vec4} out the receiving vector
     * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
     * @returns {vec4} out
     */
    vec4.random = function (out, scale) {
        scale = scale || 1.0;

        //TODO: This is a pretty awful way of doing this. Find something better.
        out[0] = glMatrix.RANDOM();
        out[1] = glMatrix.RANDOM();
        out[2] = glMatrix.RANDOM();
        out[3] = glMatrix.RANDOM();
        vec4.normalize(out, out);
        vec4.scale(out, out, scale);
        return out;
    };

    /**
     * Transforms the vec4 with a mat4.
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec4} out
     */
    vec4.transformMat4 = function(out, a, m) {
        var x = a[0], y = a[1], z = a[2], w = a[3];
        out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
        out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
        out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
        out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
        return out;
    };

    /**
     * Transforms the vec4 with a quat
     *
     * @param {vec4} out the receiving vector
     * @param {vec4} a the vector to transform
     * @param {quat} q quaternion to transform with
     * @returns {vec4} out
     */
    vec4.transformQuat = function(out, a, q) {
        var x = a[0], y = a[1], z = a[2],
            qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        out[3] = a[3];
        return out;
    };

    /**
     * Perform some operation over an array of vec4s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */
    vec4.forEach = (function() {
        var vec = vec4.create();

        return function(a, stride, offset, count, fn, arg) {
            var i, l;
            if(!stride) {
                stride = 4;
            }

            if(!offset) {
                offset = 0;
            }

            if(count) {
                l = Math.min((count * stride) + offset, a.length);
            } else {
                l = a.length;
            }

            for(i = offset; i < l; i += stride) {
                vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
                fn(vec, vec, arg);
                a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
            }

            return a;
        };
    })();

    /**
     * Returns a string representation of a vector
     *
     * @param {vec4} vec vector to represent as a string
     * @returns {String} string representation of the vector
     */
    vec4.str = function (a) {
        return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
    };

    module.exports = vec4;

},{"./common.js":117}],126:[function(require,module,exports){
    'use strict';

    function constant(value) {
        return function() {
            return value;
        }
    }

    function interpolateNumber(a, b, t) {
        return (a * (1 - t)) + (b * t);
    }

    function interpolateArray(a, b, t) {
        var result = [];
        for (var i = 0; i < a.length; i++) {
            result[i] = interpolateNumber(a[i], b[i], t);
        }
        return result;
    }

    exports['interpolated'] = function(f) {
        if (!f.stops) {
            return constant(f);
        }

        var stops = f.stops,
            base = f.base || 1,
            interpolate = Array.isArray(stops[0][1]) ? interpolateArray : interpolateNumber;

        return function(z) {
            // find the two stops which the current z is between
            var low, high;

            for (var i = 0; i < stops.length; i++) {
                var stop = stops[i];

                if (stop[0] <= z) {
                    low = stop;
                }

                if (stop[0] > z) {
                    high = stop;
                    break;
                }
            }

            if (low && high) {
                var zoomDiff = high[0] - low[0],
                    zoomProgress = z - low[0],

                    t = base === 1 ?
                        zoomProgress / zoomDiff :
                        (Math.pow(base, zoomProgress) - 1) / (Math.pow(base, zoomDiff) - 1);

                return interpolate(low[1], high[1], t);

            } else if (low) {
                return low[1];

            } else if (high) {
                return high[1];
            }
        };
    };

    exports['piecewise-constant'] = function(f) {
        if (!f.stops) {
            return constant(f);
        }

        var stops = f.stops;

        return function(z) {
            for (var i = 0; i < stops.length; i++) {
                if (stops[i][0] > z) {
                    return stops[i === 0 ? 0 : i - 1][1];
                }
            }

            return stops[stops.length - 1][1];
        }
    };

},{}],127:[function(require,module,exports){
    'use strict';

    var reference = require('../../reference/latest.js');
    var validate = require('./parsed');

    module.exports = function(style) {
        return validate(style, reference);
    };

},{"../../reference/latest.js":129,"./parsed":128}],128:[function(require,module,exports){
    'use strict';

    var parseCSSColor = require('csscolorparser').parseCSSColor;
    var format = require('util').format;

    module.exports = function(style, reference) {

        var constants = style.constants || {},
            layers = {},
            errors = [];

        function error(key, val /*, message, ...*/) {
            var err = {
                message: (key ? key + ': ' : '') +
                    format.apply(format, Array.prototype.slice.call(arguments, 2))
            };

            if (val !== null && val !== undefined && val.__line__) {
                err.line = val.__line__;
            }

            errors.push(err);
        }

        // Main recursive validation function. Tracks:
        //
        // - key: string representing location of validation in style tree. Used only
        //   for more informative error reporting.
        // - val: current value from style being evaluated. May be anything from a
        //   high level object that needs to be descended into deeper or a simple
        //   scalar value.
        // - spec: current spec being evaluated. Tracks val.
        //
        function validate(key, val, spec) {
            var type = typeof_(val);

            // Constants
            if (type === 'string' && val[0] === '@') {
                if (!(val in constants)) {
                    return error(key, val, 'constant "%s" not found', val);
                }
                val = constants[val];
                type = typeof_(val);
            }

            // Functions
            if (spec.function && type === 'object') {
                return validate.function(key, val, spec);
            }

            if (spec.type) {
                var validator = validate[spec.type];
                if (validator) {
                    return validator(key, val, spec);
                }
                spec = reference[spec.type];
            }

            validate.object(key, val, spec);
        }

        validate.constants = function(key, val) {
            var type = typeof_(val);
            if (type !== 'object') {
                return error(key, val, 'object expected, %s found', type);
            }

            for (var k in val) {
                if (k[0] !== '@') {
                    error(key + '.' + k, val[k], 'constants must start with "@"');
                }
            }
        };

        validate.source = function(key, val) {
            if (!val.type) {
                error(key, val, '"type" is required');
                return;
            }

            var type = unbundle(val.type);
            switch (type) {
                case 'vector':
                case 'raster':
                    validate.object(key, val, reference.source_tile);

                    if ('url' in val) {
                        for (var prop in val) {
                            if (['type', 'url', 'tileSize'].indexOf(prop) < 0) {
                                error(key + '.' + prop, val[prop], 'a source with a "url" property may not include a "%s" property', prop);
                            }
                        }
                    }

                    break;
                case 'geojson':
                    validate.object(key, val, reference.source_geojson);
                    break;
                case 'video':
                    validate.object(key, val, reference.source_video);
                    break;
                default:
                    validate.enum(key + '.type', val.type, {values: ['vector', 'raster', 'geojson', 'video']});
            }
        };

        validate.layer = function(key, val) {
            if (!val.type && !val.ref) {
                error(key, val, 'either "type" or "ref" is required');
            }

            var type = unbundle(val.type),
                ref = unbundle(val.ref);

            if (val.id) {
                if (layers[val.id]) {
                    error(key, val.id, 'duplicate layer id "%s", previously used at line %d', val.id, layers[val.id]);
                } else {
                    layers[val.id] = val.id.__line__;
                }
            }

            if ('ref' in val) {
                ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
                    if (p in val) {
                        error(key, val[p], '"%s" is prohibited for ref layers', p);
                    }
                });

                var parent;

                style.layers.forEach(function(layer) {
                    if (layer.id == ref) parent = layer;
                });

                if (!parent) {
                    error(key, val.ref, 'ref layer "%s" not found', ref);
                } else if (parent.ref) {
                    error(key, val.ref, 'ref cannot reference another ref layer');
                } else {
                    type = parent.type;
                }
            } else if (type !== 'background') {
                if (!val.source) {
                    error(key, val, 'missing required property "source"');
                } else {
                    var source = style.sources[val.source];
                    if (!source) {
                        error(key, val.source, 'source "%s" not found', val.source);
                    } else if (source.type == 'vector' && type == 'raster') {
                        error(key, val.source, 'layer "%s" requires a raster source', val.id);
                    } else if (source.type == 'raster' && type != 'raster') {
                        error(key, val.source, 'layer "%s" requires a vector source', val.id);
                    }
                }
            }

            validate.object(key, val, reference.layer, {
                filter: validate.filter,
                layout: function(key, val) {
                    var spec = reference['layout_' + type];
                    return type && spec && validate(key, val, spec);
                },
                paint: function(key, val) {
                    var spec = reference['paint_' + type];
                    return type && spec && validate(key, val, spec);
                }
            });
        };

        validate.object = function (key, val, spec, validators) {
            validators = validators || {};

            var type = typeof_(val);
            if (type !== 'object') {
                return error(key, val, 'object expected, %s found', type);
            }

            for (var k in val) {
                var speckey = k.split('.')[0]; // treat 'paint.*' as 'paint'
                var def = spec[speckey] || spec['*'];
                var transition = speckey.match(/^(.*)-transition$/);

                if (def) {
                    (validators[speckey] || validate)((key ? key + '.' : key) + k, val[k], def);
                } else if (transition && spec[transition[1]] && spec[transition[1]].transition) {
                    validate((key ? key + '.' : key) + k, val[k], reference.transition);
                    // tolerate root-level extra keys & arbitrary layer properties
                } else if (key !== '' && key.split('.').length !== 1) {
                    error(key, val[k], 'unknown property "%s"', k);
                }
            }

            for (var l in spec) {
                if (spec[l].required && spec[l]['default'] === undefined && val[l] === undefined) {
                    error(key, val, 'missing required property "%s"', l);
                }
            }
        };

        validate.array = function (key, val, spec, validator) {
            if (typeof_(val) !== 'array') {
                return error(key, val, 'array expected, %s found', typeof_(val));
            }

            if (spec.length && val.length !== spec.length) {
                return error(key, val, 'array length %d expected, length %d found', spec.length, val.length);
            }

            var value = {
                "type": spec.value
            };

            if (style.version < 7) {
                value.function = spec.function;
            }

            if (typeof_(spec.value) === 'object') {
                value = spec.value;
            }

            for (var i = 0; i < val.length; i++) {
                (validator || validate)(key + '[' + i + ']', val[i], value);
            }
        };

        validate.filter = function(key, val) {
            var type;

            if (typeof_(val) !== 'array') {
                return error(key, val, 'array expected, %s found', typeof_(val));
            }

            if (val.length < 1) {
                return error(key, val, 'filter array must have at least 1 element');
            }

            validate.enum(key + '[0]', val[0], reference.filter_operator);

            switch (unbundle(val[0])) {
                case '<':
                case '<=':
                case '>':
                case '>=':
                    if (val.length >= 2 && val[1] == '$type') {
                        error(key, val, '"$type" cannot be use with operator "%s"', val[0]);
                    }
                /* falls through */
                case '==':
                case '!=':
                    if (val.length != 3) {
                        error(key, val, 'filter array for operator "%s" must have 3 elements', val[0]);
                    }
                /* falls through */
                case 'in':
                case '!in':
                    if (val.length >= 2) {
                        type = typeof_(val[1]);
                        if (type !== 'string') {
                            error(key + '[1]', val[1], 'string expected, %s found', type);
                        } else if (val[1][0] === '@') {
                            error(key + '[1]', val[1], 'filter key cannot be a constant');
                        }
                    }
                    for (var i = 2; i < val.length; i++) {
                        type = typeof_(val[i]);
                        if (val[1] == '$type') {
                            validate.enum(key + '[' + i + ']', val[i], reference.geometry_type);
                        } else if (type === 'string' && val[i][0] === '@') {
                            error(key + '[' + i + ']', val[i], 'filter value cannot be a constant');
                        } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                            error(key + '[' + i + ']', val[i], 'string, number, or boolean expected, %s found', type);
                        }
                    }
                    break;

                case 'any':
                case 'all':
                case 'none':
                    for (i = 1; i < val.length; i++) {
                        validate.filter(key + '[' + i + ']', val[i]);
                    }
                    break;
            }
        };

        validate.function = function(key, val, spec) {
            validate.object(key, val, reference.function, {
                stops: function (key, val, arraySpec) {
                    var lastStop = -Infinity;
                    validate.array(key, val, arraySpec, function validateStop(key, val) {
                        if (typeof_(val) !== 'array') {
                            return error(key, val, 'array expected, %s found', typeof_(val));
                        }

                        if (val.length !== 2) {
                            return error(key, val, 'array length %d expected, length %d found', 2, val.length);
                        }

                        validate(key + '[0]', val[0], {type: 'number'});
                        validate(key + '[1]', val[1], spec);

                        if (typeof_(val[0]) === 'number') {
                            if (spec.function === 'piecewise-constant' && val[0] % 1 !== 0) {
                                error(key + '[0]', val[0], 'zoom level for piecewise-constant functions must be an integer');
                            }

                            if (val[0] < lastStop) {
                                error(key + '[0]', val[0], 'array stops must appear in ascending order');
                            }

                            lastStop = val[0];
                        }
                    });

                    if (typeof_(val) === 'array' && val.length === 0) {
                        error(key, val, 'array must have at least one stop');
                    }
                }
            });
        };

        validate.enum = function (key, val, spec) {
            if (spec.values.indexOf(unbundle(val)) === -1) {
                error(key, val, 'expected one of [%s], %s found', spec.values.join(', '), val);
            }
        };

        validate.color = function(key, val) {
            var type = typeof_(val);
            if (type !== 'string') {
                error(key, val, 'color expected, %s found', type);
            } else if (parseCSSColor(val) === null) {
                error(key, val, 'color expected, "%s" found', val);
            }
        };

        function typeValidator(expected) {
            return function(key, val, spec) {
                var actual = typeof_(val);
                if (actual !== expected) {
                    error(key, val, '%s expected, %s found', expected, actual);
                }

                if ('minimum' in spec && val < spec.minimum) {
                    error(key, val, '%s is less than the minimum value %s', val, spec.minimum);
                }

                if ('maximum' in spec && val > spec.maximum) {
                    error(key, val, '%s is greater than the maximum value %s', val, spec.maximum);
                }
            };
        }

        validate.number = typeValidator('number');
        validate.string = typeValidator('string');
        validate.boolean = typeValidator('boolean');

        validate['*'] = function() {};

        validate('', style, reference.$root);

        return errors;
    };

    function typeof_(val) {
        if (val instanceof Number)
            return 'number';
        if (val instanceof String)
            return 'string';
        if (val instanceof Boolean)
            return 'boolean';
        if (Array.isArray(val))
            return 'array';
        if (val === null)
            return 'null';
        return typeof val;
    }

    function unbundle(_) {
        if (_ instanceof Number ||
            _ instanceof String ||
            _ instanceof Boolean) {
            return _.valueOf();
        } else {
            return _;
        }
    }

},{"csscolorparser":108,"util":107}],129:[function(require,module,exports){
    module.exports = require('./v7.json');

},{"./v7.json":130}],130:[function(require,module,exports){
    module.exports={
        "$version": 7,
        "$root": {
            "version": {
                "required": true,
                "type": "enum",
                "values": [
                    7
                ],
                "doc": "Stylesheet version number. Must be 7."
            },
            "name": {
                "type": "string",
                "doc": "A human-readable name for the style."
            },
            "constants": {
                "type": "constants",
                "doc": "An object of constants to be referenced in layers."
            },
            "sources": {
                "required": true,
                "type": "sources",
                "doc": "Data source specifications."
            },
            "sprite": {
                "type": "string",
                "doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended."
            },
            "glyphs": {
                "type": "string",
                "doc": "A URL template for loading signed-distance-field glyph sets in PBF format. Valid tokens are {fontstack} and {range}."
            },
            "transition": {
                "type": "transition",
                "doc": "A global transition definition to use as a default across properties."
            },
            "layers": {
                "required": true,
                "type": "array",
                "value": "layer",
                "doc": "Layers will be drawn in the order of this array."
            }
        },
        "constants": {
            "*": {
                "type": "*",
                "doc": "A constant that will be replaced verbatim in the referencing place. This can be anything, including objects and arrays. All variable names must be prefixed with an `@` symbol."
            }
        },
        "sources": {
            "*": {
                "type": "source",
                "doc": "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided."
            }
        },
        "source": [
            "source_tile",
            "source_geojson",
            "source_video"
        ],
        "source_tile": {
            "type": {
                "required": true,
                "type": "enum",
                "values": [
                    "vector",
                    "raster"
                ],
                "doc": "The data type of the source."
            },
            "url": {
                "type": "string",
                "doc": "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."
            },
            "tiles": {
                "type": "array",
                "value": "string",
                "doc": "An array of one or more tile source URLs, as in the TileJSON spec."
            },
            "minzoom": {
                "type": "number",
                "default": 0,
                "doc": "Minimum zoom level for which tiles are available, as in the TileJSON spec."
            },
            "maxzoom": {
                "type": "number",
                "default": 22,
                "doc": "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
            },
            "tileSize": {
                "type": "number",
                "default": 512,
                "units": "pixels",
                "doc": "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
            },
            "*": {
                "type": "*",
                "doc": "Other keys to configure the data source."
            }
        },
        "source_geojson": {
            "type": {
                "required": true,
                "type": "enum",
                "values": [
                    "geojson"
                ]
            },
            "data": {
                "type": "*"
            }
        },
        "source_video": {
            "type": {
                "required": true,
                "type": "enum",
                "values": [
                    "video"
                ]
            },
            "url": {
                "required": true,
                "type": "array",
                "value": "string",
                "doc": "URLs to video content in order of preferred format."
            },
            "coordinates": {
                "required": true,
                "type": "array",
                "length": 4,
                "value": {
                    "type": "array",
                    "length": 2,
                    "value": "number"
                }
            }
        },
        "layer": {
            "id": {
                "type": "string",
                "doc": "Unique layer name."
            },
            "type": {
                "type": "enum",
                "values": [
                    "fill",
                    "line",
                    "symbol",
                    "raster",
                    "background"
                ],
                "doc": "Rendering type of this layer."
            },
            "ref": {
                "type": "string",
                "doc": "References another layer to copy `type`, `source`, `source-layer`, `minzoom`, `maxzoom`, `filter`, and `layout` properties from. This allows the layers to share processing and be more efficient."
            },
            "source": {
                "type": "string",
                "doc": "Name of a source description to be used for this layer."
            },
            "source-layer": {
                "type": "string",
                "doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
            },
            "minzoom": {
                "type": "number",
                "minimum": 0,
                "maximum": 22,
                "doc": "The minimum zoom level on which the layer gets parsed and appears on."
            },
            "maxzoom": {
                "type": "number",
                "minimum": 0,
                "maximum": 22,
                "doc": "The maximum zoom level on which the layer gets parsed and appears on."
            },
            "interactive": {
                "type": "boolean",
                "doc": "Enable querying of feature data from this layer for interactivity.",
                "default": false
            },
            "filter": {
                "type": "filter",
                "doc": "A expression specifying conditions on source features. Only features that match the filter are displayed."
            },
            "layout": {
                "type": "layout",
                "doc": "Layout properties for the layer."
            },
            "paint": {
                "type": "paint",
                "doc": "Default paint properties for this layer."
            },
            "paint.*": {
                "type": "paint",
                "doc": "Class-specific paint properties for this layer. The class name is the part after the first dot."
            }
        },
        "layout": [
            "layout_fill",
            "layout_line",
            "layout_symbol",
            "layout_raster",
            "layout_background"
        ],
        "layout_background": {
            "visibility": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "visible",
                    "none"
                ],
                "default": "visible",
                "doc": "The display of this layer. `none` hides this layer."
            }
        },
        "layout_fill": {
            "visibility": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "visible",
                    "none"
                ],
                "default": "visible",
                "doc": "The display of this layer. `none` hides this layer."
            }
        },
        "layout_line": {
            "line-cap": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "butt",
                    "round",
                    "square"
                ],
                "default": "butt",
                "doc": "The display of line endings."
            },
            "line-join": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "bevel",
                    "round",
                    "miter"
                ],
                "default": "miter",
                "doc": "The display of lines when joining."
            },
            "line-miter-limit": {
                "type": "number",
                "default": 2,
                "function": "interpolated",
                "doc": "Used to automatically convert miter joins to bevel joins for sharp angles.",
                "requires": [
                    {
                        "line-join": "miter"
                    }
                ]
            },
            "line-round-limit": {
                "type": "number",
                "default": 1,
                "function": "interpolated",
                "doc": "Used to automatically convert round joins to miter joins for shallow angles.",
                "requires": [
                    {
                        "line-join": "round"
                    }
                ]
            },
            "visibility": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "visible",
                    "none"
                ],
                "default": "visible",
                "doc": "The display of this layer. `none` hides this layer."
            }
        },
        "layout_symbol": {
            "symbol-placement": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "point",
                    "line"
                ],
                "default": "point",
                "doc": "Label placement relative to its geometry. `line` can only be used on LineStrings and Polygons."
            },
            "symbol-min-distance": {
                "type": "number",
                "default": 250,
                "minimum": 1,
                "function": "interpolated",
                "units": "pixels",
                "doc": "Minimum distance between two symbol anchors.",
                "requires": [
                    {
                        "symbol-placement": "line"
                    }
                ]
            },
            "symbol-avoid-edges": {
                "type": "boolean",
                "function": "piecewise-constant",
                "default": false,
                "doc": "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer."
            },
            "icon-allow-overlap": {
                "type": "boolean",
                "function": "piecewise-constant",
                "default": false,
                "doc": "If true, the icon will be visible even if it collides with other icons and text.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-ignore-placement": {
                "type": "boolean",
                "function": "piecewise-constant",
                "default": false,
                "doc": "If true, the icon won't affect placement of other icons and text.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-optional": {
                "type": "boolean",
                "function": "piecewise-constant",
                "default": false,
                "doc": "If true, the symbol will appear without its icon, in spaces where the icon would make it too large to fit.",
                "requires": [
                    "icon-image",
                    "text-field"
                ]
            },
            "icon-rotation-alignment": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "map",
                    "viewport"
                ],
                "default": "viewport",
                "doc": "Orientation of icon when map is rotated.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-max-size": {
                "type": "number",
                "default": 1,
                "minimum": 0,
                "function": "interpolated",
                "doc": "The maximum factor to scale the icon.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-image": {
                "type": "string",
                "function": "piecewise-constant",
                "doc": "A string with {tokens} replaced, referencing the data property to pull from.",
                "tokens": true
            },
            "icon-rotate": {
                "type": "number",
                "default": 0,
                "period": 360,
                "function": "interpolated",
                "units": "degrees",
                "doc": "Rotates the icon clockwise.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-padding": {
                "type": "number",
                "default": 2,
                "minimum": 0,
                "function": "interpolated",
                "units": "pixels",
                "doc": "Padding value around icon bounding box to avoid icon collisions.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-keep-upright": {
                "type": "boolean",
                "function": "piecewise-constant",
                "default": false,
                "doc": "If true, the icon may be flipped to prevent it from being rendered upside-down",
                "requires": [
                    "icon-image",
                    {
                        "icon-rotation-alignment": "map"
                    }
                ]
            },
            "icon-offset": {
                "type": "array",
                "value": "number",
                "length": 2,
                "default": [
                    0,
                    0
                ],
                "function": "interpolated",
                "doc": "Icon's offset distance. Values are [x, y] where negatives indicate left and up, respectively.",
                "requires": [
                    "icon-image"
                ]
            },
            "text-rotation-alignment": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "map",
                    "viewport"
                ],
                "default": "viewport",
                "doc": "Orientation of icon or text when map is rotated.",
                "requires": [
                    "text-field"
                ]
            },
            "text-field": {
                "type": "string",
                "function": "piecewise-constant",
                "default": "",
                "tokens": true,
                "doc": "Value to use for a text label. Feature properties are specified using tokens like {field_name}."
            },
            "text-font": {
                "type": "string",
                "function": "piecewise-constant",
                "default": "Open Sans Regular, Arial Unicode MS Regular",
                "doc": "Font stack to use for displaying text.",
                "requires": [
                    "text-field"
                ]
            },
            "text-max-size": {
                "type": "number",
                "default": 16,
                "minimum": 0,
                "units": "pixels",
                "function": "interpolated",
                "doc": "The maximum size text will be laid out, to calculate collisions with.",
                "requires": [
                    "text-field"
                ]
            },
            "text-max-width": {
                "type": "number",
                "default": 15,
                "minimum": 0,
                "units": "em",
                "function": "interpolated",
                "doc": "The maximum line width for text wrapping.",
                "requires": [
                    "text-field"
                ]
            },
            "text-line-height": {
                "type": "number",
                "default": 1.2,
                "units": "em",
                "function": "interpolated",
                "doc": "Text leading value for multi-line text.",
                "requires": [
                    "text-field"
                ]
            },
            "text-letter-spacing": {
                "type": "number",
                "default": 0,
                "units": "em",
                "function": "interpolated",
                "doc": "Text kerning value.",
                "requires": [
                    "text-field"
                ]
            },
            "text-justify": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "left",
                    "center",
                    "right"
                ],
                "default": "center",
                "doc": "Text justification options.",
                "requires": [
                    "text-field"
                ]
            },
            "text-anchor": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "center",
                    "left",
                    "right",
                    "top",
                    "bottom",
                    "top-left",
                    "top-right",
                    "bottom-left",
                    "bottom-right"
                ],
                "default": "center",
                "doc": "Which part of the text to place closest to the anchor.",
                "requires": [
                    "text-field"
                ]
            },
            "text-max-angle": {
                "type": "number",
                "default": 45,
                "units": "degrees",
                "function": "interpolated",
                "doc": "Maximum angle change between adjacent characters.",
                "requires": [
                    "text-field",
                    {
                        "symbol-placement": "line"
                    }
                ]
            },
            "text-rotate": {
                "type": "number",
                "default": 0,
                "period": 360,
                "units": "degrees",
                "function": "interpolated",
                "doc": "Rotates the text clockwise.",
                "requires": [
                    "text-field"
                ]
            },
            "text-padding": {
                "type": "number",
                "default": 2,
                "minimum": 0,
                "units": "pixels",
                "function": "interpolated",
                "doc": "Padding value around text bounding box to avoid label collisions.",
                "requires": [
                    "text-field"
                ]
            },
            "text-keep-upright": {
                "type": "boolean",
                "function": "piecewise-constant",
                "default": true,
                "doc": "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
                "requires": [
                    "text-field",
                    {
                        "text-rotation-alignment": "map"
                    }
                ]
            },
            "text-transform": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "none",
                    "uppercase",
                    "lowercase"
                ],
                "default": "none",
                "doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
                "requires": [
                    "text-field"
                ]
            },
            "text-offset": {
                "type": "array",
                "doc": "Specifies the distance that text is offset from its anchor horizontally and vertically.",
                "value": "number",
                "units": "ems",
                "function": "interpolated",
                "length": 2,
                "default": [
                    0,
                    0
                ],
                "requires": [
                    "text-field"
                ]
            },
            "text-allow-overlap": {
                "type": "boolean",
                "function": "piecewise-constant",
                "default": false,
                "doc": "If true, the text will be visible even if it collides with other icons and labels.",
                "requires": [
                    "text-field"
                ]
            },
            "text-ignore-placement": {
                "type": "boolean",
                "function": "piecewise-constant",
                "default": false,
                "doc": "If true, the text won't affect placement of other icons and labels.",
                "requires": [
                    "text-field"
                ]
            },
            "text-optional": {
                "type": "boolean",
                "function": "piecewise-constant",
                "default": false,
                "doc": "If true, the symbol will appear without its text, in spaces where the text would make it too large to fit.",
                "requires": [
                    "text-field",
                    "icon-image"
                ]
            },
            "visibility": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "visible",
                    "none"
                ],
                "default": "visible",
                "doc": "The display of this layer. `none` hides this layer."
            }
        },
        "layout_raster": {
            "visibility": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "visible",
                    "none"
                ],
                "default": "visible",
                "doc": "The display of this layer. `none` hides this layer."
            }
        },
        "filter": {
            "type": "array",
            "value": "*"
        },
        "filter_operator": {
            "type": "enum",
            "values": [
                "==",
                "!=",
                ">",
                ">=",
                "<",
                "<=",
                "in",
                "!in",
                "all",
                "any",
                "none"
            ]
        },
        "geometry_type": {
            "type": "enum",
            "values": [
                "Point",
                "LineString",
                "Polygon"
            ]
        },
        "function": {
            "stops": {
                "type": "array",
                "required": true,
                "doc": "An array of stops.",
                "value": "function_stop"
            },
            "base": {
                "type": "number",
                "default": 1,
                "minimum": 0,
                "doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
            }
        },
        "function_stop": {
            "type": "array",
            "minimum": 0,
            "maximum": 22,
            "value": [
                "number",
                "color"
            ],
            "length": 2,
            "doc": "Zoom level and value pair."
        },
        "paint": [
            "paint_fill",
            "paint_line",
            "paint_symbol",
            "paint_raster",
            "paint_background"
        ],
        "paint_fill": {
            "fill-antialias": {
                "type": "boolean",
                "function": "piecewise-constant",
                "default": true,
                "doc": "Whether or not the fill should be antialiased."
            },
            "fill-opacity": {
                "type": "number",
                "function": "interpolated",
                "default": 1,
                "minimum": 0,
                "maximum": 1,
                "doc": "The opacity given to the fill color.",
                "transition": true
            },
            "fill-color": {
                "type": "color",
                "default": "#000000",
                "doc": "The color of the fill.",
                "function": "interpolated",
                "transition": true,
                "requires": [
                    {
                        "!": "fill-image"
                    }
                ]
            },
            "fill-outline-color": {
                "type": "color",
                "doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
                "function": "interpolated",
                "transition": true,
                "requires": [
                    {
                        "!": "fill-image"
                    },
                    {
                        "fill-antialias": true
                    }
                ]
            },
            "fill-translate": {
                "type": "array",
                "value": "number",
                "length": 2,
                "default": [
                    0,
                    0
                ],
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
            },
            "fill-translate-anchor": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "map",
                    "viewport"
                ],
                "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
                "default": "map",
                "requires": [
                    "fill-translate"
                ]
            },
            "fill-image": {
                "type": "string",
                "function": "piecewise-constant",
                "transition": true,
                "doc": "Name of image in sprite to use for drawing image fills."
            }
        },
        "paint_line": {
            "line-opacity": {
                "type": "number",
                "doc": "The opacity at which the line will be drawn.",
                "function": "interpolated",
                "default": 1,
                "minimum": 0,
                "maximum": 1,
                "transition": true
            },
            "line-color": {
                "type": "color",
                "doc": "The color with which the line will be drawn.",
                "default": "#000000",
                "function": "interpolated",
                "transition": true,
                "requires": [
                    {
                        "!": "line-image"
                    }
                ]
            },
            "line-translate": {
                "type": "array",
                "value": "number",
                "length": 2,
                "default": [
                    0,
                    0
                ],
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
            },
            "line-translate-anchor": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "map",
                    "viewport"
                ],
                "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
                "default": "map",
                "requires": [
                    "line-translate"
                ]
            },
            "line-width": {
                "type": "number",
                "default": 1,
                "minimum": 0,
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "Stroke thickness."
            },
            "line-gap-width": {
                "type": "number",
                "default": 0,
                "minimum": 0,
                "doc": "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
                "function": "interpolated",
                "transition": true,
                "units": "pixels"
            },
            "line-blur": {
                "type": "number",
                "default": 0,
                "minimum": 0,
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "Blur applied to the line, in pixels."
            },
            "line-dasharray": {
                "type": "array",
                "function": "piecewise-constant",
                "value": "number",
                "doc": "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width.",
                "minimum": 0,
                "transition": true,
                "units": "line widths",
                "requires": [
                    {
                        "!": "line-image"
                    }
                ]
            },
            "line-image": {
                "type": "string",
                "function": "piecewise-constant",
                "transition": true,
                "doc": "Name of image in sprite to use for drawing image lines."
            }
        },
        "paint_symbol": {
            "icon-opacity": {
                "doc": "The opacity at which the icon will be drawn.",
                "type": "number",
                "default": 1,
                "minimum": 0,
                "maximum": 1,
                "function": "interpolated",
                "transition": true,
                "requires": [
                    "icon-image"
                ]
            },
            "icon-size": {
                "type": "number",
                "default": 1,
                "function": "interpolated",
                "transition": true,
                "doc": "Scale factor for icon. 1 is original size, 3 triples the size.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-color": {
                "type": "color",
                "default": "#000000",
                "function": "interpolated",
                "transition": true,
                "doc": "The color of the icon. This can only be used with sdf icons.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-halo-color": {
                "type": "color",
                "default": "rgba(0, 0, 0, 0)",
                "function": "interpolated",
                "transition": true,
                "doc": "The color of the icon's halo. Icon halos can only be used with sdf icons.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-halo-width": {
                "type": "number",
                "default": 0,
                "minimum": 0,
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "Distance of halo to the icon outline.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-halo-blur": {
                "type": "number",
                "default": 0,
                "minimum": 0,
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "Fade out the halo towards the outside.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-translate": {
                "type": "array",
                "value": "number",
                "length": 2,
                "default": [
                    0,
                    0
                ],
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "An icon's offset distance. Values are [x, y] where negatives indicate left and up, respectively.",
                "requires": [
                    "icon-image"
                ]
            },
            "icon-translate-anchor": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "map",
                    "viewport"
                ],
                "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
                "default": "map",
                "requires": [
                    "icon-image",
                    "icon-translate"
                ]
            },
            "text-opacity": {
                "type": "number",
                "doc": "The opacity at which the text will be drawn.",
                "default": 1,
                "minimum": 0,
                "maximum": 1,
                "function": "interpolated",
                "transition": true,
                "requires": [
                    "text-field"
                ]
            },
            "text-size": {
                "type": "number",
                "default": 16,
                "minimum": 0,
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "Font size. If unspecified, the text will be as big as allowed by the layer definition.",
                "requires": [
                    "text-field"
                ]
            },
            "text-color": {
                "type": "color",
                "doc": "The color with which the text will be drawn.",
                "default": "#000000",
                "function": "interpolated",
                "transition": true,
                "requires": [
                    "text-field"
                ]
            },
            "text-halo-color": {
                "type": "color",
                "default": "rgba(0, 0, 0, 0)",
                "function": "interpolated",
                "transition": true,
                "doc": "The color of the text's halo, which helps it stand out from backgrounds.",
                "requires": [
                    "text-field"
                ]
            },
            "text-halo-width": {
                "type": "number",
                "default": 0,
                "minimum": 0,
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
                "requires": [
                    "text-field"
                ]
            },
            "text-halo-blur": {
                "type": "number",
                "default": 0,
                "minimum": 0,
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "The halo's fadeout distance towards the outside.",
                "requires": [
                    "text-field"
                ]
            },
            "text-translate": {
                "type": "array",
                "value": "number",
                "length": 2,
                "default": [
                    0,
                    0
                ],
                "function": "interpolated",
                "transition": true,
                "units": "pixels",
                "doc": "Label offset. Values are [x, y] where negatives indicate left and up, respectively.",
                "requires": [
                    "text-field"
                ]
            },
            "text-translate-anchor": {
                "type": "enum",
                "function": "piecewise-constant",
                "values": [
                    "map",
                    "viewport"
                ],
                "doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
                "default": "map",
                "requires": [
                    "text-field",
                    "text-translate"
                ]
            }
        },
        "paint_raster": {
            "raster-opacity": {
                "type": "number",
                "doc": "The opacity at which the image will be drawn.",
                "default": 1,
                "minimum": 0,
                "maximum": 1,
                "function": "interpolated",
                "transition": true
            },
            "raster-hue-rotate": {
                "type": "number",
                "default": 0,
                "period": 360,
                "function": "interpolated",
                "transition": true,
                "units": "degrees",
                "doc": "Rotates hues around the color wheel."
            },
            "raster-brightness-min": {
                "type": "number",
                "function": "interpolated",
                "doc": "Increase or reduce the brightness of the image. The value is the minimum brightness.",
                "default": 0,
                "minimum": 0,
                "maximum": 1,
                "transition": true
            },
            "raster-brightness-max": {
                "type": "number",
                "function": "interpolated",
                "doc": "Increase or reduce the brightness of the image. The value is the maximum brightness.",
                "default": 1,
                "minimum": 0,
                "maximum": 1,
                "transition": true
            },
            "raster-saturation": {
                "type": "number",
                "doc": "Increase or reduce the saturation of the image.",
                "default": 0,
                "minimum": -1,
                "maximum": 1,
                "function": "interpolated",
                "transition": true
            },
            "raster-contrast": {
                "type": "number",
                "doc": "Increase or reduce the contrast of the image.",
                "default": 0,
                "minimum": -1,
                "maximum": 1,
                "function": "interpolated",
                "transition": true
            },
            "raster-fade-duration": {
                "type": "number",
                "default": 300,
                "minimum": 0,
                "function": "interpolated",
                "transition": true,
                "units": "milliseconds",
                "doc": "Fade duration when a new tile is added."
            }
        },
        "paint_background": {
            "background-color": {
                "type": "color",
                "default": "#000000",
                "doc": "The color with which the background will be drawn.",
                "function": "interpolated",
                "transition": true,
                "requires": [
                    {
                        "!": "background-image"
                    }
                ]
            },
            "background-image": {
                "type": "string",
                "function": "piecewise-constant",
                "transition": true,
                "doc": "Optionally an image which is drawn as the background."
            },
            "background-opacity": {
                "type": "number",
                "default": 1,
                "minimum": 0,
                "maximum": 1,
                "doc": "The opacity at which the background will be drawn.",
                "function": "interpolated",
                "transition": true
            }
        },
        "transition": {
            "duration": {
                "type": "number",
                "default": 300,
                "minimum": 0,
                "units": "milliseconds",
                "doc": "Time allotted for transitions to complete."
            },
            "delay": {
                "type": "number",
                "default": 0,
                "minimum": 0,
                "units": "milliseconds",
                "doc": "Length of time before a transition begins."
            }
        }
    }

},{}],131:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
    'use strict';

    var assign    = require('./lib/utils/common').assign;

    var deflate   = require('./lib/deflate');
    var inflate   = require('./lib/inflate');
    var constants = require('./lib/zlib/constants');

    var pako = {};

    assign(pako, deflate, inflate, constants);

    module.exports = pako;

},{"./lib/deflate":132,"./lib/inflate":133,"./lib/utils/common":134,"./lib/zlib/constants":137}],132:[function(require,module,exports){
    'use strict';


    var zlib_deflate = require('./zlib/deflate.js');
    var utils = require('./utils/common');
    var strings = require('./utils/strings');
    var msg = require('./zlib/messages');
    var zstream = require('./zlib/zstream');

    var toString = Object.prototype.toString;

    /* Public constants ==========================================================*/
    /* ===========================================================================*/

    var Z_NO_FLUSH      = 0;
    var Z_FINISH        = 4;

    var Z_OK            = 0;
    var Z_STREAM_END    = 1;
    var Z_SYNC_FLUSH    = 2;

    var Z_DEFAULT_COMPRESSION = -1;

    var Z_DEFAULT_STRATEGY    = 0;

    var Z_DEFLATED  = 8;

    /* ===========================================================================*/


    /**
     * class Deflate
     *
     * Generic JS-style wrapper for zlib calls. If you don't need
     * streaming behaviour - use more simple functions: [[deflate]],
     * [[deflateRaw]] and [[gzip]].
     **/

    /* internal
     * Deflate.chunks -> Array
     *
     * Chunks of output data, if [[Deflate#onData]] not overriden.
     **/

    /**
     * Deflate.result -> Uint8Array|Array
     *
     * Compressed result, generated by default [[Deflate#onData]]
     * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
     * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
     * push a chunk with explicit flush (call [[Deflate#push]] with
     * `Z_SYNC_FLUSH` param).
     **/

    /**
     * Deflate.err -> Number
     *
     * Error code after deflate finished. 0 (Z_OK) on success.
     * You will not need it in real life, because deflate errors
     * are possible only on wrong options or bad `onData` / `onEnd`
     * custom handlers.
     **/

    /**
     * Deflate.msg -> String
     *
     * Error message, if [[Deflate.err]] != 0
     **/


    /**
     * new Deflate(options)
     * - options (Object): zlib deflate options.
     *
     * Creates new deflator instance with specified params. Throws exception
     * on bad params. Supported options:
     *
     * - `level`
     * - `windowBits`
     * - `memLevel`
     * - `strategy`
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Additional options, for internal needs:
     *
     * - `chunkSize` - size of generated data chunks (16K by default)
     * - `raw` (Boolean) - do raw deflate
     * - `gzip` (Boolean) - create gzip wrapper
     * - `to` (String) - if equal to 'string', then result will be "binary string"
     *    (each char code [0..255])
     * - `header` (Object) - custom header for gzip
     *   - `text` (Boolean) - true if compressed data believed to be text
     *   - `time` (Number) - modification time, unix timestamp
     *   - `os` (Number) - operation system code
     *   - `extra` (Array) - array of bytes with extra data (max 65536)
     *   - `name` (String) - file name (binary string)
     *   - `comment` (String) - comment (binary string)
     *   - `hcrc` (Boolean) - true if header crc should be added
     *
     * ##### Example:
     *
     * ```javascript
     * var pako = require('pako')
     *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
     *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
     *
     * var deflate = new pako.Deflate({ level: 3});
     *
     * deflate.push(chunk1, false);
     * deflate.push(chunk2, true);  // true -> last chunk
     *
     * if (deflate.err) { throw new Error(deflate.err); }
     *
     * console.log(deflate.result);
     * ```
     **/
    var Deflate = function(options) {

        this.options = utils.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY,
            to: ''
        }, options || {});

        var opt = this.options;

        if (opt.raw && (opt.windowBits > 0)) {
            opt.windowBits = -opt.windowBits;
        }

        else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
            opt.windowBits += 16;
        }

        this.err    = 0;      // error code, if happens (0 = Z_OK)
        this.msg    = '';     // error message
        this.ended  = false;  // used to avoid multiple onEnd() calls
        this.chunks = [];     // chunks of compressed data

        this.strm = new zstream();
        this.strm.avail_out = 0;

        var status = zlib_deflate.deflateInit2(
            this.strm,
            opt.level,
            opt.method,
            opt.windowBits,
            opt.memLevel,
            opt.strategy
        );

        if (status !== Z_OK) {
            throw new Error(msg[status]);
        }

        if (opt.header) {
            zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
    };

    /**
     * Deflate#push(data[, mode]) -> Boolean
     * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
     *   converted to utf8 byte sequence.
     * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
     *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
     *
     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
     * new compressed chunks. Returns `true` on success. The last data block must have
     * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
     * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
     * can use mode Z_SYNC_FLUSH, keeping the compression context.
     *
     * On fail call [[Deflate#onEnd]] with error code and return false.
     *
     * We strongly recommend to use `Uint8Array` on input for best speed (output
     * array format is detected automatically). Also, don't skip last param and always
     * use the same type in your code (boolean or number). That will improve JS speed.
     *
     * For regular `Array`-s make sure all elements are [0..255].
     *
     * ##### Example
     *
     * ```javascript
     * push(chunk, false); // push one of data chunks
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     **/
    Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;

        if (this.ended) { return false; }

        _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

        // Convert data if needed
        if (typeof data === 'string') {
            // If we need to compress text, change encoding to utf8.
            strm.input = strings.string2buf(data);
        } else if (toString.call(data) === '[object ArrayBuffer]') {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }

        strm.next_in = 0;
        strm.avail_in = strm.input.length;

        do {
            if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

            if (status !== Z_STREAM_END && status !== Z_OK) {
                this.onEnd(status);
                this.ended = true;
                return false;
            }
            if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
                if (this.options.to === 'string') {
                    this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
                } else {
                    this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                }
            }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

        // Finalize on the last chunk.
        if (_mode === Z_FINISH) {
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
        }

        // callback interim results if Z_SYNC_FLUSH.
        if (_mode === Z_SYNC_FLUSH) {
            this.onEnd(Z_OK);
            strm.avail_out = 0;
            return true;
        }

        return true;
    };


    /**
     * Deflate#onData(chunk) -> Void
     * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
     *   on js engine support. When string output requested, each chunk
     *   will be string.
     *
     * By default, stores data blocks in `chunks[]` property and glue
     * those in `onEnd`. Override this handler, if you need another behaviour.
     **/
    Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
    };


    /**
     * Deflate#onEnd(status) -> Void
     * - status (Number): deflate status. 0 (Z_OK) on success,
     *   other if not.
     *
     * Called once after you tell deflate that the input stream is
     * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
     * or if an error happened. By default - join collected chunks,
     * free memory and fill `results` / `err` properties.
     **/
    Deflate.prototype.onEnd = function(status) {
        // On success - join
        if (status === Z_OK) {
            if (this.options.to === 'string') {
                this.result = this.chunks.join('');
            } else {
                this.result = utils.flattenChunks(this.chunks);
            }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };


    /**
     * deflate(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * Compress `data` with deflate alrorythm and `options`.
     *
     * Supported options are:
     *
     * - level
     * - windowBits
     * - memLevel
     * - strategy
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Sugar (options):
     *
     * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
     *   negative windowBits implicitly.
     * - `to` (String) - if equal to 'string', then result will be "binary string"
     *    (each char code [0..255])
     *
     * ##### Example:
     *
     * ```javascript
     * var pako = require('pako')
     *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
     *
     * console.log(pako.deflate(data));
     * ```
     **/
    function deflate(input, options) {
        var deflator = new Deflate(options);

        deflator.push(input, true);

        // That will never happens, if you don't cheat with options :)
        if (deflator.err) { throw deflator.msg; }

        return deflator.result;
    }


    /**
     * deflateRaw(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * The same as [[deflate]], but creates raw data, without wrapper
     * (header and adler32 crc).
     **/
    function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
    }


    /**
     * gzip(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to compress.
     * - options (Object): zlib deflate options.
     *
     * The same as [[deflate]], but create gzip wrapper instead of
     * deflate one.
     **/
    function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
    }


    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;

},{"./utils/common":134,"./utils/strings":135,"./zlib/deflate.js":139,"./zlib/messages":144,"./zlib/zstream":146}],133:[function(require,module,exports){
    'use strict';


    var zlib_inflate = require('./zlib/inflate.js');
    var utils = require('./utils/common');
    var strings = require('./utils/strings');
    var c = require('./zlib/constants');
    var msg = require('./zlib/messages');
    var zstream = require('./zlib/zstream');
    var gzheader = require('./zlib/gzheader');

    var toString = Object.prototype.toString;

    /**
     * class Inflate
     *
     * Generic JS-style wrapper for zlib calls. If you don't need
     * streaming behaviour - use more simple functions: [[inflate]]
     * and [[inflateRaw]].
     **/

    /* internal
     * inflate.chunks -> Array
     *
     * Chunks of output data, if [[Inflate#onData]] not overriden.
     **/

    /**
     * Inflate.result -> Uint8Array|Array|String
     *
     * Uncompressed result, generated by default [[Inflate#onData]]
     * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
     * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
     * push a chunk with explicit flush (call [[Inflate#push]] with
     * `Z_SYNC_FLUSH` param).
     **/

    /**
     * Inflate.err -> Number
     *
     * Error code after inflate finished. 0 (Z_OK) on success.
     * Should be checked if broken data possible.
     **/

    /**
     * Inflate.msg -> String
     *
     * Error message, if [[Inflate.err]] != 0
     **/


    /**
     * new Inflate(options)
     * - options (Object): zlib inflate options.
     *
     * Creates new inflator instance with specified params. Throws exception
     * on bad params. Supported options:
     *
     * - `windowBits`
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Additional options, for internal needs:
     *
     * - `chunkSize` - size of generated data chunks (16K by default)
     * - `raw` (Boolean) - do raw inflate
     * - `to` (String) - if equal to 'string', then result will be converted
     *   from utf8 to utf16 (javascript) string. When string output requested,
     *   chunk length can differ from `chunkSize`, depending on content.
     *
     * By default, when no options set, autodetect deflate/gzip data format via
     * wrapper header.
     *
     * ##### Example:
     *
     * ```javascript
     * var pako = require('pako')
     *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
     *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
     *
     * var inflate = new pako.Inflate({ level: 3});
     *
     * inflate.push(chunk1, false);
     * inflate.push(chunk2, true);  // true -> last chunk
     *
     * if (inflate.err) { throw new Error(inflate.err); }
     *
     * console.log(inflate.result);
     * ```
     **/
    var Inflate = function(options) {

        this.options = utils.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ''
        }, options || {});

        var opt = this.options;

        // Force window size for `raw` data, if not set directly,
        // because we have no header for autodetect.
        if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) { opt.windowBits = -15; }
        }

        // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
        if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
            !(options && options.windowBits)) {
            opt.windowBits += 32;
        }

        // Gzip header has no info about windows size, we can do autodetect only
        // for deflate. So, if window size not set, force it to max when gzip possible
        if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
            // bit 3 (16) -> gzipped data
            // bit 4 (32) -> autodetect gzip/deflate
            if ((opt.windowBits & 15) === 0) {
                opt.windowBits |= 15;
            }
        }

        this.err    = 0;      // error code, if happens (0 = Z_OK)
        this.msg    = '';     // error message
        this.ended  = false;  // used to avoid multiple onEnd() calls
        this.chunks = [];     // chunks of compressed data

        this.strm   = new zstream();
        this.strm.avail_out = 0;

        var status  = zlib_inflate.inflateInit2(
            this.strm,
            opt.windowBits
        );

        if (status !== c.Z_OK) {
            throw new Error(msg[status]);
        }

        this.header = new gzheader();

        zlib_inflate.inflateGetHeader(this.strm, this.header);
    };

    /**
     * Inflate#push(data[, mode]) -> Boolean
     * - data (Uint8Array|Array|ArrayBuffer|String): input data
     * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
     *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
     *
     * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
     * new output chunks. Returns `true` on success. The last data block must have
     * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
     * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
     * can use mode Z_SYNC_FLUSH, keeping the decompression context.
     *
     * On fail call [[Inflate#onEnd]] with error code and return false.
     *
     * We strongly recommend to use `Uint8Array` on input for best speed (output
     * format is detected automatically). Also, don't skip last param and always
     * use the same type in your code (boolean or number). That will improve JS speed.
     *
     * For regular `Array`-s make sure all elements are [0..255].
     *
     * ##### Example
     *
     * ```javascript
     * push(chunk, false); // push one of data chunks
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     **/
    Inflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        var next_out_utf8, tail, utf8str;

        if (this.ended) { return false; }
        _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

        // Convert data if needed
        if (typeof data === 'string') {
            // Only binary strings can be decompressed on practice
            strm.input = strings.binstring2buf(data);
        } else if (toString.call(data) === '[object ArrayBuffer]') {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }

        strm.next_in = 0;
        strm.avail_in = strm.input.length;

        do {
            if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }

            status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

            if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                this.onEnd(status);
                this.ended = true;
                return false;
            }

            if (strm.next_out) {
                if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

                    if (this.options.to === 'string') {

                        next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

                        tail = strm.next_out - next_out_utf8;
                        utf8str = strings.buf2string(strm.output, next_out_utf8);

                        // move tail
                        strm.next_out = tail;
                        strm.avail_out = chunkSize - tail;
                        if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

                        this.onData(utf8str);

                    } else {
                        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                    }
                }
            }
        } while ((strm.avail_in > 0) && status !== c.Z_STREAM_END);

        if (status === c.Z_STREAM_END) {
            _mode = c.Z_FINISH;
        }

        // Finalize on the last chunk.
        if (_mode === c.Z_FINISH) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === c.Z_OK;
        }

        // callback interim results if Z_SYNC_FLUSH.
        if (_mode === c.Z_SYNC_FLUSH) {
            this.onEnd(c.Z_OK);
            strm.avail_out = 0;
            return true;
        }

        return true;
    };


    /**
     * Inflate#onData(chunk) -> Void
     * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
     *   on js engine support. When string output requested, each chunk
     *   will be string.
     *
     * By default, stores data blocks in `chunks[]` property and glue
     * those in `onEnd`. Override this handler, if you need another behaviour.
     **/
    Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
    };


    /**
     * Inflate#onEnd(status) -> Void
     * - status (Number): inflate status. 0 (Z_OK) on success,
     *   other if not.
     *
     * Called either after you tell inflate that the input stream is
     * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
     * or if an error happened. By default - join collected chunks,
     * free memory and fill `results` / `err` properties.
     **/
    Inflate.prototype.onEnd = function(status) {
        // On success - join
        if (status === c.Z_OK) {
            if (this.options.to === 'string') {
                // Glue & convert here, until we teach pako to send
                // utf8 alligned strings to onData
                this.result = this.chunks.join('');
            } else {
                this.result = utils.flattenChunks(this.chunks);
            }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };


    /**
     * inflate(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * Decompress `data` with inflate/ungzip and `options`. Autodetect
     * format via wrapper header by default. That's why we don't provide
     * separate `ungzip` method.
     *
     * Supported options are:
     *
     * - windowBits
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information.
     *
     * Sugar (options):
     *
     * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
     *   negative windowBits implicitly.
     * - `to` (String) - if equal to 'string', then result will be converted
     *   from utf8 to utf16 (javascript) string. When string output requested,
     *   chunk length can differ from `chunkSize`, depending on content.
     *
     *
     * ##### Example:
     *
     * ```javascript
     * var pako = require('pako')
     *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
     *   , output;
     *
     * try {
 *   output = pako.inflate(input);
 * } catch (err)
     *   console.log(err);
     * }
     * ```
     **/
    function inflate(input, options) {
        var inflator = new Inflate(options);

        inflator.push(input, true);

        // That will never happens, if you don't cheat with options :)
        if (inflator.err) { throw inflator.msg; }

        return inflator.result;
    }


    /**
     * inflateRaw(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * The same as [[inflate]], but creates raw data, without wrapper
     * (header and adler32 crc).
     **/
    function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
    }


    /**
     * ungzip(data[, options]) -> Uint8Array|Array|String
     * - data (Uint8Array|Array|String): input data to decompress.
     * - options (Object): zlib inflate options.
     *
     * Just shortcut to [[inflate]], because it autodetects format
     * by header.content. Done for convenience.
     **/


    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip  = inflate;

},{"./utils/common":134,"./utils/strings":135,"./zlib/constants":137,"./zlib/gzheader":140,"./zlib/inflate.js":142,"./zlib/messages":144,"./zlib/zstream":146}],134:[function(require,module,exports){
    'use strict';


    var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
        (typeof Uint16Array !== 'undefined') &&
        (typeof Int32Array !== 'undefined');


    exports.assign = function (obj /*from1, from2, from3, ...*/) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
            var source = sources.shift();
            if (!source) { continue; }

            if (typeof source !== 'object') {
                throw new TypeError(source + 'must be non-object');
            }

            for (var p in source) {
                if (source.hasOwnProperty(p)) {
                    obj[p] = source[p];
                }
            }
        }

        return obj;
    };


// reduce buffer size, avoiding mem copy
    exports.shrinkBuf = function (buf, size) {
        if (buf.length === size) { return buf; }
        if (buf.subarray) { return buf.subarray(0, size); }
        buf.length = size;
        return buf;
    };


    var fnTyped = {
        arraySet: function (dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) {
                dest.set(src.subarray(src_offs, src_offs+len), dest_offs);
                return;
            }
            // Fallback to ordinary array
            for (var i=0; i<len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
            }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
            var i, l, len, pos, chunk, result;

            // calculate data length
            len = 0;
            for (i=0, l=chunks.length; i<l; i++) {
                len += chunks[i].length;
            }

            // join chunks
            result = new Uint8Array(len);
            pos = 0;
            for (i=0, l=chunks.length; i<l; i++) {
                chunk = chunks[i];
                result.set(chunk, pos);
                pos += chunk.length;
            }

            return result;
        }
    };

    var fnUntyped = {
        arraySet: function (dest, src, src_offs, len, dest_offs) {
            for (var i=0; i<len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
            }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
        }
    };


// Enable/Disable typed arrays use, for testing
//
    exports.setTyped = function (on) {
        if (on) {
            exports.Buf8  = Uint8Array;
            exports.Buf16 = Uint16Array;
            exports.Buf32 = Int32Array;
            exports.assign(exports, fnTyped);
        } else {
            exports.Buf8  = Array;
            exports.Buf16 = Array;
            exports.Buf32 = Array;
            exports.assign(exports, fnUntyped);
        }
    };

    exports.setTyped(TYPED_OK);

},{}],135:[function(require,module,exports){
// String encode/decode helpers
    'use strict';


    var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;

    try { String.fromCharCode.apply(null, [0]); } catch(__) { STR_APPLY_OK = false; }
    try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch(__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
    var _utf8len = new utils.Buf8(256);
    for (var q=0; q<256; q++) {
        _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
    }
    _utf8len[254]=_utf8len[254]=1; // Invalid sequence start


// convert string to array (typed, when possible)
    exports.string2buf = function (str) {
        var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

        // count binary size
        for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
                c2 = str.charCodeAt(m_pos+1);
                if ((c2 & 0xfc00) === 0xdc00) {
                    c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                    m_pos++;
                }
            }
            buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
        }

        // allocate buffer
        buf = new utils.Buf8(buf_len);

        // convert
        for (i=0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
                c2 = str.charCodeAt(m_pos+1);
                if ((c2 & 0xfc00) === 0xdc00) {
                    c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                    m_pos++;
                }
            }
            if (c < 0x80) {
                /* one byte */
                buf[i++] = c;
            } else if (c < 0x800) {
                /* two bytes */
                buf[i++] = 0xC0 | (c >>> 6);
                buf[i++] = 0x80 | (c & 0x3f);
            } else if (c < 0x10000) {
                /* three bytes */
                buf[i++] = 0xE0 | (c >>> 12);
                buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                buf[i++] = 0x80 | (c & 0x3f);
            } else {
                /* four bytes */
                buf[i++] = 0xf0 | (c >>> 18);
                buf[i++] = 0x80 | (c >>> 12 & 0x3f);
                buf[i++] = 0x80 | (c >>> 6 & 0x3f);
                buf[i++] = 0x80 | (c & 0x3f);
            }
        }

        return buf;
    };

// Helper (used in 2 places)
    function buf2binstring(buf, len) {
        // use fallback for big arrays to avoid stack overflow
        if (len < 65537) {
            if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
                return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
            }
        }

        var result = '';
        for (var i=0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
        }
        return result;
    }


// Convert byte array to binary string
    exports.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length);
    };


// Convert binary string (typed, when possible)
    exports.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i=0, len=buf.length; i < len; i++) {
            buf[i] = str.charCodeAt(i);
        }
        return buf;
    };


// convert array to string
    exports.buf2string = function (buf, max) {
        var i, out, c, c_len;
        var len = max || buf.length;

        // Reserve max possible length (2 words per char)
        // NB: by unknown reasons, Array is significantly faster for
        //     String.fromCharCode.apply than Uint16Array.
        var utf16buf = new Array(len*2);

        for (out=0, i=0; i<len;) {
            c = buf[i++];
            // quick process ascii
            if (c < 0x80) { utf16buf[out++] = c; continue; }

            c_len = _utf8len[c];
            // skip 5 & 6 byte codes
            if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }

            // apply mask on first byte
            c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
            // join the rest
            while (c_len > 1 && i < len) {
                c = (c << 6) | (buf[i++] & 0x3f);
                c_len--;
            }

            // terminated by end of string?
            if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

            if (c < 0x10000) {
                utf16buf[out++] = c;
            } else {
                c -= 0x10000;
                utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
                utf16buf[out++] = 0xdc00 | (c & 0x3ff);
            }
        }

        return buf2binstring(utf16buf, out);
    };


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
    exports.utf8border = function(buf, max) {
        var pos;

        max = max || buf.length;
        if (max > buf.length) { max = buf.length; }

        // go back from last position, until start of sequence found
        pos = max-1;
        while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

        // Fuckup - very small and broken sequence,
        // return max, because we should return something anyway.
        if (pos < 0) { return max; }

        // If we came to start of buffer - that means vuffer is too small,
        // return max too.
        if (pos === 0) { return max; }

        return (pos + _utf8len[buf[pos]] > max) ? pos : max;
    };

},{"./common":134}],136:[function(require,module,exports){
    'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

    function adler32(adler, buf, len, pos) {
        var s1 = (adler & 0xffff) |0,
            s2 = ((adler >>> 16) & 0xffff) |0,
            n = 0;

        while (len !== 0) {
            // Set limit ~ twice less than 5552, to keep
            // s2 in 31-bits, because we force signed ints.
            // in other case %= will fail.
            n = len > 2000 ? 2000 : len;
            len -= n;

            do {
                s1 = (s1 + buf[pos++]) |0;
                s2 = (s2 + s1) |0;
            } while (--n);

            s1 %= 65521;
            s2 %= 65521;
        }

        return (s1 | (s2 << 16)) |0;
    }


    module.exports = adler32;

},{}],137:[function(require,module,exports){
    module.exports = {

        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH:         0,
        Z_PARTIAL_FLUSH:    1,
        Z_SYNC_FLUSH:       2,
        Z_FULL_FLUSH:       3,
        Z_FINISH:           4,
        Z_BLOCK:            5,
        Z_TREES:            6,

        /* Return codes for the compression/decompression functions. Negative values
         * are errors, positive values are used for special but normal events.
         */
        Z_OK:               0,
        Z_STREAM_END:       1,
        Z_NEED_DICT:        2,
        Z_ERRNO:           -1,
        Z_STREAM_ERROR:    -2,
        Z_DATA_ERROR:      -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR:       -5,
        //Z_VERSION_ERROR: -6,

        /* compression levels */
        Z_NO_COMPRESSION:         0,
        Z_BEST_SPEED:             1,
        Z_BEST_COMPRESSION:       9,
        Z_DEFAULT_COMPRESSION:   -1,


        Z_FILTERED:               1,
        Z_HUFFMAN_ONLY:           2,
        Z_RLE:                    3,
        Z_FIXED:                  4,
        Z_DEFAULT_STRATEGY:       0,

        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY:                 0,
        Z_TEXT:                   1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN:                2,

        /* The deflate compression method */
        Z_DEFLATED:               8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };

},{}],138:[function(require,module,exports){
    'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
    function makeTable() {
        var c, table = [];

        for (var n =0; n < 256; n++) {
            c = n;
            for (var k =0; k < 8; k++) {
                c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
            }
            table[n] = c;
        }

        return table;
    }

// Create table on load. Just 255 signed longs. Not a problem.
    var crcTable = makeTable();


    function crc32(crc, buf, len, pos) {
        var t = crcTable,
            end = pos + len;

        crc = crc ^ (-1);

        for (var i = pos; i < end; i++) {
            crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
        }

        return (crc ^ (-1)); // >>> 0;
    }


    module.exports = crc32;

},{}],139:[function(require,module,exports){
    'use strict';

    var utils   = require('../utils/common');
    var trees   = require('./trees');
    var adler32 = require('./adler32');
    var crc32   = require('./crc32');
    var msg   = require('./messages');

    /* Public constants ==========================================================*/
    /* ===========================================================================*/


    /* Allowed flush values; see deflate() and inflate() below for details */
    var Z_NO_FLUSH      = 0;
    var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
    var Z_FULL_FLUSH    = 3;
    var Z_FINISH        = 4;
    var Z_BLOCK         = 5;
//var Z_TREES         = 6;


    /* Return codes for the compression/decompression functions. Negative values
     * are errors, positive values are used for special but normal events.
     */
    var Z_OK            = 0;
    var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
    var Z_STREAM_ERROR  = -2;
    var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
    var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


    /* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
    var Z_DEFAULT_COMPRESSION = -1;


    var Z_FILTERED            = 1;
    var Z_HUFFMAN_ONLY        = 2;
    var Z_RLE                 = 3;
    var Z_FIXED               = 4;
    var Z_DEFAULT_STRATEGY    = 0;

    /* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
    var Z_UNKNOWN             = 2;


    /* The deflate compression method */
    var Z_DEFLATED  = 8;

    /*============================================================================*/


    var MAX_MEM_LEVEL = 9;
    /* Maximum value for memLevel in deflateInit2 */
    var MAX_WBITS = 15;
    /* 32K LZ77 window */
    var DEF_MEM_LEVEL = 8;


    var LENGTH_CODES  = 29;
    /* number of length codes, not counting the special END_BLOCK code */
    var LITERALS      = 256;
    /* number of literal bytes 0..255 */
    var L_CODES       = LITERALS + 1 + LENGTH_CODES;
    /* number of Literal or Length codes, including the END_BLOCK code */
    var D_CODES       = 30;
    /* number of distance codes */
    var BL_CODES      = 19;
    /* number of codes used to transfer the bit lengths */
    var HEAP_SIZE     = 2*L_CODES + 1;
    /* maximum heap size */
    var MAX_BITS  = 15;
    /* All codes must not exceed MAX_BITS bits */

    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

    var PRESET_DICT = 0x20;

    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;

    var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
    var BS_BLOCK_DONE     = 2; /* block flush performed */
    var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
    var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

    var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

    function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
    }

    function rank(f) {
        return ((f) << 1) - ((f) > 4 ? 9 : 0);
    }

    function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


    /* =========================================================================
     * Flush as much pending output as possible. All deflate() output goes
     * through this function so some applications may wish to modify it
     * to avoid allocating a large strm->output buffer and copying into it.
     * (See also read_buf()).
     */
    function flush_pending(strm) {
        var s = strm.state;

        //_tr_flush_bits(s);
        var len = s.pending;
        if (len > strm.avail_out) {
            len = strm.avail_out;
        }
        if (len === 0) { return; }

        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
            s.pending_out = 0;
        }
    }


    function flush_block_only (s, last) {
        trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
    }


    function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
    }


    /* =========================================================================
     * Put a short in the pending buffer. The 16-bit value is put in MSB order.
     * IN assertion: the stream state is correct and there is enough room in
     * pending_buf.
     */
    function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
        s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
        s.pending_buf[s.pending++] = b & 0xff;
    }


    /* ===========================================================================
     * Read a new buffer from the current input stream, update the adler32
     * and total number of bytes read.  All deflate() input goes through
     * this function so some applications may wish to modify it to avoid
     * allocating a large strm->input buffer and copying from it.
     * (See also flush_pending()).
     */
    function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;

        if (len > size) { len = size; }
        if (len === 0) { return 0; }

        strm.avail_in -= len;

        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
            strm.adler = adler32(strm.adler, buf, len, start);
        }

        else if (strm.state.wrap === 2) {
            strm.adler = crc32(strm.adler, buf, len, start);
        }

        strm.next_in += len;
        strm.total_in += len;

        return len;
    }


    /* ===========================================================================
     * Set match_start to the longest match starting at the given string and
     * return its length. Matches shorter or equal to prev_length are discarded,
     * in which case the result is equal to prev_length and match_start is
     * garbage.
     * IN assertions: cur_match is the head of the hash chain for the current
     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
     * OUT assertion: the match length is not greater than s->lookahead.
     */
    function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;      /* max hash chain length */
        var scan = s.strstart; /* current string */
        var match;                       /* matched string */
        var len;                           /* length of current match */
        var best_len = s.prev_length;              /* best match length so far */
        var nice_match = s.nice_match;             /* stop if match long enough */
        var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
            s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

        var _win = s.window; // shortcut

        var wmask = s.w_mask;
        var prev  = s.prev;

        /* Stop when cur_match becomes <= limit. To simplify the code,
         * we prevent matches with the string of window index 0.
         */

        var strend = s.strstart + MAX_MATCH;
        var scan_end1  = _win[scan + best_len - 1];
        var scan_end   = _win[scan + best_len];

        /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
         * It is easy to get rid of this optimization if necessary.
         */
        // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

        /* Do not waste too much time if we already have a good match: */
        if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
        }
        /* Do not look for matches beyond the end of the input. This is necessary
         * to make deflate deterministic.
         */
        if (nice_match > s.lookahead) { nice_match = s.lookahead; }

        // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

        do {
            // Assert(cur_match < s->strstart, "no future");
            match = cur_match;

            /* Skip to next match if the match length cannot increase
             * or if the match length is less than 2.  Note that the checks below
             * for insufficient lookahead only occur occasionally for performance
             * reasons.  Therefore uninitialized memory will be accessed, and
             * conditional jumps will be made that depend on those values.
             * However the length of the match is limited to the lookahead, so
             * the output of deflate is not affected by the uninitialized values.
             */

            if (_win[match + best_len]     !== scan_end  ||
                _win[match + best_len - 1] !== scan_end1 ||
                _win[match]                !== _win[scan] ||
                _win[++match]              !== _win[scan + 1]) {
                continue;
            }

            /* The check at best_len-1 can be removed because it will be made
             * again later. (This heuristic is not always a win.)
             * It is not necessary to compare scan[2] and match[2] since they
             * are always equal when the other bytes match, given that
             * the hash keys are equal and that HASH_BITS >= 8.
             */
            scan += 2;
            match++;
            // Assert(*scan == *match, "match[2]?");

            /* We check for insufficient lookahead only every 8th comparison;
             * the 256th check will be made at strstart+258.
             */
            do {
                /*jshint noempty:false*/
            } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                scan < strend);

            // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;

            if (len > best_len) {
                s.match_start = cur_match;
                best_len = len;
                if (len >= nice_match) {
                    break;
                }
                scan_end1  = _win[scan + best_len - 1];
                scan_end   = _win[scan + best_len];
            }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

        if (best_len <= s.lookahead) {
            return best_len;
        }
        return s.lookahead;
    }


    /* ===========================================================================
     * Fill the window when the lookahead becomes insufficient.
     * Updates strstart and lookahead.
     *
     * IN assertion: lookahead < MIN_LOOKAHEAD
     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
     *    At least one byte has been read, or avail_in == 0; reads are
     *    performed for at least two bytes (required for the zip translate_eol
     *    option -- not supported here).
     */
    function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;

        //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

        do {
            more = s.window_size - s.lookahead - s.strstart;

            // JS ints have 32 bit, block below not needed
            /* Deal with !@#$% 64K limit: */
            //if (sizeof(int) <= 2) {
            //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
            //        more = wsize;
            //
            //  } else if (more == (unsigned)(-1)) {
            //        /* Very unlikely, but possible on 16 bit machine if
            //         * strstart == 0 && lookahead == 1 (input done a byte at time)
            //         */
            //        more--;
            //    }
            //}


            /* If the window is almost full and there is insufficient lookahead,
             * move the upper half to the lower one to make room in the upper half.
             */
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

                utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                s.match_start -= _w_size;
                s.strstart -= _w_size;
                /* we now have strstart >= MAX_DIST */
                s.block_start -= _w_size;

                /* Slide the hash table (could be avoided with 32 bit values
                 at the expense of memory usage). We slide even when level == 0
                 to keep the hash table consistent if we switch back to level > 0
                 later. (Using level 0 permanently is not an optimal usage of
                 zlib, so we don't care about this pathological case.)
                 */

                n = s.hash_size;
                p = n;
                do {
                    m = s.head[--p];
                    s.head[p] = (m >= _w_size ? m - _w_size : 0);
                } while (--n);

                n = _w_size;
                p = n;
                do {
                    m = s.prev[--p];
                    s.prev[p] = (m >= _w_size ? m - _w_size : 0);
                    /* If n is not on any hash chain, prev[n] is garbage but
                     * its value will never be used.
                     */
                } while (--n);

                more += _w_size;
            }
            if (s.strm.avail_in === 0) {
                break;
            }

            /* If there was no sliding:
             *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
             *    more == window_size - lookahead - strstart
             * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
             * => more >= window_size - 2*WSIZE + 2
             * In the BIG_MEM or MMAP case (not yet supported),
             *   window_size == input_size + MIN_LOOKAHEAD  &&
             *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
             * Otherwise, window_size == 2*WSIZE so more >= 2.
             * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
             */
            //Assert(more >= 2, "more < 2");
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;

            /* Initialize the hash value now that we have some input: */
            if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert;
                s.ins_h = s.window[str];

                /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
                while (s.insert) {
                    /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                    s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH-1]) & s.hash_mask;

                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                    s.insert--;
                    if (s.lookahead + s.insert < MIN_MATCH) {
                        break;
                    }
                }
            }
            /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
             * but this is not important since only literal bytes will be emitted.
             */

        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

        /* If the WIN_INIT bytes after the end of the current data have never been
         * written, then zero those bytes in order to avoid memory check reports of
         * the use of uninitialized (or uninitialised as Julian writes) bytes by
         * the longest match routines.  Update the high water mark for the next
         * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
         * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
         */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
    }

    /* ===========================================================================
     * Copy without compression as much as possible from the input stream, return
     * the current block state.
     * This function does not insert new strings in the dictionary since
     * uncompressible data is probably not useful. This function is used
     * only for the level=0 compression option.
     * NOTE: this function should be optimized to avoid extra copying from
     * window to pending_buf.
     */
    function deflate_stored(s, flush) {
        /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
         * to pending_buf_size, and each stored block has a 5 byte header:
         */
        var max_block_size = 0xffff;

        if (max_block_size > s.pending_buf_size - 5) {
            max_block_size = s.pending_buf_size - 5;
        }

        /* Copy as much as possible from input to output: */
        for (;;) {
            /* Fill the window as much as possible: */
            if (s.lookahead <= 1) {

                //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
                //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

                fill_window(s);
                if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }

                if (s.lookahead === 0) {
                    break;
                }
                /* flush the current block */
            }
            //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

            s.strstart += s.lookahead;
            s.lookahead = 0;

            /* Emit a stored block if pending_buf will be full: */
            var max_start = s.block_start + max_block_size;

            if (s.strstart === 0 || s.strstart >= max_start) {
                /* strstart == 0 is possible when wraparound on 16-bit machine */
                s.lookahead = s.strstart - max_start;
                s.strstart = max_start;
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/


            }
            /* Flush if we may have to slide, otherwise block_start may become
             * negative and the data will be gone:
             */
            if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }

        s.insert = 0;

        if (flush === Z_FINISH) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }

        if (s.strstart > s.block_start) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }

        return BS_NEED_MORE;
    }

    /* ===========================================================================
     * Compress as much as possible from the input stream, return the current
     * block state.
     * This function does not perform lazy evaluation of matches and inserts
     * new strings in the dictionary only for unmatched strings or for short
     * matches. It is used only for the fast compression options.
     */
    function deflate_fast(s, flush) {
        var hash_head;        /* head of the hash chain */
        var bflush;           /* set if current block must be flushed */

        for (;;) {
            /* Make sure that we always have enough lookahead, except
             * at the end of the input file. We need MAX_MATCH bytes
             * for the next match, plus MIN_MATCH bytes to insert the
             * string following the next match.
             */
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break; /* flush the current block */
                }
            }

            /* Insert the string window[strstart .. strstart+2] in the
             * dictionary, and set hash_head to the head of the hash chain:
             */
            hash_head = 0/*NIL*/;
            if (s.lookahead >= MIN_MATCH) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
            }

            /* Find the longest match, discarding those <= prev_length.
             * At this point we have always match_length < MIN_MATCH
             */
            if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
                /* To simplify the code, we prevent matches with the string
                 * of window index 0 (in particular we have to avoid a match
                 * of the string with itself at the start of the input file).
                 */
                s.match_length = longest_match(s, hash_head);
                /* longest_match() sets match_start */
            }
            if (s.match_length >= MIN_MATCH) {
                // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

                /*** _tr_tally_dist(s, s.strstart - s.match_start,
                 s.match_length - MIN_MATCH, bflush); ***/
                bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

                s.lookahead -= s.match_length;

                /* Insert new strings in the hash table only if the match length
                 * is not too large. This saves time but degrades compression.
                 */
                if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
                    s.match_length--; /* string at strstart already in table */
                    do {
                        s.strstart++;
                        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                        /***/
                        /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                         * always MIN_MATCH bytes ahead.
                         */
                    } while (--s.match_length !== 0);
                    s.strstart++;
                } else
                {
                    s.strstart += s.match_length;
                    s.match_length = 0;
                    s.ins_h = s.window[s.strstart];
                    /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
                    s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
                    /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                     * matter since it will be recomputed at next deflate call.
                     */
                }
            } else {
                /* No match, output a literal byte */
                //Tracevv((stderr,"%c", s.window[s.strstart]));
                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }
        s.insert = ((s.strstart < (MIN_MATCH-1)) ? s.strstart : MIN_MATCH-1);
        if (flush === Z_FINISH) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        return BS_BLOCK_DONE;
    }

    /* ===========================================================================
     * Same as above, but achieves better compression. We use a lazy
     * evaluation for matches: a match is finally adopted only if there is
     * no better match at the next window position.
     */
    function deflate_slow(s, flush) {
        var hash_head;          /* head of hash chain */
        var bflush;              /* set if current block must be flushed */

        var max_insert;

        /* Process the input block. */
        for (;;) {
            /* Make sure that we always have enough lookahead, except
             * at the end of the input file. We need MAX_MATCH bytes
             * for the next match, plus MIN_MATCH bytes to insert the
             * string following the next match.
             */
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) { break; } /* flush the current block */
            }

            /* Insert the string window[strstart .. strstart+2] in the
             * dictionary, and set hash_head to the head of the hash chain:
             */
            hash_head = 0/*NIL*/;
            if (s.lookahead >= MIN_MATCH) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
            }

            /* Find the longest match, discarding those <= prev_length.
             */
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH-1;

            if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
                s.strstart - hash_head <= (s.w_size-MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
                /* To simplify the code, we prevent matches with the string
                 * of window index 0 (in particular we have to avoid a match
                 * of the string with itself at the start of the input file).
                 */
                s.match_length = longest_match(s, hash_head);
                /* longest_match() sets match_start */

                if (s.match_length <= 5 &&
                    (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

                    /* If prev_match is also MIN_MATCH, match_start is garbage
                     * but we will ignore the current match anyway.
                     */
                    s.match_length = MIN_MATCH-1;
                }
            }
            /* If there was a match at the previous step and the current
             * match is not better, output the previous match:
             */
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH;
                /* Do not insert strings in hash table beyond this. */

                //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

                /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                 s.prev_length - MIN_MATCH, bflush);***/
                bflush = trees._tr_tally(s, s.strstart - 1- s.prev_match, s.prev_length - MIN_MATCH);
                /* Insert in hash table all strings up to the end of the match.
                 * strstart-1 and strstart are already inserted. If there is not
                 * enough lookahead, the last two strings are not inserted in
                 * the hash table.
                 */
                s.lookahead -= s.prev_length-1;
                s.prev_length -= 2;
                do {
                    if (++s.strstart <= max_insert) {
                        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                        /***/
                    }
                } while (--s.prev_length !== 0);
                s.match_available = 0;
                s.match_length = MIN_MATCH-1;
                s.strstart++;

                if (bflush) {
                    /*** FLUSH_BLOCK(s, 0); ***/
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                    /***/
                }

            } else if (s.match_available) {
                /* If there was no match at the previous position, output a
                 * single literal. If there was a match but the current match
                 * is longer, truncate the previous match to a single literal.
                 */
                //Tracevv((stderr,"%c", s->window[s->strstart-1]));
                /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);

                if (bflush) {
                    /*** FLUSH_BLOCK_ONLY(s, 0) ***/
                    flush_block_only(s, false);
                    /***/
                }
                s.strstart++;
                s.lookahead--;
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            } else {
                /* There is no previous match to compare with, wait for
                 * the next step to decide.
                 */
                s.match_available = 1;
                s.strstart++;
                s.lookahead--;
            }
        }
        //Assert (flush != Z_NO_FLUSH, "no flush?");
        if (s.match_available) {
            //Tracevv((stderr,"%c", s->window[s->strstart-1]));
            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
            bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);

            s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH-1 ? s.strstart : MIN_MATCH-1;
        if (flush === Z_FINISH) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }

        return BS_BLOCK_DONE;
    }


    /* ===========================================================================
     * For Z_RLE, simply look for runs of bytes, generate matches only of distance
     * one.  Do not maintain a hash table.  (It will be regenerated if this run of
     * deflate switches away from Z_RLE.)
     */
    function deflate_rle(s, flush) {
        var bflush;            /* set if current block must be flushed */
        var prev;              /* byte at distance one to match */
        var scan, strend;      /* scan goes up to strend for length of run */

        var _win = s.window;

        for (;;) {
            /* Make sure that we always have enough lookahead, except
             * at the end of the input file. We need MAX_MATCH bytes
             * for the longest run, plus one for the unrolled loop.
             */
            if (s.lookahead <= MAX_MATCH) {
                fill_window(s);
                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) { break; } /* flush the current block */
            }

            /* See how many times the previous byte repeats */
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1;
                prev = _win[scan];
                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                    strend = s.strstart + MAX_MATCH;
                    do {
                        /*jshint noempty:false*/
                    } while (prev === _win[++scan] && prev === _win[++scan] &&
                        prev === _win[++scan] && prev === _win[++scan] &&
                        prev === _win[++scan] && prev === _win[++scan] &&
                        prev === _win[++scan] && prev === _win[++scan] &&
                        scan < strend);
                    s.match_length = MAX_MATCH - (strend - scan);
                    if (s.match_length > s.lookahead) {
                        s.match_length = s.lookahead;
                    }
                }
                //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
            }

            /* Emit match if have run of MIN_MATCH or longer, else emit literal */
            if (s.match_length >= MIN_MATCH) {
                //check_match(s, s.strstart, s.strstart - 1, s.match_length);

                /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
                bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

                s.lookahead -= s.match_length;
                s.strstart += s.match_length;
                s.match_length = 0;
            } else {
                /* No match, output a literal byte */
                //Tracevv((stderr,"%c", s->window[s->strstart]));
                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        return BS_BLOCK_DONE;
    }

    /* ===========================================================================
     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
     * (It will be regenerated if this run of deflate switches away from Huffman.)
     */
    function deflate_huff(s, flush) {
        var bflush;             /* set if current block must be flushed */

        for (;;) {
            /* Make sure that we have a literal to write. */
            if (s.lookahead === 0) {
                fill_window(s);
                if (s.lookahead === 0) {
                    if (flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }
                    break;      /* flush the current block */
                }
            }

            /* Output a literal byte */
            s.match_length = 0;
            //Tracevv((stderr,"%c", s->window[s->strstart]));
            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
                /***/
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
            /*** FLUSH_BLOCK(s, 1); ***/
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            /***/
            return BS_FINISH_DONE;
        }
        if (s.last_lit) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
            /***/
        }
        return BS_BLOCK_DONE;
    }

    /* Values for max_lazy_match, good_match and max_chain_length, depending on
     * the desired pack level (0..9). The values given below have been tuned to
     * exclude worst case performance for pathological files. Better values may be
     * found for specific files.
     */
    var Config = function (good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
    };

    var configuration_table;

    configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
        new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

        new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
        new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
        new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
    ];


    /* ===========================================================================
     * Initialize the "longest match" routines for a new zlib stream
     */
    function lm_init(s) {
        s.window_size = 2 * s.w_size;

        /*** CLEAR_HASH(s); ***/
        zero(s.head); // Fill with NIL (= 0);

        /* Set the default configuration parameters:
         */
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;

        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
    }


    function DeflateState() {
        this.strm = null;            /* pointer back to this zlib stream */
        this.status = 0;            /* as the name implies */
        this.pending_buf = null;      /* output still pending */
        this.pending_buf_size = 0;  /* size of pending_buf */
        this.pending_out = 0;       /* next pending byte to output to the stream */
        this.pending = 0;           /* nb of bytes in the pending buffer */
        this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
        this.gzhead = null;         /* gzip header information to write */
        this.gzindex = 0;           /* where in extra, name, or comment */
        this.method = Z_DEFLATED; /* can only be DEFLATED */
        this.last_flush = -1;   /* value of flush param for previous deflate call */

        this.w_size = 0;  /* LZ77 window size (32K by default) */
        this.w_bits = 0;  /* log2(w_size)  (8..16) */
        this.w_mask = 0;  /* w_size - 1 */

        this.window = null;
        /* Sliding window. Input bytes are read into the second half of the window,
         * and move to the first half later to keep a dictionary of at least wSize
         * bytes. With this organization, matches are limited to a distance of
         * wSize-MAX_MATCH bytes, but this ensures that IO is always
         * performed with a length multiple of the block size.
         */

        this.window_size = 0;
        /* Actual size of window: 2*wSize, except when the user input buffer
         * is directly used as sliding window.
         */

        this.prev = null;
        /* Link to older string with same hash index. To limit the size of this
         * array to 64K, this link is maintained only for the last 32K strings.
         * An index in this array is thus a window index modulo 32K.
         */

        this.head = null;   /* Heads of the hash chains or NIL. */

        this.ins_h = 0;       /* hash index of string to be inserted */
        this.hash_size = 0;   /* number of elements in hash table */
        this.hash_bits = 0;   /* log2(hash_size) */
        this.hash_mask = 0;   /* hash_size-1 */

        this.hash_shift = 0;
        /* Number of bits by which ins_h must be shifted at each input
         * step. It must be such that after MIN_MATCH steps, the oldest
         * byte no longer takes part in the hash key, that is:
         *   hash_shift * MIN_MATCH >= hash_bits
         */

        this.block_start = 0;
        /* Window position at the beginning of the current output block. Gets
         * negative when the window is moved backwards.
         */

        this.match_length = 0;      /* length of best match */
        this.prev_match = 0;        /* previous match */
        this.match_available = 0;   /* set if previous match exists */
        this.strstart = 0;          /* start of string to insert */
        this.match_start = 0;       /* start of matching string */
        this.lookahead = 0;         /* number of valid bytes ahead in window */

        this.prev_length = 0;
        /* Length of the best match at previous step. Matches not greater than this
         * are discarded. This is used in the lazy match evaluation.
         */

        this.max_chain_length = 0;
        /* To speed up deflation, hash chains are never searched beyond this
         * length.  A higher limit improves compression ratio but degrades the
         * speed.
         */

        this.max_lazy_match = 0;
        /* Attempt to find a better match only when the current match is strictly
         * smaller than this value. This mechanism is used only for compression
         * levels >= 4.
         */
        // That's alias to max_lazy_match, don't use directly
        //this.max_insert_length = 0;
        /* Insert new strings in the hash table only if the match length is not
         * greater than this length. This saves time but degrades compression.
         * max_insert_length is used only for compression levels <= 3.
         */

        this.level = 0;     /* compression level (1..9) */
        this.strategy = 0;  /* favor or force Huffman coding*/

        this.good_match = 0;
        /* Use a faster search when the previous match is longer than this */

        this.nice_match = 0; /* Stop searching when current match exceeds this */

        /* used by trees.c: */

        /* Didn't use ct_data typedef below to suppress compiler warning */

        // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
        // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
        // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

        // Use flat array of DOUBLE size, with interleaved fata,
        // because JS does not support effective
        this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree  = new utils.Buf16((2*D_CODES+1) * 2);
        this.bl_tree    = new utils.Buf16((2*BL_CODES+1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);

        this.l_desc   = null;         /* desc. for literal tree */
        this.d_desc   = null;         /* desc. for distance tree */
        this.bl_desc  = null;         /* desc. for bit length tree */

        //ush bl_count[MAX_BITS+1];
        this.bl_count = new utils.Buf16(MAX_BITS+1);
        /* number of codes at each bit length for an optimal tree */

        //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
        this.heap = new utils.Buf16(2*L_CODES+1);  /* heap used to build the Huffman trees */
        zero(this.heap);

        this.heap_len = 0;               /* number of elements in the heap */
        this.heap_max = 0;               /* element of largest frequency */
        /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
         * The same heap array is used to build all trees.
         */

        this.depth = new utils.Buf16(2*L_CODES+1); //uch depth[2*L_CODES+1];
        zero(this.depth);
        /* Depth of each subtree used as tie breaker for trees of equal frequency
         */

        this.l_buf = 0;          /* buffer index for literals or lengths */

        this.lit_bufsize = 0;
        /* Size of match buffer for literals/lengths.  There are 4 reasons for
         * limiting lit_bufsize to 64K:
         *   - frequencies can be kept in 16 bit counters
         *   - if compression is not successful for the first block, all input
         *     data is still in the window so we can still emit a stored block even
         *     when input comes from standard input.  (This can also be done for
         *     all blocks if lit_bufsize is not greater than 32K.)
         *   - if compression is not successful for a file smaller than 64K, we can
         *     even emit a stored file instead of a stored block (saving 5 bytes).
         *     This is applicable only for zip (not gzip or zlib).
         *   - creating new Huffman trees less frequently may not provide fast
         *     adaptation to changes in the input data statistics. (Take for
         *     example a binary file with poorly compressible code followed by
         *     a highly compressible string table.) Smaller buffer sizes give
         *     fast adaptation but have of course the overhead of transmitting
         *     trees more frequently.
         *   - I can't count above 4
         */

        this.last_lit = 0;      /* running index in l_buf */

        this.d_buf = 0;
        /* Buffer index for distances. To simplify the code, d_buf and l_buf have
         * the same number of elements. To use different lengths, an extra flag
         * array would be necessary.
         */

        this.opt_len = 0;       /* bit length of current block with optimal trees */
        this.static_len = 0;    /* bit length of current block with static trees */
        this.matches = 0;       /* number of string matches in current block */
        this.insert = 0;        /* bytes at end of window left to insert */


        this.bi_buf = 0;
        /* Output buffer. bits are inserted starting at the bottom (least
         * significant bits).
         */
        this.bi_valid = 0;
        /* Number of valid bits in bi_buf.  All bits above the last valid bit
         * are always zero.
         */

        // Used for window memory init. We safely ignore it for JS. That makes
        // sense only for pointers and memory check tools.
        //this.high_water = 0;
        /* High water mark offset in window for initialized bytes -- bytes above
         * this are set to zero in order to avoid memory check warnings when
         * longest match routines access bytes past the input.  This is then
         * updated to the new high water mark.
         */
    }


    function deflateResetKeep(strm) {
        var s;

        if (!strm || !strm.state) {
            return err(strm, Z_STREAM_ERROR);
        }

        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;

        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;

        if (s.wrap < 0) {
            s.wrap = -s.wrap;
            /* was made negative by deflate(..., Z_FINISH); */
        }
        s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
        strm.adler = (s.wrap === 2) ?
            0  // crc32(0, Z_NULL, 0)
            :
            1; // adler32(0, Z_NULL, 0)
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK;
    }


    function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
            lm_init(strm.state);
        }
        return ret;
    }


    function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) { return Z_STREAM_ERROR; }
        if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
        strm.state.gzhead = head;
        return Z_OK;
    }


    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) { // === Z_NULL
            return Z_STREAM_ERROR;
        }
        var wrap = 1;

        if (level === Z_DEFAULT_COMPRESSION) {
            level = 6;
        }

        if (windowBits < 0) { /* suppress zlib wrapper */
            wrap = 0;
            windowBits = -windowBits;
        }

        else if (windowBits > 15) {
            wrap = 2;           /* write gzip wrapper instead */
            windowBits -= 16;
        }


        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
            windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
            strategy < 0 || strategy > Z_FIXED) {
            return err(strm, Z_STREAM_ERROR);
        }


        if (windowBits === 8) {
            windowBits = 9;
        }
        /* until 256-byte window bug fixed */

        var s = new DeflateState();

        strm.state = s;
        s.strm = strm;

        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;

        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);

        // Don't need mem init magic for JS.
        //s.high_water = 0;  /* nothing written to s->window yet */

        s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);

        s.d_buf = s.lit_bufsize >> 1;
        s.l_buf = (1 + 2) * s.lit_bufsize;

        s.level = level;
        s.strategy = strategy;
        s.method = method;

        return deflateReset(strm);
    }

    function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }


    function deflate(strm, flush) {
        var old_flush, s;
        var beg, val; // for gzip header write only

        if (!strm || !strm.state ||
            flush > Z_BLOCK || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }

        s = strm.state;

        if (!strm.output ||
            (!strm.input && strm.avail_in !== 0) ||
            (s.status === FINISH_STATE && flush !== Z_FINISH)) {
            return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }

        s.strm = strm; /* just in case */
        old_flush = s.last_flush;
        s.last_flush = flush;

        /* Write the header */
        if (s.status === INIT_STATE) {

            if (s.wrap === 2) { // GZIP header
                strm.adler = 0;  //crc32(0L, Z_NULL, 0);
                put_byte(s, 31);
                put_byte(s, 139);
                put_byte(s, 8);
                if (!s.gzhead) { // s->gzhead == Z_NULL
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, 0);
                    put_byte(s, s.level === 9 ? 2 :
                        (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                            4 : 0));
                    put_byte(s, OS_CODE);
                    s.status = BUSY_STATE;
                }
                else {
                    put_byte(s, (s.gzhead.text ? 1 : 0) +
                            (s.gzhead.hcrc ? 2 : 0) +
                            (!s.gzhead.extra ? 0 : 4) +
                            (!s.gzhead.name ? 0 : 8) +
                            (!s.gzhead.comment ? 0 : 16)
                    );
                    put_byte(s, s.gzhead.time & 0xff);
                    put_byte(s, (s.gzhead.time >> 8) & 0xff);
                    put_byte(s, (s.gzhead.time >> 16) & 0xff);
                    put_byte(s, (s.gzhead.time >> 24) & 0xff);
                    put_byte(s, s.level === 9 ? 2 :
                        (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                            4 : 0));
                    put_byte(s, s.gzhead.os & 0xff);
                    if (s.gzhead.extra && s.gzhead.extra.length) {
                        put_byte(s, s.gzhead.extra.length & 0xff);
                        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
                    }
                    if (s.gzhead.hcrc) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                    }
                    s.gzindex = 0;
                    s.status = EXTRA_STATE;
                }
            }
            else // DEFLATE header
            {
                var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
                var level_flags = -1;

                if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                    level_flags = 0;
                } else if (s.level < 6) {
                    level_flags = 1;
                } else if (s.level === 6) {
                    level_flags = 2;
                } else {
                    level_flags = 3;
                }
                header |= (level_flags << 6);
                if (s.strstart !== 0) { header |= PRESET_DICT; }
                header += 31 - (header % 31);

                s.status = BUSY_STATE;
                putShortMSB(s, header);

                /* Save the adler32 of the preset dictionary: */
                if (s.strstart !== 0) {
                    putShortMSB(s, strm.adler >>> 16);
                    putShortMSB(s, strm.adler & 0xffff);
                }
                strm.adler = 1; // adler32(0L, Z_NULL, 0);
            }
        }

//#ifdef GZIP
        if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra/* != Z_NULL*/) {
                beg = s.pending;  /* start of bytes to update crc */

                while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                            break;
                        }
                    }
                    put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
                    s.gzindex++;
                }
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (s.gzindex === s.gzhead.extra.length) {
                    s.gzindex = 0;
                    s.status = NAME_STATE;
                }
            }
            else {
                s.status = NAME_STATE;
            }
        }
        if (s.status === NAME_STATE) {
            if (s.gzhead.name/* != Z_NULL*/) {
                beg = s.pending;  /* start of bytes to update crc */
                //int val;

                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                            val = 1;
                            break;
                        }
                    }
                    // JS specific: little magic to add zero terminator to end of string
                    if (s.gzindex < s.gzhead.name.length) {
                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);

                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (val === 0) {
                    s.gzindex = 0;
                    s.status = COMMENT_STATE;
                }
            }
            else {
                s.status = COMMENT_STATE;
            }
        }
        if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment/* != Z_NULL*/) {
                beg = s.pending;  /* start of bytes to update crc */
                //int val;

                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                            val = 1;
                            break;
                        }
                    }
                    // JS specific: little magic to add zero terminator to end of string
                    if (s.gzindex < s.gzhead.comment.length) {
                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);

                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (val === 0) {
                    s.status = HCRC_STATE;
                }
            }
            else {
                s.status = HCRC_STATE;
            }
        }
        if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                    flush_pending(strm);
                }
                if (s.pending + 2 <= s.pending_buf_size) {
                    put_byte(s, strm.adler & 0xff);
                    put_byte(s, (strm.adler >> 8) & 0xff);
                    strm.adler = 0; //crc32(0L, Z_NULL, 0);
                    s.status = BUSY_STATE;
                }
            }
            else {
                s.status = BUSY_STATE;
            }
        }
//#endif

        /* Flush as much pending output as possible */
        if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
                /* Since avail_out is 0, deflate will be called again with
                 * more output space, but possibly with both pending and
                 * avail_in equal to zero. There won't be anything to do,
                 * but this is not an error situation so make sure we
                 * return OK instead of BUF_ERROR at next call of deflate:
                 */
                s.last_flush = -1;
                return Z_OK;
            }

            /* Make sure there is something to do and avoid duplicate consecutive
             * flushes. For repeated and useless calls with Z_FINISH, we keep
             * returning Z_STREAM_END instead of Z_BUF_ERROR.
             */
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
            flush !== Z_FINISH) {
            return err(strm, Z_BUF_ERROR);
        }

        /* User must not provide more input after the first FINISH: */
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR);
        }

        /* Start a new block or continue the current one.
         */
        if (strm.avail_in !== 0 || s.lookahead !== 0 ||
            (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
            var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
                (s.strategy === Z_RLE ? deflate_rle(s, flush) :
                    configuration_table[s.level].func(s, flush));

            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    /* avoid BUF_ERROR next call, see above */
                }
                return Z_OK;
                /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
                 * of deflate should use the same flush parameter to make sure
                 * that the flush is complete. So we don't have to output an
                 * empty block here, this will be done at next call. This also
                 * ensures that for a very small output buffer, we emit at most
                 * one empty block.
                 */
            }
            if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                    trees._tr_align(s);
                }
                else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

                    trees._tr_stored_block(s, 0, 0, false);
                    /* For a full flush, this empty block will be recognized
                     * as a special marker by inflate_sync().
                     */
                    if (flush === Z_FULL_FLUSH) {
                        /*** CLEAR_HASH(s); ***/             /* forget history */
                        zero(s.head); // Fill with NIL (= 0);

                        if (s.lookahead === 0) {
                            s.strstart = 0;
                            s.block_start = 0;
                            s.insert = 0;
                        }
                    }
                }
                flush_pending(strm);
                if (strm.avail_out === 0) {
                    s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
                    return Z_OK;
                }
            }
        }
        //Assert(strm->avail_out > 0, "bug2");
        //if (strm.avail_out <= 0) { throw new Error("bug2");}

        if (flush !== Z_FINISH) { return Z_OK; }
        if (s.wrap <= 0) { return Z_STREAM_END; }

        /* Write the trailer */
        if (s.wrap === 2) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, (strm.adler >> 8) & 0xff);
            put_byte(s, (strm.adler >> 16) & 0xff);
            put_byte(s, (strm.adler >> 24) & 0xff);
            put_byte(s, strm.total_in & 0xff);
            put_byte(s, (strm.total_in >> 8) & 0xff);
            put_byte(s, (strm.total_in >> 16) & 0xff);
            put_byte(s, (strm.total_in >> 24) & 0xff);
        }
        else
        {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
        }

        flush_pending(strm);
        /* If avail_out is zero, the application will call deflate again
         * to flush the rest.
         */
        if (s.wrap > 0) { s.wrap = -s.wrap; }
        /* write the trailer only once! */
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }

    function deflateEnd(strm) {
        var status;

        if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
            return Z_STREAM_ERROR;
        }

        status = strm.state.status;
        if (status !== INIT_STATE &&
            status !== EXTRA_STATE &&
            status !== NAME_STATE &&
            status !== COMMENT_STATE &&
            status !== HCRC_STATE &&
            status !== BUSY_STATE &&
            status !== FINISH_STATE
            ) {
            return err(strm, Z_STREAM_ERROR);
        }

        strm.state = null;

        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }

    /* =========================================================================
     * Copy the source state to the destination state
     */
//function deflateCopy(dest, source) {
//
//}

    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateInfo = 'pako deflate (from Nodeca project)';

    /* Not implemented
     exports.deflateBound = deflateBound;
     exports.deflateCopy = deflateCopy;
     exports.deflateSetDictionary = deflateSetDictionary;
     exports.deflateParams = deflateParams;
     exports.deflatePending = deflatePending;
     exports.deflatePrime = deflatePrime;
     exports.deflateTune = deflateTune;
     */

},{"../utils/common":134,"./adler32":136,"./crc32":138,"./messages":144,"./trees":145}],140:[function(require,module,exports){
    'use strict';


    function GZheader() {
        /* true if compressed data believed to be text */
        this.text       = 0;
        /* modification time */
        this.time       = 0;
        /* extra flags (not used when writing a gzip file) */
        this.xflags     = 0;
        /* operating system */
        this.os         = 0;
        /* pointer to extra field or Z_NULL if none */
        this.extra      = null;
        /* extra field length (valid if extra != Z_NULL) */
        this.extra_len  = 0; // Actually, we don't need it in JS,
        // but leave for few code modifications

        //
        // Setup limits is not necessary because in js we should not preallocate memory
        // for inflate use constant limit in 65536 bytes
        //

        /* space at extra (only when reading header) */
        // this.extra_max  = 0;
        /* pointer to zero-terminated file name or Z_NULL */
        this.name       = '';
        /* space at name (only when reading header) */
        // this.name_max   = 0;
        /* pointer to zero-terminated comment or Z_NULL */
        this.comment    = '';
        /* space at comment (only when reading header) */
        // this.comm_max   = 0;
        /* true if there was or will be a header crc */
        this.hcrc       = 0;
        /* true when done reading gzip header (not used when writing a gzip file) */
        this.done       = false;
    }

    module.exports = GZheader;

},{}],141:[function(require,module,exports){
    'use strict';

// See state defs from inflate.js
    var BAD = 30;       /* got a data error -- remain here until reset */
    var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

    /*
     Decode literal, length, and distance codes and write out the resulting
     literal and match bytes until either not enough input or output is
     available, an end-of-block is encountered, or a data error is encountered.
     When large enough input and output buffers are supplied to inflate(), for
     example, a 16K input buffer and a 64K output buffer, more than 95% of the
     inflate execution time is spent in this routine.

     Entry assumptions:

     state.mode === LEN
     strm.avail_in >= 6
     strm.avail_out >= 258
     start >= strm.avail_out
     state.bits < 8

     On return, state.mode is one of:

     LEN -- ran out of enough output space or enough available input
     TYPE -- reached end of block code, inflate() to interpret next block
     BAD -- error in block data

     Notes:

     - The maximum input bits used by a length/distance pair is 15 bits for the
     length code, 5 bits for the length extra, 15 bits for the distance code,
     and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
     Therefore if strm.avail_in >= 6, then there is enough input to avoid
     checking for available input while decoding.

     - The maximum bytes that a single length/distance pair can output is 258
     bytes, which is the maximum length that can be coded.  inflate_fast()
     requires strm.avail_out >= 258 for each loop to avoid checking for
     output space.
     */
    module.exports = function inflate_fast(strm, start) {
        var state;
        var _in;                    /* local strm.input */
        var last;                   /* have enough input while in < last */
        var _out;                   /* local strm.output */
        var beg;                    /* inflate()'s initial strm.output */
        var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
        var dmax;                   /* maximum distance from zlib header */
//#endif
        var wsize;                  /* window size or zero if not using window */
        var whave;                  /* valid bytes in the window */
        var wnext;                  /* window write index */
        var window;                 /* allocated sliding window, if wsize != 0 */
        var hold;                   /* local strm.hold */
        var bits;                   /* local strm.bits */
        var lcode;                  /* local strm.lencode */
        var dcode;                  /* local strm.distcode */
        var lmask;                  /* mask for first level of length codes */
        var dmask;                  /* mask for first level of distance codes */
        var here;                   /* retrieved table entry */
        var op;                     /* code bits, operation, extra bits, or */
        /*  window position, window bytes to copy */
        var len;                    /* match length, unused bytes */
        var dist;                   /* match distance */
        var from;                   /* where to copy match from */
        var from_source;


        var input, output; // JS specific, because we have no pointers

        /* copy state to local variables */
        state = strm.state;
        //here = state.here;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
        dmax = state.dmax;
//#endif
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;


        /* decode literals and length/distances until end-of-block or not enough
         input data or output space */

        top:
            do {
                if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                }

                here = lcode[hold & lmask];

                dolen:
                    for (;;) { // Goto emulation
                        op = here >>> 24/*here.bits*/;
                        hold >>>= op;
                        bits -= op;
                        op = (here >>> 16) & 0xff/*here.op*/;
                        if (op === 0) {                          /* literal */
                            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                            //        "inflate:         literal '%c'\n" :
                            //        "inflate:         literal 0x%02x\n", here.val));
                            output[_out++] = here & 0xffff/*here.val*/;
                        }
                        else if (op & 16) {                     /* length base */
                            len = here & 0xffff/*here.val*/;
                            op &= 15;                           /* number of extra bits */
                            if (op) {
                                if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                }
                                len += hold & ((1 << op) - 1);
                                hold >>>= op;
                                bits -= op;
                            }
                            //Tracevv((stderr, "inflate:         length %u\n", len));
                            if (bits < 15) {
                                hold += input[_in++] << bits;
                                bits += 8;
                                hold += input[_in++] << bits;
                                bits += 8;
                            }
                            here = dcode[hold & dmask];

                            dodist:
                                for (;;) { // goto emulation
                                    op = here >>> 24/*here.bits*/;
                                    hold >>>= op;
                                    bits -= op;
                                    op = (here >>> 16) & 0xff/*here.op*/;

                                    if (op & 16) {                      /* distance base */
                                        dist = here & 0xffff/*here.val*/;
                                        op &= 15;                       /* number of extra bits */
                                        if (bits < op) {
                                            hold += input[_in++] << bits;
                                            bits += 8;
                                            if (bits < op) {
                                                hold += input[_in++] << bits;
                                                bits += 8;
                                            }
                                        }
                                        dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
                                        if (dist > dmax) {
                                            strm.msg = 'invalid distance too far back';
                                            state.mode = BAD;
                                            break top;
                                        }
//#endif
                                        hold >>>= op;
                                        bits -= op;
                                        //Tracevv((stderr, "inflate:         distance %u\n", dist));
                                        op = _out - beg;                /* max distance in output */
                                        if (dist > op) {                /* see if copy from window */
                                            op = dist - op;               /* distance back in window */
                                            if (op > whave) {
                                                if (state.sane) {
                                                    strm.msg = 'invalid distance too far back';
                                                    state.mode = BAD;
                                                    break top;
                                                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
                                            }
                                            from = 0; // window index
                                            from_source = window;
                                            if (wnext === 0) {           /* very common case */
                                                from += wsize - op;
                                                if (op < len) {         /* some from window */
                                                    len -= op;
                                                    do {
                                                        output[_out++] = window[from++];
                                                    } while (--op);
                                                    from = _out - dist;  /* rest from output */
                                                    from_source = output;
                                                }
                                            }
                                            else if (wnext < op) {      /* wrap around window */
                                                from += wsize + wnext - op;
                                                op -= wnext;
                                                if (op < len) {         /* some from end of window */
                                                    len -= op;
                                                    do {
                                                        output[_out++] = window[from++];
                                                    } while (--op);
                                                    from = 0;
                                                    if (wnext < len) {  /* some from start of window */
                                                        op = wnext;
                                                        len -= op;
                                                        do {
                                                            output[_out++] = window[from++];
                                                        } while (--op);
                                                        from = _out - dist;      /* rest from output */
                                                        from_source = output;
                                                    }
                                                }
                                            }
                                            else {                      /* contiguous in window */
                                                from += wnext - op;
                                                if (op < len) {         /* some from window */
                                                    len -= op;
                                                    do {
                                                        output[_out++] = window[from++];
                                                    } while (--op);
                                                    from = _out - dist;  /* rest from output */
                                                    from_source = output;
                                                }
                                            }
                                            while (len > 2) {
                                                output[_out++] = from_source[from++];
                                                output[_out++] = from_source[from++];
                                                output[_out++] = from_source[from++];
                                                len -= 3;
                                            }
                                            if (len) {
                                                output[_out++] = from_source[from++];
                                                if (len > 1) {
                                                    output[_out++] = from_source[from++];
                                                }
                                            }
                                        }
                                        else {
                                            from = _out - dist;          /* copy direct from output */
                                            do {                        /* minimum length is three */
                                                output[_out++] = output[from++];
                                                output[_out++] = output[from++];
                                                output[_out++] = output[from++];
                                                len -= 3;
                                            } while (len > 2);
                                            if (len) {
                                                output[_out++] = output[from++];
                                                if (len > 1) {
                                                    output[_out++] = output[from++];
                                                }
                                            }
                                        }
                                    }
                                    else if ((op & 64) === 0) {          /* 2nd level distance code */
                                        here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                                        continue dodist;
                                    }
                                    else {
                                        strm.msg = 'invalid distance code';
                                        state.mode = BAD;
                                        break top;
                                    }

                                    break; // need to emulate goto via "continue"
                                }
                        }
                        else if ((op & 64) === 0) {              /* 2nd level length code */
                            here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                            continue dolen;
                        }
                        else if (op & 32) {                     /* end-of-block */
                            //Tracevv((stderr, "inflate:         end of block\n"));
                            state.mode = TYPE;
                            break top;
                        }
                        else {
                            strm.msg = 'invalid literal/length code';
                            state.mode = BAD;
                            break top;
                        }

                        break; // need to emulate goto via "continue"
                    }
            } while (_in < last && _out < end);

        /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;

        /* update state and return */
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
        strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
        state.hold = hold;
        state.bits = bits;
        return;
    };

},{}],142:[function(require,module,exports){
    'use strict';


    var utils = require('../utils/common');
    var adler32 = require('./adler32');
    var crc32   = require('./crc32');
    var inflate_fast = require('./inffast');
    var inflate_table = require('./inftrees');

    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;

    /* Public constants ==========================================================*/
    /* ===========================================================================*/


    /* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
    var Z_FINISH        = 4;
    var Z_BLOCK         = 5;
    var Z_TREES         = 6;


    /* Return codes for the compression/decompression functions. Negative values
     * are errors, positive values are used for special but normal events.
     */
    var Z_OK            = 0;
    var Z_STREAM_END    = 1;
    var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
    var Z_STREAM_ERROR  = -2;
    var Z_DATA_ERROR    = -3;
    var Z_MEM_ERROR     = -4;
    var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

    /* The deflate compression method */
    var Z_DEFLATED  = 8;


    /* STATES ====================================================================*/
    /* ===========================================================================*/


    var    HEAD = 1;       /* i: waiting for magic header */
    var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
    var    TIME = 3;       /* i: waiting for modification time (gzip) */
    var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
    var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
    var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
    var    NAME = 7;       /* i: waiting for end of file name (gzip) */
    var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
    var    HCRC = 9;       /* i: waiting for header crc (gzip) */
    var    DICTID = 10;    /* i: waiting for dictionary check value */
    var    DICT = 11;      /* waiting for inflateSetDictionary() call */
    var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
    var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
    var        STORED = 14;    /* i: waiting for stored size (length and complement) */
    var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
    var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
    var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
    var        LENLENS = 18;   /* i: waiting for code length code lengths */
    var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
    var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
    var            LEN = 21;       /* i: waiting for length/lit/eob code */
    var            LENEXT = 22;    /* i: waiting for length extra bits */
    var            DIST = 23;      /* i: waiting for distance code */
    var            DISTEXT = 24;   /* i: waiting for distance extra bits */
    var            MATCH = 25;     /* o: waiting for output space to copy string */
    var            LIT = 26;       /* o: waiting for output space to write literal */
    var    CHECK = 27;     /* i: waiting for 32-bit check value */
    var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
    var    DONE = 29;      /* finished check, done -- remain here until reset */
    var    BAD = 30;       /* got a data error -- remain here until reset */
    var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
    var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

    /* ===========================================================================*/



    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

    var MAX_WBITS = 15;
    /* 32K LZ77 window */
    var DEF_WBITS = MAX_WBITS;


    function ZSWAP32(q) {
        return  (((q >>> 24) & 0xff) +
            ((q >>> 8) & 0xff00) +
            ((q & 0xff00) << 8) +
            ((q & 0xff) << 24));
    }


    function InflateState() {
        this.mode = 0;             /* current inflate mode */
        this.last = false;          /* true if processing last block */
        this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
        this.havedict = false;      /* true if dictionary provided */
        this.flags = 0;             /* gzip header method and flags (0 if zlib) */
        this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
        this.check = 0;             /* protected copy of check value */
        this.total = 0;             /* protected copy of output count */
        // TODO: may be {}
        this.head = null;           /* where to save gzip header information */

        /* sliding window */
        this.wbits = 0;             /* log base 2 of requested window size */
        this.wsize = 0;             /* window size or zero if not using window */
        this.whave = 0;             /* valid bytes in the window */
        this.wnext = 0;             /* window write index */
        this.window = null;         /* allocated sliding window, if needed */

        /* bit accumulator */
        this.hold = 0;              /* input bit accumulator */
        this.bits = 0;              /* number of bits in "in" */

        /* for string and stored block copying */
        this.length = 0;            /* literal or length of data to copy */
        this.offset = 0;            /* distance back to copy string from */

        /* for table and code decoding */
        this.extra = 0;             /* extra bits needed */

        /* fixed and dynamic code tables */
        this.lencode = null;          /* starting table for length/literal codes */
        this.distcode = null;         /* starting table for distance codes */
        this.lenbits = 0;           /* index bits for lencode */
        this.distbits = 0;          /* index bits for distcode */

        /* dynamic table building */
        this.ncode = 0;             /* number of code length code lengths */
        this.nlen = 0;              /* number of length code lengths */
        this.ndist = 0;             /* number of distance code lengths */
        this.have = 0;              /* number of code lengths in lens[] */
        this.next = null;              /* next available space in codes[] */

        this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
        this.work = new utils.Buf16(288); /* work area for code table building */

        /*
         because we don't have pointers in js, we use lencode and distcode directly
         as buffers so we don't need codes
         */
        //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
        this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
        this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
        this.sane = 0;                   /* if false, allow invalid distance too far */
        this.back = 0;                   /* bits back of last unprocessed length/lit */
        this.was = 0;                    /* initial length of match */
    }

    function inflateResetKeep(strm) {
        var state;

        if (!strm || !strm.state) { return Z_STREAM_ERROR; }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = ''; /*Z_NULL*/
        if (state.wrap) {       /* to support ill-conceived Java test suite */
            strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null/*Z_NULL*/;
        state.hold = 0;
        state.bits = 0;
        //state.lencode = state.distcode = state.next = state.codes;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

        state.sane = 1;
        state.back = -1;
        //Tracev((stderr, "inflate: reset\n"));
        return Z_OK;
    }

    function inflateReset(strm) {
        var state;

        if (!strm || !strm.state) { return Z_STREAM_ERROR; }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);

    }

    function inflateReset2(strm, windowBits) {
        var wrap;
        var state;

        /* get the state */
        if (!strm || !strm.state) { return Z_STREAM_ERROR; }
        state = strm.state;

        /* extract wrap request from windowBits parameter */
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        }
        else {
            wrap = (windowBits >> 4) + 1;
            if (windowBits < 48) {
                windowBits &= 15;
            }
        }

        /* set number of window bits, free window if different */
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
        }

        /* update state and reset the rest of it */
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
    }

    function inflateInit2(strm, windowBits) {
        var ret;
        var state;

        if (!strm) { return Z_STREAM_ERROR; }
        //strm.msg = Z_NULL;                 /* in case we return an error */

        state = new InflateState();

        //if (state === Z_NULL) return Z_MEM_ERROR;
        //Tracev((stderr, "inflate: allocated\n"));
        strm.state = state;
        state.window = null/*Z_NULL*/;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
            strm.state = null/*Z_NULL*/;
        }
        return ret;
    }

    function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS);
    }


    /*
     Return state with length and distance decoding tables and index sizes set to
     fixed code decoding.  Normally this returns fixed tables from inffixed.h.
     If BUILDFIXED is defined, then instead this routine builds the tables the
     first time it's called, and returns those tables the first time and
     thereafter.  This reduces the size of the code by about 2K bytes, in
     exchange for a little execution time.  However, BUILDFIXED should not be
     used for threaded applications, since the rewriting of the tables and virgin
     may not be thread-safe.
     */
    var virgin = true;

    var lenfix, distfix; // We have no pointers in JS, so keep tables separate

    function fixedtables(state) {
        /* build fixed huffman tables if first call (may not be thread safe) */
        if (virgin) {
            var sym;

            lenfix = new utils.Buf32(512);
            distfix = new utils.Buf32(32);

            /* literal/length table */
            sym = 0;
            while (sym < 144) { state.lens[sym++] = 8; }
            while (sym < 256) { state.lens[sym++] = 9; }
            while (sym < 280) { state.lens[sym++] = 7; }
            while (sym < 288) { state.lens[sym++] = 8; }

            inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, {bits: 9});

            /* distance table */
            sym = 0;
            while (sym < 32) { state.lens[sym++] = 5; }

            inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, {bits: 5});

            /* do this just once */
            virgin = false;
        }

        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
    }


    /*
     Update the window with the last wsize (normally 32K) bytes written before
     returning.  If window does not exist yet, create it.  This is only called
     when a window is already in use, or when output has been written during this
     inflate call, but the end of the deflate stream has not been reached yet.
     It is also called to create a window for dictionary data when a dictionary
     is loaded.

     Providing output buffers larger than 32K to inflate() should provide a speed
     advantage, since only the last 32K of output is copied to the sliding window
     upon return from inflate(), and since all distances after the first 32K of
     output will fall in the output data, making match copies simpler and faster.
     The advantage may be dependent on the size of the processor's data caches.
     */
    function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;

        /* if it hasn't been done already, allocate space for the window */
        if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;

            state.window = new utils.Buf8(state.wsize);
        }

        /* copy state->wsize or less output bytes into the circular window */
        if (copy >= state.wsize) {
            utils.arraySet(state.window,src, end - state.wsize, state.wsize, 0);
            state.wnext = 0;
            state.whave = state.wsize;
        }
        else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
                dist = copy;
            }
            //zmemcpy(state->window + state->wnext, end - copy, dist);
            utils.arraySet(state.window,src, end - copy, dist, state.wnext);
            copy -= dist;
            if (copy) {
                //zmemcpy(state->window, end - copy, copy);
                utils.arraySet(state.window,src, end - copy, copy, 0);
                state.wnext = copy;
                state.whave = state.wsize;
            }
            else {
                state.wnext += dist;
                if (state.wnext === state.wsize) { state.wnext = 0; }
                if (state.whave < state.wsize) { state.whave += dist; }
            }
        }
        return 0;
    }

    function inflate(strm, flush) {
        var state;
        var input, output;          // input/output buffers
        var next;                   /* next input INDEX */
        var put;                    /* next output INDEX */
        var have, left;             /* available input and output */
        var hold;                   /* bit buffer */
        var bits;                   /* bits in bit buffer */
        var _in, _out;              /* save starting available input and output */
        var copy;                   /* number of stored or match bytes to copy */
        var from;                   /* where to copy match bytes from */
        var from_source;
        var here = 0;               /* current decoding table entry */
        var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
        //var last;                   /* parent table entry */
        var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
        var len;                    /* length to copy for repeats, bits to drop */
        var ret;                    /* return code */
        var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
        var opts;

        var n; // temporary var for NEED_BITS

        var order = /* permutation of code lengths */
            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


        if (!strm || !strm.state || !strm.output ||
            (!strm.input && strm.avail_in !== 0)) {
            return Z_STREAM_ERROR;
        }

        state = strm.state;
        if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        _in = have;
        _out = left;
        ret = Z_OK;

        inf_leave: // goto emulation
            for (;;) {
                switch (state.mode) {
                    case HEAD:
                        if (state.wrap === 0) {
                            state.mode = TYPEDO;
                            break;
                        }
                        //=== NEEDBITS(16);
                        while (bits < 16) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
                            state.check = 0/*crc32(0L, Z_NULL, 0)*/;
                            //=== CRC2(state.check, hold);
                            hbuf[0] = hold & 0xff;
                            hbuf[1] = (hold >>> 8) & 0xff;
                            state.check = crc32(state.check, hbuf, 2, 0);
                            //===//

                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            state.mode = FLAGS;
                            break;
                        }
                        state.flags = 0;           /* expect zlib header */
                        if (state.head) {
                            state.head.done = false;
                        }
                        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
                            (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
                            strm.msg = 'incorrect header check';
                            state.mode = BAD;
                            break;
                        }
                        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
                            strm.msg = 'unknown compression method';
                            state.mode = BAD;
                            break;
                        }
                        //--- DROPBITS(4) ---//
                        hold >>>= 4;
                        bits -= 4;
                        //---//
                        len = (hold & 0x0f)/*BITS(4)*/ + 8;
                        if (state.wbits === 0) {
                            state.wbits = len;
                        }
                        else if (len > state.wbits) {
                            strm.msg = 'invalid window size';
                            state.mode = BAD;
                            break;
                        }
                        state.dmax = 1 << len;
                        //Tracev((stderr, "inflate:   zlib header ok\n"));
                        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
                        state.mode = hold & 0x200 ? DICTID : TYPE;
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        break;
                    case FLAGS:
                        //=== NEEDBITS(16); */
                        while (bits < 16) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        state.flags = hold;
                        if ((state.flags & 0xff) !== Z_DEFLATED) {
                            strm.msg = 'unknown compression method';
                            state.mode = BAD;
                            break;
                        }
                        if (state.flags & 0xe000) {
                            strm.msg = 'unknown header flags set';
                            state.mode = BAD;
                            break;
                        }
                        if (state.head) {
                            state.head.text = ((hold >> 8) & 1);
                        }
                        if (state.flags & 0x0200) {
                            //=== CRC2(state.check, hold);
                            hbuf[0] = hold & 0xff;
                            hbuf[1] = (hold >>> 8) & 0xff;
                            state.check = crc32(state.check, hbuf, 2, 0);
                            //===//
                        }
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = TIME;
                    /* falls through */
                    case TIME:
                        //=== NEEDBITS(32); */
                        while (bits < 32) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        if (state.head) {
                            state.head.time = hold;
                        }
                        if (state.flags & 0x0200) {
                            //=== CRC4(state.check, hold)
                            hbuf[0] = hold & 0xff;
                            hbuf[1] = (hold >>> 8) & 0xff;
                            hbuf[2] = (hold >>> 16) & 0xff;
                            hbuf[3] = (hold >>> 24) & 0xff;
                            state.check = crc32(state.check, hbuf, 4, 0);
                            //===
                        }
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = OS;
                    /* falls through */
                    case OS:
                        //=== NEEDBITS(16); */
                        while (bits < 16) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        if (state.head) {
                            state.head.xflags = (hold & 0xff);
                            state.head.os = (hold >> 8);
                        }
                        if (state.flags & 0x0200) {
                            //=== CRC2(state.check, hold);
                            hbuf[0] = hold & 0xff;
                            hbuf[1] = (hold >>> 8) & 0xff;
                            state.check = crc32(state.check, hbuf, 2, 0);
                            //===//
                        }
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = EXLEN;
                    /* falls through */
                    case EXLEN:
                        if (state.flags & 0x0400) {
                            //=== NEEDBITS(16); */
                            while (bits < 16) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.length = hold;
                            if (state.head) {
                                state.head.extra_len = hold;
                            }
                            if (state.flags & 0x0200) {
                                //=== CRC2(state.check, hold);
                                hbuf[0] = hold & 0xff;
                                hbuf[1] = (hold >>> 8) & 0xff;
                                state.check = crc32(state.check, hbuf, 2, 0);
                                //===//
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                        }
                        else if (state.head) {
                            state.head.extra = null/*Z_NULL*/;
                        }
                        state.mode = EXTRA;
                    /* falls through */
                    case EXTRA:
                        if (state.flags & 0x0400) {
                            copy = state.length;
                            if (copy > have) { copy = have; }
                            if (copy) {
                                if (state.head) {
                                    len = state.head.extra_len - state.length;
                                    if (!state.head.extra) {
                                        // Use untyped array for more conveniend processing later
                                        state.head.extra = new Array(state.head.extra_len);
                                    }
                                    utils.arraySet(
                                        state.head.extra,
                                        input,
                                        next,
                                        // extra field is limited to 65536 bytes
                                        // - no need for additional size check
                                        copy,
                                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                                        len
                                    );
                                    //zmemcpy(state.head.extra + len, next,
                                    //        len + copy > state.head.extra_max ?
                                    //        state.head.extra_max - len : copy);
                                }
                                if (state.flags & 0x0200) {
                                    state.check = crc32(state.check, input, copy, next);
                                }
                                have -= copy;
                                next += copy;
                                state.length -= copy;
                            }
                            if (state.length) { break inf_leave; }
                        }
                        state.length = 0;
                        state.mode = NAME;
                    /* falls through */
                    case NAME:
                        if (state.flags & 0x0800) {
                            if (have === 0) { break inf_leave; }
                            copy = 0;
                            do {
                                // TODO: 2 or 1 bytes?
                                len = input[next + copy++];
                                /* use constant limit because in js we should not preallocate memory */
                                if (state.head && len &&
                                    (state.length < 65536 /*state.head.name_max*/)) {
                                    state.head.name += String.fromCharCode(len);
                                }
                            } while (len && copy < have);

                            if (state.flags & 0x0200) {
                                state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            if (len) { break inf_leave; }
                        }
                        else if (state.head) {
                            state.head.name = null;
                        }
                        state.length = 0;
                        state.mode = COMMENT;
                    /* falls through */
                    case COMMENT:
                        if (state.flags & 0x1000) {
                            if (have === 0) { break inf_leave; }
                            copy = 0;
                            do {
                                len = input[next + copy++];
                                /* use constant limit because in js we should not preallocate memory */
                                if (state.head && len &&
                                    (state.length < 65536 /*state.head.comm_max*/)) {
                                    state.head.comment += String.fromCharCode(len);
                                }
                            } while (len && copy < have);
                            if (state.flags & 0x0200) {
                                state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            if (len) { break inf_leave; }
                        }
                        else if (state.head) {
                            state.head.comment = null;
                        }
                        state.mode = HCRC;
                    /* falls through */
                    case HCRC:
                        if (state.flags & 0x0200) {
                            //=== NEEDBITS(16); */
                            while (bits < 16) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            if (hold !== (state.check & 0xffff)) {
                                strm.msg = 'header crc mismatch';
                                state.mode = BAD;
                                break;
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                        }
                        if (state.head) {
                            state.head.hcrc = ((state.flags >> 9) & 1);
                            state.head.done = true;
                        }
                        strm.adler = state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
                        state.mode = TYPE;
                        break;
                    case DICTID:
                        //=== NEEDBITS(32); */
                        while (bits < 32) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        strm.adler = state.check = ZSWAP32(hold);
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = DICT;
                    /* falls through */
                    case DICT:
                        if (state.havedict === 0) {
                            //--- RESTORE() ---
                            strm.next_out = put;
                            strm.avail_out = left;
                            strm.next_in = next;
                            strm.avail_in = have;
                            state.hold = hold;
                            state.bits = bits;
                            //---
                            return Z_NEED_DICT;
                        }
                        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
                        state.mode = TYPE;
                    /* falls through */
                    case TYPE:
                        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
                    /* falls through */
                    case TYPEDO:
                        if (state.last) {
                            //--- BYTEBITS() ---//
                            hold >>>= bits & 7;
                            bits -= bits & 7;
                            //---//
                            state.mode = CHECK;
                            break;
                        }
                        //=== NEEDBITS(3); */
                        while (bits < 3) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        state.last = (hold & 0x01)/*BITS(1)*/;
                        //--- DROPBITS(1) ---//
                        hold >>>= 1;
                        bits -= 1;
                        //---//

                        switch ((hold & 0x03)/*BITS(2)*/) {
                            case 0:                             /* stored block */
                                //Tracev((stderr, "inflate:     stored block%s\n",
                                //        state.last ? " (last)" : ""));
                                state.mode = STORED;
                                break;
                            case 1:                             /* fixed block */
                                fixedtables(state);
                                //Tracev((stderr, "inflate:     fixed codes block%s\n",
                                //        state.last ? " (last)" : ""));
                                state.mode = LEN_;             /* decode codes */
                                if (flush === Z_TREES) {
                                    //--- DROPBITS(2) ---//
                                    hold >>>= 2;
                                    bits -= 2;
                                    //---//
                                    break inf_leave;
                                }
                                break;
                            case 2:                             /* dynamic block */
                                //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                                //        state.last ? " (last)" : ""));
                                state.mode = TABLE;
                                break;
                            case 3:
                                strm.msg = 'invalid block type';
                                state.mode = BAD;
                        }
                        //--- DROPBITS(2) ---//
                        hold >>>= 2;
                        bits -= 2;
                        //---//
                        break;
                    case STORED:
                        //--- BYTEBITS() ---// /* go to byte boundary */
                        hold >>>= bits & 7;
                        bits -= bits & 7;
                        //---//
                        //=== NEEDBITS(32); */
                        while (bits < 32) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
                            strm.msg = 'invalid stored block lengths';
                            state.mode = BAD;
                            break;
                        }
                        state.length = hold & 0xffff;
                        //Tracev((stderr, "inflate:       stored length %u\n",
                        //        state.length));
                        //=== INITBITS();
                        hold = 0;
                        bits = 0;
                        //===//
                        state.mode = COPY_;
                        if (flush === Z_TREES) { break inf_leave; }
                    /* falls through */
                    case COPY_:
                        state.mode = COPY;
                    /* falls through */
                    case COPY:
                        copy = state.length;
                        if (copy) {
                            if (copy > have) { copy = have; }
                            if (copy > left) { copy = left; }
                            if (copy === 0) { break inf_leave; }
                            //--- zmemcpy(put, next, copy); ---
                            utils.arraySet(output, input, next, copy, put);
                            //---//
                            have -= copy;
                            next += copy;
                            left -= copy;
                            put += copy;
                            state.length -= copy;
                            break;
                        }
                        //Tracev((stderr, "inflate:       stored end\n"));
                        state.mode = TYPE;
                        break;
                    case TABLE:
                        //=== NEEDBITS(14); */
                        while (bits < 14) {
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        //===//
                        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
                        //--- DROPBITS(5) ---//
                        hold >>>= 5;
                        bits -= 5;
                        //---//
                        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
                        //--- DROPBITS(5) ---//
                        hold >>>= 5;
                        bits -= 5;
                        //---//
                        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
                        //--- DROPBITS(4) ---//
                        hold >>>= 4;
                        bits -= 4;
                        //---//
//#ifndef PKZIP_BUG_WORKAROUND
                        if (state.nlen > 286 || state.ndist > 30) {
                            strm.msg = 'too many length or distance symbols';
                            state.mode = BAD;
                            break;
                        }
//#endif
                        //Tracev((stderr, "inflate:       table sizes ok\n"));
                        state.have = 0;
                        state.mode = LENLENS;
                    /* falls through */
                    case LENLENS:
                        while (state.have < state.ncode) {
                            //=== NEEDBITS(3);
                            while (bits < 3) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
                            //--- DROPBITS(3) ---//
                            hold >>>= 3;
                            bits -= 3;
                            //---//
                        }
                        while (state.have < 19) {
                            state.lens[order[state.have++]] = 0;
                        }
                        // We have separate tables & no pointers. 2 commented lines below not needed.
                        //state.next = state.codes;
                        //state.lencode = state.next;
                        // Switch to use dynamic table
                        state.lencode = state.lendyn;
                        state.lenbits = 7;

                        opts = {bits: state.lenbits};
                        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                        state.lenbits = opts.bits;

                        if (ret) {
                            strm.msg = 'invalid code lengths set';
                            state.mode = BAD;
                            break;
                        }
                        //Tracev((stderr, "inflate:       code lengths ok\n"));
                        state.have = 0;
                        state.mode = CODELENS;
                    /* falls through */
                    case CODELENS:
                        while (state.have < state.nlen + state.ndist) {
                            for (;;) {
                                here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
                                here_bits = here >>> 24;
                                here_op = (here >>> 16) & 0xff;
                                here_val = here & 0xffff;

                                if ((here_bits) <= bits) { break; }
                                //--- PULLBYTE() ---//
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                                //---//
                            }
                            if (here_val < 16) {
                                //--- DROPBITS(here.bits) ---//
                                hold >>>= here_bits;
                                bits -= here_bits;
                                //---//
                                state.lens[state.have++] = here_val;
                            }
                            else {
                                if (here_val === 16) {
                                    //=== NEEDBITS(here.bits + 2);
                                    n = here_bits + 2;
                                    while (bits < n) {
                                        if (have === 0) { break inf_leave; }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    //--- DROPBITS(here.bits) ---//
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    //---//
                                    if (state.have === 0) {
                                        strm.msg = 'invalid bit length repeat';
                                        state.mode = BAD;
                                        break;
                                    }
                                    len = state.lens[state.have - 1];
                                    copy = 3 + (hold & 0x03);//BITS(2);
                                    //--- DROPBITS(2) ---//
                                    hold >>>= 2;
                                    bits -= 2;
                                    //---//
                                }
                                else if (here_val === 17) {
                                    //=== NEEDBITS(here.bits + 3);
                                    n = here_bits + 3;
                                    while (bits < n) {
                                        if (have === 0) { break inf_leave; }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    //--- DROPBITS(here.bits) ---//
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    //---//
                                    len = 0;
                                    copy = 3 + (hold & 0x07);//BITS(3);
                                    //--- DROPBITS(3) ---//
                                    hold >>>= 3;
                                    bits -= 3;
                                    //---//
                                }
                                else {
                                    //=== NEEDBITS(here.bits + 7);
                                    n = here_bits + 7;
                                    while (bits < n) {
                                        if (have === 0) { break inf_leave; }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    //===//
                                    //--- DROPBITS(here.bits) ---//
                                    hold >>>= here_bits;
                                    bits -= here_bits;
                                    //---//
                                    len = 0;
                                    copy = 11 + (hold & 0x7f);//BITS(7);
                                    //--- DROPBITS(7) ---//
                                    hold >>>= 7;
                                    bits -= 7;
                                    //---//
                                }
                                if (state.have + copy > state.nlen + state.ndist) {
                                    strm.msg = 'invalid bit length repeat';
                                    state.mode = BAD;
                                    break;
                                }
                                while (copy--) {
                                    state.lens[state.have++] = len;
                                }
                            }
                        }

                        /* handle error breaks in while */
                        if (state.mode === BAD) { break; }

                        /* check for end-of-block code (better have one) */
                        if (state.lens[256] === 0) {
                            strm.msg = 'invalid code -- missing end-of-block';
                            state.mode = BAD;
                            break;
                        }

                        /* build code tables -- note: do not change the lenbits or distbits
                         values here (9 and 6) without reading the comments in inftrees.h
                         concerning the ENOUGH constants, which depend on those values */
                        state.lenbits = 9;

                        opts = {bits: state.lenbits};
                        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                        // We have separate tables & no pointers. 2 commented lines below not needed.
                        // state.next_index = opts.table_index;
                        state.lenbits = opts.bits;
                        // state.lencode = state.next;

                        if (ret) {
                            strm.msg = 'invalid literal/lengths set';
                            state.mode = BAD;
                            break;
                        }

                        state.distbits = 6;
                        //state.distcode.copy(state.codes);
                        // Switch to use dynamic table
                        state.distcode = state.distdyn;
                        opts = {bits: state.distbits};
                        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                        // We have separate tables & no pointers. 2 commented lines below not needed.
                        // state.next_index = opts.table_index;
                        state.distbits = opts.bits;
                        // state.distcode = state.next;

                        if (ret) {
                            strm.msg = 'invalid distances set';
                            state.mode = BAD;
                            break;
                        }
                        //Tracev((stderr, 'inflate:       codes ok\n'));
                        state.mode = LEN_;
                        if (flush === Z_TREES) { break inf_leave; }
                    /* falls through */
                    case LEN_:
                        state.mode = LEN;
                    /* falls through */
                    case LEN:
                        if (have >= 6 && left >= 258) {
                            //--- RESTORE() ---
                            strm.next_out = put;
                            strm.avail_out = left;
                            strm.next_in = next;
                            strm.avail_in = have;
                            state.hold = hold;
                            state.bits = bits;
                            //---
                            inflate_fast(strm, _out);
                            //--- LOAD() ---
                            put = strm.next_out;
                            output = strm.output;
                            left = strm.avail_out;
                            next = strm.next_in;
                            input = strm.input;
                            have = strm.avail_in;
                            hold = state.hold;
                            bits = state.bits;
                            //---

                            if (state.mode === TYPE) {
                                state.back = -1;
                            }
                            break;
                        }
                        state.back = 0;
                        for (;;) {
                            here = state.lencode[hold & ((1 << state.lenbits) -1)];  /*BITS(state.lenbits)*/
                            here_bits = here >>> 24;
                            here_op = (here >>> 16) & 0xff;
                            here_val = here & 0xffff;

                            if (here_bits <= bits) { break; }
                            //--- PULLBYTE() ---//
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                            //---//
                        }
                        if (here_op && (here_op & 0xf0) === 0) {
                            last_bits = here_bits;
                            last_op = here_op;
                            last_val = here_val;
                            for (;;) {
                                here = state.lencode[last_val +
                                    ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                                here_bits = here >>> 24;
                                here_op = (here >>> 16) & 0xff;
                                here_val = here & 0xffff;

                                if ((last_bits + here_bits) <= bits) { break; }
                                //--- PULLBYTE() ---//
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                                //---//
                            }
                            //--- DROPBITS(last.bits) ---//
                            hold >>>= last_bits;
                            bits -= last_bits;
                            //---//
                            state.back += last_bits;
                        }
                        //--- DROPBITS(here.bits) ---//
                        hold >>>= here_bits;
                        bits -= here_bits;
                        //---//
                        state.back += here_bits;
                        state.length = here_val;
                        if (here_op === 0) {
                            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                            //        "inflate:         literal '%c'\n" :
                            //        "inflate:         literal 0x%02x\n", here.val));
                            state.mode = LIT;
                            break;
                        }
                        if (here_op & 32) {
                            //Tracevv((stderr, "inflate:         end of block\n"));
                            state.back = -1;
                            state.mode = TYPE;
                            break;
                        }
                        if (here_op & 64) {
                            strm.msg = 'invalid literal/length code';
                            state.mode = BAD;
                            break;
                        }
                        state.extra = here_op & 15;
                        state.mode = LENEXT;
                    /* falls through */
                    case LENEXT:
                        if (state.extra) {
                            //=== NEEDBITS(state.extra);
                            n = state.extra;
                            while (bits < n) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.length += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
                            //--- DROPBITS(state.extra) ---//
                            hold >>>= state.extra;
                            bits -= state.extra;
                            //---//
                            state.back += state.extra;
                        }
                        //Tracevv((stderr, "inflate:         length %u\n", state.length));
                        state.was = state.length;
                        state.mode = DIST;
                    /* falls through */
                    case DIST:
                        for (;;) {
                            here = state.distcode[hold & ((1 << state.distbits) -1)];/*BITS(state.distbits)*/
                            here_bits = here >>> 24;
                            here_op = (here >>> 16) & 0xff;
                            here_val = here & 0xffff;

                            if ((here_bits) <= bits) { break; }
                            //--- PULLBYTE() ---//
                            if (have === 0) { break inf_leave; }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                            //---//
                        }
                        if ((here_op & 0xf0) === 0) {
                            last_bits = here_bits;
                            last_op = here_op;
                            last_val = here_val;
                            for (;;) {
                                here = state.distcode[last_val +
                                    ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                                here_bits = here >>> 24;
                                here_op = (here >>> 16) & 0xff;
                                here_val = here & 0xffff;

                                if ((last_bits + here_bits) <= bits) { break; }
                                //--- PULLBYTE() ---//
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                                //---//
                            }
                            //--- DROPBITS(last.bits) ---//
                            hold >>>= last_bits;
                            bits -= last_bits;
                            //---//
                            state.back += last_bits;
                        }
                        //--- DROPBITS(here.bits) ---//
                        hold >>>= here_bits;
                        bits -= here_bits;
                        //---//
                        state.back += here_bits;
                        if (here_op & 64) {
                            strm.msg = 'invalid distance code';
                            state.mode = BAD;
                            break;
                        }
                        state.offset = here_val;
                        state.extra = (here_op) & 15;
                        state.mode = DISTEXT;
                    /* falls through */
                    case DISTEXT:
                        if (state.extra) {
                            //=== NEEDBITS(state.extra);
                            n = state.extra;
                            while (bits < n) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            state.offset += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
                            //--- DROPBITS(state.extra) ---//
                            hold >>>= state.extra;
                            bits -= state.extra;
                            //---//
                            state.back += state.extra;
                        }
//#ifdef INFLATE_STRICT
                        if (state.offset > state.dmax) {
                            strm.msg = 'invalid distance too far back';
                            state.mode = BAD;
                            break;
                        }
//#endif
                        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
                        state.mode = MATCH;
                    /* falls through */
                    case MATCH:
                        if (left === 0) { break inf_leave; }
                        copy = _out - left;
                        if (state.offset > copy) {         /* copy from window */
                            copy = state.offset - copy;
                            if (copy > state.whave) {
                                if (state.sane) {
                                    strm.msg = 'invalid distance too far back';
                                    state.mode = BAD;
                                    break;
                                }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
                            }
                            if (copy > state.wnext) {
                                copy -= state.wnext;
                                from = state.wsize - copy;
                            }
                            else {
                                from = state.wnext - copy;
                            }
                            if (copy > state.length) { copy = state.length; }
                            from_source = state.window;
                        }
                        else {                              /* copy from output */
                            from_source = output;
                            from = put - state.offset;
                            copy = state.length;
                        }
                        if (copy > left) { copy = left; }
                        left -= copy;
                        state.length -= copy;
                        do {
                            output[put++] = from_source[from++];
                        } while (--copy);
                        if (state.length === 0) { state.mode = LEN; }
                        break;
                    case LIT:
                        if (left === 0) { break inf_leave; }
                        output[put++] = state.length;
                        left--;
                        state.mode = LEN;
                        break;
                    case CHECK:
                        if (state.wrap) {
                            //=== NEEDBITS(32);
                            while (bits < 32) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                // Use '|' insdead of '+' to make sure that result is signed
                                hold |= input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            _out -= left;
                            strm.total_out += _out;
                            state.total += _out;
                            if (_out) {
                                strm.adler = state.check =
                                    /*UPDATE(state.check, put - _out, _out);*/
                                    (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

                            }
                            _out = left;
                            // NB: crc32 stored as signed 32-bit int, ZSWAP32 returns signed too
                            if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
                                strm.msg = 'incorrect data check';
                                state.mode = BAD;
                                break;
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            //Tracev((stderr, "inflate:   check matches trailer\n"));
                        }
                        state.mode = LENGTH;
                    /* falls through */
                    case LENGTH:
                        if (state.wrap && state.flags) {
                            //=== NEEDBITS(32);
                            while (bits < 32) {
                                if (have === 0) { break inf_leave; }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            //===//
                            if (hold !== (state.total & 0xffffffff)) {
                                strm.msg = 'incorrect length check';
                                state.mode = BAD;
                                break;
                            }
                            //=== INITBITS();
                            hold = 0;
                            bits = 0;
                            //===//
                            //Tracev((stderr, "inflate:   length matches trailer\n"));
                        }
                        state.mode = DONE;
                    /* falls through */
                    case DONE:
                        ret = Z_STREAM_END;
                        break inf_leave;
                    case BAD:
                        ret = Z_DATA_ERROR;
                        break inf_leave;
                    case MEM:
                        return Z_MEM_ERROR;
                    case SYNC:
                    /* falls through */
                    default:
                        return Z_STREAM_ERROR;
                }
            }

        // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

        /*
         Return from inflate(), updating the total counts and the check value.
         If there was no progress during the inflate() call, return a buffer
         error.  Call updatewindow() to create and/or update the window state.
         Note: a memory error from inflate() is non-recoverable.
         */

        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---

        if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
            (state.mode < CHECK || flush !== Z_FINISH))) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                state.mode = MEM;
                return Z_MEM_ERROR;
            }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
            strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) +
            (state.mode === TYPE ? 128 : 0) +
            (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
            ret = Z_BUF_ERROR;
        }
        return ret;
    }

    function inflateEnd(strm) {

        if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
            return Z_STREAM_ERROR;
        }

        var state = strm.state;
        if (state.window) {
            state.window = null;
        }
        strm.state = null;
        return Z_OK;
    }

    function inflateGetHeader(strm, head) {
        var state;

        /* check state */
        if (!strm || !strm.state) { return Z_STREAM_ERROR; }
        state = strm.state;
        if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

        /* save header structure */
        state.head = head;
        head.done = false;
        return Z_OK;
    }


    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateInfo = 'pako inflate (from Nodeca project)';

    /* Not implemented
     exports.inflateCopy = inflateCopy;
     exports.inflateGetDictionary = inflateGetDictionary;
     exports.inflateMark = inflateMark;
     exports.inflatePrime = inflatePrime;
     exports.inflateSetDictionary = inflateSetDictionary;
     exports.inflateSync = inflateSync;
     exports.inflateSyncPoint = inflateSyncPoint;
     exports.inflateUndermine = inflateUndermine;
     */

},{"../utils/common":134,"./adler32":136,"./crc32":138,"./inffast":141,"./inftrees":143}],143:[function(require,module,exports){
    'use strict';


    var utils = require('../utils/common');

    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;

    var lbase = [ /* Length codes 257..285 base */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ];

    var lext = [ /* Length codes 257..285 extra */
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
    ];

    var dbase = [ /* Distance codes 0..29 base */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577, 0, 0
    ];

    var dext = [ /* Distance codes 0..29 extra */
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
        28, 28, 29, 29, 64, 64
    ];

    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
    {
        var bits = opts.bits;
        //here = opts.here; /* table entry for duplication */

        var len = 0;               /* a code's length in bits */
        var sym = 0;               /* index of code symbols */
        var min = 0, max = 0;          /* minimum and maximum code lengths */
        var root = 0;              /* number of index bits for root table */
        var curr = 0;              /* number of index bits for current table */
        var drop = 0;              /* code bits to drop for sub-table */
        var left = 0;                   /* number of prefix codes available */
        var used = 0;              /* code entries in table used */
        var huff = 0;              /* Huffman code */
        var incr;              /* for incrementing code, index */
        var fill;              /* index for replicating entries */
        var low;               /* low bits for current root entry */
        var mask;              /* mask for low root bits */
        var next;             /* next available space in table */
        var base = null;     /* base value table to use */
        var base_index = 0;
//  var shoextra;    /* extra bits table to use */
        var end;                    /* use base and extra for symbol > end */
        var count = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];    /* number of codes of each length */
        var offs = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];     /* offsets in table for each length */
        var extra = null;
        var extra_index = 0;

        var here_bits, here_op, here_val;

        /*
         Process a set of code lengths to create a canonical Huffman code.  The
         code lengths are lens[0..codes-1].  Each length corresponds to the
         symbols 0..codes-1.  The Huffman code is generated by first sorting the
         symbols by length from short to long, and retaining the symbol order
         for codes with equal lengths.  Then the code starts with all zero bits
         for the first code of the shortest length, and the codes are integer
         increments for the same length, and zeros are appended as the length
         increases.  For the deflate format, these bits are stored backwards
         from their more natural integer increment ordering, and so when the
         decoding tables are built in the large loop below, the integer codes
         are incremented backwards.

         This routine assumes, but does not check, that all of the entries in
         lens[] are in the range 0..MAXBITS.  The caller must assure this.
         1..MAXBITS is interpreted as that code length.  zero means that that
         symbol does not occur in this code.

         The codes are sorted by computing a count of codes for each length,
         creating from that a table of starting indices for each length in the
         sorted table, and then entering the symbols in order in the sorted
         table.  The sorted table is work[], with that space being provided by
         the caller.

         The length counts are used for other purposes as well, i.e. finding
         the minimum and maximum length codes, determining if there are any
         codes at all, checking for a valid set of lengths, and looking ahead
         at length counts to determine sub-table sizes when building the
         decoding tables.
         */

        /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
        for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
        }

        /* bound code lengths, force root to be within code lengths */
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) { break; }
        }
        if (root > max) {
            root = max;
        }
        if (max === 0) {                     /* no symbols to code at all */
            //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
            //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
            //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
            table[table_index++] = (1 << 24) | (64 << 16) | 0;


            //table.op[opts.table_index] = 64;
            //table.bits[opts.table_index] = 1;
            //table.val[opts.table_index++] = 0;
            table[table_index++] = (1 << 24) | (64 << 16) | 0;

            opts.bits = 1;
            return 0;     /* no symbols, but wait for decoding to report error */
        }
        for (min = 1; min < max; min++) {
            if (count[min] !== 0) { break; }
        }
        if (root < min) {
            root = min;
        }

        /* check for an over-subscribed or incomplete set of lengths */
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
                return -1;
            }        /* over-subscribed */
        }
        if (left > 0 && (type === CODES || max !== 1)) {
            return -1;                      /* incomplete set */
        }

        /* generate offsets into symbol table for each length for sorting */
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
        }

        /* sort symbols by length, by symbol order within each length */
        for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym;
            }
        }

        /*
         Create and fill in decoding tables.  In this loop, the table being
         filled is at next and has curr index bits.  The code being used is huff
         with length len.  That code is converted to an index by dropping drop
         bits off of the bottom.  For codes where len is less than drop + curr,
         those top drop + curr - len bits are incremented through all values to
         fill the table with replicated entries.

         root is the number of index bits for the root table.  When len exceeds
         root, sub-tables are created pointed to by the root entry with an index
         of the low root bits of huff.  This is saved in low to check for when a
         new sub-table should be started.  drop is zero when the root table is
         being filled, and drop is root when sub-tables are being filled.

         When a new sub-table is needed, it is necessary to look ahead in the
         code lengths to determine what size sub-table is needed.  The length
         counts are used for this, and so count[] is decremented as codes are
         entered in the tables.

         used keeps track of how many table entries have been allocated from the
         provided *table space.  It is checked for LENS and DIST tables against
         the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
         the initial root table size constants.  See the comments in inftrees.h
         for more information.

         sym increments through all symbols, and the loop terminates when
         all codes of length max, i.e. all codes, have been processed.  This
         routine permits incomplete codes, so another loop after this one fills
         in the rest of the decoding tables with invalid code markers.
         */

        /* set up for code type */
        // poor man optimization - use if-else instead of switch,
        // to avoid deopts in old v8
        if (type === CODES) {
            base = extra = work;    /* dummy value--not used */
            end = 19;

        } else if (type === LENS) {
            base = lbase;
            base_index -= 257;
            extra = lext;
            extra_index -= 257;
            end = 256;

        } else {                    /* DISTS */
            base = dbase;
            extra = dext;
            end = -1;
        }

        /* initialize opts for loop */
        huff = 0;                   /* starting code */
        sym = 0;                    /* starting code symbol */
        len = min;                  /* starting code length */
        next = table_index;              /* current table to fill in */
        curr = root;                /* current table index bits */
        drop = 0;                   /* current bits to drop from code for index */
        low = -1;                   /* trigger new sub-table when len > root */
        used = 1 << root;          /* use root table entries */
        mask = used - 1;            /* mask for comparing low */

        /* check available table space */
        if ((type === LENS && used > ENOUGH_LENS) ||
            (type === DISTS && used > ENOUGH_DISTS)) {
            return 1;
        }

        var i=0;
        /* process all codes and make table entries */
        for (;;) {
            i++;
            /* create table entry */
            here_bits = len - drop;
            if (work[sym] < end) {
                here_op = 0;
                here_val = work[sym];
            }
            else if (work[sym] > end) {
                here_op = extra[extra_index + work[sym]];
                here_val = base[base_index + work[sym]];
            }
            else {
                here_op = 32 + 64;         /* end of block */
                here_val = 0;
            }

            /* replicate for those indices with low len bits equal to huff */
            incr = 1 << (len - drop);
            fill = 1 << curr;
            min = fill;                 /* save offset to next table */
            do {
                fill -= incr;
                table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
            } while (fill !== 0);

            /* backwards increment the len-bit code huff */
            incr = 1 << (len - 1);
            while (huff & incr) {
                incr >>= 1;
            }
            if (incr !== 0) {
                huff &= incr - 1;
                huff += incr;
            } else {
                huff = 0;
            }

            /* go to next symbol, update count, len */
            sym++;
            if (--count[len] === 0) {
                if (len === max) { break; }
                len = lens[lens_index + work[sym]];
            }

            /* create new sub-table if needed */
            if (len > root && (huff & mask) !== low) {
                /* if first time, transition to sub-tables */
                if (drop === 0) {
                    drop = root;
                }

                /* increment past last table */
                next += min;            /* here min is 1 << curr */

                /* determine length of next table */
                curr = len - drop;
                left = 1 << curr;
                while (curr + drop < max) {
                    left -= count[curr + drop];
                    if (left <= 0) { break; }
                    curr++;
                    left <<= 1;
                }

                /* check for enough space */
                used += 1 << curr;
                if ((type === LENS && used > ENOUGH_LENS) ||
                    (type === DISTS && used > ENOUGH_DISTS)) {
                    return 1;
                }

                /* point entry in root table to sub-table */
                low = huff & mask;
                /*table.op[low] = curr;
                 table.bits[low] = root;
                 table.val[low] = next - opts.table_index;*/
                table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
            }
        }

        /* fill in remaining table entry if code is incomplete (guaranteed to have
         at most one remaining entry, since if the code is incomplete, the
         maximum code length that was allowed to get this far is one bit) */
        if (huff !== 0) {
            //table.op[next + huff] = 64;            /* invalid code marker */
            //table.bits[next + huff] = len - drop;
            //table.val[next + huff] = 0;
            table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
        }

        /* set return parameters */
        //opts.table_index += used;
        opts.bits = root;
        return 0;
    };

},{"../utils/common":134}],144:[function(require,module,exports){
    'use strict';

    module.exports = {
        '2':    'need dictionary',     /* Z_NEED_DICT       2  */
        '1':    'stream end',          /* Z_STREAM_END      1  */
        '0':    '',                    /* Z_OK              0  */
        '-1':   'file error',          /* Z_ERRNO         (-1) */
        '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
        '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
        '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
        '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
        '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
    };

},{}],145:[function(require,module,exports){
    'use strict';


    var utils = require('../utils/common');

    /* Public constants ==========================================================*/
    /* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
    var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

    /* Possible values of the data_type field (though see inflate()) */
    var Z_BINARY              = 0;
    var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
    var Z_UNKNOWN             = 2;

    /*============================================================================*/


    function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES    = 2;
    /* The three kinds of block type */

    var MIN_MATCH    = 3;
    var MAX_MATCH    = 258;
    /* The minimum and maximum match lengths */

// From deflate.h
    /* ===========================================================================
     * Internal compression state.
     */

    var LENGTH_CODES  = 29;
    /* number of length codes, not counting the special END_BLOCK code */

    var LITERALS      = 256;
    /* number of literal bytes 0..255 */

    var L_CODES       = LITERALS + 1 + LENGTH_CODES;
    /* number of Literal or Length codes, including the END_BLOCK code */

    var D_CODES       = 30;
    /* number of distance codes */

    var BL_CODES      = 19;
    /* number of codes used to transfer the bit lengths */

    var HEAP_SIZE     = 2*L_CODES + 1;
    /* maximum heap size */

    var MAX_BITS      = 15;
    /* All codes must not exceed MAX_BITS bits */

    var Buf_size      = 16;
    /* size of bit buffer in bi_buf */


    /* ===========================================================================
     * Constants
     */

    var MAX_BL_BITS = 7;
    /* Bit length codes must not exceed MAX_BL_BITS bits */

    var END_BLOCK   = 256;
    /* end of block literal code */

    var REP_3_6     = 16;
    /* repeat previous bit length 3-6 times (2 bits of repeat count) */

    var REPZ_3_10   = 17;
    /* repeat a zero length 3-10 times  (3 bits of repeat count) */

    var REPZ_11_138 = 18;
    /* repeat a zero length 11-138 times  (7 bits of repeat count) */

    var extra_lbits =   /* extra bits for each length code */
        [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

    var extra_dbits =   /* extra bits for each distance code */
        [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

    var extra_blbits =  /* extra bits for each bit length code */
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

    var bl_order =
        [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
    /* The lengths of the bit length codes are sent in order of decreasing
     * probability, to avoid transmitting the lengths for unused bit length codes.
     */

    /* ===========================================================================
     * Local data. These are initialized only once.
     */

// We pre-fill arrays with 0 to avoid uninitialized gaps

    var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
    var static_ltree  = new Array((L_CODES+2) * 2);
    zero(static_ltree);
    /* The static literal tree. Since the bit lengths are imposed, there is no
     * need for the L_CODES extra codes used during heap construction. However
     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
     * below).
     */

    var static_dtree  = new Array(D_CODES * 2);
    zero(static_dtree);
    /* The static distance tree. (Actually a trivial tree since all codes use
     * 5 bits.)
     */

    var _dist_code    = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    /* Distance codes. The first 256 values correspond to the distances
     * 3 .. 258, the last 256 values correspond to the top 8 bits of
     * the 15 bit distances.
     */

    var _length_code  = new Array(MAX_MATCH-MIN_MATCH+1);
    zero(_length_code);
    /* length code for each normalized match length (0 == MIN_MATCH) */

    var base_length   = new Array(LENGTH_CODES);
    zero(base_length);
    /* First normalized length for each code (0 = MIN_MATCH) */

    var base_dist     = new Array(D_CODES);
    zero(base_dist);
    /* First normalized distance for each code (0 = distance of 1) */


    var StaticTreeDesc = function (static_tree, extra_bits, extra_base, elems, max_length) {

        this.static_tree  = static_tree;  /* static tree or NULL */
        this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
        this.extra_base   = extra_base;   /* base index for extra_bits */
        this.elems        = elems;        /* max number of elements in the tree */
        this.max_length   = max_length;   /* max bit length for the codes */

        // show if `static_tree` has data or dummy - needed for monomorphic objects
        this.has_stree    = static_tree && static_tree.length;
    };


    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;


    var TreeDesc = function(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;     /* the dynamic tree */
        this.max_code = 0;            /* largest code with non zero frequency */
        this.stat_desc = stat_desc;   /* the corresponding static tree */
    };



    function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }


    /* ===========================================================================
     * Output a short LSB first on the stream.
     * IN assertion: there is enough room in pendingBuf.
     */
    function put_short (s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
        s.pending_buf[s.pending++] = (w) & 0xff;
        s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
    }


    /* ===========================================================================
     * Send a value on a given number of bits.
     * IN assertion: length <= 16 and value fits in length bits.
     */
    function send_bits(s, value, length) {
        if (s.bi_valid > (Buf_size - length)) {
            s.bi_buf |= (value << s.bi_valid) & 0xffff;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> (Buf_size - s.bi_valid);
            s.bi_valid += length - Buf_size;
        } else {
            s.bi_buf |= (value << s.bi_valid) & 0xffff;
            s.bi_valid += length;
        }
    }


    function send_code(s, c, tree) {
        send_bits(s, tree[c*2]/*.Code*/, tree[c*2 + 1]/*.Len*/);
    }


    /* ===========================================================================
     * Reverse the first len bits of a code, using straightforward code (a faster
     * method would use a table)
     * IN assertion: 1 <= len <= 15
     */
    function bi_reverse(code, len) {
        var res = 0;
        do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
        } while (--len > 0);
        return res >>> 1;
    }


    /* ===========================================================================
     * Flush the bit buffer, keeping at most 7 bits in it.
     */
    function bi_flush(s) {
        if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;

        } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 0xff;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
        }
    }


    /* ===========================================================================
     * Compute the optimal bit lengths for a tree and update the total bit length
     * for the current block.
     * IN assertion: the fields freq and dad are set, heap[heap_max] and
     *    above are the tree nodes sorted by increasing frequency.
     * OUT assertions: the field len is set to the optimal bit length, the
     *     array bl_count contains the frequencies for each bit length.
     *     The length opt_len is updated; static_len is also updated if stree is
     *     not null.
     */
    function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
    {
        var tree            = desc.dyn_tree;
        var max_code        = desc.max_code;
        var stree           = desc.stat_desc.static_tree;
        var has_stree       = desc.stat_desc.has_stree;
        var extra           = desc.stat_desc.extra_bits;
        var base            = desc.stat_desc.extra_base;
        var max_length      = desc.stat_desc.max_length;
        var h;              /* heap index */
        var n, m;           /* iterate over the tree elements */
        var bits;           /* bit length */
        var xbits;          /* extra bits */
        var f;              /* frequency */
        var overflow = 0;   /* number of elements with bit length too large */

        for (bits = 0; bits <= MAX_BITS; bits++) {
            s.bl_count[bits] = 0;
        }

        /* In a first pass, compute the optimal bit lengths (which may
         * overflow in the case of the bit length tree).
         */
        tree[s.heap[s.heap_max]*2 + 1]/*.Len*/ = 0; /* root of the heap */

        for (h = s.heap_max+1; h < HEAP_SIZE; h++) {
            n = s.heap[h];
            bits = tree[tree[n*2 +1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
            if (bits > max_length) {
                bits = max_length;
                overflow++;
            }
            tree[n*2 + 1]/*.Len*/ = bits;
            /* We overwrite tree[n].Dad which is no longer needed */

            if (n > max_code) { continue; } /* not a leaf node */

            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
                xbits = extra[n-base];
            }
            f = tree[n * 2]/*.Freq*/;
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
                s.static_len += f * (stree[n*2 + 1]/*.Len*/ + xbits);
            }
        }
        if (overflow === 0) { return; }

        // Trace((stderr,"\nbit length overflow\n"));
        /* This happens for example on obj2 and pic of the Calgary corpus */

        /* Find the first bit length which could increase: */
        do {
            bits = max_length-1;
            while (s.bl_count[bits] === 0) { bits--; }
            s.bl_count[bits]--;      /* move one leaf down the tree */
            s.bl_count[bits+1] += 2; /* move one overflow item as its brother */
            s.bl_count[max_length]--;
            /* The brother of the overflow item also moves one step up,
             * but this does not affect bl_count[max_length]
             */
            overflow -= 2;
        } while (overflow > 0);

        /* Now recompute all bit lengths, scanning in increasing frequency.
         * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
         * lengths instead of fixing only the wrong ones. This idea is taken
         * from 'ar' written by Haruhiko Okumura.)
         */
        for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
                m = s.heap[--h];
                if (m > max_code) { continue; }
                if (tree[m*2 + 1]/*.Len*/ !== bits) {
                    // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                    s.opt_len += (bits - tree[m*2 + 1]/*.Len*/)*tree[m*2]/*.Freq*/;
                    tree[m*2 + 1]/*.Len*/ = bits;
                }
                n--;
            }
        }
    }


    /* ===========================================================================
     * Generate the codes for a given tree and bit counts (which need not be
     * optimal).
     * IN assertion: the array bl_count contains the bit length statistics for
     * the given tree and the field len is set for all tree elements.
     * OUT assertion: the field code is set for all tree elements of non
     *     zero code length.
     */
    function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
    {
        var next_code = new Array(MAX_BITS+1); /* next code value for each bit length */
        var code = 0;              /* running code value */
        var bits;                  /* bit index */
        var n;                     /* code index */

        /* The distribution counts are first used to generate the code values
         * without bit reversal.
         */
        for (bits = 1; bits <= MAX_BITS; bits++) {
            next_code[bits] = code = (code + bl_count[bits-1]) << 1;
        }
        /* Check that the bit counts in bl_count are consistent. The last code
         * must be all ones.
         */
        //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
        //        "inconsistent bit counts");
        //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

        for (n = 0;  n <= max_code; n++) {
            var len = tree[n*2 + 1]/*.Len*/;
            if (len === 0) { continue; }
            /* Now reverse the bits */
            tree[n*2]/*.Code*/ = bi_reverse(next_code[len]++, len);

            //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
            //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
        }
    }


    /* ===========================================================================
     * Initialize the various 'constant' tables.
     */
    function tr_static_init() {
        var n;        /* iterates over tree elements */
        var bits;     /* bit counter */
        var length;   /* length value */
        var code;     /* code value */
        var dist;     /* distance index */
        var bl_count = new Array(MAX_BITS+1);
        /* number of codes at each bit length for an optimal tree */

        // do check in _tr_init()
        //if (static_init_done) return;

        /* For some embedded targets, global variables are not initialized: */
        /*#ifdef NO_INIT_GLOBAL_POINTERS
         static_l_desc.static_tree = static_ltree;
         static_l_desc.extra_bits = extra_lbits;
         static_d_desc.static_tree = static_dtree;
         static_d_desc.extra_bits = extra_dbits;
         static_bl_desc.extra_bits = extra_blbits;
         #endif*/

        /* Initialize the mapping length (0..255) -> length code (0..28) */
        length = 0;
        for (code = 0; code < LENGTH_CODES-1; code++) {
            base_length[code] = length;
            for (n = 0; n < (1<<extra_lbits[code]); n++) {
                _length_code[length++] = code;
            }
        }
        //Assert (length == 256, "tr_static_init: length != 256");
        /* Note that the length 255 (match length 258) can be represented
         * in two different ways: code 284 + 5 bits or code 285, so we
         * overwrite length_code[255] to use the best encoding:
         */
        _length_code[length-1] = code;

        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
        dist = 0;
        for (code = 0 ; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < (1<<extra_dbits[code]); n++) {
                _dist_code[dist++] = code;
            }
        }
        //Assert (dist == 256, "tr_static_init: dist != 256");
        dist >>= 7; /* from now on, all distances are divided by 128 */
        for (; code < D_CODES; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
                _dist_code[256 + dist++] = code;
            }
        }
        //Assert (dist == 256, "tr_static_init: 256+dist != 512");

        /* Construct the codes of the static literal tree */
        for (bits = 0; bits <= MAX_BITS; bits++) {
            bl_count[bits] = 0;
        }

        n = 0;
        while (n <= 143) {
            static_ltree[n*2 + 1]/*.Len*/ = 8;
            n++;
            bl_count[8]++;
        }
        while (n <= 255) {
            static_ltree[n*2 + 1]/*.Len*/ = 9;
            n++;
            bl_count[9]++;
        }
        while (n <= 279) {
            static_ltree[n*2 + 1]/*.Len*/ = 7;
            n++;
            bl_count[7]++;
        }
        while (n <= 287) {
            static_ltree[n*2 + 1]/*.Len*/ = 8;
            n++;
            bl_count[8]++;
        }
        /* Codes 286 and 287 do not exist, but we must include them in the
         * tree construction to get a canonical Huffman tree (longest code
         * all ones)
         */
        gen_codes(static_ltree, L_CODES+1, bl_count);

        /* The static distance tree is trivial: */
        for (n = 0; n < D_CODES; n++) {
            static_dtree[n*2 + 1]/*.Len*/ = 5;
            static_dtree[n*2]/*.Code*/ = bi_reverse(n, 5);
        }

        // Now data ready and we can init static trees
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
        static_bl_desc =new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

        //static_init_done = true;
    }


    /* ===========================================================================
     * Initialize a new block.
     */
    function init_block(s) {
        var n; /* iterates over tree elements */

        /* Initialize the trees. */
        for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n*2]/*.Freq*/ = 0; }
        for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n*2]/*.Freq*/ = 0; }
        for (n = 0; n < BL_CODES; n++) { s.bl_tree[n*2]/*.Freq*/ = 0; }

        s.dyn_ltree[END_BLOCK*2]/*.Freq*/ = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
    }


    /* ===========================================================================
     * Flush the bit buffer and align the output on a byte boundary
     */
    function bi_windup(s)
    {
        if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
            //put_byte(s, (Byte)s->bi_buf);
            s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
    }

    /* ===========================================================================
     * Copy a stored block, storing first the length and its
     * one's complement if requested.
     */
    function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
    {
        bi_windup(s);        /* align on byte boundary */

        if (header) {
            put_short(s, len);
            put_short(s, ~len);
        }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
    }

    /* ===========================================================================
     * Compares to subtrees, using the tree depth as tie breaker when
     * the subtrees have equal frequency. This minimizes the worst case length.
     */
    function smaller(tree, n, m, depth) {
        var _n2 = n*2;
        var _m2 = m*2;
        return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
            (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
    }

    /* ===========================================================================
     * Restore the heap property by moving down the tree starting at node k,
     * exchanging a node with the smallest of its two sons if necessary, stopping
     * when the heap property is re-established (each father smaller than its
     * two sons).
     */
    function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
    {
        var v = s.heap[k];
        var j = k << 1;  /* left son of k */
        while (j <= s.heap_len) {
            /* Set j to the smallest of the two sons: */
            if (j < s.heap_len &&
                smaller(tree, s.heap[j+1], s.heap[j], s.depth)) {
                j++;
            }
            /* Exit if v is smaller than both sons */
            if (smaller(tree, v, s.heap[j], s.depth)) { break; }

            /* Exchange v with the smallest son */
            s.heap[k] = s.heap[j];
            k = j;

            /* And continue down the tree, setting j to the left son of k */
            j <<= 1;
        }
        s.heap[k] = v;
    }


// inlined manually
// var SMALLEST = 1;

    /* ===========================================================================
     * Send the block data compressed using the given Huffman trees
     */
    function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
    {
        var dist;           /* distance of matched string */
        var lc;             /* match length or unmatched char (if dist == 0) */
        var lx = 0;         /* running index in l_buf */
        var code;           /* the code to send */
        var extra;          /* number of extra bits to send */

        if (s.last_lit !== 0) {
            do {
                dist = (s.pending_buf[s.d_buf + lx*2] << 8) | (s.pending_buf[s.d_buf + lx*2 + 1]);
                lc = s.pending_buf[s.l_buf + lx];
                lx++;

                if (dist === 0) {
                    send_code(s, lc, ltree); /* send a literal byte */
                    //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
                } else {
                    /* Here, lc is the match length - MIN_MATCH */
                    code = _length_code[lc];
                    send_code(s, code+LITERALS+1, ltree); /* send the length code */
                    extra = extra_lbits[code];
                    if (extra !== 0) {
                        lc -= base_length[code];
                        send_bits(s, lc, extra);       /* send the extra length bits */
                    }
                    dist--; /* dist is now the match distance - 1 */
                    code = d_code(dist);
                    //Assert (code < D_CODES, "bad d_code");

                    send_code(s, code, dtree);       /* send the distance code */
                    extra = extra_dbits[code];
                    if (extra !== 0) {
                        dist -= base_dist[code];
                        send_bits(s, dist, extra);   /* send the extra distance bits */
                    }
                } /* literal or match pair ? */

                /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
                //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
                //       "pendingBuf overflow");

            } while (lx < s.last_lit);
        }

        send_code(s, END_BLOCK, ltree);
    }


    /* ===========================================================================
     * Construct one Huffman tree and assigns the code bit strings and lengths.
     * Update the total bit length for the current block.
     * IN assertion: the field freq is set for all tree elements.
     * OUT assertions: the fields len and code are set to the optimal bit length
     *     and corresponding code. The length opt_len is updated; static_len is
     *     also updated if stree is not null. The field max_code is set.
     */
    function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
    {
        var tree     = desc.dyn_tree;
        var stree    = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems    = desc.stat_desc.elems;
        var n, m;          /* iterate over heap elements */
        var max_code = -1; /* largest code with non zero frequency */
        var node;          /* new node being created */

        /* Construct the initial heap, with least frequent element in
         * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
         * heap[0] is not used.
         */
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;

        for (n = 0; n < elems; n++) {
            if (tree[n * 2]/*.Freq*/ !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;

            } else {
                tree[n*2 + 1]/*.Len*/ = 0;
            }
        }

        /* The pkzip format requires that at least one distance code exists,
         * and that at least one bit should be sent even if there is only one
         * possible code. So to avoid special checks later on we force at least
         * two codes of non zero frequency.
         */
        while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
            tree[node * 2]/*.Freq*/ = 1;
            s.depth[node] = 0;
            s.opt_len--;

            if (has_stree) {
                s.static_len -= stree[node*2 + 1]/*.Len*/;
            }
            /* node is 0 or 1 so it does not have extra bits */
        }
        desc.max_code = max_code;

        /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
         * establish sub-heaps of increasing lengths:
         */
        for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

        /* Construct the Huffman tree by repeatedly combining the least two
         * frequent nodes.
         */
        node = elems;              /* next internal node of the tree */
        do {
            //pqremove(s, tree, n);  /* n = node of least frequency */
            /*** pqremove ***/
            n = s.heap[1/*SMALLEST*/];
            s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
            pqdownheap(s, tree, 1/*SMALLEST*/);
            /***/

            m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

            s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
            s.heap[--s.heap_max] = m;

            /* Create a new node father of n and m */
            tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n*2 + 1]/*.Dad*/ = tree[m*2 + 1]/*.Dad*/ = node;

            /* and insert the new node in the heap */
            s.heap[1/*SMALLEST*/] = node++;
            pqdownheap(s, tree, 1/*SMALLEST*/);

        } while (s.heap_len >= 2);

        s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

        /* At this point, the fields freq and dad are set. We can now
         * generate the bit lengths.
         */
        gen_bitlen(s, desc);

        /* The field len is now set, we can generate the bit codes */
        gen_codes(tree, max_code, s.bl_count);
    }


    /* ===========================================================================
     * Scan a literal or distance tree to determine the frequencies of the codes
     * in the bit length tree.
     */
    function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
    {
        var n;                     /* iterates over all tree elements */
        var prevlen = -1;          /* last emitted length */
        var curlen;                /* length of current code */

        var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */

        var count = 0;             /* repeat count of the current code */
        var max_count = 7;         /* max repeat count */
        var min_count = 4;         /* min repeat count */

        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        tree[(max_code+1)*2 + 1]/*.Len*/ = 0xffff; /* guard */

        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n+1)*2 + 1]/*.Len*/;

            if (++count < max_count && curlen === nextlen) {
                continue;

            } else if (count < min_count) {
                s.bl_tree[curlen * 2]/*.Freq*/ += count;

            } else if (curlen !== 0) {

                if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
                s.bl_tree[REP_3_6*2]/*.Freq*/++;

            } else if (count <= 10) {
                s.bl_tree[REPZ_3_10*2]/*.Freq*/++;

            } else {
                s.bl_tree[REPZ_11_138*2]/*.Freq*/++;
            }

            count = 0;
            prevlen = curlen;

            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;

            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;

            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }


    /* ===========================================================================
     * Send a literal or distance tree in compressed form, using the codes in
     * bl_tree.
     */
    function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
    {
        var n;                     /* iterates over all tree elements */
        var prevlen = -1;          /* last emitted length */
        var curlen;                /* length of current code */

        var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */

        var count = 0;             /* repeat count of the current code */
        var max_count = 7;         /* max repeat count */
        var min_count = 4;         /* min repeat count */

        /* tree[max_code+1].Len = -1; */  /* guard already set */
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }

        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n+1)*2 + 1]/*.Len*/;

            if (++count < max_count && curlen === nextlen) {
                continue;

            } else if (count < min_count) {
                do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    send_code(s, curlen, s.bl_tree);
                    count--;
                }
                //Assert(count >= 3 && count <= 6, " 3_6?");
                send_code(s, REP_3_6, s.bl_tree);
                send_bits(s, count-3, 2);

            } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree);
                send_bits(s, count-3, 3);

            } else {
                send_code(s, REPZ_11_138, s.bl_tree);
                send_bits(s, count-11, 7);
            }

            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;

            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;

            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }


    /* ===========================================================================
     * Construct the Huffman tree for the bit lengths and return the index in
     * bl_order of the last bit length code to send.
     */
    function build_bl_tree(s) {
        var max_blindex;  /* index of last bit length code of non zero freq */

        /* Determine the bit length frequencies for literal and distance trees */
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

        /* Build the bit length tree: */
        build_tree(s, s.bl_desc);
        /* opt_len now includes the length of the tree representations, except
         * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
         */

        /* Determine the number of bit length codes to send. The pkzip format
         * requires that at least 4 bit length codes be sent. (appnote.txt says
         * 3 but the actual value used is 4.)
         */
        for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex]*2 + 1]/*.Len*/ !== 0) {
                break;
            }
        }
        /* Update opt_len to include the bit length tree and counts */
        s.opt_len += 3*(max_blindex+1) + 5+5+4;
        //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
        //        s->opt_len, s->static_len));

        return max_blindex;
    }


    /* ===========================================================================
     * Send the header for a block using dynamic Huffman trees: the counts, the
     * lengths of the bit length codes, the literal tree and the distance tree.
     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
     */
    function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
    {
        var rank;                    /* index in bl_order */

        //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
        //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
        //        "too many codes");
        //Tracev((stderr, "\nbl counts: "));
        send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
        send_bits(s, dcodes-1,   5);
        send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
        for (rank = 0; rank < blcodes; rank++) {
            //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
            send_bits(s, s.bl_tree[bl_order[rank]*2 + 1]/*.Len*/, 3);
        }
        //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

        send_tree(s, s.dyn_ltree, lcodes-1); /* literal tree */
        //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

        send_tree(s, s.dyn_dtree, dcodes-1); /* distance tree */
        //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
    }


    /* ===========================================================================
     * Check if the data type is TEXT or BINARY, using the following algorithm:
     * - TEXT if the two conditions below are satisfied:
     *    a) There are no non-portable control characters belonging to the
     *       "black list" (0..6, 14..25, 28..31).
     *    b) There is at least one printable character belonging to the
     *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
     * - BINARY otherwise.
     * - The following partially-portable control characters form a
     *   "gray list" that is ignored in this detection algorithm:
     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
     * IN assertion: the fields Freq of dyn_ltree are set.
     */
    function detect_data_type(s) {
        /* black_mask is the bit mask of black-listed bytes
         * set bits 0..6, 14..25, and 28..31
         * 0xf3ffc07f = binary 11110011111111111100000001111111
         */
        var black_mask = 0xf3ffc07f;
        var n;

        /* Check for non-textual ("black-listed") bytes. */
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
            if ((black_mask & 1) && (s.dyn_ltree[n*2]/*.Freq*/ !== 0)) {
                return Z_BINARY;
            }
        }

        /* Check for textual ("white-listed") bytes. */
        if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
            s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
            return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
            if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
                return Z_TEXT;
            }
        }

        /* There are no "black-listed" or "white-listed" bytes:
         * this stream either is empty or has tolerated ("gray-listed") bytes only.
         */
        return Z_BINARY;
    }


    var static_init_done = false;

    /* ===========================================================================
     * Initialize the tree data structures for a new zlib stream.
     */
    function _tr_init(s)
    {

        if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
        }

        s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

        s.bi_buf = 0;
        s.bi_valid = 0;

        /* Initialize the first block of the first file: */
        init_block(s);
    }


    /* ===========================================================================
     * Send a stored block
     */
    function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
    {
        send_bits(s, (STORED_BLOCK<<1)+(last ? 1 : 0), 3);    /* send block type */
        copy_block(s, buf, stored_len, true); /* with header */
    }


    /* ===========================================================================
     * Send one empty static block to give enough lookahead for inflate.
     * This takes 10 bits, of which 7 may remain in the bit buffer.
     */
    function _tr_align(s) {
        send_bits(s, STATIC_TREES<<1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
    }


    /* ===========================================================================
     * Determine the best encoding for the current block: dynamic trees, static
     * trees or store, and output the encoded block to the zip file.
     */
    function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
    {
        var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
        var max_blindex = 0;        /* index of last bit length code of non zero freq */

        /* Build the Huffman trees unless a stored block is forced */
        if (s.level > 0) {

            /* Check if the file is binary or text */
            if (s.strm.data_type === Z_UNKNOWN) {
                s.strm.data_type = detect_data_type(s);
            }

            /* Construct the literal and distance trees */
            build_tree(s, s.l_desc);
            // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
            //        s->static_len));

            build_tree(s, s.d_desc);
            // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
            //        s->static_len));
            /* At this point, opt_len and static_len are the total bit lengths of
             * the compressed block data, excluding the tree representations.
             */

            /* Build the bit length tree for the above two trees, and get the index
             * in bl_order of the last bit length code to send.
             */
            max_blindex = build_bl_tree(s);

            /* Determine the best encoding. Compute the block lengths in bytes. */
            opt_lenb = (s.opt_len+3+7) >>> 3;
            static_lenb = (s.static_len+3+7) >>> 3;

            // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
            //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
            //        s->last_lit));

            if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

        } else {
            // Assert(buf != (char*)0, "lost buf");
            opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
        }

        if ((stored_len+4 <= opt_lenb) && (buf !== -1)) {
            /* 4: two words for the lengths */

            /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
             * Otherwise we can't have processed more than WSIZE input bytes since
             * the last block flush, because compression would have been
             * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
             * transform a block into a stored block.
             */
            _tr_stored_block(s, buf, stored_len, last);

        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

            send_bits(s, (STATIC_TREES<<1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);

        } else {
            send_bits(s, (DYN_TREES<<1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code+1, s.d_desc.max_code+1, max_blindex+1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
        /* The above check is made mod 2^32, for files larger than 512 MB
         * and uLong implemented on 32 bits.
         */
        init_block(s);

        if (last) {
            bi_windup(s);
        }
        // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
        //       s->compressed_len-7*last));
    }

    /* ===========================================================================
     * Save the match info and tally the frequency counts. Return true if
     * the current block must be flushed.
     */
    function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
    {
        //var out_length, in_length, dcode;

        s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

        s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
        s.last_lit++;

        if (dist === 0) {
            /* lc is the unmatched char */
            s.dyn_ltree[lc*2]/*.Freq*/++;
        } else {
            s.matches++;
            /* Here, lc is the match length - MIN_MATCH */
            dist--;             /* dist = match distance - 1 */
            //Assert((ush)dist < (ush)MAX_DIST(s) &&
            //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
            //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

            s.dyn_ltree[(_length_code[lc]+LITERALS+1) * 2]/*.Freq*/++;
            s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
        }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

        return (s.last_lit === s.lit_bufsize-1);
        /* We avoid equality with lit_bufsize because of wraparound at 64K
         * on 16 bit machines and because stored blocks are restricted to
         * 64K-1 bytes.
         */
    }

    exports._tr_init  = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block  = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;

},{"../utils/common":134}],146:[function(require,module,exports){
    'use strict';


    function ZStream() {
        /* next input byte */
        this.input = null; // JS specific, because we have no pointers
        this.next_in = 0;
        /* number of bytes available at input */
        this.avail_in = 0;
        /* total number of input bytes read so far */
        this.total_in = 0;
        /* next output byte should be put there */
        this.output = null; // JS specific, because we have no pointers
        this.next_out = 0;
        /* remaining free space at output */
        this.avail_out = 0;
        /* total number of bytes output so far */
        this.total_out = 0;
        /* last error message, NULL if no error */
        this.msg = ''/*Z_NULL*/;
        /* not visible by applications */
        this.state = null;
        /* best guess about the data type: binary or text */
        this.data_type = 2/*Z_UNKNOWN*/;
        /* adler32 value of the uncompressed data */
        this.adler = 0;
    }

    module.exports = ZStream;

},{}],147:[function(require,module,exports){
    'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

    module.exports = Buffer;

    var ieee754 = require('ieee754');

    var BufferMethods;

    function Buffer(length) {
        var arr;
        if (length && length.length) {
            arr = length;
            length = arr.length;
        }
        var buf = new Uint8Array(length || 0);
        if (arr) buf.set(arr);

        buf.readUInt32LE = BufferMethods.readUInt32LE;
        buf.writeUInt32LE = BufferMethods.writeUInt32LE;
        buf.readInt32LE = BufferMethods.readInt32LE;
        buf.writeInt32LE = BufferMethods.writeInt32LE;
        buf.readFloatLE = BufferMethods.readFloatLE;
        buf.writeFloatLE = BufferMethods.writeFloatLE;
        buf.readDoubleLE = BufferMethods.readDoubleLE;
        buf.writeDoubleLE = BufferMethods.writeDoubleLE;
        buf.toString = BufferMethods.toString;
        buf.write = BufferMethods.write;
        buf.slice = BufferMethods.slice;
        buf.copy = BufferMethods.copy;

        buf._isBuffer = true;
        return buf;
    }

    var lastStr, lastStrEncoded;

    BufferMethods = {
        readUInt32LE: function(pos) {
            return ((this[pos]) |
                (this[pos + 1] << 8) |
                (this[pos + 2] << 16)) +
                (this[pos + 3] * 0x1000000);
        },

        writeUInt32LE: function(val, pos) {
            this[pos] = val;
            this[pos + 1] = (val >>> 8);
            this[pos + 2] = (val >>> 16);
            this[pos + 3] = (val >>> 24);
        },

        readInt32LE: function(pos) {
            return ((this[pos]) |
                (this[pos + 1] << 8) |
                (this[pos + 2] << 16)) +
                (this[pos + 3] << 24);
        },

        readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
        readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

        writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
        writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

        toString: function(encoding, start, end) {
            var str = '',
                tmp = '';

            start = start || 0;
            end = Math.min(this.length, end || this.length);

            for (var i = start; i < end; i++) {
                var ch = this[i];
                if (ch <= 0x7F) {
                    str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                    tmp = '';
                } else {
                    tmp += '%' + ch.toString(16);
                }
            }

            str += decodeURIComponent(tmp);

            return str;
        },

        write: function(str, pos) {
            var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
            for (var i = 0; i < bytes.length; i++) {
                this[pos + i] = bytes[i];
            }
        },

        slice: function(start, end) {
            return this.subarray(start, end);
        },

        copy: function(buf, pos) {
            pos = pos || 0;
            for (var i = 0; i < this.length; i++) {
                buf[pos + i] = this[i];
            }
        }
    };

    BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

    Buffer.byteLength = function(str) {
        lastStr = str;
        lastStrEncoded = encodeString(str);
        return lastStrEncoded.length;
    };

    Buffer.isBuffer = function(buf) {
        return !!(buf && buf._isBuffer);
    };

    function encodeString(str) {
        var length = str.length,
            bytes = [];

        for (var i = 0, c, lead; i < length; i++) {
            c = str.charCodeAt(i); // code point

            if (c > 0xD7FF && c < 0xE000) {

                if (lead) {
                    if (c < 0xDC00) {
                        bytes.push(0xEF, 0xBF, 0xBD);
                        lead = c;
                        continue;

                    } else {
                        c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                        lead = null;
                    }

                } else {
                    if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                    else lead = c;

                    continue;
                }

            } else if (lead) {
                bytes.push(0xEF, 0xBF, 0xBD);
                lead = null;
            }

            if (c < 0x80) bytes.push(c);
            else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
            else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
            else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        }
        return bytes;
    }

},{"ieee754":149}],148:[function(require,module,exports){
    (function (global){
        'use strict';

        module.exports = Pbf;

        var Buffer = global.Buffer || require('./buffer');

        function Pbf(buf) {
            this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
            this.pos = 0;
            this.length = this.buf.length;
        }

        Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
        Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
        Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
        Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

        var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
            SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
            POW_2_63 = Math.pow(2, 63);

        Pbf.prototype = {

            destroy: function() {
                this.buf = null;
            },

            // === READING =================================================================

            readFields: function(readField, result, end) {
                end = end || this.length;

                while (this.pos < end) {
                    var val = this.readVarint(),
                        tag = val >> 3,
                        startPos = this.pos;

                    readField(tag, result, this);

                    if (this.pos === startPos) this.skip(val);
                }
                return result;
            },

            readMessage: function(readField, result) {
                return this.readFields(readField, result, this.readVarint() + this.pos);
            },

            readFixed32: function() {
                var val = this.buf.readUInt32LE(this.pos);
                this.pos += 4;
                return val;
            },

            readSFixed32: function() {
                var val = this.buf.readInt32LE(this.pos);
                this.pos += 4;
                return val;
            },

            // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

            readFixed64: function() {
                var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
                this.pos += 8;
                return val;
            },

            readSFixed64: function() {
                var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
                this.pos += 8;
                return val;
            },

            readFloat: function() {
                var val = this.buf.readFloatLE(this.pos);
                this.pos += 4;
                return val;
            },

            readDouble: function() {
                var val = this.buf.readDoubleLE(this.pos);
                this.pos += 8;
                return val;
            },

            readVarint: function() {
                var buf = this.buf,
                    val, b, b0, b1, b2, b3;

                b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;
                b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;
                b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;
                b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;

                val = b0 | b1 | b2 | (b3 & 0x7f) << 21;

                b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
                b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
                b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
                b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
                b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
                b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

                throw new Error('Expected varint not more than 10 bytes');
            },

            readVarint64: function() {
                var startPos = this.pos,
                    val = this.readVarint();

                if (val < POW_2_63) return val;

                var pos = this.pos - 2;
                while (this.buf[pos] === 0xff) pos--;
                if (pos < startPos) pos = startPos;

                val = 0;
                for (var i = 0; i < pos - startPos + 1; i++) {
                    var b = ~this.buf[startPos + i] & 0x7f;
                    val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
                }

                return -val - 1;
            },

            readSVarint: function() {
                var num = this.readVarint();
                return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
            },

            readBoolean: function() {
                return Boolean(this.readVarint());
            },

            readString: function() {
                var end = this.readVarint() + this.pos,
                    str = this.buf.toString('utf8', this.pos, end);
                this.pos = end;
                return str;
            },

            readBytes: function() {
                var end = this.readVarint() + this.pos,
                    buffer = this.buf.slice(this.pos, end);
                this.pos = end;
                return buffer;
            },

            // verbose for performance reasons; doesn't affect gzipped size

            readPackedVarint: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos < end) arr.push(this.readVarint());
                return arr;
            },
            readPackedSVarint: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos < end) arr.push(this.readSVarint());
                return arr;
            },
            readPackedBoolean: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos < end) arr.push(this.readBoolean());
                return arr;
            },
            readPackedFloat: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos < end) arr.push(this.readFloat());
                return arr;
            },
            readPackedDouble: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos < end) arr.push(this.readDouble());
                return arr;
            },
            readPackedFixed32: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos < end) arr.push(this.readFixed32());
                return arr;
            },
            readPackedSFixed32: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos < end) arr.push(this.readSFixed32());
                return arr;
            },
            readPackedFixed64: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos < end) arr.push(this.readFixed64());
                return arr;
            },
            readPackedSFixed64: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos < end) arr.push(this.readSFixed64());
                return arr;
            },

            skip: function(val) {
                var type = val & 0x7;
                if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
                else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
                else if (type === Pbf.Fixed32) this.pos += 4;
                else if (type === Pbf.Fixed64) this.pos += 8;
                else throw new Error('Unimplemented type: ' + type);
            },

            // === WRITING =================================================================

            writeTag: function(tag, type) {
                this.writeVarint((tag << 3) | type);
            },

            realloc: function(min) {
                var length = this.length || 16;

                while (length < this.pos + min) length *= 2;

                if (length !== this.length) {
                    var buf = new Buffer(length);
                    this.buf.copy(buf);
                    this.buf = buf;
                    this.length = length;
                }
            },

            finish: function() {
                this.length = this.pos;
                this.pos = 0;
                return this.buf.slice(0, this.length);
            },

            writeFixed32: function(val) {
                this.realloc(4);
                this.buf.writeUInt32LE(val, this.pos);
                this.pos += 4;
            },

            writeSFixed32: function(val) {
                this.realloc(4);
                this.buf.writeInt32LE(val, this.pos);
                this.pos += 4;
            },

            writeFixed64: function(val) {
                this.realloc(8);
                this.buf.writeInt32LE(val & -1, this.pos);
                this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
                this.pos += 8;
            },

            writeSFixed64: function(val) {
                this.realloc(8);
                this.buf.writeInt32LE(val & -1, this.pos);
                this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
                this.pos += 8;
            },

            writeVarint: function(val) {
                val = +val;

                if (val <= 0x7f) {
                    this.realloc(1);
                    this.buf[this.pos++] = val;

                } else if (val <= 0x3fff) {
                    this.realloc(2);
                    this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val >>> 7) & 0x7f);

                } else if (val <= 0x1fffff) {
                    this.realloc(3);
                    this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val >>> 14) & 0x7f);

                } else if (val <= 0xfffffff) {
                    this.realloc(4);
                    this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val >>> 21) & 0x7f);

                } else {
                    var pos = this.pos;
                    while (val >= 0x80) {
                        this.realloc(1);
                        this.buf[this.pos++] = (val & 0xff) | 0x80;
                        val /= 0x80;
                    }
                    this.realloc(1);
                    this.buf[this.pos++] = val | 0;
                    if (this.pos - pos > 10) throw new Error('Given varint doesn\'t fit into 10 bytes');
                }
            },

            writeSVarint: function(val) {
                this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
            },

            writeBoolean: function(val) {
                this.writeVarint(Boolean(val));
            },

            writeString: function(str) {
                str = String(str);
                var bytes = Buffer.byteLength(str);
                this.writeVarint(bytes);
                this.realloc(bytes);
                this.buf.write(str, this.pos);
                this.pos += bytes;
            },

            writeFloat: function(val) {
                this.realloc(4);
                this.buf.writeFloatLE(val, this.pos);
                this.pos += 4;
            },

            writeDouble: function(val) {
                this.realloc(8);
                this.buf.writeDoubleLE(val, this.pos);
                this.pos += 8;
            },

            writeBytes: function(buffer) {
                var len = buffer.length;
                this.writeVarint(len);
                this.realloc(len);
                for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
            },

            writeMessage: function(tag, fn, obj) {
                this.writeTag(tag, Pbf.Bytes);

                this.pos++; // reserve 1 byte for short message length

                // write the message directly to the buffer and see how much was written
                var startPos = this.pos;
                fn(obj, this);
                var len = this.pos - startPos;

                var varintLen =
                        len <= 0x7f ? 1 :
                        len <= 0x3fff ? 2 :
                        len <= 0x1fffff ? 3 :
                        len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

                // if 1 byte isn't enough for encoding message length, shift the data to the right
                if (varintLen > 1) {
                    this.realloc(varintLen - 1);
                    for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
                }

                // finally, write the message length in the reserved place and restore the position
                this.pos = startPos - 1;
                this.writeVarint(len);
                this.pos += len;
            },

            writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
            writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
            writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
            writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
            writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
            writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
            writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
            writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
            writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

            writeBytesField: function(tag, buffer) {
                this.writeTag(tag, Pbf.Bytes);
                this.writeBytes(buffer);
            },
            writeFixed32Field: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed32);
                this.writeFixed32(val);
            },
            writeSFixed32Field: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed32);
                this.writeSFixed32(val);
            },
            writeFixed64Field: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed64);
                this.writeFixed64(val);
            },
            writeSFixed64Field: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed64);
                this.writeSFixed64(val);
            },
            writeVarintField: function(tag, val) {
                this.writeTag(tag, Pbf.Varint);
                this.writeVarint(val);
            },
            writeSVarintField: function(tag, val) {
                this.writeTag(tag, Pbf.Varint);
                this.writeSVarint(val);
            },
            writeStringField: function(tag, str) {
                this.writeTag(tag, Pbf.Bytes);
                this.writeString(str);
            },
            writeFloatField: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed32);
                this.writeFloat(val);
            },
            writeDoubleField: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed64);
                this.writeDouble(val);
            },
            writeBooleanField: function(tag, val) {
                this.writeVarintField(tag, Boolean(val));
            }
        };

        function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
        function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
        function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
        function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
        function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
        function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
        function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
        function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
        function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./buffer":147}],149:[function(require,module,exports){
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m
        var eLen = nBytes * 8 - mLen - 1
        var eMax = (1 << eLen) - 1
        var eBias = eMax >> 1
        var nBits = -7
        var i = isLE ? (nBytes - 1) : 0
        var d = isLE ? -1 : 1
        var s = buffer[offset + i]

        i += d

        e = s & ((1 << (-nBits)) - 1)
        s >>= (-nBits)
        nBits += eLen
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1)
        e >>= (-nBits)
        nBits += mLen
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity)
        } else {
            m = m + Math.pow(2, mLen)
            e = e - eBias
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c
        var eLen = nBytes * 8 - mLen - 1
        var eMax = (1 << eLen) - 1
        var eBias = eMax >> 1
        var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
        var i = isLE ? 0 : (nBytes - 1)
        var d = isLE ? 1 : -1
        var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

        value = Math.abs(value)

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0
            e = eMax
        } else {
            e = Math.floor(Math.log(value) / Math.LN2)
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--
                c *= 2
            }
            if (e + eBias >= 1) {
                value += rt / c
            } else {
                value += rt * Math.pow(2, 1 - eBias)
            }
            if (value * c >= 2) {
                e++
                c /= 2
            }

            if (e + eBias >= eMax) {
                m = 0
                e = eMax
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen)
                e = e + eBias
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                e = 0
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m
        eLen += mLen
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128
    }

},{}],150:[function(require,module,exports){
    'use strict';

    module.exports = Point;

    function Point(x, y) {
        this.x = x;
        this.y = y;
    }

    Point.prototype = {
        clone: function() { return new Point(this.x, this.y); },

        add:     function(p) { return this.clone()._add(p);     },
        sub:     function(p) { return this.clone()._sub(p);     },
        mult:    function(k) { return this.clone()._mult(k);    },
        div:     function(k) { return this.clone()._div(k);     },
        rotate:  function(a) { return this.clone()._rotate(a);  },
        matMult: function(m) { return this.clone()._matMult(m); },
        unit:    function() { return this.clone()._unit(); },
        perp:    function() { return this.clone()._perp(); },
        round:   function() { return this.clone()._round(); },

        mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },

        equals: function(p) {
            return this.x === p.x &&
                this.y === p.y;
        },

        dist: function(p) {
            return Math.sqrt(this.distSqr(p));
        },

        distSqr: function(p) {
            var dx = p.x - this.x,
                dy = p.y - this.y;
            return dx * dx + dy * dy;
        },

        angle: function() {
            return Math.atan2(this.y, this.x);
        },

        angleTo: function(b) {
            return Math.atan2(this.y - b.y, this.x - b.x);
        },

        angleWith: function(b) {
            return this.angleWithSep(b.x, b.y);
        },

        // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
        angleWithSep: function(x, y) {
            return Math.atan2(
                    this.x * y - this.y * x,
                    this.x * x + this.y * y);
        },

        _matMult: function(m) {
            var x = m[0] * this.x + m[1] * this.y,
                y = m[2] * this.x + m[3] * this.y;
            this.x = x;
            this.y = y;
            return this;
        },

        _add: function(p) {
            this.x += p.x;
            this.y += p.y;
            return this;
        },

        _sub: function(p) {
            this.x -= p.x;
            this.y -= p.y;
            return this;
        },

        _mult: function(k) {
            this.x *= k;
            this.y *= k;
            return this;
        },

        _div: function(k) {
            this.x /= k;
            this.y /= k;
            return this;
        },

        _unit: function() {
            this._div(this.mag());
            return this;
        },

        _perp: function() {
            var y = this.y;
            this.y = this.x;
            this.x = -y;
            return this;
        },

        _rotate: function(angle) {
            var cos = Math.cos(angle),
                sin = Math.sin(angle),
                x = cos * this.x - sin * this.y,
                y = sin * this.x + cos * this.y;
            this.x = x;
            this.y = y;
            return this;
        },

        _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        }
    };

// constructs Point from an array if necessary
    Point.convert = function (a) {
        if (a instanceof Point) {
            return a;
        }
        if (Array.isArray(a)) {
            return new Point(a[0], a[1]);
        }
        return a;
    };

},{}],151:[function(require,module,exports){
    /*
     (c) 2013, Vladimir Agafonkin
     RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
     https://github.com/mourner/rbush
     */

    (function () { 'use strict';

        function rbush(maxEntries, format) {

            // jshint newcap: false, validthis: true
            if (!(this instanceof rbush)) return new rbush(maxEntries, format);

            // max entries in a node is 9 by default; min node fill is 40% for best performance
            this._maxEntries = Math.max(4, maxEntries || 9);
            this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

            if (format) {
                this._initFormat(format);
            }

            this.clear();
        }

        rbush.prototype = {

            all: function () {
                return this._all(this.data, []);
            },

            search: function (bbox) {

                var node = this.data,
                    result = [],
                    toBBox = this.toBBox;

                if (!intersects(bbox, node.bbox)) return result;

                var nodesToSearch = [],
                    i, len, child, childBBox;

                while (node) {
                    for (i = 0, len = node.children.length; i < len; i++) {

                        child = node.children[i];
                        childBBox = node.leaf ? toBBox(child) : child.bbox;

                        if (intersects(bbox, childBBox)) {
                            if (node.leaf) result.push(child);
                            else if (contains(bbox, childBBox)) this._all(child, result);
                            else nodesToSearch.push(child);
                        }
                    }
                    node = nodesToSearch.pop();
                }

                return result;
            },

            collides: function (bbox) {

                var node = this.data,
                    toBBox = this.toBBox;

                if (!intersects(bbox, node.bbox)) return false;

                var nodesToSearch = [],
                    i, len, child, childBBox;

                while (node) {
                    for (i = 0, len = node.children.length; i < len; i++) {

                        child = node.children[i];
                        childBBox = node.leaf ? toBBox(child) : child.bbox;

                        if (intersects(bbox, childBBox)) {
                            if (node.leaf || contains(bbox, childBBox)) return true;
                            nodesToSearch.push(child);
                        }
                    }
                    node = nodesToSearch.pop();
                }

                return false;
            },

            load: function (data) {
                if (!(data && data.length)) return this;

                if (data.length < this._minEntries) {
                    for (var i = 0, len = data.length; i < len; i++) {
                        this.insert(data[i]);
                    }
                    return this;
                }

                // recursively build the tree with the given data from stratch using OMT algorithm
                var node = this._build(data.slice(), 0, data.length - 1, 0);

                if (!this.data.children.length) {
                    // save as is if tree is empty
                    this.data = node;

                } else if (this.data.height === node.height) {
                    // split root if trees have the same height
                    this._splitRoot(this.data, node);

                } else {
                    if (this.data.height < node.height) {
                        // swap trees if inserted one is bigger
                        var tmpNode = this.data;
                        this.data = node;
                        node = tmpNode;
                    }

                    // insert the small tree into the large tree at appropriate level
                    this._insert(node, this.data.height - node.height - 1, true);
                }

                return this;
            },

            insert: function (item) {
                if (item) this._insert(item, this.data.height - 1);
                return this;
            },

            clear: function () {
                this.data = {
                    children: [],
                    height: 1,
                    bbox: empty(),
                    leaf: true
                };
                return this;
            },

            remove: function (item) {
                if (!item) return this;

                var node = this.data,
                    bbox = this.toBBox(item),
                    path = [],
                    indexes = [],
                    i, parent, index, goingUp;

                // depth-first iterative tree traversal
                while (node || path.length) {

                    if (!node) { // go up
                        node = path.pop();
                        parent = path[path.length - 1];
                        i = indexes.pop();
                        goingUp = true;
                    }

                    if (node.leaf) { // check current node
                        index = node.children.indexOf(item);

                        if (index !== -1) {
                            // item found, remove the item and condense tree upwards
                            node.children.splice(index, 1);
                            path.push(node);
                            this._condense(path);
                            return this;
                        }
                    }

                    if (!goingUp && !node.leaf && contains(node.bbox, bbox)) { // go down
                        path.push(node);
                        indexes.push(i);
                        i = 0;
                        parent = node;
                        node = node.children[0];

                    } else if (parent) { // go right
                        i++;
                        node = parent.children[i];
                        goingUp = false;

                    } else node = null; // nothing found
                }

                return this;
            },

            toBBox: function (item) { return item; },

            compareMinX: function (a, b) { return a[0] - b[0]; },
            compareMinY: function (a, b) { return a[1] - b[1]; },

            toJSON: function () { return this.data; },

            fromJSON: function (data) {
                this.data = data;
                return this;
            },

            _all: function (node, result) {
                var nodesToSearch = [];
                while (node) {
                    if (node.leaf) result.push.apply(result, node.children);
                    else nodesToSearch.push.apply(nodesToSearch, node.children);

                    node = nodesToSearch.pop();
                }
                return result;
            },

            _build: function (items, left, right, height) {

                var N = right - left + 1,
                    M = this._maxEntries,
                    node;

                if (N <= M) {
                    // reached leaf level; return leaf
                    node = {
                        children: items.slice(left, right + 1),
                        height: 1,
                        bbox: null,
                        leaf: true
                    };
                    calcBBox(node, this.toBBox);
                    return node;
                }

                if (!height) {
                    // target height of the bulk-loaded tree
                    height = Math.ceil(Math.log(N) / Math.log(M));

                    // target number of root entries to maximize storage utilization
                    M = Math.ceil(N / Math.pow(M, height - 1));
                }

                // TODO eliminate recursion?

                node = {
                    children: [],
                    height: height,
                    bbox: null
                };

                // split the items into M mostly square tiles

                var N2 = Math.ceil(N / M),
                    N1 = N2 * Math.ceil(Math.sqrt(M)),
                    i, j, right2, right3;

                multiSelect(items, left, right, N1, this.compareMinX);

                for (i = left; i <= right; i += N1) {

                    right2 = Math.min(i + N1 - 1, right);

                    multiSelect(items, i, right2, N2, this.compareMinY);

                    for (j = i; j <= right2; j += N2) {

                        right3 = Math.min(j + N2 - 1, right2);

                        // pack each entry recursively
                        node.children.push(this._build(items, j, right3, height - 1));
                    }
                }

                calcBBox(node, this.toBBox);

                return node;
            },

            _chooseSubtree: function (bbox, node, level, path) {

                var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

                while (true) {
                    path.push(node);

                    if (node.leaf || path.length - 1 === level) break;

                    minArea = minEnlargement = Infinity;

                    for (i = 0, len = node.children.length; i < len; i++) {
                        child = node.children[i];
                        area = bboxArea(child.bbox);
                        enlargement = enlargedArea(bbox, child.bbox) - area;

                        // choose entry with the least area enlargement
                        if (enlargement < minEnlargement) {
                            minEnlargement = enlargement;
                            minArea = area < minArea ? area : minArea;
                            targetNode = child;

                        } else if (enlargement === minEnlargement) {
                            // otherwise choose one with the smallest area
                            if (area < minArea) {
                                minArea = area;
                                targetNode = child;
                            }
                        }
                    }

                    node = targetNode;
                }

                return node;
            },

            _insert: function (item, level, isNode) {

                var toBBox = this.toBBox,
                    bbox = isNode ? item.bbox : toBBox(item),
                    insertPath = [];

                // find the best node for accommodating the item, saving all nodes along the path too
                var node = this._chooseSubtree(bbox, this.data, level, insertPath);

                // put the item into the node
                node.children.push(item);
                extend(node.bbox, bbox);

                // split on node overflow; propagate upwards if necessary
                while (level >= 0) {
                    if (insertPath[level].children.length > this._maxEntries) {
                        this._split(insertPath, level);
                        level--;
                    } else break;
                }

                // adjust bboxes along the insertion path
                this._adjustParentBBoxes(bbox, insertPath, level);
            },

            // split overflowed node into two
            _split: function (insertPath, level) {

                var node = insertPath[level],
                    M = node.children.length,
                    m = this._minEntries;

                this._chooseSplitAxis(node, m, M);

                var newNode = {
                    children: node.children.splice(this._chooseSplitIndex(node, m, M)),
                    height: node.height
                };

                if (node.leaf) newNode.leaf = true;

                calcBBox(node, this.toBBox);
                calcBBox(newNode, this.toBBox);

                if (level) insertPath[level - 1].children.push(newNode);
                else this._splitRoot(node, newNode);
            },

            _splitRoot: function (node, newNode) {
                // split root node
                this.data = {
                    children: [node, newNode],
                    height: node.height + 1
                };
                calcBBox(this.data, this.toBBox);
            },

            _chooseSplitIndex: function (node, m, M) {

                var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

                minOverlap = minArea = Infinity;

                for (i = m; i <= M - m; i++) {
                    bbox1 = distBBox(node, 0, i, this.toBBox);
                    bbox2 = distBBox(node, i, M, this.toBBox);

                    overlap = intersectionArea(bbox1, bbox2);
                    area = bboxArea(bbox1) + bboxArea(bbox2);

                    // choose distribution with minimum overlap
                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        index = i;

                        minArea = area < minArea ? area : minArea;

                    } else if (overlap === minOverlap) {
                        // otherwise choose distribution with minimum area
                        if (area < minArea) {
                            minArea = area;
                            index = i;
                        }
                    }
                }

                return index;
            },

            // sorts node children by the best axis for split
            _chooseSplitAxis: function (node, m, M) {

                var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
                    compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
                    xMargin = this._allDistMargin(node, m, M, compareMinX),
                    yMargin = this._allDistMargin(node, m, M, compareMinY);

                // if total distributions margin value is minimal for x, sort by minX,
                // otherwise it's already sorted by minY
                if (xMargin < yMargin) node.children.sort(compareMinX);
            },

            // total margin of all possible split distributions where each node is at least m full
            _allDistMargin: function (node, m, M, compare) {

                node.children.sort(compare);

                var toBBox = this.toBBox,
                    leftBBox = distBBox(node, 0, m, toBBox),
                    rightBBox = distBBox(node, M - m, M, toBBox),
                    margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
                    i, child;

                for (i = m; i < M - m; i++) {
                    child = node.children[i];
                    extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);
                    margin += bboxMargin(leftBBox);
                }

                for (i = M - m - 1; i >= m; i--) {
                    child = node.children[i];
                    extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);
                    margin += bboxMargin(rightBBox);
                }

                return margin;
            },

            _adjustParentBBoxes: function (bbox, path, level) {
                // adjust bboxes along the given tree path
                for (var i = level; i >= 0; i--) {
                    extend(path[i].bbox, bbox);
                }
            },

            _condense: function (path) {
                // go through the path, removing empty nodes and updating bboxes
                for (var i = path.length - 1, siblings; i >= 0; i--) {
                    if (path[i].children.length === 0) {
                        if (i > 0) {
                            siblings = path[i - 1].children;
                            siblings.splice(siblings.indexOf(path[i]), 1);

                        } else this.clear();

                    } else calcBBox(path[i], this.toBBox);
                }
            },

            _initFormat: function (format) {
                // data format (minX, minY, maxX, maxY accessors)

                // uses eval-type function compilation instead of just accepting a toBBox function
                // because the algorithms are very sensitive to sorting functions performance,
                // so they should be dead simple and without inner calls

                // jshint evil: true

                var compareArr = ['return a', ' - b', ';'];

                this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
                this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

                this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');
            }
        };


// calculate node's bbox from bboxes of its children
        function calcBBox(node, toBBox) {
            node.bbox = distBBox(node, 0, node.children.length, toBBox);
        }

// min bounding rectangle of node children from k to p-1
        function distBBox(node, k, p, toBBox) {
            var bbox = empty();

            for (var i = k, child; i < p; i++) {
                child = node.children[i];
                extend(bbox, node.leaf ? toBBox(child) : child.bbox);
            }

            return bbox;
        }

        function empty() { return [Infinity, Infinity, -Infinity, -Infinity]; }

        function extend(a, b) {
            a[0] = Math.min(a[0], b[0]);
            a[1] = Math.min(a[1], b[1]);
            a[2] = Math.max(a[2], b[2]);
            a[3] = Math.max(a[3], b[3]);
            return a;
        }

        function compareNodeMinX(a, b) { return a.bbox[0] - b.bbox[0]; }
        function compareNodeMinY(a, b) { return a.bbox[1] - b.bbox[1]; }

        function bboxArea(a)   { return (a[2] - a[0]) * (a[3] - a[1]); }
        function bboxMargin(a) { return (a[2] - a[0]) + (a[3] - a[1]); }

        function enlargedArea(a, b) {
            return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) *
                (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
        }

        function intersectionArea(a, b) {
            var minX = Math.max(a[0], b[0]),
                minY = Math.max(a[1], b[1]),
                maxX = Math.min(a[2], b[2]),
                maxY = Math.min(a[3], b[3]);

            return Math.max(0, maxX - minX) *
                Math.max(0, maxY - minY);
        }

        function contains(a, b) {
            return a[0] <= b[0] &&
                a[1] <= b[1] &&
                b[2] <= a[2] &&
                b[3] <= a[3];
        }

        function intersects(a, b) {
            return b[0] <= a[2] &&
                b[1] <= a[3] &&
                b[2] >= a[0] &&
                b[3] >= a[1];
        }

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

        function multiSelect(arr, left, right, n, compare) {
            var stack = [left, right],
                mid;

            while (stack.length) {
                right = stack.pop();
                left = stack.pop();

                if (right - left <= n) continue;

                mid = left + Math.ceil((right - left) / n / 2) * n;
                select(arr, left, right, mid, compare);

                stack.push(left, mid, mid, right);
            }
        }

// Floyd-Rivest selection algorithm:
// sort an array between left and right (inclusive) so that the smallest k elements come first (unordered)
        function select(arr, left, right, k, compare) {
            var n, i, z, s, sd, newLeft, newRight, t, j;

            while (right > left) {
                if (right - left > 600) {
                    n = right - left + 1;
                    i = k - left + 1;
                    z = Math.log(n);
                    s = 0.5 * Math.exp(2 * z / 3);
                    sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i - n / 2 < 0 ? -1 : 1);
                    newLeft = Math.max(left, Math.floor(k - i * s / n + sd));
                    newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));
                    select(arr, newLeft, newRight, k, compare);
                }

                t = arr[k];
                i = left;
                j = right;

                swap(arr, left, k);
                if (compare(arr[right], t) > 0) swap(arr, left, right);

                while (i < j) {
                    swap(arr, i, j);
                    i++;
                    j--;
                    while (compare(arr[i], t) < 0) i++;
                    while (compare(arr[j], t) > 0) j--;
                }

                if (compare(arr[left], t) === 0) swap(arr, left, j);
                else {
                    j++;
                    swap(arr, j, right);
                }

                if (j <= k) left = j + 1;
                if (k <= j) right = j - 1;
            }
        }

        function swap(arr, i, j) {
            var tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        }


// export as AMD/CommonJS module or global variable
        if (typeof define === 'function' && define.amd) define('rbush', function() { return rbush; });
        else if (typeof module !== 'undefined') module.exports = rbush;
        else if (typeof self !== 'undefined') self.rbush = rbush;
        else window.rbush = rbush;

    })();

},{}],152:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

    void (function(root, factory) {
        if (typeof define === "function" && define.amd) {
            define(factory)
        } else if (typeof exports === "object") {
            module.exports = factory()
        } else {
            root.resolveUrl = factory()
        }
    }(this, function() {

        function resolveUrl(/* ...urls */) {
            var numUrls = arguments.length

            if (numUrls === 0) {
                throw new Error("resolveUrl requires at least one argument; got none.")
            }

            var base = document.createElement("base")
            base.href = arguments[0]

            if (numUrls === 1) {
                return base.href
            }

            var head = document.getElementsByTagName("head")[0]
            head.insertBefore(base, head.firstChild)

            var a = document.createElement("a")
            var resolved

            for (var index = 1; index < numUrls; index++) {
                a.href = arguments[index]
                resolved = a.href
                base.href = resolved
            }

            head.removeChild(base)

            return resolved
        }

        return resolveUrl

    }));

},{}],153:[function(require,module,exports){
    /*
     * Copyright (C) 2008 Apple Inc. All Rights Reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions
     * are met:
     * 1. Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     * 2. Redistributions in binary form must reproduce the above copyright
     *    notice, this list of conditions and the following disclaimer in the
     *    documentation and/or other materials provided with the distribution.
     *
     * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
     * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
     * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     *
     * Ported from Webkit
     * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
     */

    module.exports = UnitBezier;

    function UnitBezier(p1x, p1y, p2x, p2y) {
        // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
        this.cx = 3.0 * p1x;
        this.bx = 3.0 * (p2x - p1x) - this.cx;
        this.ax = 1.0 - this.cx - this.bx;

        this.cy = 3.0 * p1y;
        this.by = 3.0 * (p2y - p1y) - this.cy;
        this.ay = 1.0 - this.cy - this.by;

        this.p1x = p1x;
        this.p1y = p2y;
        this.p2x = p2x;
        this.p2y = p2y;
    }

    UnitBezier.prototype.sampleCurveX = function(t) {
        // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
        return ((this.ax * t + this.bx) * t + this.cx) * t;
    };

    UnitBezier.prototype.sampleCurveY = function(t) {
        return ((this.ay * t + this.by) * t + this.cy) * t;
    };

    UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
        return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
    };

    UnitBezier.prototype.solveCurveX = function(x, epsilon) {
        if (typeof epsilon === 'undefined') epsilon = 1e-6;

        var t0, t1, t2, x2, i;

        // First try a few iterations of Newton's method -- normally very fast.
        for (t2 = x, i = 0; i < 8; i++) {

            x2 = this.sampleCurveX(t2) - x;
            if (Math.abs(x2) < epsilon) return t2;

            var d2 = this.sampleCurveDerivativeX(t2);
            if (Math.abs(d2) < 1e-6) break;

            t2 = t2 - x2 / d2;
        }

        // Fall back to the bisection method for reliability.
        t0 = 0.0;
        t1 = 1.0;
        t2 = x;

        if (t2 < t0) return t0;
        if (t2 > t1) return t1;

        while (t0 < t1) {

            x2 = this.sampleCurveX(t2);
            if (Math.abs(x2 - x) < epsilon) return t2;

            if (x > x2) {
                t0 = t2;
            } else {
                t1 = t2;
            }

            t2 = (t1 - t0) * 0.5 + t0;
        }

        // Failure.
        return t2;
    };

    UnitBezier.prototype.solve = function(x, epsilon) {
        return this.sampleCurveY(this.solveCurveX(x, epsilon));
    };

},{}],154:[function(require,module,exports){
    module.exports.VectorTile = require('./lib/vectortile.js');
    module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
    module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":155,"./lib/vectortilefeature.js":156,"./lib/vectortilelayer.js":157}],155:[function(require,module,exports){
    'use strict';

    var VectorTileLayer = require('./vectortilelayer');

    module.exports = VectorTile;

    function VectorTile(pbf, end) {
        this.layers = pbf.readFields(readTile, {}, end);
    }

    function readTile(tag, layers, pbf) {
        if (tag === 3) {
            var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
            if (layer.length) layers[layer.name] = layer;
        }
    }


},{"./vectortilelayer":157}],156:[function(require,module,exports){
    'use strict';

    var Point = require('point-geometry');

    module.exports = VectorTileFeature;

    function VectorTileFeature(pbf, end, extent, keys, values) {
        // Public
        this.properties = {};
        this.extent = extent;
        this.type = 0;

        // Private
        this._pbf = pbf;
        this._geometry = -1;
        this._keys = keys;
        this._values = values;

        pbf.readFields(readFeature, this, end);
    }

    function readFeature(tag, feature, pbf) {
        if (tag == 1) feature._id = pbf.readVarint();
        else if (tag == 2) readTag(pbf, feature);
        else if (tag == 3) feature.type = pbf.readVarint();
        else if (tag == 4) feature._geometry = pbf.pos;
    }

    function readTag(pbf, feature) {
        var end = pbf.readVarint() + pbf.pos;

        while (pbf.pos < end) {
            var key = feature._keys[pbf.readVarint()],
                value = feature._values[pbf.readVarint()];
            feature.properties[key] = value;
        }
    }

    VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

    VectorTileFeature.prototype.loadGeometry = function() {
        var pbf = this._pbf;
        pbf.pos = this._geometry;

        var end = pbf.readVarint() + pbf.pos,
            cmd = 1,
            length = 0,
            x = 0,
            y = 0,
            lines = [],
            line;

        while (pbf.pos < end) {
            if (!length) {
                var cmdLen = pbf.readVarint();
                cmd = cmdLen & 0x7;
                length = cmdLen >> 3;
            }

            length--;

            if (cmd === 1 || cmd === 2) {
                x += pbf.readSVarint();
                y += pbf.readSVarint();

                if (cmd === 1) { // moveTo
                    if (line) lines.push(line);
                    line = [];
                }

                line.push(new Point(x, y));

            } else if (cmd === 7) {

                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
                if (line) {
                    line.push(line[0].clone()); // closePolygon
                }

            } else {
                throw new Error('unknown command ' + cmd);
            }
        }

        if (line) lines.push(line);

        return lines;
    };

    VectorTileFeature.prototype.bbox = function() {
        var pbf = this._pbf;
        pbf.pos = this._geometry;

        var end = pbf.readVarint() + pbf.pos,
            cmd = 1,
            length = 0,
            x = 0,
            y = 0,
            x1 = Infinity,
            x2 = -Infinity,
            y1 = Infinity,
            y2 = -Infinity;

        while (pbf.pos < end) {
            if (!length) {
                var cmdLen = pbf.readVarint();
                cmd = cmdLen & 0x7;
                length = cmdLen >> 3;
            }

            length--;

            if (cmd === 1 || cmd === 2) {
                x += pbf.readSVarint();
                y += pbf.readSVarint();
                if (x < x1) x1 = x;
                if (x > x2) x2 = x;
                if (y < y1) y1 = y;
                if (y > y2) y2 = y;

            } else if (cmd !== 7) {
                throw new Error('unknown command ' + cmd);
            }
        }

        return [x1, y1, x2, y2];
    };

    VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
        var size = this.extent * Math.pow(2, z),
            x0 = this.extent * x,
            y0 = this.extent * y,
            coords = this.loadGeometry(),
            type = VectorTileFeature.types[this.type];

        for (var i = 0; i < coords.length; i++) {
            var line = coords[i];
            for (var j = 0; j < line.length; j++) {
                var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
                line[j] = [
                        (p.x + x0) * 360 / size - 180,
                        360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
                ];
            }
        }

        if (type === 'Point' && coords.length === 1) {
            coords = coords[0][0];
        } else if (type === 'Point') {
            coords = coords[0];
            type = 'MultiPoint';
        } else if (type === 'LineString' && coords.length === 1) {
            coords = coords[0];
        } else if (type === 'LineString') {
            type = 'MultiLineString';
        }

        return {
            type: "Feature",
            geometry: {
                type: type,
                coordinates: coords
            },
            properties: this.properties
        };
    };

},{"point-geometry":150}],157:[function(require,module,exports){
    'use strict';

    var VectorTileFeature = require('./vectortilefeature.js');

    module.exports = VectorTileLayer;

    function VectorTileLayer(pbf, end) {
        // Public
        this.version = 1;
        this.name = null;
        this.extent = 4096;
        this.length = 0;

        // Private
        this._pbf = pbf;
        this._keys = [];
        this._values = [];
        this._features = [];

        pbf.readFields(readLayer, this, end);

        this.length = this._features.length;
    }

    function readLayer(tag, layer, pbf) {
        if (tag === 15) layer.version = pbf.readVarint();
        else if (tag === 1) layer.name = pbf.readString();
        else if (tag === 5) layer.extent = pbf.readVarint();
        else if (tag === 2) layer._features.push(pbf.pos);
        else if (tag === 3) layer._keys.push(pbf.readString());
        else if (tag === 4) layer._values.push(readValueMessage(pbf));
    }

    function readValueMessage(pbf) {
        var value = null,
            end = pbf.readVarint() + pbf.pos;

        while (pbf.pos < end) {
            var tag = pbf.readVarint() >> 3;

            value = tag === 1 ? pbf.readString() :
                    tag === 2 ? pbf.readFloat() :
                    tag === 3 ? pbf.readDouble() :
                    tag === 4 ? pbf.readVarint64() :
                    tag === 5 ? pbf.readVarint() :
                    tag === 6 ? pbf.readSVarint() :
                    tag === 7 ? pbf.readBoolean() : null;
        }

        return value;
    }

// return feature `i` from this layer as a `VectorTileFeature`
    VectorTileLayer.prototype.feature = function(i) {
        if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

        this._pbf.pos = this._features[i];

        var end = this._pbf.readVarint() + this._pbf.pos;
        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
    };

},{"./vectortilefeature.js":156}],158:[function(require,module,exports){
    var bundleFn = arguments[3];
    var sources = arguments[4];
    var cache = arguments[5];

    var stringify = JSON.stringify;

    module.exports = function (fn) {
        var keys = [];
        var wkey;
        var cacheKeys = Object.keys(cache);

        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            if (cache[key].exports === fn) {
                wkey = key;
                break;
            }
        }

        if (!wkey) {
            wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
            var wcache = {};
            for (var i = 0, l = cacheKeys.length; i < l; i++) {
                var key = cacheKeys[i];
                wcache[key] = key;
            }
            sources[wkey] = [
                Function(['require','module','exports'], '(' + fn + ')(self)'),
                wcache
            ];
        }
        var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

        var scache = {}; scache[wkey] = wkey;
        sources[skey] = [
            Function(['require'],'require(' + stringify(wkey) + ')(self)'),
            scache
        ];

        var src = '(' + bundleFn + ')({'
                + Object.keys(sources).map(function (key) {
                    return stringify(key) + ':['
                        + sources[key][0]
                        + ',' + stringify(sources[key][1]) + ']'
                        ;
                }).join(',')
                + '},{},[' + stringify(skey) + '])'
            ;

        var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

        return new Worker(URL.createObjectURL(
            new Blob([src], { type: 'text/javascript' })
        ));
    };

},{}]},{},[22])(22)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kYXRhL2J1ZmZlci9idWZmZXIuanMiLCJqcy9kYXRhL2J1ZmZlci9idWZmZXJfc2V0LmpzIiwianMvZGF0YS9idWZmZXIvY29sbGlzaW9uX2JveF92ZXJ0ZXhfYnVmZmVyLmpzIiwianMvZGF0YS9idWZmZXIvZmlsbF92ZXJ0ZXhfYnVmZmVyLmpzIiwianMvZGF0YS9idWZmZXIvZ2x5cGhfdmVydGV4X2J1ZmZlci5qcyIsImpzL2RhdGEvYnVmZmVyL2ljb25fdmVydGV4X2J1ZmZlci5qcyIsImpzL2RhdGEvYnVmZmVyL2xpbmVfZWxlbWVudF9idWZmZXIuanMiLCJqcy9kYXRhL2J1ZmZlci9saW5lX3ZlcnRleF9idWZmZXIuanMiLCJqcy9kYXRhL2J1ZmZlci9vdXRsaW5lX2VsZW1lbnRfYnVmZmVyLmpzIiwianMvZGF0YS9idWZmZXIvdHJpYW5nbGVfZWxlbWVudF9idWZmZXIuanMiLCJqcy9kYXRhL2NyZWF0ZV9idWNrZXQuanMiLCJqcy9kYXRhL2VsZW1lbnRfZ3JvdXBzLmpzIiwianMvZGF0YS9mZWF0dXJlX3RyZWUuanMiLCJqcy9kYXRhL2ZpbGxfYnVja2V0LmpzIiwianMvZGF0YS9saW5lX2J1Y2tldC5qcyIsImpzL2RhdGEvc3ltYm9sX2J1Y2tldC5qcyIsImpzL2dlby9jb29yZGluYXRlLmpzIiwianMvZ2VvL2xhdF9sbmcuanMiLCJqcy9nZW8vbGF0X2xuZ19ib3VuZHMuanMiLCJqcy9nZW8vdHJhbnNmb3JtLmpzIiwianMvbGliL2RlYnVndGV4dC5qcyIsImpzL21hcGJveC1nbC5qcyIsImpzL3JlbmRlci9kcmF3X2JhY2tncm91bmQuanMiLCJqcy9yZW5kZXIvZHJhd19jb2xsaXNpb25fZGVidWcuanMiLCJqcy9yZW5kZXIvZHJhd19kZWJ1Zy5qcyIsImpzL3JlbmRlci9kcmF3X2ZpbGwuanMiLCJqcy9yZW5kZXIvZHJhd19saW5lLmpzIiwianMvcmVuZGVyL2RyYXdfcmFzdGVyLmpzIiwianMvcmVuZGVyL2RyYXdfc3ltYm9sLmpzIiwianMvcmVuZGVyL2RyYXdfdmVydGljZXMuanMiLCJqcy9yZW5kZXIvZnJhbWVfaGlzdG9yeS5qcyIsImpzL3JlbmRlci9nbF91dGlsLmpzIiwianMvcmVuZGVyL2xpbmVfYXRsYXMuanMiLCJqcy9yZW5kZXIvcGFpbnRlci5qcyIsImpzL3JlbmRlci9zaGFkZXJzLmpzIiwianMvc291cmNlL2dlb2pzb25fc291cmNlLmpzIiwianMvc291cmNlL2dlb2pzb25fd3JhcHBlci5qcyIsImpzL3NvdXJjZS9yYXN0ZXJfdGlsZV9zb3VyY2UuanMiLCJqcy9zb3VyY2Uvc291cmNlLmpzIiwianMvc291cmNlL3RpbGUuanMiLCJqcy9zb3VyY2UvdGlsZV9jb29yZC5qcyIsImpzL3NvdXJjZS90aWxlX3B5cmFtaWQuanMiLCJqcy9zb3VyY2UvdmVjdG9yX3RpbGVfc291cmNlLmpzIiwianMvc291cmNlL3ZpZGVvX3NvdXJjZS5qcyIsImpzL3NvdXJjZS93b3JrZXIuanMiLCJqcy9zb3VyY2Uvd29ya2VyX3RpbGUuanMiLCJqcy9zdHlsZS9hbmltYXRpb25fbG9vcC5qcyIsImpzL3N0eWxlL2ltYWdlX3Nwcml0ZS5qcyIsImpzL3N0eWxlL2xheW91dF9wcm9wZXJ0aWVzLmpzIiwianMvc3R5bGUvcGFpbnRfcHJvcGVydGllcy5qcyIsImpzL3N0eWxlL3JlZmVyZW5jZS5qcyIsImpzL3N0eWxlL3N0eWxlLmpzIiwianMvc3R5bGUvc3R5bGVfYmF0Y2guanMiLCJqcy9zdHlsZS9zdHlsZV9jb25zdGFudC5qcyIsImpzL3N0eWxlL3N0eWxlX2RlY2xhcmF0aW9uLmpzIiwianMvc3R5bGUvc3R5bGVfZGVjbGFyYXRpb25fc2V0LmpzIiwianMvc3R5bGUvc3R5bGVfbGF5ZXIuanMiLCJqcy9zdHlsZS9zdHlsZV90cmFuc2l0aW9uLmpzIiwianMvc3ltYm9sL2FuY2hvci5qcyIsImpzL3N5bWJvbC9iaW5fcGFjay5qcyIsImpzL3N5bWJvbC9jaGVja19tYXhfYW5nbGUuanMiLCJqcy9zeW1ib2wvY2xpcF9saW5lLmpzIiwianMvc3ltYm9sL2NvbGxpc2lvbl9ib3guanMiLCJqcy9zeW1ib2wvY29sbGlzaW9uX2ZlYXR1cmUuanMiLCJqcy9zeW1ib2wvY29sbGlzaW9uX3RpbGUuanMiLCJqcy9zeW1ib2wvZ2V0X2FuY2hvcnMuanMiLCJqcy9zeW1ib2wvZ2x5cGhfYXRsYXMuanMiLCJqcy9zeW1ib2wvZ2x5cGhfc291cmNlLmpzIiwianMvc3ltYm9sL21lcmdlbGluZXMuanMiLCJqcy9zeW1ib2wvcXVhZHMuanMiLCJqcy9zeW1ib2wvcmVzb2x2ZV9pY29ucy5qcyIsImpzL3N5bWJvbC9yZXNvbHZlX3RleHQuanMiLCJqcy9zeW1ib2wvc2hhcGluZy5qcyIsImpzL3N5bWJvbC9zcHJpdGVfYXRsYXMuanMiLCJqcy91aS9jYW1lcmEuanMiLCJqcy91aS9jb250cm9sL2F0dHJpYnV0aW9uLmpzIiwianMvdWkvY29udHJvbC9jb250cm9sLmpzIiwianMvdWkvY29udHJvbC9uYXZpZ2F0aW9uLmpzIiwianMvdWkvaGFuZGxlci9ib3hfem9vbS5qcyIsImpzL3VpL2hhbmRsZXIvZGJsY2xpY2tfem9vbS5qcyIsImpzL3VpL2hhbmRsZXIvZHJhZ19wYW4uanMiLCJqcy91aS9oYW5kbGVyL2RyYWdfcm90YXRlLmpzIiwianMvdWkvaGFuZGxlci9rZXlib2FyZC5qcyIsImpzL3VpL2hhbmRsZXIvcGluY2guanMiLCJqcy91aS9oYW5kbGVyL3Njcm9sbF96b29tLmpzIiwianMvdWkvaGFzaC5qcyIsImpzL3VpL2ludGVyYWN0aW9uLmpzIiwianMvdWkvbWFwLmpzIiwianMvdWkvcG9wdXAuanMiLCJqcy91dGlsL2FjdG9yLmpzIiwianMvdXRpbC9icm93c2VyL2FqYXguanMiLCJqcy91dGlsL2Jyb3dzZXIvYnJvd3Nlci5qcyIsImpzL3V0aWwvYnJvd3Nlci9jYW52YXMuanMiLCJqcy91dGlsL2Jyb3dzZXIvZGlzcGF0Y2hlci5qcyIsImpzL3V0aWwvYnJvd3Nlci9kb20uanMiLCJqcy91dGlsL2NvbmZpZy5qcyIsImpzL3V0aWwvZXZlbnRlZC5qcyIsImpzL3V0aWwvZ2x5cGhzLmpzIiwianMvdXRpbC9pbnRlcnBvbGF0ZS5qcyIsImpzL3V0aWwvbWFwYm94LmpzIiwianMvdXRpbC9tcnVfY2FjaGUuanMiLCJqcy91dGlsL3Rva2VuLmpzIiwianMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2Nzc2NvbG9ycGFyc2VyL2Nzc2NvbG9ycGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2ZlYXR1cmUtZmlsdGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2NsaXAuanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvY29udmVydC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9zaW1wbGlmeS5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy90aWxlLmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL3dyYXAuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0MmQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0My5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3F1YXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMzLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLWZ1bmN0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS9sYXRlc3QuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3BhcnNlZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9yZWZlcmVuY2UvbGF0ZXN0LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS92Ny5qc29uIiwibm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3BiZi9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvcGJmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BiZi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wb2ludC1nZW9tZXRyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYnVzaC9yYnVzaC5qcyIsIm5vZGVfbW9kdWxlcy9yZXNvbHZlLXVybC9yZXNvbHZlLXVybC5qcyIsIm5vZGVfbW9kdWxlcy91bml0YmV6aWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlLmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWxheWVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYndvcmtpZnkvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNueEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbndDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ppQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BZQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbi8vIGEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIGEgc2luZ2xlIGFycmF5YnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuXG5mdW5jdGlvbiBCdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmRlZmF1bHRMZW5ndGgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZGVmYXVsdExlbmd0aDtcbiAgICAgICAgdGhpcy5zZXR1cFZpZXdzKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBvbmx5IHJlY3JlYXRlIGJ1ZmZlcnMgYWZ0ZXIgcmVjZWl2aW5nIHRoZW0gZnJvbSB3b3JrZXJzIGZvciBiaW5kaW5nIHRvIGdsLFxuICAgICAgICAvLyBzbyB3ZSBvbmx5IG5lZWQgdGhlc2UgMiBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuYXJyYXkgPSBidWZmZXIuYXJyYXk7XG4gICAgICAgIHRoaXMucG9zID0gYnVmZmVyLnBvcztcbiAgICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUgPSB7XG4gICAgcG9zOiAwLFxuICAgIGl0ZW1TaXplOiA0LCAvLyBieXRlcyBpbiBvbmUgaXRlbVxuICAgIGRlZmF1bHRMZW5ndGg6IDgxOTIsIC8vIGluaXRpYWwgYnVmZmVyIHNpemVcbiAgICBhcnJheVR5cGU6ICdBUlJBWV9CVUZGRVInLCAvLyBnbCBidWZmZXIgdHlwZVxuXG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLyB0aGlzLml0ZW1TaXplO1xuICAgIH0sXG5cbiAgICBzZXR1cFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2V0IHVwIHZpZXdzIGZvciBlYWNoIHR5cGUgdG8gYWRkIGRhdGEgb2YgZGlmZmVyZW50IHR5cGVzIHRvIHRoZSBzYW1lIGJ1ZmZlclxuICAgICAgICB0aGlzLnVieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXkpO1xuICAgICAgICB0aGlzLmJ5dGVzID0gbmV3IEludDhBcnJheSh0aGlzLmFycmF5KTtcbiAgICAgICAgdGhpcy51c2hvcnRzID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXkpO1xuICAgICAgICB0aGlzLnNob3J0cyA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXkpO1xuICAgIH0sXG5cbiAgICAvLyBiaW5kcyB0aGUgYnVmZmVyIHRvIGEgd2ViZ2wgY29udGV4dFxuICAgIGJpbmQ6IGZ1bmN0aW9uKGdsKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2xbdGhpcy5hcnJheVR5cGVdO1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKHR5cGUsIHRoaXMuYXJyYXkuc2xpY2UoMCwgdGhpcy5wb3MpLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgICAgIC8vIGR1bXAgYXJyYXkgYnVmZmVyIG9uY2UgaXQncyBib3VuZCB0byBnbFxuICAgICAgICAgICAgdGhpcy5hcnJheSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbihnbCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gaW5jcmVhc2UgdGhlIGJ1ZmZlciBzaXplIGJ5IDUwJSBpZiBhIG5ldyBpdGVtIGRvZXNuJ3QgZml0XG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy5wb3MgKyB0aGlzLml0ZW1TaXplKSB7XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHRoaXMucG9zICsgdGhpcy5pdGVtU2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsZW5ndGggYnkgNTAlIGJ1dCBrZWVwIGl0IGV2ZW5cbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IE1hdGgucm91bmQodGhpcy5sZW5ndGggKiAxLjUgLyAyKSAqIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFycmF5IGJ1ZmZlcnMgY2FuJ3QgYmUgcmVzaXplZCwgc28gd2UgY3JlYXRlIGEgbmV3IG9uZSBhbmQgcmVzZXQgYWxsIGJ5dGVzIHRoZXJlXG4gICAgICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEFycmF5QnVmZmVyKHRoaXMubGVuZ3RoKTtcblxuICAgICAgICAgICAgdmFyIHVieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXkpO1xuICAgICAgICAgICAgdWJ5dGVzLnNldCh0aGlzLnVieXRlcyk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0dXBWaWV3cygpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIExpbmVWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuL2xpbmVfdmVydGV4X2J1ZmZlcicpO1xudmFyIExpbmVFbGVtZW50QnVmZmVyID0gcmVxdWlyZSgnLi9saW5lX2VsZW1lbnRfYnVmZmVyJyk7XG52YXIgRmlsbFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4vZmlsbF92ZXJ0ZXhfYnVmZmVyJyk7XG52YXIgRmlsbEVsZW1lbnRCdWZmZXIgPSByZXF1aXJlKCcuL3RyaWFuZ2xlX2VsZW1lbnRfYnVmZmVyJyk7XG52YXIgT3V0bGluZUVsZW1lbnRCdWZmZXIgPSByZXF1aXJlKCcuL291dGxpbmVfZWxlbWVudF9idWZmZXInKTtcbnZhciBHbHlwaFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4vZ2x5cGhfdmVydGV4X2J1ZmZlcicpO1xudmFyIEdseXBoRWxlbWVudEJ1ZmZlciA9IHJlcXVpcmUoJy4vdHJpYW5nbGVfZWxlbWVudF9idWZmZXInKTtcbnZhciBJY29uVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi9pY29uX3ZlcnRleF9idWZmZXInKTtcbnZhciBJY29uRWxlbWVudEJ1ZmZlciA9IHJlcXVpcmUoJy4vdHJpYW5nbGVfZWxlbWVudF9idWZmZXInKTtcbnZhciBDb2xsaXNpb25Cb3hWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuL2NvbGxpc2lvbl9ib3hfdmVydGV4X2J1ZmZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJ1ZmZlcnNldCkge1xuICAgIGJ1ZmZlcnNldCA9IGJ1ZmZlcnNldCB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnbHlwaFZlcnRleDogbmV3IEdseXBoVmVydGV4QnVmZmVyKGJ1ZmZlcnNldC5nbHlwaFZlcnRleCksXG4gICAgICAgIGdseXBoRWxlbWVudDogbmV3IEdseXBoRWxlbWVudEJ1ZmZlcihidWZmZXJzZXQuZ2x5cGhFbGVtZW50KSxcbiAgICAgICAgaWNvblZlcnRleDogbmV3IEljb25WZXJ0ZXhCdWZmZXIoYnVmZmVyc2V0Lmljb25WZXJ0ZXgpLFxuICAgICAgICBpY29uRWxlbWVudDogbmV3IEljb25FbGVtZW50QnVmZmVyKGJ1ZmZlcnNldC5pY29uRWxlbWVudCksXG4gICAgICAgIGZpbGxWZXJ0ZXg6IG5ldyBGaWxsVmVydGV4QnVmZmVyKGJ1ZmZlcnNldC5maWxsVmVydGV4KSxcbiAgICAgICAgZmlsbEVsZW1lbnQ6IG5ldyBGaWxsRWxlbWVudEJ1ZmZlcihidWZmZXJzZXQuZmlsbEVsZW1lbnQpLFxuICAgICAgICBvdXRsaW5lRWxlbWVudDogbmV3IE91dGxpbmVFbGVtZW50QnVmZmVyKGJ1ZmZlcnNldC5vdXRsaW5lRWxlbWVudCksXG4gICAgICAgIGxpbmVWZXJ0ZXg6IG5ldyBMaW5lVmVydGV4QnVmZmVyKGJ1ZmZlcnNldC5saW5lVmVydGV4KSxcbiAgICAgICAgbGluZUVsZW1lbnQ6IG5ldyBMaW5lRWxlbWVudEJ1ZmZlcihidWZmZXJzZXQubGluZUVsZW1lbnQpLFxuICAgICAgICBjb2xsaXNpb25Cb3hWZXJ0ZXg6IG5ldyBDb2xsaXNpb25Cb3hWZXJ0ZXhCdWZmZXIoYnVmZmVyc2V0LmNvbGxpc2lvbkJveFZlcnRleClcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvbkJveFZlcnRleEJ1ZmZlcjtcblxuZnVuY3Rpb24gQ29sbGlzaW9uQm94VmVydGV4QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cbkNvbGxpc2lvbkJveFZlcnRleEJ1ZmZlci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVmZmVyLCB7XG4gICAgaXRlbVNpemU6IDEyLCAvLyBieXRlcyBwZXIgdmVydGV4ICgyICogc2hvcnQgKyAxICogc2hvcnQgKyAyICogYnl0ZSA9IDggYnl0ZXMpXG4gICAgZGVmYXVsdExlbmd0aDogMzI3NjgsXG5cbiAgICAvLyBhZGQgYSB2ZXJ0ZXggdG8gdGhpcyBidWZmZXI7XG4gICAgLy8geCwgeSAtIHZlcnRleCBwb3NpdGlvblxuICAgIC8vIGV4LCBleSAtIGV4dHJ1ZGUgbm9ybWFsXG4gICAgYWRkOiBmdW5jdGlvbihwb2ludCwgZXh0cnVkZSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3MsXG4gICAgICAgICAgICBwb3MyID0gcG9zIC8gMixcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAgIHRoaXMuc2hvcnRzW3BvczIgKyAwXSA9IHBvaW50Lng7XG4gICAgICAgIHRoaXMuc2hvcnRzW3BvczIgKyAxXSA9IHBvaW50Lnk7XG5cbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDJdID0gTWF0aC5yb3VuZChleHRydWRlLngpO1xuICAgICAgICB0aGlzLnNob3J0c1twb3MyICsgM10gPSBNYXRoLnJvdW5kKGV4dHJ1ZGUueSk7XG4gICAgICAgIHRoaXMudWJ5dGVzW3BvcyArIDhdID0gTWF0aC5mbG9vcihtYXhab29tICogMTApO1xuICAgICAgICB0aGlzLnVieXRlc1twb3MgKyA5XSA9IE1hdGguZmxvb3IocGxhY2VtZW50Wm9vbSAqIDEwKTtcblxuICAgICAgICB0aGlzLnBvcyArPSB0aGlzLml0ZW1TaXplO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxsVmVydGV4QnVmZmVyO1xuXG5mdW5jdGlvbiBGaWxsVmVydGV4QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cbkZpbGxWZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEJ1ZmZlciwge1xuICAgIGl0ZW1TaXplOiA0LCAvLyBieXRlcyBwZXIgdmVydGV4ICgyICogc2hvcnQgPT0gNCBieXRlcylcblxuICAgIGFkZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgcG9zMiA9IHRoaXMucG9zIC8gMjtcblxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAgIHRoaXMuc2hvcnRzW3BvczIgKyAwXSA9IHg7XG4gICAgICAgIHRoaXMuc2hvcnRzW3BvczIgKyAxXSA9IHk7XG5cbiAgICAgICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBoVmVydGV4QnVmZmVyO1xuXG5mdW5jdGlvbiBHbHlwaFZlcnRleEJ1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG5cbkdseXBoVmVydGV4QnVmZmVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWZmZXIsIHtcbiAgICBkZWZhdWx0TGVuZ3RoOiAyMDQ4ICogMTYsXG4gICAgaXRlbVNpemU6IDE2LFxuXG4gICAgYWRkOiBmdW5jdGlvbih4LCB5LCBveCwgb3ksIHR4LCB0eSwgbWluem9vbSwgbWF4em9vbSwgbGFiZWxtaW56b29tKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyxcbiAgICAgICAgICAgIHBvczIgPSBwb3MgLyAyO1xuXG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDBdID0geDtcbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDFdID0geTtcbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDJdID0gTWF0aC5yb3VuZChveCAqIDY0KTsgLy8gdXNlIDEvNjQgcGl4ZWxzIGZvciBwbGFjZW1lbnRcbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDNdID0gTWF0aC5yb3VuZChveSAqIDY0KTtcblxuICAgICAgICAvLyBhX2RhdGExXG4gICAgICAgIHRoaXMudWJ5dGVzW3BvcyArIDhdIC8qIHRleCAqLyA9IE1hdGguZmxvb3IodHggLyA0KTtcbiAgICAgICAgdGhpcy51Ynl0ZXNbcG9zICsgOV0gLyogdGV4ICovID0gTWF0aC5mbG9vcih0eSAvIDQpO1xuICAgICAgICB0aGlzLnVieXRlc1twb3MgKyAxMF0gLyogbGFiZWxtaW56b29tICovID0gTWF0aC5mbG9vcigobGFiZWxtaW56b29tKSAqIDEwKTtcblxuICAgICAgICAvLyBhX2RhdGEyXG4gICAgICAgIHRoaXMudWJ5dGVzW3BvcyArIDEyXSAvKiBtaW56b29tICovID0gTWF0aC5mbG9vcigobWluem9vbSkgKiAxMCk7IC8vIDEvMTAgem9vbSBsZXZlbHM6IHoxNiA9PSAxNjAuXG4gICAgICAgIHRoaXMudWJ5dGVzW3BvcyArIDEzXSAvKiBtYXh6b29tICovID0gTWF0aC5mbG9vcihNYXRoLm1pbihtYXh6b29tLCAyNSkgKiAxMCk7IC8vIDEvMTAgem9vbSBsZXZlbHM6IHoxNiA9PSAxNjAuXG5cbiAgICAgICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbiAgICB9LFxuXG4gICAgYmluZDogZnVuY3Rpb24oZ2wsIHNoYWRlciwgb2Zmc2V0KSB7XG4gICAgICAgIEJ1ZmZlci5wcm90b3R5cGUuYmluZC5jYWxsKHRoaXMsIGdsKTtcblxuICAgICAgICB2YXIgc3RyaWRlID0gdGhpcy5pdGVtU2l6ZTtcblxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCBzdHJpZGUsIG9mZnNldCArIDApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX29mZnNldCwgMiwgZ2wuU0hPUlQsIGZhbHNlLCBzdHJpZGUsIG9mZnNldCArIDQpO1xuXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfZGF0YTEsIDQsIGdsLlVOU0lHTkVEX0JZVEUsIGZhbHNlLCBzdHJpZGUsIG9mZnNldCArIDgpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2RhdGEyLCAyLCBnbC5VTlNJR05FRF9CWVRFLCBmYWxzZSwgc3RyaWRlLCBvZmZzZXQgKyAxMik7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJY29uVmVydGV4QnVmZmVyO1xuXG5mdW5jdGlvbiBJY29uVmVydGV4QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cbkljb25WZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEJ1ZmZlciwge1xuICAgIGRlZmF1bHRMZW5ndGg6IDIwNDggKiAxNixcbiAgICBpdGVtU2l6ZTogMTYsXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKHgsIHksIG94LCBveSwgdHgsIHR5LCBtaW56b29tLCBtYXh6b29tLCBsYWJlbG1pbnpvb20pIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgcG9zMiA9IHBvcyAvIDI7XG5cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgICB0aGlzLnNob3J0c1twb3MyICsgMF0gPSB4O1xuICAgICAgICB0aGlzLnNob3J0c1twb3MyICsgMV0gPSB5O1xuICAgICAgICB0aGlzLnNob3J0c1twb3MyICsgMl0gPSBNYXRoLnJvdW5kKG94ICogNjQpOyAvLyB1c2UgMS82NCBwaXhlbHMgZm9yIHBsYWNlbWVudFxuICAgICAgICB0aGlzLnNob3J0c1twb3MyICsgM10gPSBNYXRoLnJvdW5kKG95ICogNjQpO1xuXG4gICAgICAgIC8vIGFfZGF0YTFcbiAgICAgICAgdGhpcy51Ynl0ZXNbcG9zICsgOF0gLyogdGV4ICovID0gdHggLyA0O1xuICAgICAgICB0aGlzLnVieXRlc1twb3MgKyA5XSAvKiB0ZXggKi8gPSB0eSAvIDQ7XG4gICAgICAgIHRoaXMudWJ5dGVzW3BvcyArIDEwXSAvKiBsYWJlbG1pbnpvb20gKi8gPSBNYXRoLmZsb29yKChsYWJlbG1pbnpvb20gfHwgMCkgKiAxMCk7XG5cbiAgICAgICAgLy8gYV9kYXRhMlxuICAgICAgICB0aGlzLnVieXRlc1twb3MgKyAxMl0gLyogbWluem9vbSAqLyA9IE1hdGguZmxvb3IoKG1pbnpvb20gfHwgMCkgKiAxMCk7IC8vIDEvMTAgem9vbSBsZXZlbHM6IHoxNiA9PSAxNjAuXG4gICAgICAgIHRoaXMudWJ5dGVzW3BvcyArIDEzXSAvKiBtYXh6b29tICovID0gTWF0aC5mbG9vcihNYXRoLm1pbihtYXh6b29tIHx8IDI1LCAyNSkgKiAxMCk7IC8vIDEvMTAgem9vbSBsZXZlbHM6IHoxNiA9PSAxNjAuXG5cbiAgICAgICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbiAgICB9LFxuXG4gICAgYmluZDogZnVuY3Rpb24oZ2wsIHNoYWRlciwgb2Zmc2V0KSB7XG4gICAgICAgIEJ1ZmZlci5wcm90b3R5cGUuYmluZC5jYWxsKHRoaXMsIGdsKTtcblxuICAgICAgICB2YXIgc3RyaWRlID0gdGhpcy5pdGVtU2l6ZTtcblxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCBzdHJpZGUsIG9mZnNldCArIDApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX29mZnNldCwgMiwgZ2wuU0hPUlQsIGZhbHNlLCBzdHJpZGUsIG9mZnNldCArIDQpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2RhdGExLCA0LCBnbC5VTlNJR05FRF9CWVRFLCBmYWxzZSwgc3RyaWRlLCBvZmZzZXQgKyA4KTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9kYXRhMiwgMiwgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIHN0cmlkZSwgb2Zmc2V0ICsgMTIpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZUVsZW1lbnRCdWZmZXI7XG5cbmZ1bmN0aW9uIExpbmVFbGVtZW50QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cbkxpbmVFbGVtZW50QnVmZmVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWZmZXIsIHtcbiAgICBpdGVtU2l6ZTogNiwgLy8gYnl0ZXMgcGVyIHRyaWFuZ2xlICgzICogdW5zaWduZWQgc2hvcnQgPT0gNiBieXRlcylcbiAgICBhcnJheVR5cGU6ICdFTEVNRU5UX0FSUkFZX0JVRkZFUicsXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIHBvczIgPSB0aGlzLnBvcyAvIDI7XG5cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDBdID0gYTtcbiAgICAgICAgdGhpcy51c2hvcnRzW3BvczIgKyAxXSA9IGI7XG4gICAgICAgIHRoaXMudXNob3J0c1twb3MyICsgMl0gPSBjO1xuXG4gICAgICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVmVydGV4QnVmZmVyO1xuXG5mdW5jdGlvbiBMaW5lVmVydGV4QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cbi8vIHNjYWxlIHRoZSBleHRydXNpb24gdmVjdG9yIHNvIHRoYXQgdGhlIG5vcm1hbCBsZW5ndGggaXMgdGhpcyB2YWx1ZS5cbi8vIGNvbnRhaW5zIHRoZSBcInRleHR1cmVcIiBub3JtYWxzICgtMS4uMSkuIHRoaXMgaXMgZGlzdGluY3QgZnJvbSB0aGUgZXh0cnVkZVxuLy8gbm9ybWFscyBmb3IgbGluZSBqb2lucywgYmVjYXVzZSB0aGUgeC12YWx1ZSByZW1haW5zIDAgZm9yIHRoZSB0ZXh0dXJlXG4vLyBub3JtYWwgYXJyYXksIHdoaWxlIHRoZSBleHRydWRlIG5vcm1hbCBhY3R1YWxseSBtb3ZlcyB0aGUgdmVydGV4IHRvIGNyZWF0ZVxuLy8gdGhlIGFjdXRlL2JldmVsbGVkIGxpbmUgam9pbi5cbkxpbmVWZXJ0ZXhCdWZmZXIuZXh0cnVkZVNjYWxlID0gNjM7XG5cbkxpbmVWZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEJ1ZmZlciwge1xuICAgIGl0ZW1TaXplOiA4LCAvLyBieXRlcyBwZXIgdmVydGV4ICgyICogc2hvcnQgKyAxICogc2hvcnQgKyAyICogYnl0ZSA9IDggYnl0ZXMpXG4gICAgZGVmYXVsdExlbmd0aDogMzI3NjgsXG5cbiAgICAvLyBhZGQgYSB2ZXJ0ZXggdG8gdGhpcyBidWZmZXI7XG4gICAgLy8geCwgeSAtIHZlcnRleCBwb3NpdGlvblxuICAgIC8vIGV4LCBleSAtIGV4dHJ1ZGUgbm9ybWFsXG4gICAgLy8gdHgsIHR5IC0gdGV4dHVyZSBub3JtYWxcbiAgICBhZGQ6IGZ1bmN0aW9uKHBvaW50LCBleHRydWRlLCB0eCwgdHksIGxpbmVzb2Zhcikge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3MsXG4gICAgICAgICAgICBwb3MyID0gcG9zIC8gMixcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleCxcbiAgICAgICAgICAgIGV4dHJ1ZGVTY2FsZSA9IExpbmVWZXJ0ZXhCdWZmZXIuZXh0cnVkZVNjYWxlO1xuXG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDBdID0gKE1hdGguZmxvb3IocG9pbnQueCkgKiAyKSB8IHR4O1xuICAgICAgICB0aGlzLnNob3J0c1twb3MyICsgMV0gPSAoTWF0aC5mbG9vcihwb2ludC55KSAqIDIpIHwgdHk7XG5cbiAgICAgICAgdGhpcy5ieXRlc1twb3MgKyA0XSA9IE1hdGgucm91bmQoZXh0cnVkZVNjYWxlICogZXh0cnVkZS54KTtcbiAgICAgICAgdGhpcy5ieXRlc1twb3MgKyA1XSA9IE1hdGgucm91bmQoZXh0cnVkZVNjYWxlICogZXh0cnVkZS55KTtcbiAgICAgICAgdGhpcy5ieXRlc1twb3MgKyA2XSA9IChsaW5lc29mYXIgfHwgMCkgLyAxMjg7XG4gICAgICAgIHRoaXMuYnl0ZXNbcG9zICsgN10gPSAobGluZXNvZmFyIHx8IDApICUgMTI4O1xuXG4gICAgICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE91dGxpbmVFbGVtZW50QnVmZmVyO1xuXG5mdW5jdGlvbiBPdXRsaW5lRWxlbWVudEJ1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG5PdXRsaW5lRWxlbWVudEJ1ZmZlci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVmZmVyLCB7XG4gICAgaXRlbVNpemU6IDQsIC8vIGJ5dGVzIHBlciBsaW5lICgyICogdW5zaWduZWQgc2hvcnQgPT0gNCBieXRlcylcbiAgICBhcnJheVR5cGU6ICdFTEVNRU5UX0FSUkFZX0JVRkZFUicsXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgdmFyIHBvczIgPSB0aGlzLnBvcyAvIDI7XG5cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDBdID0gYTtcbiAgICAgICAgdGhpcy51c2hvcnRzW3BvczIgKyAxXSA9IGI7XG5cbiAgICAgICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyaWFuZ2xlRWxlbWVudEJ1ZmZlcjtcblxuZnVuY3Rpb24gVHJpYW5nbGVFbGVtZW50QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cblRyaWFuZ2xlRWxlbWVudEJ1ZmZlci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVmZmVyLCB7XG4gICAgaXRlbVNpemU6IDYsIC8vIGJ5dGVzIHBlciB0cmlhbmdsZSAoMyAqIHVuc2lnbmVkIHNob3J0ID09IDYgYnl0ZXMpXG4gICAgYXJyYXlUeXBlOiAnRUxFTUVOVF9BUlJBWV9CVUZGRVInLFxuXG4gICAgYWRkOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgIHZhciBwb3MyID0gdGhpcy5wb3MgLyAyO1xuXG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgdGhpcy51c2hvcnRzW3BvczIgKyAwXSA9IGE7XG4gICAgICAgIHRoaXMudXNob3J0c1twb3MyICsgMV0gPSBiO1xuICAgICAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDJdID0gYztcblxuICAgICAgICB0aGlzLnBvcyArPSB0aGlzLml0ZW1TaXplO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJ1Y2tldDtcblxudmFyIExpbmVCdWNrZXQgPSByZXF1aXJlKCcuL2xpbmVfYnVja2V0Jyk7XG52YXIgRmlsbEJ1Y2tldCA9IHJlcXVpcmUoJy4vZmlsbF9idWNrZXQnKTtcbnZhciBTeW1ib2xCdWNrZXQgPSByZXF1aXJlKCcuL3N5bWJvbF9idWNrZXQnKTtcbnZhciBMYXlvdXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vc3R5bGUvbGF5b3V0X3Byb3BlcnRpZXMnKTtcbnZhciBmZWF0dXJlRmlsdGVyID0gcmVxdWlyZSgnZmVhdHVyZS1maWx0ZXInKTtcbnZhciBTdHlsZURlY2xhcmF0aW9uU2V0ID0gcmVxdWlyZSgnLi4vc3R5bGUvc3R5bGVfZGVjbGFyYXRpb25fc2V0Jyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1Y2tldChsYXllciwgYnVmZmVycywgeiwgb3ZlcnNjYWxpbmcsIGNvbGxpc2lvbkRlYnVnKSB7XG4gICAgdmFyIHZhbHVlcyA9IG5ldyBTdHlsZURlY2xhcmF0aW9uU2V0KCdsYXlvdXQnLCBsYXllci50eXBlLCBsYXllci5sYXlvdXQsIHt9KS52YWx1ZXMoKSxcbiAgICAgICAgZmFrZVpvb21IaXN0b3J5ID0geyBsYXN0SW50ZWdlclpvb206IEluZmluaXR5LCBsYXN0SW50ZWdlclpvb21UaW1lOiAwLCBsYXN0Wm9vbTogMCB9LFxuICAgICAgICBsYXlvdXQgPSB7fTtcblxuICAgIGZvciAodmFyIGsgaW4gdmFsdWVzKSB7XG4gICAgICAgIGxheW91dFtrXSA9IHZhbHVlc1trXS5jYWxjdWxhdGUoeiwgZmFrZVpvb21IaXN0b3J5KTtcbiAgICB9XG5cbiAgICB2YXIgQnVja2V0Q2xhc3MgPVxuICAgICAgICBsYXllci50eXBlID09PSAnbGluZScgPyBMaW5lQnVja2V0IDpcbiAgICAgICAgbGF5ZXIudHlwZSA9PT0gJ2ZpbGwnID8gRmlsbEJ1Y2tldCA6XG4gICAgICAgIGxheWVyLnR5cGUgPT09ICdzeW1ib2wnID8gU3ltYm9sQnVja2V0IDogbnVsbDtcblxuICAgIHZhciBidWNrZXQgPSBuZXcgQnVja2V0Q2xhc3MoYnVmZmVycywgbmV3IExheW91dFByb3BlcnRpZXNbbGF5ZXIudHlwZV0obGF5b3V0KSwgb3ZlcnNjYWxpbmcsIHosIGNvbGxpc2lvbkRlYnVnKTtcblxuICAgIGJ1Y2tldC5pZCA9IGxheWVyLmlkO1xuICAgIGJ1Y2tldC50eXBlID0gbGF5ZXIudHlwZTtcbiAgICBidWNrZXRbJ3NvdXJjZS1sYXllciddID0gbGF5ZXJbJ3NvdXJjZS1sYXllciddO1xuICAgIGJ1Y2tldC5pbnRlcmFjdGl2ZSA9IGxheWVyLmludGVyYWN0aXZlO1xuICAgIGJ1Y2tldC5taW5ab29tID0gbGF5ZXIubWluem9vbTtcbiAgICBidWNrZXQubWF4Wm9vbSA9IGxheWVyLm1heHpvb207XG4gICAgYnVja2V0LmZpbHRlciA9IGZlYXR1cmVGaWx0ZXIobGF5ZXIuZmlsdGVyKTtcbiAgICBidWNrZXQuZmVhdHVyZXMgPSBbXTtcblxuICAgIHJldHVybiBidWNrZXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudEdyb3VwcztcblxuZnVuY3Rpb24gRWxlbWVudEdyb3Vwcyh2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXIsIHNlY29uZEVsZW1lbnRCdWZmZXIpIHtcblxuICAgIHRoaXMudmVydGV4QnVmZmVyID0gdmVydGV4QnVmZmVyO1xuICAgIHRoaXMuZWxlbWVudEJ1ZmZlciA9IGVsZW1lbnRCdWZmZXI7XG4gICAgdGhpcy5zZWNvbmRFbGVtZW50QnVmZmVyID0gc2Vjb25kRWxlbWVudEJ1ZmZlcjtcbiAgICB0aGlzLmdyb3VwcyA9IFtdO1xufVxuXG5FbGVtZW50R3JvdXBzLnByb3RvdHlwZS5tYWtlUm9vbUZvciA9IGZ1bmN0aW9uKG51bVZlcnRpY2VzKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQgfHwgdGhpcy5jdXJyZW50LnZlcnRleExlbmd0aCArIG51bVZlcnRpY2VzID4gNjU1MzUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IEVsZW1lbnRHcm91cCh0aGlzLnZlcnRleEJ1ZmZlci5pbmRleCxcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRCdWZmZXIgJiYgdGhpcy5lbGVtZW50QnVmZmVyLmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kRWxlbWVudEJ1ZmZlciAmJiB0aGlzLnNlY29uZEVsZW1lbnRCdWZmZXIuaW5kZXgpO1xuICAgICAgICB0aGlzLmdyb3Vwcy5wdXNoKHRoaXMuY3VycmVudCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gRWxlbWVudEdyb3VwKHZlcnRleFN0YXJ0SW5kZXgsIGVsZW1lbnRTdGFydEluZGV4LCBzZWNvbmRFbGVtZW50U3RhcnRJbmRleCkge1xuICAgIC8vIHRoZSBvZmZzZXQgaW50byB0aGUgdmVydGV4IGJ1ZmZlciBvZiB0aGUgZmlyc3QgdmVydGV4IGluIHRoaXMgZ3JvdXBcbiAgICB0aGlzLnZlcnRleFN0YXJ0SW5kZXggPSB2ZXJ0ZXhTdGFydEluZGV4O1xuICAgIHRoaXMuZWxlbWVudFN0YXJ0SW5kZXggPSBlbGVtZW50U3RhcnRJbmRleDtcbiAgICB0aGlzLnNlY29uZEVsZW1lbnRTdGFydEluZGV4ID0gc2Vjb25kRWxlbWVudFN0YXJ0SW5kZXg7XG4gICAgdGhpcy5lbGVtZW50TGVuZ3RoID0gMDtcbiAgICB0aGlzLnZlcnRleExlbmd0aCA9IDA7XG4gICAgdGhpcy5zZWNvbmRFbGVtZW50TGVuZ3RoID0gMDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJidXNoID0gcmVxdWlyZSgncmJ1c2gnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgdnQgPSByZXF1aXJlKCd2ZWN0b3ItdGlsZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGZWF0dXJlVHJlZTtcblxuZnVuY3Rpb24gRmVhdHVyZVRyZWUoY29vcmQsIG92ZXJzY2FsaW5nKSB7XG4gICAgdGhpcy54ID0gY29vcmQueDtcbiAgICB0aGlzLnkgPSBjb29yZC55O1xuICAgIHRoaXMueiA9IGNvb3JkLnogLSBNYXRoLmxvZyhvdmVyc2NhbGluZykgLyBNYXRoLkxOMjtcbiAgICB0aGlzLnJ0cmVlID0gcmJ1c2goOSk7XG4gICAgdGhpcy50b0JlSW5zZXJ0ZWQgPSBbXTtcbn1cblxuRmVhdHVyZVRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGJib3gsIGxheWVycywgZmVhdHVyZSkge1xuICAgIGJib3gubGF5ZXJzID0gbGF5ZXJzO1xuICAgIGJib3guZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgdGhpcy50b0JlSW5zZXJ0ZWQucHVzaChiYm94KTtcbn07XG5cbi8vIGJ1bGsgaW5zZXJ0IGludG8gdHJlZVxuRmVhdHVyZVRyZWUucHJvdG90eXBlLl9sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ydHJlZS5sb2FkKHRoaXMudG9CZUluc2VydGVkKTtcbiAgICB0aGlzLnRvQmVJbnNlcnRlZCA9IFtdO1xufTtcblxuLy8gRmluZHMgZmVhdHVyZXMgaW4gdGhpcyB0aWxlIGF0IGEgcGFydGljdWxhciBwb3NpdGlvbi5cbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMudG9CZUluc2VydGVkLmxlbmd0aCkgdGhpcy5fbG9hZCgpO1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3MucGFyYW1zIHx8IHt9LFxuICAgICAgICByYWRpdXMgPSAocGFyYW1zLnJhZGl1cyB8fCAwKSAqIDQwOTYgLyBhcmdzLnNjYWxlLFxuICAgICAgICB4ID0gYXJncy54LFxuICAgICAgICB5ID0gYXJncy55LFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHZhciBtYXRjaGluZyA9IHRoaXMucnRyZWUuc2VhcmNoKFsgeCAtIHJhZGl1cywgeSAtIHJhZGl1cywgeCArIHJhZGl1cywgeSArIHJhZGl1cyBdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gbWF0Y2hpbmdbaV0uZmVhdHVyZSxcbiAgICAgICAgICAgIGxheWVycyA9IG1hdGNoaW5nW2ldLmxheWVycyxcbiAgICAgICAgICAgIHR5cGUgPSB2dC5WZWN0b3JUaWxlRmVhdHVyZS50eXBlc1tmZWF0dXJlLnR5cGVdO1xuXG4gICAgICAgIGlmIChwYXJhbXMuJHR5cGUgJiYgdHlwZSAhPT0gcGFyYW1zLiR0eXBlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghZ2VvbWV0cnlDb250YWluc1BvaW50KGZlYXR1cmUubG9hZEdlb21ldHJ5KCksIHR5cGUsIG5ldyBQb2ludCh4LCB5KSwgcmFkaXVzKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBnZW9KU09OID0gZmVhdHVyZS50b0dlb0pTT04odGhpcy54LCB0aGlzLnksIHRoaXMueik7XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGF5ZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbbF07XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMubGF5ZXIgJiYgbGF5ZXIgIT09IHBhcmFtcy5sYXllci5pZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgcmVzdWx0LnB1c2godXRpbC5leHRlbmQoe2xheWVyOiBsYXllcn0sIGdlb0pTT04pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG59O1xuXG5mdW5jdGlvbiBnZW9tZXRyeUNvbnRhaW5zUG9pbnQocmluZ3MsIHR5cGUsIHAsIHJhZGl1cykge1xuICAgIHJldHVybiB0eXBlID09PSAnUG9pbnQnID8gcG9pbnRDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpIDpcbiAgICAgICAgICAgdHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gbGluZUNvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cykgOlxuICAgICAgICAgICB0eXBlID09PSAnUG9seWdvbicgPyBwb2x5Q29udGFpbnNQb2ludChyaW5ncywgcCkgfHwgbGluZUNvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cykgOiBmYWxzZTtcbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1MDE3MjUvMzMxMzc5LlxuZnVuY3Rpb24gZGlzdFRvU2VnbWVudFNxdWFyZWQocCwgdiwgdykge1xuICAgIHZhciBsMiA9IHYuZGlzdFNxcih3KTtcbiAgICBpZiAobDIgPT09IDApIHJldHVybiBwLmRpc3RTcXIodik7XG4gICAgdmFyIHQgPSAoKHAueCAtIHYueCkgKiAody54IC0gdi54KSArIChwLnkgLSB2LnkpICogKHcueSAtIHYueSkpIC8gbDI7XG4gICAgaWYgKHQgPCAwKSByZXR1cm4gcC5kaXN0U3FyKHYpO1xuICAgIGlmICh0ID4gMSkgcmV0dXJuIHAuZGlzdFNxcih3KTtcbiAgICByZXR1cm4gcC5kaXN0U3FyKHcuc3ViKHYpLl9tdWx0KHQpLl9hZGQodikpO1xufVxuXG5mdW5jdGlvbiBsaW5lQ29udGFpbnNQb2ludChyaW5ncywgcCwgcmFkaXVzKSB7XG4gICAgdmFyIHIgPSByYWRpdXMgKiByYWRpdXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgLy8gRmluZCBsaW5lIHNlZ21lbnRzIHRoYXQgaGF2ZSBhIGRpc3RhbmNlIDw9IHJhZGl1c14yIHRvIHBcbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgdHJlYXQgdGhlIGxpbmUgYXMgXCJjb250YWluaW5nIHBvaW50IHBcIi5cbiAgICAgICAgICAgIHZhciB2ID0gcmluZ1tqIC0gMV0sIHcgPSByaW5nW2pdO1xuICAgICAgICAgICAgaWYgKGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIDwgcikgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBwb2ludCBpbiBwb2x5Z29uIHJheSBjYXN0aW5nIGFsZ29yaXRobVxuZnVuY3Rpb24gcG9seUNvbnRhaW5zUG9pbnQocmluZ3MsIHApIHtcbiAgICB2YXIgYyA9IGZhbHNlLFxuICAgICAgICByaW5nLCBwMSwgcDI7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHJpbmdzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHJpbmcgPSByaW5nc1trXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSByaW5nLmxlbmd0aCAtIDE7IGkgPCByaW5nLmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICAgICAgcDEgPSByaW5nW2ldO1xuICAgICAgICAgICAgcDIgPSByaW5nW2pdO1xuICAgICAgICAgICAgaWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcbiAgICAgICAgICAgICAgICBjID0gIWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIHBvaW50Q29udGFpbnNQb2ludChyaW5ncywgcCwgcmFkaXVzKSB7XG4gICAgdmFyIHIgPSByYWRpdXMgKiByYWRpdXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHJpbmdbal0uZGlzdFNxcihwKSA8PSByKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFbGVtZW50R3JvdXBzID0gcmVxdWlyZSgnLi9lbGVtZW50X2dyb3VwcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGxCdWNrZXQ7XG5cbmZ1bmN0aW9uIEZpbGxCdWNrZXQoYnVmZmVycykge1xuICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XG4gICAgdGhpcy5lbGVtZW50R3JvdXBzID0gbmV3IEVsZW1lbnRHcm91cHMoYnVmZmVycy5maWxsVmVydGV4LCBidWZmZXJzLmZpbGxFbGVtZW50LCBidWZmZXJzLm91dGxpbmVFbGVtZW50KTtcbn1cblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGZlYXR1cmUubG9hZEdlb21ldHJ5KCkpO1xuICAgIH1cbn07XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbihsaW5lcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRGaWxsKGxpbmVzW2ldKTtcbiAgICB9XG59O1xuXG5GaWxsQnVja2V0LnByb3RvdHlwZS5hZGRGaWxsID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICBpZiAodmVydGljZXMubGVuZ3RoIDwgMykge1xuICAgICAgICAvL2NvbnNvbGUud2FybignYSBmaWxsIG11c3QgaGF2ZSBhdCBsZWFzdCB0aHJlZSB2ZXJ0aWNlcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2YgdmVydGljZXMgd2UncmUgZ29pbmcgdG8gcHJvZHVjZSBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHJlc2l6ZSB0aGUgYnVmZmVyIGJlZm9yZWhhbmQsIG9yIGRldGVjdCB3aGV0aGVyIHRoZSBjdXJyZW50IGxpbmVcbiAgICAvLyB3b24ndCBmaXQgaW50byB0aGUgYnVmZmVyIGFueW1vcmUuXG4gICAgLy8gSW4gb3JkZXIgdG8gYmUgYWJsZSB0byB1c2UgdGhlIHZlcnRleCBidWZmZXIgZm9yIGRyYXdpbmcgdGhlIGFudGlhbGlhc2VkXG4gICAgLy8gb3V0bGluZXMsIHdlIHNlcGFyYXRlIGFsbCBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBkZWdlbmVyYXRlIChvdXQtb2YtXG4gICAgLy8gdmlld3BsYW5lKSB2ZXJ0ZXguXG5cbiAgICB2YXIgbGVuID0gdmVydGljZXMubGVuZ3RoO1xuXG4gICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIGdlb21ldHJ5IGJ1ZmZlciBjYW4gaG9sZCBhbGwgdGhlIHJlcXVpcmVkIHZlcnRpY2VzLlxuICAgIHRoaXMuZWxlbWVudEdyb3Vwcy5tYWtlUm9vbUZvcihsZW4gKyAxKTtcbiAgICB2YXIgZWxlbWVudEdyb3VwID0gdGhpcy5lbGVtZW50R3JvdXBzLmN1cnJlbnQ7XG5cbiAgICB2YXIgZmlsbFZlcnRleCA9IHRoaXMuYnVmZmVycy5maWxsVmVydGV4O1xuICAgIHZhciBmaWxsRWxlbWVudCA9IHRoaXMuYnVmZmVycy5maWxsRWxlbWVudDtcbiAgICB2YXIgb3V0bGluZUVsZW1lbnQgPSB0aGlzLmJ1ZmZlcnMub3V0bGluZUVsZW1lbnQ7XG5cbiAgICAvLyBXZSdyZSBnZW5lcmF0aW5nIHRyaWFuZ2xlIGZhbnMsIHNvIHdlIGFsd2F5cyBzdGFydCB3aXRoIHRoZSBmaXJzdCBjb29yZGluYXRlIGluIHRoaXMgcG9seWdvbi5cbiAgICB2YXIgZmlyc3RJbmRleCA9IGZpbGxWZXJ0ZXguaW5kZXggLSBlbGVtZW50R3JvdXAudmVydGV4U3RhcnRJbmRleCxcbiAgICAgICAgcHJldkluZGV4LCBjdXJyZW50SW5kZXgsIGN1cnJlbnRWZXJ0ZXg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGZpbGxWZXJ0ZXguaW5kZXggLSBlbGVtZW50R3JvdXAudmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgIGZpbGxWZXJ0ZXguYWRkKGN1cnJlbnRWZXJ0ZXgueCwgY3VycmVudFZlcnRleC55KTtcbiAgICAgICAgZWxlbWVudEdyb3VwLnZlcnRleExlbmd0aCsrO1xuXG4gICAgICAgIC8vIE9ubHkgYWRkIHRyaWFuZ2xlcyB0aGF0IGhhdmUgZGlzdGluY3QgdmVydGljZXMuXG4gICAgICAgIGlmIChpID49IDIgJiYgKGN1cnJlbnRWZXJ0ZXgueCAhPT0gdmVydGljZXNbMF0ueCB8fCBjdXJyZW50VmVydGV4LnkgIT09IHZlcnRpY2VzWzBdLnkpKSB7XG4gICAgICAgICAgICBmaWxsRWxlbWVudC5hZGQoZmlyc3RJbmRleCwgcHJldkluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgZWxlbWVudEdyb3VwLmVsZW1lbnRMZW5ndGgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID49IDEpIHtcbiAgICAgICAgICAgIG91dGxpbmVFbGVtZW50LmFkZChwcmV2SW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXAuc2Vjb25kRWxlbWVudExlbmd0aCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkluZGV4ID0gY3VycmVudEluZGV4O1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFbGVtZW50R3JvdXBzID0gcmVxdWlyZSgnLi9lbGVtZW50X2dyb3VwcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVCdWNrZXQ7XG5cbi8qKlxuICogQGNsYXNzIExpbmVCdWNrZXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIExpbmVCdWNrZXQoYnVmZmVycywgbGF5b3V0UHJvcGVydGllcykge1xuICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XG4gICAgdGhpcy5lbGVtZW50R3JvdXBzID0gbmV3IEVsZW1lbnRHcm91cHMoYnVmZmVycy5saW5lVmVydGV4LCBidWZmZXJzLmxpbmVFbGVtZW50KTtcbiAgICB0aGlzLmxheW91dFByb3BlcnRpZXMgPSBsYXlvdXRQcm9wZXJ0aWVzO1xufVxuXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZmVhdHVyZS5sb2FkR2VvbWV0cnkoKSk7XG4gICAgfVxufTtcblxuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgdmFyIGxheW91dFByb3BlcnRpZXMgPSB0aGlzLmxheW91dFByb3BlcnRpZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZExpbmUobGluZXNbaV0sXG4gICAgICAgICAgICBsYXlvdXRQcm9wZXJ0aWVzWydsaW5lLWpvaW4nXSxcbiAgICAgICAgICAgIGxheW91dFByb3BlcnRpZXNbJ2xpbmUtY2FwJ10sXG4gICAgICAgICAgICBsYXlvdXRQcm9wZXJ0aWVzWydsaW5lLW1pdGVyLWxpbWl0J10sXG4gICAgICAgICAgICBsYXlvdXRQcm9wZXJ0aWVzWydsaW5lLXJvdW5kLWxpbWl0J10pO1xuICAgIH1cbn07XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgam9pbiwgY2FwLCBtaXRlckxpbWl0LCByb3VuZExpbWl0KSB7XG5cbiAgICB2YXIgbGVuID0gdmVydGljZXMubGVuZ3RoO1xuICAgIC8vIElmIHRoZSBsaW5lIGhhcyBkdXBsaWNhdGUgdmVydGljZXMgYXQgdGhlIGVuZCwgYWRqdXN0IGxlbmd0aCB0byByZW1vdmUgdGhlbS5cbiAgICB3aGlsZSAobGVuID4gMiAmJiB2ZXJ0aWNlc1tsZW4gLSAxXS5lcXVhbHModmVydGljZXNbbGVuIC0gMl0pKSB7XG4gICAgICAgIGxlbi0tO1xuICAgIH1cblxuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIC8vY29uc29sZS53YXJuKCdhIGxpbmUgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byB2ZXJ0aWNlcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGpvaW4gPT09ICdiZXZlbCcpIG1pdGVyTGltaXQgPSAxLjA1O1xuXG4gICAgdmFyIGZpcnN0VmVydGV4ID0gdmVydGljZXNbMF0sXG4gICAgICAgIGxhc3RWZXJ0ZXggPSB2ZXJ0aWNlc1tsZW4gLSAxXSxcbiAgICAgICAgY2xvc2VkID0gZmlyc3RWZXJ0ZXguZXF1YWxzKGxhc3RWZXJ0ZXgpO1xuXG4gICAgLy8gd2UgY291bGQgYmUgbW9yZSBwcmVjaXNlLCBidXQgaXQgd291bGQgb25seSBzYXZlIGEgbmVnbGlnaWJsZSBhbW91bnQgb2Ygc3BhY2VcbiAgICB0aGlzLmVsZW1lbnRHcm91cHMubWFrZVJvb21Gb3IobGVuICogNCk7XG5cbiAgICBpZiAobGVuID09PSAyICYmIGNsb3NlZCkge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ2EgbGluZSBtYXkgbm90IGhhdmUgY29pbmNpZGVudCBwb2ludHMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiZWdpbkNhcCA9IGNhcCxcbiAgICAgICAgZW5kQ2FwID0gY2xvc2VkID8gJ2J1dHQnIDogY2FwLFxuICAgICAgICBmbGlwID0gMSxcbiAgICAgICAgZGlzdGFuY2UgPSAwLFxuICAgICAgICBzdGFydE9mTGluZSA9IHRydWUsXG4gICAgICAgIGN1cnJlbnRWZXJ0ZXgsIHByZXZWZXJ0ZXgsIG5leHRWZXJ0ZXgsIHByZXZOb3JtYWwsIG5leHROb3JtYWwsIG9mZnNldEEsIG9mZnNldEI7XG5cbiAgICAvLyB0aGUgbGFzdCB0aHJlZSB2ZXJ0aWNlcyBhZGRlZFxuICAgIHRoaXMuZTEgPSB0aGlzLmUyID0gdGhpcy5lMyA9IC0xO1xuXG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbbGVuIC0gMl07XG4gICAgICAgIG5leHROb3JtYWwgPSBmaXJzdFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICBuZXh0VmVydGV4ID0gY2xvc2VkICYmIGkgPT09IGxlbiAtIDEgP1xuICAgICAgICAgICAgdmVydGljZXNbMV0gOiAvLyBpZiB0aGUgbGluZSBpcyBjbG9zZWQsIHdlIHRyZWF0IHRoZSBsYXN0IHZlcnRleCBsaWtlIHRoZSBmaXJzdFxuICAgICAgICAgICAgdmVydGljZXNbaSArIDFdOyAvLyBqdXN0IHRoZSBuZXh0IHZlcnRleFxuXG4gICAgICAgIC8vIGlmIHR3byBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBleGlzdCwgc2tpcCB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgaWYgKG5leHRWZXJ0ZXggJiYgdmVydGljZXNbaV0uZXF1YWxzKG5leHRWZXJ0ZXgpKSBjb250aW51ZTtcblxuICAgICAgICBpZiAobmV4dE5vcm1hbCkgcHJldk5vcm1hbCA9IG5leHROb3JtYWw7XG4gICAgICAgIGlmIChjdXJyZW50VmVydGV4KSBwcmV2VmVydGV4ID0gY3VycmVudFZlcnRleDtcblxuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgYWxvbmcgdGhlIGxpbmUgdGhlIGN1cnJlbnRWZXJ0ZXggaXNcbiAgICAgICAgaWYgKHByZXZWZXJ0ZXgpIGRpc3RhbmNlICs9IGN1cnJlbnRWZXJ0ZXguZGlzdChwcmV2VmVydGV4KTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5vcm1hbCB0b3dhcmRzIHRoZSBuZXh0IHZlcnRleCBpbiB0aGlzIGxpbmUuIEluIGNhc2VcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmV4dCB2ZXJ0ZXgsIHByZXRlbmQgdGhhdCB0aGUgbGluZSBpcyBjb250aW51aW5nIHN0cmFpZ2h0LFxuICAgICAgICAvLyBtZWFuaW5nIHRoYXQgd2UgYXJlIGp1c3QgdXNpbmcgdGhlIHByZXZpb3VzIG5vcm1hbC5cbiAgICAgICAgbmV4dE5vcm1hbCA9IG5leHRWZXJ0ZXggPyBuZXh0VmVydGV4LnN1YihjdXJyZW50VmVydGV4KS5fdW5pdCgpLl9wZXJwKCkgOiBwcmV2Tm9ybWFsO1xuXG4gICAgICAgIC8vIElmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSBwcmV2aW91cyBub3JtYWwsIHRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiBhXG4gICAgICAgIC8vIG5vbi1jbG9zZWQgbGluZSwgc28gd2UncmUgZG9pbmcgYSBzdHJhaWdodCBcImpvaW5cIi5cbiAgICAgICAgcHJldk5vcm1hbCA9IHByZXZOb3JtYWwgfHwgbmV4dE5vcm1hbDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG5vcm1hbCBvZiB0aGUgam9pbiBleHRydXNpb24uIEl0IGlzIHRoZSBhbmdsZSBiaXNlY3RvclxuICAgICAgICAvLyBvZiB0aGUgc2VnbWVudHMgYmV0d2VlbiB0aGUgcHJldmlvdXMgbGluZSBhbmQgdGhlIG5leHQgbGluZS5cbiAgICAgICAgdmFyIGpvaW5Ob3JtYWwgPSBwcmV2Tm9ybWFsLmFkZChuZXh0Tm9ybWFsKS5fdW5pdCgpO1xuXG4gICAgICAgIC8qICBqb2luTm9ybWFsICAgICBwcmV2Tm9ybWFsXG4gICAgICAgICAqICAgICAgICAgICAgIOKGliAgICAgIOKGkVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAuX19fX19fX18uIHByZXZWZXJ0ZXhcbiAgICAgICAgICogICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiBuZXh0Tm9ybWFsICDihpAgIHwgIGN1cnJlbnRWZXJ0ZXhcbiAgICAgICAgICogICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgbmV4dFZlcnRleCAhXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBtaXRlciAodGhlIHJhdGlvIG9mIHRoZSBtaXRlciB0byB0aGUgd2lkdGgpLlxuICAgICAgICAvLyBGaW5kIHRoZSBjb3NpbmUgb2YgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIG5leHQgYW5kIGpvaW4gbm9ybWFsc1xuICAgICAgICAvLyB1c2luZyBkb3QgcHJvZHVjdC4gVGhlIGludmVyc2Ugb2YgdGhhdCBpcyB0aGUgbWl0ZXIgbGVuZ3RoLlxuICAgICAgICB2YXIgY29zSGFsZkFuZ2xlID0gam9pbk5vcm1hbC54ICogbmV4dE5vcm1hbC54ICsgam9pbk5vcm1hbC55ICogbmV4dE5vcm1hbC55O1xuICAgICAgICB2YXIgbWl0ZXJMZW5ndGggPSAxIC8gY29zSGFsZkFuZ2xlO1xuXG4gICAgICAgIC8vIFRoZSBqb2luIGlmIGEgbWlkZGxlIHZlcnRleCwgb3RoZXJ3aXNlIHRoZSBjYXAuXG4gICAgICAgIHZhciBtaWRkbGVWZXJ0ZXggPSBwcmV2VmVydGV4ICYmIG5leHRWZXJ0ZXg7XG4gICAgICAgIHZhciBjdXJyZW50Sm9pbiA9IG1pZGRsZVZlcnRleCA/IGpvaW4gOiBuZXh0VmVydGV4ID8gYmVnaW5DYXAgOiBlbmRDYXA7XG5cbiAgICAgICAgaWYgKG1pZGRsZVZlcnRleCAmJiBjdXJyZW50Sm9pbiA9PT0gJ3JvdW5kJyAmJiBtaXRlckxlbmd0aCA8IHJvdW5kTGltaXQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ21pdGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ21pdGVyJyAmJiBtaXRlckxlbmd0aCA+IG1pdGVyTGltaXQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ2JldmVsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2JldmVsJykge1xuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gZXh0cnVkZSBsZW5ndGggaXMgMTI4IC8gNjMgPSAyIHRpbWVzIHRoZSB3aWR0aCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgLy8gc28gaWYgbWl0ZXJMZW5ndGggPj0gMiB3ZSBuZWVkIHRvIGRyYXcgYSBkaWZmZXJlbnQgdHlwZSBvZiBiZXZlbCB3aGVyZS5cbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA+IDIpIGN1cnJlbnRKb2luID0gJ2ZsaXBiZXZlbCc7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBtaXRlckxlbmd0aCBpcyByZWFsbHkgc21hbGwgYW5kIHRoZSBsaW5lIGJldmVsIHdvdWxkbid0IGJlIHZpc2libGUsXG4gICAgICAgICAgICAvLyBqdXN0IGRyYXcgYSBtaXRlciBqb2luIHRvIHNhdmUgYSB0cmlhbmdsZS5cbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA8IG1pdGVyTGltaXQpIGN1cnJlbnRKb2luID0gJ21pdGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ21pdGVyJykge1xuICAgICAgICAgICAgam9pbk5vcm1hbC5fbXVsdChtaXRlckxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgZmxpcCwgZGlzdGFuY2UsIGpvaW5Ob3JtYWwsIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnZmxpcGJldmVsJykge1xuICAgICAgICAgICAgLy8gbWl0ZXIgaXMgdG9vIGJpZywgZmxpcCB0aGUgZGlyZWN0aW9uIHRvIG1ha2UgYSBiZXZlbGVkIGpvaW5cblxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxtb3N0IHBhcmFsbGVsIGxpbmVzXG4gICAgICAgICAgICAgICAgam9pbk5vcm1hbCA9IG5leHROb3JtYWwuY2xvbmUoKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcHJldk5vcm1hbC54ICogbmV4dE5vcm1hbC55IC0gcHJldk5vcm1hbC55ICogbmV4dE5vcm1hbC54ID4gMCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgYmV2ZWxMZW5ndGggPSBtaXRlckxlbmd0aCAqIHByZXZOb3JtYWwuYWRkKG5leHROb3JtYWwpLm1hZygpIC8gcHJldk5vcm1hbC5zdWIobmV4dE5vcm1hbCkubWFnKCk7XG4gICAgICAgICAgICAgICAgam9pbk5vcm1hbC5fcGVycCgpLl9tdWx0KGJldmVsTGVuZ3RoICogZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCBmbGlwLCBkaXN0YW5jZSwgam9pbk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgZmxpcCA9IC1mbGlwO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdiZXZlbCcpIHtcbiAgICAgICAgICAgIHZhciBkaXIgPSBwcmV2Tm9ybWFsLnggKiBuZXh0Tm9ybWFsLnkgLSBwcmV2Tm9ybWFsLnkgKiBuZXh0Tm9ybWFsLng7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gLU1hdGguc3FydChtaXRlckxlbmd0aCAqIG1pdGVyTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAoZmxpcCAqIGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRCID0gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXRBID0gb2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRBID0gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXRCID0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYSBiZXZlbFxuICAgICAgICAgICAgaWYgKCFzdGFydE9mTGluZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCBmbGlwLCBkaXN0YW5jZSwgcHJldk5vcm1hbCwgb2Zmc2V0QSwgb2Zmc2V0QiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAtb2Zmc2V0QSwgLW9mZnNldEIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnYnV0dCcpIHtcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYSBidXR0XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBwcmV2Tm9ybWFsLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgc2VnbWVudCB3aXRoIGEgYnV0dFxuICAgICAgICAgICAgaWYgKG5leHRWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgZmxpcCwgZGlzdGFuY2UsIG5leHROb3JtYWwsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnc3F1YXJlJykge1xuXG4gICAgICAgICAgICBpZiAoIXN0YXJ0T2ZMaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc2VnbWVudCB3aXRoIGEgc3F1YXJlIGNhcFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCBmbGlwLCBkaXN0YW5jZSwgcHJldk5vcm1hbCwgMSwgMSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlZ21lbnQgaXMgZG9uZS4gVW5zZXQgdmVydGljZXMgdG8gZGlzY29ubmVjdCBzZWdtZW50cy5cbiAgICAgICAgICAgICAgICB0aGlzLmUxID0gdGhpcy5lMiA9IC0xO1xuICAgICAgICAgICAgICAgIGZsaXAgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAtMSwgLTEsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAncm91bmQnKSB7XG5cbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYnV0dFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCBmbGlwLCBkaXN0YW5jZSwgcHJldk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJvdW5kIGNhcCBvciBsaW5lam9pbiBhdCBlbmQgb2Ygc2VnbWVudFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCBmbGlwLCBkaXN0YW5jZSwgcHJldk5vcm1hbCwgMSwgMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VnbWVudCBpcyBkb25lLiBVbnNldCB2ZXJ0aWNlcyB0byBkaXNjb25uZWN0IHNlZ21lbnRzLlxuICAgICAgICAgICAgICAgIHRoaXMuZTEgPSB0aGlzLmUyID0gLTE7XG4gICAgICAgICAgICAgICAgZmxpcCA9IDE7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmVnaW5DYXAgPT09ICdyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgcm91bmQgY2FwIGJlZm9yZSBmaXJzdCBzZWdtZW50XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAtMSwgLTEsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHNlZ21lbnQgd2l0aCBhIGJ1dHRcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mTGluZSA9IGZhbHNlO1xuICAgIH1cblxuXG59O1xuXG4vKipcbiAqIEFkZCB0d28gdmVydGljZXMgdG8gdGhlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRWZXJ0ZXggdGhlIGxpbmUgdmVydGV4IHRvIGFkZCBidWZmZXIgdmVydGljZXMgZm9yXG4gKiBAcGFyYW0ge251bWJlcn0gZmxpcCAtMSBpZiB0aGUgdmVydGljZXMgc2hvdWxkIGJlIGZsaXBwZWQsIDEgb3RoZXJ3aXNlXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGJlZ2dpbmluZyBvZiB0aGUgbGluZSB0byB0aGUgdmVydGV4XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kTGVmdCBleHRydWRlIHRvIHNoaWZ0IHRoZSBsZWZ0IHZlcnRleCBhbG9uZyB0aGUgbGluZVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFJpZ2h0IGV4dHJ1ZGUgdG8gc2hpZnQgdGhlIGxlZnQgdmVydGV4IGFsb25nIHRoZSBsaW5lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJvdW5kIHdoZXRoZXIgdGhpcyBpcyBhIHJvdW5kIGNhcFxuICogQHByaXZhdGVcbiAqL1xuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkQ3VycmVudFZlcnRleCA9IGZ1bmN0aW9uKGN1cnJlbnRWZXJ0ZXgsIGZsaXAsIGRpc3RhbmNlLCBub3JtYWwsIGVuZExlZnQsIGVuZFJpZ2h0LCByb3VuZCkge1xuICAgIHZhciB0eCA9IHJvdW5kID8gMSA6IDA7XG4gICAgdmFyIGV4dHJ1ZGU7XG5cbiAgICB2YXIgbGluZVZlcnRleCA9IHRoaXMuYnVmZmVycy5saW5lVmVydGV4O1xuICAgIHZhciBsaW5lRWxlbWVudCA9IHRoaXMuYnVmZmVycy5saW5lRWxlbWVudDtcbiAgICB2YXIgZWxlbWVudEdyb3VwID0gdGhpcy5lbGVtZW50R3JvdXBzLmN1cnJlbnQ7XG4gICAgdmFyIHZlcnRleFN0YXJ0SW5kZXggPSB0aGlzLmVsZW1lbnRHcm91cHMuY3VycmVudC52ZXJ0ZXhTdGFydEluZGV4O1xuXG4gICAgZXh0cnVkZSA9IG5vcm1hbC5tdWx0KGZsaXApO1xuICAgIGlmIChlbmRMZWZ0KSBleHRydWRlLl9zdWIobm9ybWFsLnBlcnAoKS5fbXVsdChlbmRMZWZ0KSk7XG4gICAgdGhpcy5lMyA9IGxpbmVWZXJ0ZXguYWRkKGN1cnJlbnRWZXJ0ZXgsIGV4dHJ1ZGUsIHR4LCAwLCBkaXN0YW5jZSkgLSB2ZXJ0ZXhTdGFydEluZGV4O1xuICAgIGlmICh0aGlzLmUxID49IDAgJiYgdGhpcy5lMiA+PSAwKSB7XG4gICAgICAgIGxpbmVFbGVtZW50LmFkZCh0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICAgICAgZWxlbWVudEdyb3VwLmVsZW1lbnRMZW5ndGgrKztcbiAgICB9XG4gICAgdGhpcy5lMSA9IHRoaXMuZTI7XG4gICAgdGhpcy5lMiA9IHRoaXMuZTM7XG5cbiAgICBleHRydWRlID0gbm9ybWFsLm11bHQoLWZsaXApO1xuICAgIGlmIChlbmRSaWdodCkgZXh0cnVkZS5fc3ViKG5vcm1hbC5wZXJwKCkuX211bHQoZW5kUmlnaHQpKTtcbiAgICB0aGlzLmUzID0gbGluZVZlcnRleC5hZGQoY3VycmVudFZlcnRleCwgZXh0cnVkZSwgdHgsIDEsIGRpc3RhbmNlKSAtIHZlcnRleFN0YXJ0SW5kZXg7XG4gICAgaWYgKHRoaXMuZTEgPj0gMCAmJiB0aGlzLmUyID49IDApIHtcbiAgICAgICAgbGluZUVsZW1lbnQuYWRkKHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMpO1xuICAgICAgICBlbGVtZW50R3JvdXAuZWxlbWVudExlbmd0aCsrO1xuICAgIH1cbiAgICB0aGlzLmUxID0gdGhpcy5lMjtcbiAgICB0aGlzLmUyID0gdGhpcy5lMztcblxuICAgIGVsZW1lbnRHcm91cC52ZXJ0ZXhMZW5ndGggKz0gMjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFbGVtZW50R3JvdXBzID0gcmVxdWlyZSgnLi9lbGVtZW50X2dyb3VwcycpO1xudmFyIEFuY2hvciA9IHJlcXVpcmUoJy4uL3N5bWJvbC9hbmNob3InKTtcbnZhciBnZXRBbmNob3JzID0gcmVxdWlyZSgnLi4vc3ltYm9sL2dldF9hbmNob3JzJyk7XG52YXIgcmVzb2x2ZVRva2VucyA9IHJlcXVpcmUoJy4uL3V0aWwvdG9rZW4nKTtcbnZhciBRdWFkcyA9IHJlcXVpcmUoJy4uL3N5bWJvbC9xdWFkcycpO1xudmFyIFNoYXBpbmcgPSByZXF1aXJlKCcuLi9zeW1ib2wvc2hhcGluZycpO1xudmFyIHJlc29sdmVUZXh0ID0gcmVxdWlyZSgnLi4vc3ltYm9sL3Jlc29sdmVfdGV4dCcpO1xudmFyIHJlc29sdmVJY29ucyA9IHJlcXVpcmUoJy4uL3N5bWJvbC9yZXNvbHZlX2ljb25zJyk7XG52YXIgbWVyZ2VMaW5lcyA9IHJlcXVpcmUoJy4uL3N5bWJvbC9tZXJnZWxpbmVzJyk7XG52YXIgc2hhcGVUZXh0ID0gU2hhcGluZy5zaGFwZVRleHQ7XG52YXIgc2hhcGVJY29uID0gU2hhcGluZy5zaGFwZUljb247XG52YXIgZ2V0R2x5cGhRdWFkcyA9IFF1YWRzLmdldEdseXBoUXVhZHM7XG52YXIgZ2V0SWNvblF1YWRzID0gUXVhZHMuZ2V0SWNvblF1YWRzO1xudmFyIGNsaXBMaW5lID0gcmVxdWlyZSgnLi4vc3ltYm9sL2NsaXBfbGluZScpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxudmFyIENvbGxpc2lvbkZlYXR1cmUgPSByZXF1aXJlKCcuLi9zeW1ib2wvY29sbGlzaW9uX2ZlYXR1cmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xCdWNrZXQ7XG5cbmZ1bmN0aW9uIFN5bWJvbEJ1Y2tldChidWZmZXJzLCBsYXlvdXRQcm9wZXJ0aWVzLCBvdmVyc2NhbGluZywgem9vbSwgY29sbGlzaW9uRGVidWcpIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xuICAgIHRoaXMubGF5b3V0UHJvcGVydGllcyA9IGxheW91dFByb3BlcnRpZXM7XG4gICAgdGhpcy5vdmVyc2NhbGluZyA9IG92ZXJzY2FsaW5nO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgdGhpcy5jb2xsaXNpb25EZWJ1ZyA9IGNvbGxpc2lvbkRlYnVnO1xuXG4gICAgdmFyIHRpbGVTaXplID0gNTEyICogb3ZlcnNjYWxpbmc7XG4gICAgdmFyIHRpbGVFeHRlbnQgPSA0MDk2O1xuICAgIHRoaXMudGlsZVBpeGVsUmF0aW8gPSB0aWxlRXh0ZW50IC8gdGlsZVNpemU7XG5cbiAgICB0aGlzLnN5bWJvbEluc3RhbmNlcyA9IFtdO1xuXG59XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUubmVlZHNQbGFjZW1lbnQgPSB0cnVlO1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSkge1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dFByb3BlcnRpZXM7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICB2YXIgdGV4dEZlYXR1cmVzID0gdGhpcy50ZXh0RmVhdHVyZXM7XG5cbiAgICB2YXIgaG9yaXpvbnRhbEFsaWduID0gMC41LFxuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gMC41O1xuXG4gICAgc3dpdGNoIChsYXlvdXRbJ3RleHQtYW5jaG9yJ10pIHtcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICAgICAgaG9yaXpvbnRhbEFsaWduID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgICAgICBob3Jpem9udGFsQWxpZ24gPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3dpdGNoIChsYXlvdXRbJ3RleHQtYW5jaG9yJ10pIHtcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICAgICAgdmVydGljYWxBbGlnbiA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICAgICAgdmVydGljYWxBbGlnbiA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIganVzdGlmeSA9IGxheW91dFsndGV4dC1qdXN0aWZ5J10gPT09ICdyaWdodCcgPyAxIDpcbiAgICAgICAgbGF5b3V0Wyd0ZXh0LWp1c3RpZnknXSA9PT0gJ2xlZnQnID8gMCA6XG4gICAgICAgIDAuNTtcblxuICAgIHZhciBvbmVFbSA9IDI0O1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gbGF5b3V0Wyd0ZXh0LWxpbmUtaGVpZ2h0J10gKiBvbmVFbTtcbiAgICB2YXIgbWF4V2lkdGggPSBsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSAhPT0gJ2xpbmUnID8gbGF5b3V0Wyd0ZXh0LW1heC13aWR0aCddICogb25lRW0gOiAwO1xuICAgIHZhciBzcGFjaW5nID0gbGF5b3V0Wyd0ZXh0LWxldHRlci1zcGFjaW5nJ10gKiBvbmVFbTtcbiAgICB2YXIgdGV4dE9mZnNldCA9IFtsYXlvdXRbJ3RleHQtb2Zmc2V0J11bMF0gKiBvbmVFbSwgbGF5b3V0Wyd0ZXh0LW9mZnNldCddWzFdICogb25lRW1dO1xuICAgIHZhciBmb250c3RhY2sgPSBsYXlvdXRbJ3RleHQtZm9udCddO1xuXG4gICAgdmFyIGdlb21ldHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBnID0gMDsgZyA8IGZlYXR1cmVzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgIGdlb21ldHJpZXMucHVzaChmZWF0dXJlc1tnXS5sb2FkR2VvbWV0cnkoKSk7XG4gICAgfVxuXG4gICAgaWYgKGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScpIHtcbiAgICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgbGluZXMgd2l0aCB0aGUgc2FtZSB0ZXh0IHRvIGltcHJvdmUgbGFiZWxsaW5nLlxuICAgICAgICAvLyBJdCdzIGJldHRlciB0byBwbGFjZSBsYWJlbHMgb24gb25lIGxvbmcgbGluZSB0aGFuIG9uIG1hbnkgc2hvcnQgc2VnbWVudHMuXG4gICAgICAgIHZhciBtZXJnZWQgPSBtZXJnZUxpbmVzKGZlYXR1cmVzLCB0ZXh0RmVhdHVyZXMsIGdlb21ldHJpZXMpO1xuXG4gICAgICAgIGdlb21ldHJpZXMgPSBtZXJnZWQuZ2VvbWV0cmllcztcbiAgICAgICAgZmVhdHVyZXMgPSBtZXJnZWQuZmVhdHVyZXM7XG4gICAgICAgIHRleHRGZWF0dXJlcyA9IG1lcmdlZC50ZXh0RmVhdHVyZXM7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlZFRleHQsIHNoYXBlZEljb247XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGZlYXR1cmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGlmICghZ2VvbWV0cmllc1trXSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKHRleHRGZWF0dXJlc1trXSkge1xuICAgICAgICAgICAgc2hhcGVkVGV4dCA9IHNoYXBlVGV4dCh0ZXh0RmVhdHVyZXNba10sIHRoaXMuc3RhY2tzW2ZvbnRzdGFja10sIG1heFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHNwYWNpbmcsIHRleHRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGVkVGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5b3V0WydpY29uLWltYWdlJ10pIHtcbiAgICAgICAgICAgIHZhciBpY29uTmFtZSA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNba10ucHJvcGVydGllcywgbGF5b3V0WydpY29uLWltYWdlJ10pO1xuICAgICAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pY29uc1tpY29uTmFtZV07XG4gICAgICAgICAgICBzaGFwZWRJY29uID0gc2hhcGVJY29uKGltYWdlLCBsYXlvdXQpO1xuXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZGZJY29ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2RmSWNvbnMgPSBpbWFnZS5zZGY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNkZkljb25zICE9PSBpbWFnZS5zZGYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdTdHlsZSBzaGVldCB3YXJuaW5nOiBDYW5ub3QgbWl4IFNERiBhbmQgbm9uLVNERiBpY29ucyBpbiBvbmUgYnVja2V0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGVkSWNvbiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGVkVGV4dCB8fCBzaGFwZWRJY29uKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZ2VvbWV0cmllc1trXSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBsYWNlRmVhdHVyZXMoY29sbGlzaW9uVGlsZSwgdGhpcy5idWZmZXJzLCB0aGlzLmNvbGxpc2lvbkRlYnVnKTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uKSB7XG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0UHJvcGVydGllcztcblxuICAgIHZhciBnbHlwaFNpemUgPSAyNDtcblxuICAgIHZhciBmb250U2NhbGUgPSBsYXlvdXRbJ3RleHQtbWF4LXNpemUnXSAvIGdseXBoU2l6ZSxcbiAgICAgICAgdGV4dEJveFNjYWxlID0gdGhpcy50aWxlUGl4ZWxSYXRpbyAqIGZvbnRTY2FsZSxcbiAgICAgICAgaWNvbkJveFNjYWxlID0gdGhpcy50aWxlUGl4ZWxSYXRpbyAqIGxheW91dFsnaWNvbi1tYXgtc2l6ZSddLFxuICAgICAgICBzeW1ib2xNaW5EaXN0YW5jZSA9IHRoaXMudGlsZVBpeGVsUmF0aW8gKiBsYXlvdXRbJ3N5bWJvbC1taW4tZGlzdGFuY2UnXSxcbiAgICAgICAgYXZvaWRFZGdlcyA9IGxheW91dFsnc3ltYm9sLWF2b2lkLWVkZ2VzJ10sXG4gICAgICAgIHRleHRQYWRkaW5nID0gbGF5b3V0Wyd0ZXh0LXBhZGRpbmcnXSAqIHRoaXMudGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIGljb25QYWRkaW5nID0gbGF5b3V0WydpY29uLXBhZGRpbmcnXSAqIHRoaXMudGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIHRleHRNYXhBbmdsZSA9IGxheW91dFsndGV4dC1tYXgtYW5nbGUnXSAvIDE4MCAqIE1hdGguUEksXG4gICAgICAgIHRleHRBbG9uZ0xpbmUgPSBsYXlvdXRbJ3RleHQtcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScsXG4gICAgICAgIGljb25BbG9uZ0xpbmUgPSBsYXlvdXRbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScsXG4gICAgICAgIG1heU92ZXJsYXAgPSBsYXlvdXRbJ3RleHQtYWxsb3ctb3ZlcmxhcCddIHx8IGxheW91dFsnaWNvbi1hbGxvdy1vdmVybGFwJ10gfHxcbiAgICAgICAgICAgIGxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10gfHwgbGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXTtcblxuICAgIGlmIChsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgIGxpbmVzID0gY2xpcExpbmUobGluZXMsIDAsIDAsIDQwOTYsIDQwOTYpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGFuY2hvciBwb2ludHMgYXJvdW5kIHdoaWNoIHlvdSB3YW50IHRvIHBsYWNlIGxhYmVsc1xuICAgICAgICB2YXIgYW5jaG9ycyA9IGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScgP1xuICAgICAgICAgICAgZ2V0QW5jaG9ycyhsaW5lLCBzeW1ib2xNaW5EaXN0YW5jZSwgdGV4dE1heEFuZ2xlLCBzaGFwZWRUZXh0LCBnbHlwaFNpemUsIHRleHRCb3hTY2FsZSwgdGhpcy5vdmVyc2NhbGluZykgOlxuICAgICAgICAgICAgWyBuZXcgQW5jaG9yKGxpbmVbMF0ueCwgbGluZVswXS55LCAwKSBdO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHBvdGVudGlhbCBsYWJlbCwgY3JlYXRlIHRoZSBwbGFjZW1lbnQgZmVhdHVyZXMgdXNlZCB0byBjaGVjayBmb3IgY29sbGlzaW9ucywgYW5kIHRoZSBxdWFkcyB1c2UgZm9yIHJlbmRlcmluZy5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGFuY2hvcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBhbmNob3JzW2pdO1xuXG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gIShhbmNob3IueCA8IDAgfHwgYW5jaG9yLnggPiA0MDk2IHx8IGFuY2hvci55IDwgMCB8fCBhbmNob3IueSA+IDQwOTYpO1xuXG4gICAgICAgICAgICBpZiAoYXZvaWRFZGdlcyAmJiAhaW5zaWRlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsbHkgc3ltYm9sIGxheWVycyBhcmUgZHJhd24gYWNyb3NzIHRpbGUgYm91bmRhcmllcy4gT25seSBzeW1ib2xzXG4gICAgICAgICAgICAvLyB3aXRoIHRoZWlyIGFuY2hvcnMgd2l0aGluIHRoZSB0aWxlIGJvdW5kYXJpZXMgYXJlIGFkZGVkIHRvIHRoZSBidWZmZXJzXG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IHN5bWJvbHMgZnJvbSBiZWluZyBkcmF3biB0d2ljZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTeW1ib2xzIGluIGxheWVycyB3aXRoIG92ZXJsYXAgYXJlIHNvcnRlZCBpbiB0aGUgeSBkaXJlY3Rpb24gc28gdGhhdFxuICAgICAgICAgICAgLy8gc3ltYm9scyBsb3dlciBvbiB0aGUgY2FudmFzIGFyZSBkcmF3biBvbiB0b3Agb2Ygc3ltYm9scyBuZWFyIHRoZSB0b3AuXG4gICAgICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGlzIG9yZGVyIGFjcm9zcyB0aWxlIGJvdW5kYXJpZXMgdGhlc2Ugc3ltYm9scyBjYW4ndFxuICAgICAgICAgICAgLy8gYmUgZHJhd24gYWNyb3NzIHRpbGUgYm91bmRhcmllcy4gSW5zdGVhZCB0aGV5IG5lZWQgdG8gYmUgaW5jbHVkZWQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBidWZmZXJzIGZvciBib3RoIHRpbGVzIGFuZCBjbGlwcGVkIHRvIHRpbGUgYm91bmRhcmllcyBhdCBkcmF3IHRpbWUuXG4gICAgICAgICAgICB2YXIgYWRkVG9CdWZmZXJzID0gaW5zaWRlIHx8IG1heU92ZXJsYXA7XG5cbiAgICAgICAgICAgIHRoaXMuc3ltYm9sSW5zdGFuY2VzLnB1c2gobmV3IFN5bWJvbEluc3RhbmNlKGFuY2hvciwgbGluZSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbiwgbGF5b3V0LCBhZGRUb0J1ZmZlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Qm94U2NhbGUsIHRleHRQYWRkaW5nLCB0ZXh0QWxvbmdMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbkJveFNjYWxlLCBpY29uUGFkZGluZywgaWNvbkFsb25nTGluZSkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5wbGFjZUZlYXR1cmVzID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSwgYnVmZmVycywgY29sbGlzaW9uRGVidWcpIHtcblxuICAgIC8vIENhbGN1bGF0ZSB3aGljaCBsYWJlbHMgY2FuIGJlIHNob3duIGFuZCB3aGVuIHRoZXkgY2FuIGJlIHNob3duIGFuZFxuICAgIC8vIGNyZWF0ZSB0aGUgYnVmZXJzIHVzZWQgZm9yIHJlbmRlcmluZy5cblxuICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XG5cbiAgICB2YXIgZWxlbWVudEdyb3VwcyA9IHRoaXMuZWxlbWVudEdyb3VwcyA9IHtcbiAgICAgICAgdGV4dDogbmV3IEVsZW1lbnRHcm91cHMoYnVmZmVycy5nbHlwaFZlcnRleCwgYnVmZmVycy5nbHlwaEVsZW1lbnQpLFxuICAgICAgICBpY29uOiBuZXcgRWxlbWVudEdyb3VwcyhidWZmZXJzLmljb25WZXJ0ZXgsIGJ1ZmZlcnMuaWNvbkVsZW1lbnQpLFxuICAgICAgICBzZGZJY29uczogdGhpcy5zZGZJY29uc1xuICAgIH07XG5cbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXRQcm9wZXJ0aWVzO1xuICAgIHZhciBtYXhTY2FsZSA9IGNvbGxpc2lvblRpbGUubWF4U2NhbGU7XG5cbiAgICB2YXIgdGV4dEFsb25nTGluZSA9IGxheW91dFsndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCcgJiYgbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJztcbiAgICB2YXIgaWNvbkFsb25nTGluZSA9IGxheW91dFsnaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCcgJiYgbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJztcblxuICAgIHZhciBtYXlPdmVybGFwID0gbGF5b3V0Wyd0ZXh0LWFsbG93LW92ZXJsYXAnXSB8fCBsYXlvdXRbJ2ljb24tYWxsb3ctb3ZlcmxhcCddIHx8XG4gICAgICAgIGxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10gfHwgbGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXTtcblxuICAgIC8vIFNvcnQgc3ltYm9scyBieSB0aGVpciB5IHBvc2l0aW9uIG9uIHRoZSBjYW52YXMgc28gdGhhdCB0aGV5IGxvd2VyIHN5bWJvbHNcbiAgICAvLyBhcmUgZHJhd24gb24gdG9wIG9mIGhpZ2hlciBzeW1ib2xzLlxuICAgIC8vIERvbid0IHNvcnQgc3ltYm9scyB0aGF0IHdvbid0IG92ZXJsYXAgYmVjYXVzZSBpdCBpc24ndCBuZWNlc3NhcnkgYW5kXG4gICAgLy8gYmVjYXVzZSBpdCBjYXVzZXMgbW9yZSBsYWJlbHMgdG8gcG9wIGluIGFuZCBvdXQgd2hlbiByb3RhdGluZy5cbiAgICBpZiAobWF5T3ZlcmxhcCkge1xuICAgICAgICB2YXIgYW5nbGUgPSBjb2xsaXNpb25UaWxlLmFuZ2xlO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXG4gICAgICAgIHRoaXMuc3ltYm9sSW5zdGFuY2VzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgdmFyIGFSb3RhdGVkID0gc2luICogYS54ICsgY29zICogYS55O1xuICAgICAgICAgICAgdmFyIGJSb3RhdGVkID0gc2luICogYi54ICsgY29zICogYi55O1xuICAgICAgICAgICAgcmV0dXJuIGJSb3RhdGVkIC0gYVJvdGF0ZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgPSAwOyBwIDwgdGhpcy5zeW1ib2xJbnN0YW5jZXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgdmFyIHN5bWJvbEluc3RhbmNlID0gdGhpcy5zeW1ib2xJbnN0YW5jZXNbcF07XG4gICAgICAgIHZhciBoYXNUZXh0ID0gc3ltYm9sSW5zdGFuY2UuaGFzVGV4dDtcbiAgICAgICAgdmFyIGhhc0ljb24gPSBzeW1ib2xJbnN0YW5jZS5oYXNJY29uO1xuXG4gICAgICAgIHZhciBpY29uV2l0aG91dFRleHQgPSBsYXlvdXRbJ3RleHQtb3B0aW9uYWwnXSB8fCAhaGFzVGV4dCxcbiAgICAgICAgICAgIHRleHRXaXRob3V0SWNvbiA9IGxheW91dFsnaWNvbi1vcHRpb25hbCddIHx8ICFoYXNJY29uO1xuXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzY2FsZXMgYXQgd2hpY2ggdGhlIHRleHQgYW5kIGljb24gY2FuIGJlIHBsYWNlZCB3aXRob3V0IGNvbGxpc2lvbi5cblxuICAgICAgICB2YXIgZ2x5cGhTY2FsZSA9IGhhc1RleHQgJiYgIWxheW91dFsndGV4dC1hbGxvdy1vdmVybGFwJ10gP1xuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5wbGFjZUNvbGxpc2lvbkZlYXR1cmUoc3ltYm9sSW5zdGFuY2UudGV4dENvbGxpc2lvbkZlYXR1cmUpIDpcbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGUubWluU2NhbGU7XG5cbiAgICAgICAgdmFyIGljb25TY2FsZSA9IGhhc0ljb24gJiYgIWxheW91dFsnaWNvbi1hbGxvdy1vdmVybGFwJ10gP1xuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5wbGFjZUNvbGxpc2lvbkZlYXR1cmUoc3ltYm9sSW5zdGFuY2UuaWNvbkNvbGxpc2lvbkZlYXR1cmUpIDpcbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGUubWluU2NhbGU7XG5cblxuICAgICAgICAvLyBDb21iaW5lIHRoZSBzY2FsZXMgZm9yIGljb25zIGFuZCB0ZXh0LlxuXG4gICAgICAgIGlmICghaWNvbldpdGhvdXRUZXh0ICYmICF0ZXh0V2l0aG91dEljb24pIHtcbiAgICAgICAgICAgIGljb25TY2FsZSA9IGdseXBoU2NhbGUgPSBNYXRoLm1heChpY29uU2NhbGUsIGdseXBoU2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0ZXh0V2l0aG91dEljb24gJiYgZ2x5cGhTY2FsZSkge1xuICAgICAgICAgICAgZ2x5cGhTY2FsZSA9IE1hdGgubWF4KGljb25TY2FsZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWljb25XaXRob3V0VGV4dCAmJiBpY29uU2NhbGUpIHtcbiAgICAgICAgICAgIGljb25TY2FsZSA9IE1hdGgubWF4KGljb25TY2FsZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEluc2VydCBmaW5hbCBwbGFjZW1lbnQgaW50byBjb2xsaXNpb24gdHJlZSBhbmQgYWRkIGdseXBocy9pY29ucyB0byBidWZmZXJzXG5cbiAgICAgICAgaWYgKGhhc1RleHQpIHtcbiAgICAgICAgICAgIGlmICghbGF5b3V0Wyd0ZXh0LWlnbm9yZS1wbGFjZW1lbnQnXSkge1xuICAgICAgICAgICAgICAgIGNvbGxpc2lvblRpbGUuaW5zZXJ0Q29sbGlzaW9uRmVhdHVyZShzeW1ib2xJbnN0YW5jZS50ZXh0Q29sbGlzaW9uRmVhdHVyZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2x5cGhTY2FsZSA8PSBtYXhTY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3ltYm9scyhidWZmZXJzLmdseXBoVmVydGV4LCBidWZmZXJzLmdseXBoRWxlbWVudCwgZWxlbWVudEdyb3Vwcy50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sSW5zdGFuY2UuZ2x5cGhRdWFkcywgZ2x5cGhTY2FsZSwgbGF5b3V0Wyd0ZXh0LWtlZXAtdXByaWdodCddLCB0ZXh0QWxvbmdMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5hbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzSWNvbikge1xuICAgICAgICAgICAgaWYgKCFsYXlvdXRbJ2ljb24taWdub3JlLXBsYWNlbWVudCddKSB7XG4gICAgICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5pbnNlcnRDb2xsaXNpb25GZWF0dXJlKHN5bWJvbEluc3RhbmNlLmljb25Db2xsaXNpb25GZWF0dXJlLCBpY29uU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGljb25TY2FsZSA8PSBtYXhTY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3ltYm9scyhidWZmZXJzLmljb25WZXJ0ZXgsIGJ1ZmZlcnMuaWNvbkVsZW1lbnQsIGVsZW1lbnRHcm91cHMuaWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbEluc3RhbmNlLmljb25RdWFkcywgaWNvblNjYWxlLCBsYXlvdXRbJ2ljb24ta2VlcC11cHJpZ2h0J10sIGljb25BbG9uZ0xpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25UaWxlLmFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKGNvbGxpc2lvbkRlYnVnKSB0aGlzLmFkZFRvRGVidWdCdWZmZXJzKGNvbGxpc2lvblRpbGUpO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRTeW1ib2xzID0gZnVuY3Rpb24odmVydGV4LCBlbGVtZW50LCBlbGVtZW50R3JvdXBzLCBxdWFkcywgc2NhbGUsIGtlZXBVcHJpZ2h0LCBhbG9uZ0xpbmUsIHBsYWNlbWVudEFuZ2xlKSB7XG5cbiAgICBlbGVtZW50R3JvdXBzLm1ha2VSb29tRm9yKDQgKiBxdWFkcy5sZW5ndGgpO1xuICAgIHZhciBlbGVtZW50R3JvdXAgPSBlbGVtZW50R3JvdXBzLmN1cnJlbnQ7XG5cbiAgICB2YXIgem9vbSA9IHRoaXMuem9vbTtcbiAgICB2YXIgcGxhY2VtZW50Wm9vbSA9IE1hdGgubWF4KE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yICsgem9vbSwgMCk7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHF1YWRzLmxlbmd0aDsgaysrKSB7XG5cbiAgICAgICAgdmFyIHN5bWJvbCA9IHF1YWRzW2tdLFxuICAgICAgICAgICAgYW5nbGUgPSBzeW1ib2wuYW5nbGU7XG5cbiAgICAgICAgLy8gZHJvcCB1cHNpZGUgZG93biB2ZXJzaW9ucyBvZiBnbHlwaHNcbiAgICAgICAgdmFyIGEgPSAoYW5nbGUgKyBwbGFjZW1lbnRBbmdsZSArIE1hdGguUEkpICUgKE1hdGguUEkgKiAyKTtcbiAgICAgICAgaWYgKGtlZXBVcHJpZ2h0ICYmIGFsb25nTGluZSAmJiAoYSA8PSBNYXRoLlBJIC8gMiB8fCBhID4gTWF0aC5QSSAqIDMgLyAyKSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIHRsID0gc3ltYm9sLnRsLFxuICAgICAgICAgICAgdHIgPSBzeW1ib2wudHIsXG4gICAgICAgICAgICBibCA9IHN5bWJvbC5ibCxcbiAgICAgICAgICAgIGJyID0gc3ltYm9sLmJyLFxuICAgICAgICAgICAgdGV4ID0gc3ltYm9sLnRleCxcbiAgICAgICAgICAgIGFuY2hvclBvaW50ID0gc3ltYm9sLmFuY2hvclBvaW50LFxuXG4gICAgICAgICAgICBtaW5ab29tID0gTWF0aC5tYXgoem9vbSArIE1hdGgubG9nKHN5bWJvbC5taW5TY2FsZSkgLyBNYXRoLkxOMiwgcGxhY2VtZW50Wm9vbSksXG4gICAgICAgICAgICBtYXhab29tID0gTWF0aC5taW4oem9vbSArIE1hdGgubG9nKHN5bWJvbC5tYXhTY2FsZSkgLyBNYXRoLkxOMiwgMjUpO1xuXG4gICAgICAgIGlmIChtYXhab29tIDw9IG1pblpvb20pIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIExvd2VyIG1pbiB6b29tIHNvIHRoYXQgd2hpbGUgZmFkaW5nIG91dCB0aGUgbGFiZWwgaXQgY2FuIGJlIHNob3duIG91dHNpZGUgb2YgY29sbGlzaW9uLWZyZWUgem9vbSBsZXZlbHNcbiAgICAgICAgaWYgKG1pblpvb20gPT09IHBsYWNlbWVudFpvb20pIG1pblpvb20gPSAwO1xuXG4gICAgICAgIHZhciB0cmlhbmdsZUluZGV4ID0gdmVydGV4LmluZGV4IC0gZWxlbWVudEdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG5cbiAgICAgICAgdmVydGV4LmFkZChhbmNob3JQb2ludC54LCBhbmNob3JQb2ludC55LCB0bC54LCB0bC55LCB0ZXgueCwgdGV4LnksIG1pblpvb20sIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICB2ZXJ0ZXguYWRkKGFuY2hvclBvaW50LngsIGFuY2hvclBvaW50LnksIHRyLngsIHRyLnksIHRleC54ICsgdGV4LncsIHRleC55LCBtaW5ab29tLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgdmVydGV4LmFkZChhbmNob3JQb2ludC54LCBhbmNob3JQb2ludC55LCBibC54LCBibC55LCB0ZXgueCwgdGV4LnkgKyB0ZXguaCwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgIHZlcnRleC5hZGQoYW5jaG9yUG9pbnQueCwgYW5jaG9yUG9pbnQueSwgYnIueCwgYnIueSwgdGV4LnggKyB0ZXgudywgdGV4LnkgKyB0ZXguaCwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgIGVsZW1lbnRHcm91cC52ZXJ0ZXhMZW5ndGggKz0gNDtcblxuICAgICAgICBlbGVtZW50LmFkZCh0cmlhbmdsZUluZGV4LCB0cmlhbmdsZUluZGV4ICsgMSwgdHJpYW5nbGVJbmRleCArIDIpO1xuICAgICAgICBlbGVtZW50LmFkZCh0cmlhbmdsZUluZGV4ICsgMSwgdHJpYW5nbGVJbmRleCArIDIsIHRyaWFuZ2xlSW5kZXggKyAzKTtcbiAgICAgICAgZWxlbWVudEdyb3VwLmVsZW1lbnRMZW5ndGggKz0gMjtcbiAgICB9XG5cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuZ2V0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24odGlsZSwgYWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpcnN0ZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuZ2V0VGV4dERlcGVuZGVuY2llcyh0aWxlLCBhY3RvciwgZG9uZSk7XG4gICAgdGhpcy5nZXRJY29uRGVwZW5kZW5jaWVzKHRpbGUsIGFjdG9yLCBkb25lKTtcbiAgICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICBpZiAoZXJyIHx8IGZpcnN0ZG9uZSkgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIGZpcnN0ZG9uZSA9IHRydWU7XG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5nZXRJY29uRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24odGlsZSwgYWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0UHJvcGVydGllc1snaWNvbi1pbWFnZSddKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgICAgIHZhciBpY29ucyA9IHJlc29sdmVJY29ucyhmZWF0dXJlcywgdGhpcy5sYXlvdXRQcm9wZXJ0aWVzKTtcblxuICAgICAgICBpZiAoaWNvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhY3Rvci5zZW5kKCdnZXQgaWNvbnMnLCB7IGljb25zOiBpY29ucyB9LCBzZXRJY29ucy5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEljb25zKGVyciwgbmV3aWNvbnMpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHRoaXMuaWNvbnMgPSBuZXdpY29ucztcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmdldFRleHREZXBlbmRlbmNpZXMgPSBmdW5jdGlvbih0aWxlLCBhY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuICAgIHZhciBmb250c3RhY2sgPSB0aGlzLmxheW91dFByb3BlcnRpZXNbJ3RleHQtZm9udCddO1xuXG4gICAgdmFyIHN0YWNrcyA9IHRoaXMuc3RhY2tzID0gdGlsZS5zdGFja3M7XG4gICAgaWYgKHN0YWNrc1tmb250c3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhY2tzW2ZvbnRzdGFja10gPSB7fTtcbiAgICB9XG4gICAgdmFyIHN0YWNrID0gc3RhY2tzW2ZvbnRzdGFja107XG5cbiAgICB2YXIgZGF0YSA9IHJlc29sdmVUZXh0KGZlYXR1cmVzLCB0aGlzLmxheW91dFByb3BlcnRpZXMsIHN0YWNrKTtcbiAgICB0aGlzLnRleHRGZWF0dXJlcyA9IGRhdGEudGV4dEZlYXR1cmVzO1xuXG4gICAgYWN0b3Iuc2VuZCgnZ2V0IGdseXBocycsIHtcbiAgICAgICAgdWlkOiB0aWxlLnVpZCxcbiAgICAgICAgZm9udHN0YWNrOiBmb250c3RhY2ssXG4gICAgICAgIGNvZGVwb2ludHM6IGRhdGEuY29kZXBvaW50c1xuICAgIH0sIGZ1bmN0aW9uKGVyciwgbmV3c3RhY2spIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cbiAgICAgICAgZm9yICh2YXIgY29kZXBvaW50IGluIG5ld3N0YWNrKSB7XG4gICAgICAgICAgICBzdGFja1tjb2RlcG9pbnRdID0gbmV3c3RhY2tbY29kZXBvaW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZFRvRGVidWdCdWZmZXJzID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSkge1xuXG4gICAgdGhpcy5lbGVtZW50R3JvdXBzLmNvbGxpc2lvbkJveCA9IG5ldyBFbGVtZW50R3JvdXBzKHRoaXMuYnVmZmVycy5jb2xsaXNpb25Cb3hWZXJ0ZXgpO1xuICAgIHRoaXMuZWxlbWVudEdyb3Vwcy5jb2xsaXNpb25Cb3gubWFrZVJvb21Gb3IoMCk7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVycy5jb2xsaXNpb25Cb3hWZXJ0ZXg7XG4gICAgdmFyIGFuZ2xlID0gLWNvbGxpc2lvblRpbGUuYW5nbGU7XG4gICAgdmFyIHlTdHJldGNoID0gY29sbGlzaW9uVGlsZS55U3RyZXRjaDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5zeW1ib2xJbnN0YW5jZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gdGhpcy5zeW1ib2xJbnN0YW5jZXNbal1baSA9PT0gMCA/ICd0ZXh0Q29sbGlzaW9uRmVhdHVyZScgOiAnaWNvbkNvbGxpc2lvbkZlYXR1cmUnXTtcbiAgICAgICAgICAgIGlmICghZmVhdHVyZSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgYm94ZXMgPSBmZWF0dXJlLmJveGVzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJveGVzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJveCA9IGJveGVzW2JdO1xuICAgICAgICAgICAgICAgIHZhciBhbmNob3JQb2ludCA9IGJveC5hbmNob3JQb2ludDtcblxuICAgICAgICAgICAgICAgIHZhciB0bCA9IG5ldyBQb2ludChib3gueDEsIGJveC55MSAqIHlTdHJldGNoKS5fcm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgUG9pbnQoYm94LngyLCBib3gueTEgKiB5U3RyZXRjaCkuX3JvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJsID0gbmV3IFBvaW50KGJveC54MSwgYm94LnkyICogeVN0cmV0Y2gpLl9yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZhciBiciA9IG5ldyBQb2ludChib3gueDIsIGJveC55MiAqIHlTdHJldGNoKS5fcm90YXRlKGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXhab29tID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjUsIHRoaXMuem9vbSArIE1hdGgubG9nKGJveC5tYXhTY2FsZSkgLyBNYXRoLkxOMikpO1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnRab29tID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjUsIHRoaXMuem9vbSArIE1hdGgubG9nKGJveC5wbGFjZW1lbnRTY2FsZSkgLyBNYXRoLkxOMikpO1xuXG4gICAgICAgICAgICAgICAgYnVmZmVyLmFkZChhbmNob3JQb2ludCwgdGwsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hZGQoYW5jaG9yUG9pbnQsIHRyLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICBidWZmZXIuYWRkKGFuY2hvclBvaW50LCB0ciwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFkZChhbmNob3JQb2ludCwgYnIsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hZGQoYW5jaG9yUG9pbnQsIGJyLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICBidWZmZXIuYWRkKGFuY2hvclBvaW50LCBibCwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFkZChhbmNob3JQb2ludCwgYmwsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hZGQoYW5jaG9yUG9pbnQsIHRsLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEdyb3Vwcy5jb2xsaXNpb25Cb3guY3VycmVudC52ZXJ0ZXhMZW5ndGggKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIFN5bWJvbEluc3RhbmNlKGFuY2hvciwgbGluZSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbiwgbGF5b3V0LCBhZGRUb0J1ZmZlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Qm94U2NhbGUsIHRleHRQYWRkaW5nLCB0ZXh0QWxvbmdMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbkJveFNjYWxlLCBpY29uUGFkZGluZywgaWNvbkFsb25nTGluZSkge1xuXG4gICAgdGhpcy54ID0gYW5jaG9yLng7XG4gICAgdGhpcy55ID0gYW5jaG9yLnk7XG4gICAgdGhpcy5oYXNUZXh0ID0gISFzaGFwZWRUZXh0O1xuICAgIHRoaXMuaGFzSWNvbiA9ICEhc2hhcGVkSWNvbjtcblxuICAgIGlmICh0aGlzLmhhc1RleHQpIHtcbiAgICAgICAgdGhpcy5nbHlwaFF1YWRzID0gYWRkVG9CdWZmZXJzID8gZ2V0R2x5cGhRdWFkcyhhbmNob3IsIHNoYXBlZFRleHQsIHRleHRCb3hTY2FsZSwgbGluZSwgbGF5b3V0LCB0ZXh0QWxvbmdMaW5lKSA6IFtdO1xuICAgICAgICB0aGlzLnRleHRDb2xsaXNpb25GZWF0dXJlID0gbmV3IENvbGxpc2lvbkZlYXR1cmUobGluZSwgYW5jaG9yLCBzaGFwZWRUZXh0LCB0ZXh0Qm94U2NhbGUsIHRleHRQYWRkaW5nLCB0ZXh0QWxvbmdMaW5lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNJY29uKSB7XG4gICAgICAgIHRoaXMuaWNvblF1YWRzID0gYWRkVG9CdWZmZXJzID8gZ2V0SWNvblF1YWRzKGFuY2hvciwgc2hhcGVkSWNvbiwgaWNvbkJveFNjYWxlLCBsaW5lLCBsYXlvdXQsIGljb25BbG9uZ0xpbmUpIDogW107XG4gICAgICAgIHRoaXMuaWNvbkNvbGxpc2lvbkZlYXR1cmUgPSBuZXcgQ29sbGlzaW9uRmVhdHVyZShsaW5lLCBhbmNob3IsIHNoYXBlZEljb24sIGljb25Cb3hTY2FsZSwgaWNvblBhZGRpbmcsIGljb25BbG9uZ0xpbmUpO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDb29yZGluYXRlO1xuXG4vKipcbiAqIEEgY29vcmRpbmF0ZSBpcyBhIGNvbHVtbiwgcm93LCB6b29tIGNvbWJpbmF0aW9uLCBvZnRlbiB1c2VkXG4gKiBhcyB0aGUgZGF0YSBjb21wb25lbnQgb2YgYSB0aWxlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb29yZGluYXRlKGNvbHVtbiwgcm93LCB6b29tKSB7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy5yb3cgPSByb3c7XG4gICAgdGhpcy56b29tID0gem9vbTtcbn1cblxuQ29vcmRpbmF0ZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIGNvb3JkaW5hdGUgdGhhdCBjYW4gYmUgbXV0YXRlZCB3aXRob3V0XG4gICAgICogY2hhbmdpbmcgdGhlIG9yaWdpbmFsIGNvb3JkaW5hdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSBjbG9uZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoMCwgMCwgMCk7XG4gICAgICogdmFyIGMyID0gY29vcmQuY2xvbmUoKTtcbiAgICAgKiAvLyBzaW5jZSBjb29yZCBpcyBjbG9uZWQsIG1vZGlmeWluZyBhIHByb3BlcnR5IG9mIGMyIGRvZXNcbiAgICAgKiAvLyBub3QgbW9kaWZ5IGl0LlxuICAgICAqIGMyLnpvb20gPSAyO1xuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHRoaXMuY29sdW1uLCB0aGlzLnJvdywgdGhpcy56b29tKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0aGlzIGNvb3JkaW5hdGUgdG8gYSBnaXZlbiB6b29tIGxldmVsLiBUaGlzIHJldHVybnMgYSBuZXdcbiAgICAgKiBjb29yZGluYXRlIG9iamVjdCwgbm90IG11dGF0aW5nIHRoZSBvbGQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb21cbiAgICAgKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gem9vbWVkIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoMCwgMCwgMCk7XG4gICAgICogdmFyIGMyID0gY29vcmQuem9vbVRvKDEpO1xuICAgICAqIGMyIC8vIGVxdWFscyBuZXcgQ29vcmRpbmF0ZSgwLCAwLCAxKTtcbiAgICAgKi9cbiAgICB6b29tVG86IGZ1bmN0aW9uKHpvb20pIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fem9vbVRvKHpvb20pOyB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdGhlIGNvbHVtbiBhbmQgcm93IHZhbHVlcyBvZiB0aGlzIGNvb3JkaW5hdGUgZnJvbSB0aG9zZVxuICAgICAqIG9mIGFub3RoZXIgY29vcmRpbmF0ZS4gVGhlIG90aGVyIGNvb3JkaW5hdCB3aWxsIGJlIHpvb21lZCB0byB0aGVcbiAgICAgKiBzYW1lIGxldmVsIGFzIGB0aGlzYCBiZWZvcmUgdGhlIHN1YnRyYWN0aW9uIG9jY3Vyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjIG90aGVyIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gcmVzdWx0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdWI6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKGMpOyB9LFxuXG4gICAgX3pvb21UbzogZnVuY3Rpb24oem9vbSkge1xuICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tIC0gdGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jb2x1bW4gKj0gc2NhbGU7XG4gICAgICAgIHRoaXMucm93ICo9IHNjYWxlO1xuICAgICAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3N1YjogZnVuY3Rpb24oYykge1xuICAgICAgICBjID0gYy56b29tVG8odGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jb2x1bW4gLT0gYy5jb2x1bW47XG4gICAgICAgIHRoaXMucm93IC09IGMucm93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhdExuZztcblxudmFyIHdyYXAgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKS53cmFwO1xuXG4vKipcbiAqIENyZWF0ZSBhIGxhdGl0dWRlLCBsb25naXR1ZGUgb2JqZWN0IGZyb20gYSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIHBhaXIgaW4gZGVncmVlcy5cbiAqXG4gKiBAY2xhc3MgTGF0TG5nXG4gKiBAY2xhc3NkZXNjIEEgcmVwcmVzZW50YXRpb24gb2YgYSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIHBvaW50LCBpbiBkZWdyZWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGxhdCBsYXRpdHVkZVxuICogQHBhcmFtIHtudW1iZXJ9IGxuZyBsb25naXR1ZGVcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGF0bG5nID0gbmV3IG1hcGJveGdsLkxhdExuZygzNy43NiwgLTEyMi40NCk7XG4gKi9cbmZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZykge1xuICAgIGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XG4gICAgfVxuICAgIHRoaXMubGF0ID0gK2xhdDtcbiAgICB0aGlzLmxuZyA9ICtsbmc7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aG9zZSBsb25naXR1ZGUgaXMgd3JhcHBlZCB0byB0aGUgcmFuZ2UgKC0xODAsIDE4MCkuXG4gKlxuICogQHJldHVybnMge0xhdExuZ30gd3JhcHBlZCBMYXRMbmcgb2JqZWN0XG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50ID0gbWFwYm94Z2wuTGF0TG5nKDAsIDIwMCk7XG4gKiB2YXIgd3JhcHBlZCA9IHBvaW50LndyYXAoKTtcbiAqIHdyYXBwZWQubG5nOyAvLyA9IC0xNjBcbiAqL1xuTGF0TG5nLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTGF0TG5nKHRoaXMubGF0LCB3cmFwKHRoaXMubG5nLCAtMTgwLCAxODApKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSB0byBhIGBMYXRMbmdgIG9iamVjdCwgb3IgcmV0dXJuIGFuIGV4aXN0aW5nIGBMYXRMbmdgIG9iamVjdFxuICogdW5jaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxMYXRMbmd9IGlucHV0IGBpbnB1dGAgdG8gY29udmVydFxuICogQHJldHVybnMge0xhdExuZ30gTGF0TG5nIG9iamVjdCBvciBvcmlnaW5hbCBpbnB1dFxuICogQGV4YW1wbGVcbiAqIHZhciBsbCA9IG1hcGJveGdsLkxhdExuZy5jb252ZXJ0KFsxMCwgMTBdKTtcbiAqIHZhciBsbDIgPSBuZXcgbWFwYm94Z2wuTGF0TG5nKDEwLCAxMCk7XG4gKiBsbCAvLyA9IGxsMlxuICovXG5MYXRMbmcuY29udmVydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIExhdExuZykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbmV3IExhdExuZyhpbnB1dFswXSwgaW5wdXRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhdExuZ0JvdW5kcztcblxudmFyIExhdExuZyA9IHJlcXVpcmUoJy4vbGF0X2xuZycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBib3VuZGluZyBib3ggZnJvbSB0aGUgZ2l2ZW4gcGFpciBvZiBwb2ludHMuIElmIHBhcmFtZXRlcmVzIGFyZSBvbWl0dGVkLCBhIGBudWxsYCBib3VuZGluZyBib3ggaXMgY3JlYXRlZC5cbiAqXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXG4gKiBAY2xhc3NkZXNjIEEgcmVwcmVzZW50YXRpb24gb2YgcmVjdGFuZ3VsYXIgYm94IG9uIHRoZSBlYXJ0aCwgZGVmaW5lZCBieSBpdHMgc291dGh3ZXN0IGFuZCBub3J0aGVhc3QgcG9pbnRzIGluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXG4gKiBAcGFyYW0ge0xhdExuZ30gc3cgc291dGh3ZXN0XG4gKiBAcGFyYW0ge0xhdExuZ30gbmUgbm9ydGhlYXN0XG4gKiBAZXhhbXBsZVxuICogdmFyIHN3ID0gbmV3IG1hcGJveGdsLkxhdExuZygwLCAwKTtcbiAqIHZhciBuZSA9IG5ldyBtYXBib3hnbC5MYXRMbmcoMTAsIC0xMCk7XG4gKiB2YXIgYm91bmRzID0gbmV3IG1hcGJveGdsLkxhdExuZ0JvdW5kcyhzdywgbmUpO1xuICpcbiAqL1xuZnVuY3Rpb24gTGF0TG5nQm91bmRzKHN3LCBuZSkge1xuICAgIGlmICghc3cpIHJldHVybjtcblxuICAgIHZhciBsYXRsbmdzID0gbmUgPyBbc3csIG5lXSA6IHN3O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XG4gICAgfVxufVxuXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHRoZSBib3VuZHMgdG8gaW5jbHVkZSBhIGdpdmVuIExhdExuZyBvciBMYXRMbmdCb3VuZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xhdExuZ3xMYXRMbmdCb3VuZHN9IG9iaiBvYmplY3QgdG8gZXh0ZW5kIHRvXG4gICAgICogQHJldHVybnMge0xhdExuZ0JvdW5kc30gYHRoaXNgXG4gICAgICovXG4gICAgZXh0ZW5kOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIHN3ID0gdGhpcy5fc3csXG4gICAgICAgICAgICBuZSA9IHRoaXMuX25lLFxuICAgICAgICAgICAgc3cyLCBuZTI7XG5cbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZykge1xuICAgICAgICAgICAgc3cyID0gb2JqO1xuICAgICAgICAgICAgbmUyID0gb2JqO1xuXG4gICAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XG4gICAgICAgICAgICBzdzIgPSBvYmouX3N3O1xuICAgICAgICAgICAgbmUyID0gb2JqLl9uZTtcblxuICAgICAgICAgICAgaWYgKCFzdzIgfHwgIW5lMikgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogPyB0aGlzLmV4dGVuZChMYXRMbmcuY29udmVydChvYmopIHx8IExhdExuZ0JvdW5kcy5jb252ZXJ0KG9iaikpIDogdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3cgJiYgIW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9zdyA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XG4gICAgICAgICAgICB0aGlzLl9uZSA9IG5ldyBMYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XG4gICAgICAgICAgICBzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xuICAgICAgICAgICAgbmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcbiAgICAgICAgICAgIG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb2ludCBlcXVpZGlzdGFudCBmcm9tIHRoaXMgYm94J3MgY29ybmVyc1xuICAgICAqIEByZXR1cm5zIHtMYXRMbmd9IGNlbnRlcnBvaW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYm91bmRzID0gbmV3IG1hcGJveGdsLkxhdExuZ0JvdW5kcyhcbiAgICAgKiAgIG5ldyBtYXBib3hnbC5MYXRMbmcoMTAsIDEwKSxcbiAgICAgKiAgIG5ldyBtYXBib3hnbC5MYXRMbmcoLTEwLCAtMTApO1xuICAgICAqIGJvdW5kcy5nZXRDZW50ZXIoKTsgLy8gZXF1YWxzIG1hcGJveGdsLkxhdExuZygwLCAwKVxuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF0TG5nKCh0aGlzLl9zdy5sYXQgKyB0aGlzLl9uZS5sYXQpIC8gMiwgKHRoaXMuX3N3LmxuZyArIHRoaXMuX25lLmxuZykgLyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNvdXRod2VzdCBjb3JuZXJcbiAgICAgKiBAcmV0dXJucyB7TGF0TG5nfSBzb3V0aHdlc3RcbiAgICAgKi9cbiAgICBnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc3c7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbm9ydGhlYXN0IGNvcm5lclxuICAgICAqIEByZXR1cm5zIHtMYXRMbmd9IG5vcnRoZWFzdFxuICAgICAqL1xuICAgIGdldE5vcnRoRWFzdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9uZTsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBub3J0aHdlc3QgY29ybmVyXG4gICAgICogQHJldHVybnMge0xhdExuZ30gbm9ydGh3ZXN0XG4gICAgICovXG4gICAgZ2V0Tm9ydGhXZXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc291dGhlYXN0IGNvcm5lclxuICAgICAqIEByZXR1cm5zIHtMYXRMbmd9IHNvdXRoZWFzdFxuICAgICAqL1xuICAgIGdldFNvdXRoRWFzdDogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpOyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHdlc3QgZWRnZSBsb25naXR1ZGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB3ZXN0XG4gICAgICovXG4gICAgZ2V0V2VzdDogIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc3cubG5nOyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNvdXRoIGVkZ2UgbGF0aXR1ZGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzb3V0aFxuICAgICAqL1xuICAgIGdldFNvdXRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3N3LmxhdDsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBlYXN0IGVkZ2UgbG9uZ2l0dWRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gZWFzdFxuICAgICAqL1xuICAgIGdldEVhc3Q6ICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX25lLmxuZzsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBub3J0aCBlZGdlIGxhdGl0dWRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbm9ydGhcbiAgICAgKi9cbiAgICBnZXROb3J0aDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9uZS5sYXQ7IH1cbn07XG5cbi8qKlxuICogY29uc3RydWN0cyBMYXRMbmdCb3VuZHMgZnJvbSBhbiBhcnJheSBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7TGF0TG5nQm91bmRzfCp9IGEgYW55IGlucHV0XG4gKiBAcmV0dXJucyB7TGF0TG5nQm91bmRzfGZhbHNlfVxuICogQGV4YW1wbGVcbiAqIC8vIGNhbGxzIExhdExuZy5jb252ZXJ0IGludGVybmFsbHkgdG9cbiAqIC8vIHN1cHBvcnQgYXJyYXlzIGFzIGxhdGxuZyB2YWx1ZXNcbiAqIExhdExuZ0JvdW5kcy5jb252ZXJ0KFtbLTEwLCAtMTBdLCBbMTAsIDEwXV0pO1xuICovXG5MYXRMbmdCb3VuZHMuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHJldHVybiBhO1xuICAgIHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIExhdExuZyA9IHJlcXVpcmUoJy4vbGF0X2xuZycpLFxuICAgIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKSxcbiAgICBDb29yZGluYXRlID0gcmVxdWlyZSgnLi9jb29yZGluYXRlJyksXG4gICAgd3JhcCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpLndyYXAsXG4gICAgaW50ZXJwID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpLFxuICAgIHZlYzQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWM0LFxuICAgIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxuLypcbiAqIEEgc2luZ2xlIHRyYW5zZm9ybSwgZ2VuZXJhbGx5IHVzZWQgZm9yIGEgc2luZ2xlIHRpbGUgdG8gYmVcbiAqIHNjYWxlZCwgcm90YXRlZCwgYW5kIHpvb21lZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWm9vbVxuICogQHBhcmFtIHtudW1iZXJ9IG1heFpvb21cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFRyYW5zZm9ybShtaW5ab29tLCBtYXhab29tKSB7XG4gICAgdGhpcy50aWxlU2l6ZSA9IDUxMjsgLy8gY29uc3RhbnRcblxuICAgIHRoaXMuX21pblpvb20gPSBtaW5ab29tIHx8IDA7XG4gICAgdGhpcy5fbWF4Wm9vbSA9IG1heFpvb20gfHwgMjI7XG5cbiAgICB0aGlzLmxhdFJhbmdlID0gWy04NS4wNTExMywgODUuMDUxMTNdO1xuXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuem9vbSA9IDA7XG4gICAgdGhpcy5jZW50ZXIgPSBuZXcgTGF0TG5nKDAsIDApO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIHRoaXMuX2FsdGl0dWRlID0gMS41O1xuICAgIHRoaXMuX3BpdGNoID0gMDtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgICBnZXQgbWluWm9vbSgpIHsgcmV0dXJuIHRoaXMuX21pblpvb207IH0sXG4gICAgc2V0IG1pblpvb20oem9vbSkge1xuICAgICAgICB0aGlzLl9taW5ab29tID0gem9vbTtcbiAgICAgICAgdGhpcy56b29tID0gTWF0aC5tYXgodGhpcy56b29tLCB6b29tKTtcbiAgICB9LFxuXG4gICAgZ2V0IG1heFpvb20oKSB7IHJldHVybiB0aGlzLl9tYXhab29tOyB9LFxuICAgIHNldCBtYXhab29tKHpvb20pIHtcbiAgICAgICAgdGhpcy5fbWF4Wm9vbSA9IHpvb207XG4gICAgICAgIHRoaXMuem9vbSA9IE1hdGgubWluKHRoaXMuem9vbSwgem9vbSk7XG4gICAgfSxcblxuICAgIGdldCB3b3JsZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplICogdGhpcy5zY2FsZTtcbiAgICB9LFxuXG4gICAgZ2V0IGNlbnRlclBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplLl9kaXYoMik7XG4gICAgfSxcblxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZ2V0IGJlYXJpbmcoKSB7XG4gICAgICAgIHJldHVybiAtdGhpcy5hbmdsZSAvIE1hdGguUEkgKiAxODA7XG4gICAgfSxcbiAgICBzZXQgYmVhcmluZyhiZWFyaW5nKSB7XG4gICAgICAgIHRoaXMuYW5nbGUgPSAtd3JhcChiZWFyaW5nLCAtMTgwLCAxODApICogTWF0aC5QSSAvIDE4MDtcbiAgICB9LFxuXG4gICAgZ2V0IHBpdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl0Y2ggLyBNYXRoLlBJICogMTgwO1xuICAgIH0sXG4gICAgc2V0IHBpdGNoKHBpdGNoKSB7XG4gICAgICAgIHRoaXMuX3BpdGNoID0gTWF0aC5taW4oNjAsIHBpdGNoKSAvIDE4MCAqIE1hdGguUEk7XG4gICAgfSxcblxuICAgIGdldCBhbHRpdHVkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsdGl0dWRlO1xuICAgIH0sXG4gICAgc2V0IGFsdGl0dWRlKGFsdGl0dWRlKSB7XG4gICAgICAgIHRoaXMuX2FsdGl0dWRlID0gTWF0aC5tYXgoMC43NSwgYWx0aXR1ZGUpO1xuICAgIH0sXG5cbiAgICBnZXQgem9vbSgpIHsgcmV0dXJuIHRoaXMuX3pvb207IH0sXG4gICAgc2V0IHpvb20oem9vbSkge1xuICAgICAgICB6b29tID0gTWF0aC5taW4oTWF0aC5tYXgoem9vbSwgdGhpcy5taW5ab29tKSwgdGhpcy5tYXhab29tKTtcbiAgICAgICAgdGhpcy5fem9vbSA9IHpvb207XG4gICAgICAgIHRoaXMuc2NhbGUgPSB0aGlzLnpvb21TY2FsZSh6b29tKTtcbiAgICAgICAgdGhpcy50aWxlWm9vbSA9IE1hdGguZmxvb3Ioem9vbSk7XG4gICAgICAgIHRoaXMuem9vbUZyYWN0aW9uID0gem9vbSAtIHRoaXMudGlsZVpvb207XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbigpO1xuICAgIH0sXG5cbiAgICB6b29tU2NhbGU6IGZ1bmN0aW9uKHpvb20pIHsgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pOyB9LFxuICAgIHNjYWxlWm9vbTogZnVuY3Rpb24oc2NhbGUpIHsgcmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yOyB9LFxuXG4gICAgcHJvamVjdDogZnVuY3Rpb24obGF0bG5nLCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMubG5nWChsYXRsbmcubG5nLCB3b3JsZFNpemUpLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxhdGxuZy5sYXQsIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKHBvaW50LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXRMbmcoXG4gICAgICAgICAgICB0aGlzLnlMYXQocG9pbnQueSwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueExuZyhwb2ludC54LCB3b3JsZFNpemUpKTtcbiAgICB9LFxuXG4gICAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLmxuZ1godGhpcy5jZW50ZXIubG5nKTsgfSxcbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMubGF0WSh0aGlzLmNlbnRlci5sYXQpOyB9LFxuXG4gICAgZ2V0IHBvaW50KCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIC8qKlxuICAgICAqIGxhdC9sb24gPC0+IGFic29sdXRlIHBpeGVsIGNvb3JkcyBjb252ZXJzaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd29ybGRTaXplPXRoaXMud29ybGRTaXplXVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBpeGVsIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxuZ1g6IGZ1bmN0aW9uKGxvbiwgd29ybGRTaXplKSB7XG4gICAgICAgIHJldHVybiAoMTgwICsgbG9uKSAqICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpIC8gMzYwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogbGF0aXR1ZGUgdG8gYWJzb2x1dGUgeSBjb29yZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd29ybGRTaXplPXRoaXMud29ybGRTaXplXVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBpeGVsIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxhdFk6IGZ1bmN0aW9uKGxhdCwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5ID0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgbGF0ICogTWF0aC5QSSAvIDM2MCkpO1xuICAgICAgICByZXR1cm4gKDE4MCAtIHkpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcblxuICAgIHhMbmc6IGZ1bmN0aW9uKHgsIHdvcmxkU2l6ZSkge1xuICAgICAgICByZXR1cm4geCAqIDM2MCAvICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpIC0gMTgwO1xuICAgIH0sXG4gICAgeUxhdDogZnVuY3Rpb24oeSwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5MiA9IDE4MCAtIHkgKiAzNjAgLyAod29ybGRTaXplIHx8IHRoaXMud29ybGRTaXplKTtcbiAgICAgICAgcmV0dXJuIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MDtcbiAgICB9LFxuXG4gICAgcGFuQnk6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmNlbnRlclBvaW50Ll9hZGQob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnBvaW50TG9jYXRpb24ocG9pbnQpO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW4oKTtcbiAgICB9LFxuXG4gICAgc2V0TG9jYXRpb25BdFBvaW50OiBmdW5jdGlvbihsYXRsbmcsIHBvaW50KSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5sb2NhdGlvbkNvb3JkaW5hdGUobGF0bG5nKTtcbiAgICAgICAgdmFyIGNvb3JkQXRQb2ludCA9IHRoaXMucG9pbnRDb29yZGluYXRlKHBvaW50KTtcbiAgICAgICAgdmFyIGNvb3JkQ2VudGVyID0gdGhpcy5wb2ludENvb3JkaW5hdGUodGhpcy5jZW50ZXJQb2ludCk7XG5cbiAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IGNvb3JkQXRQb2ludC5fc3ViKGMpO1xuICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKGNvb3JkQ2VudGVyLl9zdWIodHJhbnNsYXRlKSk7XG5cbiAgICAgICAgdGhpcy5fY29uc3RyYWluKCk7XG4gICAgfSxcblxuICAgIHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uKHpvb20sIGNlbnRlcikge1xuICAgICAgICB2YXIgcDtcbiAgICAgICAgaWYgKGNlbnRlcikgcCA9IHRoaXMubG9jYXRpb25Qb2ludChjZW50ZXIpO1xuICAgICAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgICAgICBpZiAoY2VudGVyKSB0aGlzLnNldExvY2F0aW9uQXRQb2ludChjZW50ZXIsIHApO1xuICAgIH0sXG5cbiAgICBzZXRCZWFyaW5nQXJvdW5kOiBmdW5jdGlvbihiZWFyaW5nLCBjZW50ZXIpIHtcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIGlmIChjZW50ZXIpIHAgPSB0aGlzLmxvY2F0aW9uUG9pbnQoY2VudGVyKTtcbiAgICAgICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICAgICAgaWYgKGNlbnRlcikgdGhpcy5zZXRMb2NhdGlvbkF0UG9pbnQoY2VudGVyLCBwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsb2NhdGlvbiwgcmV0dXJuIHRoZSBzY3JlZW4gcG9pbnQgdGhhdCBjb3JyZXNwb25kcyB0byBpdFxuICAgICAqIEBwYXJhbSB7TGF0TG5nfSBsYXRsbmcgbG9jYXRpb25cbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHNjcmVlbiBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9jYXRpb25Qb2ludDogZnVuY3Rpb24obGF0bG5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVQb2ludCh0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsYXRsbmcpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb2ludCBvbiBzY3JlZW4sIHJldHVybiBpdHMgbGF0bG5nXG4gICAgICogQHBhcmFtIHtQb2ludH0gcCBzY3JlZW4gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7TGF0TG5nfSBsYXRsbmcgbG9jYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50TG9jYXRpb246IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKHRoaXMucG9pbnRDb29yZGluYXRlKHApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBnZW9ncmFwaGljYWwgbGF0bG5nLCByZXR1cm4gYW4gdW5yb3VuZGVkXG4gICAgICogY29vcmRpbmF0ZSB0aGF0IHJlcHJlc2VudHMgaXQgYXQgdGhpcyB0cmFuc2Zvcm0ncyB6b29tIGxldmVsIGFuZFxuICAgICAqIHdvcmxkc2l6ZS5cbiAgICAgKiBAcGFyYW0ge0xhdExuZ30gbGF0bG5nXG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsb2NhdGlvbkNvb3JkaW5hdGU6IGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICB2YXIgayA9IHRoaXMuem9vbVNjYWxlKHRoaXMudGlsZVpvb20pIC8gdGhpcy53b3JsZFNpemU7XG4gICAgICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZShcbiAgICAgICAgICAgIHRoaXMubG5nWChsYXRsbmcubG5nKSAqIGssXG4gICAgICAgICAgICB0aGlzLmxhdFkobGF0bG5nLmxhdCkgKiBrLFxuICAgICAgICAgICAgdGhpcy50aWxlWm9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgQ29vcmRpbmF0ZSwgcmV0dXJuIGl0cyBnZW9ncmFwaGljYWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtMYXRMbmd9IGxhdGxuZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29vcmRpbmF0ZUxvY2F0aW9uOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgd29ybGRTaXplID0gdGhpcy56b29tU2NhbGUoY29vcmQuem9vbSk7XG4gICAgICAgIHJldHVybiBuZXcgTGF0TG5nKFxuICAgICAgICAgICAgdGhpcy55TGF0KGNvb3JkLnJvdywgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueExuZyhjb29yZC5jb2x1bW4sIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICBwb2ludENvb3JkaW5hdGU6IGZ1bmN0aW9uKHAsIHRhcmdldFopIHtcblxuICAgICAgICBpZiAodGFyZ2V0WiA9PT0gdW5kZWZpbmVkKSB0YXJnZXRaID0gMDtcblxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5jb29yZGluYXRlUG9pbnRNYXRyaXgodGhpcy50aWxlWm9vbSk7XG4gICAgICAgIHZhciBpbnZlcnRlZCA9IG1hdDQuaW52ZXJ0KG5ldyBGbG9hdDY0QXJyYXkoMTYpLCBtYXRyaXgpO1xuXG4gICAgICAgIGlmICghaW52ZXJ0ZWQpIHRocm93IFwiZmFpbGVkIHRvIGludmVydCBtYXRyaXhcIjtcblxuICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBrbm93IHRoZSBjb3JyZWN0IHByb2plY3RlZCB6IHZhbHVlIGZvciB0aGUgcG9pbnQsXG4gICAgICAgIC8vIHVucHJvamVjdCB0d28gcG9pbnRzIHRvIGdldCBhIGxpbmUgYW5kIHRoZW4gZmluZCB0aGUgcG9pbnQgb24gdGhhdFxuICAgICAgICAvLyBsaW5lIHdpdGggej0wXG5cbiAgICAgICAgdmFyIGNvb3JkMCA9IHZlYzQudHJhbnNmb3JtTWF0NChbXSwgW3AueCwgcC55LCAwLCAxXSwgaW52ZXJ0ZWQpO1xuICAgICAgICB2YXIgY29vcmQxID0gdmVjNC50cmFuc2Zvcm1NYXQ0KFtdLCBbcC54LCBwLnksIDEsIDFdLCBpbnZlcnRlZCk7XG5cbiAgICAgICAgdmFyIHcwID0gY29vcmQwWzNdO1xuICAgICAgICB2YXIgdzEgPSBjb29yZDFbM107XG4gICAgICAgIHZhciB4MCA9IGNvb3JkMFswXSAvIHcwO1xuICAgICAgICB2YXIgeDEgPSBjb29yZDFbMF0gLyB3MTtcbiAgICAgICAgdmFyIHkwID0gY29vcmQwWzFdIC8gdzA7XG4gICAgICAgIHZhciB5MSA9IGNvb3JkMVsxXSAvIHcxO1xuICAgICAgICB2YXIgejAgPSBjb29yZDBbMl0gLyB3MDtcbiAgICAgICAgdmFyIHoxID0gY29vcmQxWzJdIC8gdzE7XG5cblxuICAgICAgICB2YXIgdCA9IHowID09PSB6MSA/IDAgOiAodGFyZ2V0WiAtIHowKSAvICh6MSAtIHowKTtcblxuICAgICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUoXG4gICAgICAgICAgICBpbnRlcnAoeDAsIHgxLCB0KSxcbiAgICAgICAgICAgIGludGVycCh5MCwgeTEsIHQpLFxuICAgICAgICAgICAgdGhpcy50aWxlWm9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgY29vcmRpbmF0ZSwgcmV0dXJuIHRoZSBzY3JlZW4gcG9pbnQgdGhhdCBjb3JyZXNwb25kcyB0byBpdFxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHNjcmVlbiBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29vcmRpbmF0ZVBvaW50OiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5jb29yZGluYXRlUG9pbnRNYXRyaXgoY29vcmQuem9vbSk7XG4gICAgICAgIHZhciBwID0gdmVjNC50cmFuc2Zvcm1NYXQ0KFtdLCBbY29vcmQuY29sdW1uLCBjb29yZC5yb3csIDAsIDFdLCBtYXRyaXgpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBbMF0gLyBwWzNdLCBwWzFdIC8gcFszXSk7XG4gICAgfSxcblxuICAgIGNvb3JkaW5hdGVQb2ludE1hdHJpeDogZnVuY3Rpb24oeikge1xuICAgICAgICB2YXIgcHJvaiA9IHRoaXMuZ2V0UHJvak1hdHJpeCgpO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLndvcmxkU2l6ZSAvIHRoaXMuem9vbVNjYWxlKHopO1xuICAgICAgICBtYXQ0LnNjYWxlKHByb2osIHByb2osIFtzY2FsZSwgc2NhbGUsIDFdKTtcbiAgICAgICAgbWF0NC5tdWx0aXBseShwcm9qLCB0aGlzLmdldFBpeGVsTWF0cml4KCksIHByb2opO1xuICAgICAgICByZXR1cm4gcHJvajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydHMgZ2wgY29vcmRpbmF0ZXMgLTEuLjEgdG8gcGl4ZWxzIDAuLndpZHRoXG4gICAgICogQHJldHVybnMge09iamVjdH0gbWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRQaXhlbE1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgbWF0NC5zY2FsZShtLCBtLCBbdGhpcy53aWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIsIDFdKTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzEsIC0xLCAwXSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH0sXG5cbiAgICBfY29uc3RyYWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNlbnRlcikgcmV0dXJuO1xuXG4gICAgICAgIHZhciBtaW5ZLCBtYXhZLCBtaW5YLCBtYXhYLCBzeSwgc3gsIHgyLCB5MixcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLnNpemU7XG5cbiAgICAgICAgaWYgKHRoaXMubGF0UmFuZ2UpIHtcbiAgICAgICAgICAgIG1pblkgPSB0aGlzLmxhdFkodGhpcy5sYXRSYW5nZVsxXSk7XG4gICAgICAgICAgICBtYXhZID0gdGhpcy5sYXRZKHRoaXMubGF0UmFuZ2VbMF0pO1xuICAgICAgICAgICAgc3kgPSBtYXhZIC0gbWluWSA8IHNpemUueSA/IHNpemUueSAvIChtYXhZIC0gbWluWSkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubG5nUmFuZ2UpIHtcbiAgICAgICAgICAgIG1pblggPSB0aGlzLmxuZ1godGhpcy5sbmdSYW5nZVswXSk7XG4gICAgICAgICAgICBtYXhYID0gdGhpcy5sbmdYKHRoaXMubG5nUmFuZ2VbMV0pO1xuICAgICAgICAgICAgc3ggPSBtYXhYIC0gbWluWCA8IHNpemUueCA/IHNpemUueCAvIChtYXhYIC0gbWluWCkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaG93IG11Y2ggdGhlIG1hcCBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBzY3JlZW4gaW50byBnaXZlbiBsYXRpdHVkZS9sb25naXR1ZGUgcmFuZ2VzXG4gICAgICAgIHZhciBzID0gTWF0aC5tYXgoc3ggfHwgMCwgc3kgfHwgMCk7XG5cbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy51bnByb2plY3QobmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIHN4ID8gKG1heFggKyBtaW5YKSAvIDIgOiB0aGlzLngsXG4gICAgICAgICAgICAgICAgc3kgPyAobWF4WSArIG1pblkpIC8gMiA6IHRoaXMueSkpO1xuICAgICAgICAgICAgdGhpcy56b29tICs9IHRoaXMuc2NhbGVab29tKHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGF0UmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy55LFxuICAgICAgICAgICAgICAgIGgyID0gc2l6ZS55IC8gMjtcblxuICAgICAgICAgICAgaWYgKHkgLSBoMiA8IG1pblkpIHkyID0gbWluWSArIGgyO1xuICAgICAgICAgICAgaWYgKHkgKyBoMiA+IG1heFkpIHkyID0gbWF4WSAtIGgyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubG5nUmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgICAgICAgIHcyID0gc2l6ZS54IC8gMjtcblxuICAgICAgICAgICAgaWYgKHggLSB3MiA8IG1pblgpIHgyID0gbWluWCArIHcyO1xuICAgICAgICAgICAgaWYgKHggKyB3MiA+IG1heFgpIHgyID0gbWF4WCAtIHcyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuIHRoZSBtYXAgaWYgdGhlIHNjcmVlbiBnb2VzIG9mZiB0aGUgcmFuZ2VcbiAgICAgICAgaWYgKHgyICE9PSB1bmRlZmluZWQgfHwgeTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnVucHJvamVjdChuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgeDIgIT09IHVuZGVmaW5lZCA/IHgyIDogdGhpcy54LFxuICAgICAgICAgICAgICAgIHkyICE9PSB1bmRlZmluZWQgPyB5MiA6IHRoaXMueSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFByb2pNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbSA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBwb2ludCB0byB0aGUgY2VudGVyIHRvcCBpbiBhbHRpdHVkZSB1bml0cyB1c2luZyBsYXcgb2Ygc2luZXMuXG4gICAgICAgIHZhciBoYWxmRm92ID0gTWF0aC5hdGFuKDAuNSAvIHRoaXMuYWx0aXR1ZGUpO1xuICAgICAgICB2YXIgdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSA9IE1hdGguc2luKGhhbGZGb3YpICogdGhpcy5hbHRpdHVkZSAvIE1hdGguc2luKE1hdGguUEkgLyAyIC0gdGhpcy5fcGl0Y2ggLSBoYWxmRm92KTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHogdmFsdWUgb2YgdGhlIGZhcnRoZXN0IGZyYWdtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgICAgICB2YXIgZmFyWiA9IE1hdGguY29zKE1hdGguUEkgLyAyIC0gdGhpcy5fcGl0Y2gpICogdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSArIHRoaXMuYWx0aXR1ZGU7XG5cbiAgICAgICAgbWF0NC5wZXJzcGVjdGl2ZShtLCAyICogTWF0aC5hdGFuKCh0aGlzLmhlaWdodCAvIDIpIC8gdGhpcy5hbHRpdHVkZSksIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCwgMC4xLCBmYXJaKTtcblxuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMCwgMCwgLXRoaXMuYWx0aXR1ZGVdKTtcblxuICAgICAgICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgICAgICAgLy8gYWx0aXR1ZGUgdW5pdGVzLiAxIGFsdGl0dWRlIHVuaXQgPSB0aGUgc2NyZWVuIGhlaWdodC5cbiAgICAgICAgbWF0NC5zY2FsZShtLCBtLCBbMSwgLTEsIDEgLyB0aGlzLmhlaWdodF0pO1xuXG4gICAgICAgIG1hdDQucm90YXRlWChtLCBtLCB0aGlzLl9waXRjaCk7XG4gICAgICAgIG1hdDQucm90YXRlWihtLCBtLCB0aGlzLmFuZ2xlKTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWy10aGlzLngsIC10aGlzLnksIDBdKTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gRm9udCBkYXRhIEZyb20gSGVyc2hleSBTaW1wbGV4IEZvbnRcbi8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9kYXRhZm9ybWF0cy9oZXJzaGV5L1xudmFyIHNpbXBsZXhGb250ID0ge1xuICAgIFwiIFwiOiBbMTYsIFtdXSxcbiAgICBcIiFcIjogWzEwLCBbNSwgMjEsIDUsIDcsIC0xLCAtMSwgNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxuICAgIFwiXFxcIlwiOiBbMTYsIFs0LCAyMSwgNCwgMTQsIC0xLCAtMSwgMTIsIDIxLCAxMiwgMTRdXSxcbiAgICBcIiNcIjogWzIxLCBbMTEsIDI1LCA0LCAtNywgLTEsIC0xLCAxNywgMjUsIDEwLCAtNywgLTEsIC0xLCA0LCAxMiwgMTgsIDEyLCAtMSwgLTEsIDMsIDYsIDE3LCA2XV0sXG4gICAgXCIkXCI6IFsyMCwgWzgsIDI1LCA4LCAtNCwgLTEsIC0xLCAxMiwgMjUsIDEyLCAtNCwgLTEsIC0xLCAxNywgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMSwgNSwgMjAsIDMsIDE4LCAzLCAxNiwgNCwgMTQsIDUsIDEzLCA3LCAxMiwgMTMsIDEwLCAxNSwgOSwgMTYsIDgsIDE3LCA2LCAxNywgMywgMTUsIDEsIDEyLCAwLCA4LCAwLCA1LCAxLCAzLCAzXV0sXG4gICAgXCIlXCI6IFsyNCwgWzIxLCAyMSwgMywgMCwgLTEsIC0xLCA4LCAyMSwgMTAsIDE5LCAxMCwgMTcsIDksIDE1LCA3LCAxNCwgNSwgMTQsIDMsIDE2LCAzLCAxOCwgNCwgMjAsIDYsIDIxLCA4LCAyMSwgMTAsIDIwLCAxMywgMTksIDE2LCAxOSwgMTksIDIwLCAyMSwgMjEsIC0xLCAtMSwgMTcsIDcsIDE1LCA2LCAxNCwgNCwgMTQsIDIsIDE2LCAwLCAxOCwgMCwgMjAsIDEsIDIxLCAzLCAyMSwgNSwgMTksIDcsIDE3LCA3XV0sXG4gICAgXCImXCI6IFsyNiwgWzIzLCAxMiwgMjMsIDEzLCAyMiwgMTQsIDIxLCAxNCwgMjAsIDEzLCAxOSwgMTEsIDE3LCA2LCAxNSwgMywgMTMsIDEsIDExLCAwLCA3LCAwLCA1LCAxLCA0LCAyLCAzLCA0LCAzLCA2LCA0LCA4LCA1LCA5LCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE2LCAxNCwgMTgsIDEzLCAyMCwgMTEsIDIxLCA5LCAyMCwgOCwgMTgsIDgsIDE2LCA5LCAxMywgMTEsIDEwLCAxNiwgMywgMTgsIDEsIDIwLCAwLCAyMiwgMCwgMjMsIDEsIDIzLCAyXV0sXG4gICAgXCInXCI6IFsxMCwgWzUsIDE5LCA0LCAyMCwgNSwgMjEsIDYsIDIwLCA2LCAxOCwgNSwgMTYsIDQsIDE1XV0sXG4gICAgXCIoXCI6IFsxNCwgWzExLCAyNSwgOSwgMjMsIDcsIDIwLCA1LCAxNiwgNCwgMTEsIDQsIDcsIDUsIDIsIDcsIC0yLCA5LCAtNSwgMTEsIC03XV0sXG4gICAgXCIpXCI6IFsxNCwgWzMsIDI1LCA1LCAyMywgNywgMjAsIDksIDE2LCAxMCwgMTEsIDEwLCA3LCA5LCAyLCA3LCAtMiwgNSwgLTUsIDMsIC03XV0sXG4gICAgXCIqXCI6IFsxNiwgWzgsIDIxLCA4LCA5LCAtMSwgLTEsIDMsIDE4LCAxMywgMTIsIC0xLCAtMSwgMTMsIDE4LCAzLCAxMl1dLFxuICAgIFwiK1wiOiBbMjYsIFsxMywgMTgsIDEzLCAwLCAtMSwgLTEsIDQsIDksIDIyLCA5XV0sXG4gICAgXCIsXCI6IFsxMCwgWzYsIDEsIDUsIDAsIDQsIDEsIDUsIDIsIDYsIDEsIDYsIC0xLCA1LCAtMywgNCwgLTRdXSxcbiAgICBcIi1cIjogWzI2LCBbNCwgOSwgMjIsIDldXSxcbiAgICBcIi5cIjogWzEwLCBbNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxuICAgIFwiL1wiOiBbMjIsIFsyMCwgMjUsIDIsIC03XV0sXG4gICAgXCIwXCI6IFsyMCwgWzksIDIxLCA2LCAyMCwgNCwgMTcsIDMsIDEyLCAzLCA5LCA0LCA0LCA2LCAxLCA5LCAwLCAxMSwgMCwgMTQsIDEsIDE2LCA0LCAxNywgOSwgMTcsIDEyLCAxNiwgMTcsIDE0LCAyMCwgMTEsIDIxLCA5LCAyMV1dLFxuICAgIFwiMVwiOiBbMjAsIFs2LCAxNywgOCwgMTgsIDExLCAyMSwgMTEsIDBdXSxcbiAgICBcIjJcIjogWzIwLCBbNCwgMTYsIDQsIDE3LCA1LCAxOSwgNiwgMjAsIDgsIDIxLCAxMiwgMjEsIDE0LCAyMCwgMTUsIDE5LCAxNiwgMTcsIDE2LCAxNSwgMTUsIDEzLCAxMywgMTAsIDMsIDAsIDE3LCAwXV0sXG4gICAgXCIzXCI6IFsyMCwgWzUsIDIxLCAxNiwgMjEsIDEwLCAxMywgMTMsIDEzLCAxNSwgMTIsIDE2LCAxMSwgMTcsIDgsIDE3LCA2LCAxNiwgMywgMTQsIDEsIDExLCAwLCA4LCAwLCA1LCAxLCA0LCAyLCAzLCA0XV0sXG4gICAgXCI0XCI6IFsyMCwgWzEzLCAyMSwgMywgNywgMTgsIDcsIC0xLCAtMSwgMTMsIDIxLCAxMywgMF1dLFxuICAgIFwiNVwiOiBbMjAsIFsxNSwgMjEsIDUsIDIxLCA0LCAxMiwgNSwgMTMsIDgsIDE0LCAxMSwgMTQsIDE0LCAxMywgMTYsIDExLCAxNywgOCwgMTcsIDYsIDE2LCAzLCAxNCwgMSwgMTEsIDAsIDgsIDAsIDUsIDEsIDQsIDIsIDMsIDRdXSxcbiAgICBcIjZcIjogWzIwLCBbMTYsIDE4LCAxNSwgMjAsIDEyLCAyMSwgMTAsIDIxLCA3LCAyMCwgNSwgMTcsIDQsIDEyLCA0LCA3LCA1LCAzLCA3LCAxLCAxMCwgMCwgMTEsIDAsIDE0LCAxLCAxNiwgMywgMTcsIDYsIDE3LCA3LCAxNiwgMTAsIDE0LCAxMiwgMTEsIDEzLCAxMCwgMTMsIDcsIDEyLCA1LCAxMCwgNCwgN11dLFxuICAgIFwiN1wiOiBbMjAsIFsxNywgMjEsIDcsIDAsIC0xLCAtMSwgMywgMjEsIDE3LCAyMV1dLFxuICAgIFwiOFwiOiBbMjAsIFs4LCAyMSwgNSwgMjAsIDQsIDE4LCA0LCAxNiwgNSwgMTQsIDcsIDEzLCAxMSwgMTIsIDE0LCAxMSwgMTYsIDksIDE3LCA3LCAxNywgNCwgMTYsIDIsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgNCwgMiwgMywgNCwgMywgNywgNCwgOSwgNiwgMTEsIDksIDEyLCAxMywgMTMsIDE1LCAxNCwgMTYsIDE2LCAxNiwgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMV1dLFxuICAgIFwiOVwiOiBbMjAsIFsxNiwgMTQsIDE1LCAxMSwgMTMsIDksIDEwLCA4LCA5LCA4LCA2LCA5LCA0LCAxMSwgMywgMTQsIDMsIDE1LCA0LCAxOCwgNiwgMjAsIDksIDIxLCAxMCwgMjEsIDEzLCAyMCwgMTUsIDE4LCAxNiwgMTQsIDE2LCA5LCAxNSwgNCwgMTMsIDEsIDEwLCAwLCA4LCAwLCA1LCAxLCA0LCAzXV0sXG4gICAgXCI6XCI6IFsxMCwgWzUsIDE0LCA0LCAxMywgNSwgMTIsIDYsIDEzLCA1LCAxNCwgLTEsIC0xLCA1LCAyLCA0LCAxLCA1LCAwLCA2LCAxLCA1LCAyXV0sXG4gICAgXCI7XCI6IFsxMCwgWzUsIDE0LCA0LCAxMywgNSwgMTIsIDYsIDEzLCA1LCAxNCwgLTEsIC0xLCA2LCAxLCA1LCAwLCA0LCAxLCA1LCAyLCA2LCAxLCA2LCAtMSwgNSwgLTMsIDQsIC00XV0sXG4gICAgXCI8XCI6IFsyNCwgWzIwLCAxOCwgNCwgOSwgMjAsIDBdXSxcbiAgICBcIj1cIjogWzI2LCBbNCwgMTIsIDIyLCAxMiwgLTEsIC0xLCA0LCA2LCAyMiwgNl1dLFxuICAgIFwiPlwiOiBbMjQsIFs0LCAxOCwgMjAsIDksIDQsIDBdXSxcbiAgICBcIj9cIjogWzE4LCBbMywgMTYsIDMsIDE3LCA0LCAxOSwgNSwgMjAsIDcsIDIxLCAxMSwgMjEsIDEzLCAyMCwgMTQsIDE5LCAxNSwgMTcsIDE1LCAxNSwgMTQsIDEzLCAxMywgMTIsIDksIDEwLCA5LCA3LCAtMSwgLTEsIDksIDIsIDgsIDEsIDksIDAsIDEwLCAxLCA5LCAyXV0sXG4gICAgXCJAXCI6IFsyNywgWzE4LCAxMywgMTcsIDE1LCAxNSwgMTYsIDEyLCAxNiwgMTAsIDE1LCA5LCAxNCwgOCwgMTEsIDgsIDgsIDksIDYsIDExLCA1LCAxNCwgNSwgMTYsIDYsIDE3LCA4LCAtMSwgLTEsIDEyLCAxNiwgMTAsIDE0LCA5LCAxMSwgOSwgOCwgMTAsIDYsIDExLCA1LCAtMSwgLTEsIDE4LCAxNiwgMTcsIDgsIDE3LCA2LCAxOSwgNSwgMjEsIDUsIDIzLCA3LCAyNCwgMTAsIDI0LCAxMiwgMjMsIDE1LCAyMiwgMTcsIDIwLCAxOSwgMTgsIDIwLCAxNSwgMjEsIDEyLCAyMSwgOSwgMjAsIDcsIDE5LCA1LCAxNywgNCwgMTUsIDMsIDEyLCAzLCA5LCA0LCA2LCA1LCA0LCA3LCAyLCA5LCAxLCAxMiwgMCwgMTUsIDAsIDE4LCAxLCAyMCwgMiwgMjEsIDMsIC0xLCAtMSwgMTksIDE2LCAxOCwgOCwgMTgsIDYsIDE5LCA1XV0sXG4gICAgXCJBXCI6IFsxOCwgWzksIDIxLCAxLCAwLCAtMSwgLTEsIDksIDIxLCAxNywgMCwgLTEsIC0xLCA0LCA3LCAxNCwgN11dLFxuICAgIFwiQlwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTUsIDE3LCAxMywgMTYsIDEyLCAxMywgMTEsIC0xLCAtMSwgNCwgMTEsIDEzLCAxMSwgMTYsIDEwLCAxNywgOSwgMTgsIDcsIDE4LCA0LCAxNywgMiwgMTYsIDEsIDEzLCAwLCA0LCAwXV0sXG4gICAgXCJDXCI6IFsyMSwgWzE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNV1dLFxuICAgIFwiRFwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTEsIDIxLCAxNCwgMjAsIDE2LCAxOCwgMTcsIDE2LCAxOCwgMTMsIDE4LCA4LCAxNywgNSwgMTYsIDMsIDE0LCAxLCAxMSwgMCwgNCwgMF1dLFxuICAgIFwiRVwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTcsIDIxLCAtMSwgLTEsIDQsIDExLCAxMiwgMTEsIC0xLCAtMSwgNCwgMCwgMTcsIDBdXSxcbiAgICBcIkZcIjogWzE4LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDE3LCAyMSwgLTEsIC0xLCA0LCAxMSwgMTIsIDExXV0sXG4gICAgXCJHXCI6IFsyMSwgWzE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTgsIDgsIC0xLCAtMSwgMTMsIDgsIDE4LCA4XV0sXG4gICAgXCJIXCI6IFsyMiwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE4LCAyMSwgMTgsIDAsIC0xLCAtMSwgNCwgMTEsIDE4LCAxMV1dLFxuICAgIFwiSVwiOiBbOCwgWzQsIDIxLCA0LCAwXV0sXG4gICAgXCJKXCI6IFsxNiwgWzEyLCAyMSwgMTIsIDUsIDExLCAyLCAxMCwgMSwgOCwgMCwgNiwgMCwgNCwgMSwgMywgMiwgMiwgNSwgMiwgN11dLFxuICAgIFwiS1wiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCAxOCwgMjEsIDQsIDcsIC0xLCAtMSwgOSwgMTIsIDE4LCAwXV0sXG4gICAgXCJMXCI6IFsxNywgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDAsIDE2LCAwXV0sXG4gICAgXCJNXCI6IFsyNCwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMiwgMCwgLTEsIC0xLCAyMCwgMjEsIDEyLCAwLCAtMSwgLTEsIDIwLCAyMSwgMjAsIDBdXSxcbiAgICBcIk5cIjogWzIyLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDE4LCAwLCAtMSwgLTEsIDE4LCAyMSwgMTgsIDBdXSxcbiAgICBcIk9cIjogWzIyLCBbOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTksIDgsIDE5LCAxMywgMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMV1dLFxuICAgIFwiUFwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTQsIDE3LCAxMiwgMTYsIDExLCAxMywgMTAsIDQsIDEwXV0sXG4gICAgXCJRXCI6IFsyMiwgWzksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDUsIDE5LCA4LCAxOSwgMTMsIDE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIC0xLCAtMSwgMTIsIDQsIDE4LCAtMl1dLFxuICAgIFwiUlwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTUsIDE3LCAxMywgMTYsIDEyLCAxMywgMTEsIDQsIDExLCAtMSwgLTEsIDExLCAxMSwgMTgsIDBdXSxcbiAgICBcIlNcIjogWzIwLCBbMTcsIDE4LCAxNSwgMjAsIDEyLCAyMSwgOCwgMjEsIDUsIDIwLCAzLCAxOCwgMywgMTYsIDQsIDE0LCA1LCAxMywgNywgMTIsIDEzLCAxMCwgMTUsIDksIDE2LCA4LCAxNywgNiwgMTcsIDMsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgMywgM11dLFxuICAgIFwiVFwiOiBbMTYsIFs4LCAyMSwgOCwgMCwgLTEsIC0xLCAxLCAyMSwgMTUsIDIxXV0sXG4gICAgXCJVXCI6IFsyMiwgWzQsIDIxLCA0LCA2LCA1LCAzLCA3LCAxLCAxMCwgMCwgMTIsIDAsIDE1LCAxLCAxNywgMywgMTgsIDYsIDE4LCAyMV1dLFxuICAgIFwiVlwiOiBbMTgsIFsxLCAyMSwgOSwgMCwgLTEsIC0xLCAxNywgMjEsIDksIDBdXSxcbiAgICBcIldcIjogWzI0LCBbMiwgMjEsIDcsIDAsIC0xLCAtMSwgMTIsIDIxLCA3LCAwLCAtMSwgLTEsIDEyLCAyMSwgMTcsIDAsIC0xLCAtMSwgMjIsIDIxLCAxNywgMF1dLFxuICAgIFwiWFwiOiBbMjAsIFszLCAyMSwgMTcsIDAsIC0xLCAtMSwgMTcsIDIxLCAzLCAwXV0sXG4gICAgXCJZXCI6IFsxOCwgWzEsIDIxLCA5LCAxMSwgOSwgMCwgLTEsIC0xLCAxNywgMjEsIDksIDExXV0sXG4gICAgXCJaXCI6IFsyMCwgWzE3LCAyMSwgMywgMCwgLTEsIC0xLCAzLCAyMSwgMTcsIDIxLCAtMSwgLTEsIDMsIDAsIDE3LCAwXV0sXG4gICAgXCJbXCI6IFsxNCwgWzQsIDI1LCA0LCAtNywgLTEsIC0xLCA1LCAyNSwgNSwgLTcsIC0xLCAtMSwgNCwgMjUsIDExLCAyNSwgLTEsIC0xLCA0LCAtNywgMTEsIC03XV0sXG4gICAgXCJcXFxcXCI6IFsxNCwgWzAsIDIxLCAxNCwgLTNdXSxcbiAgICBcIl1cIjogWzE0LCBbOSwgMjUsIDksIC03LCAtMSwgLTEsIDEwLCAyNSwgMTAsIC03LCAtMSwgLTEsIDMsIDI1LCAxMCwgMjUsIC0xLCAtMSwgMywgLTcsIDEwLCAtN11dLFxuICAgIFwiXlwiOiBbMTYsIFs2LCAxNSwgOCwgMTgsIDEwLCAxNSwgLTEsIC0xLCAzLCAxMiwgOCwgMTcsIDEzLCAxMiwgLTEsIC0xLCA4LCAxNywgOCwgMF1dLFxuICAgIFwiX1wiOiBbMTYsIFswLCAtMiwgMTYsIC0yXV0sXG4gICAgXCJgXCI6IFsxMCwgWzYsIDIxLCA1LCAyMCwgNCwgMTgsIDQsIDE2LCA1LCAxNSwgNiwgMTYsIDUsIDE3XV0sXG4gICAgXCJhXCI6IFsxOSwgWzE1LCAxNCwgMTUsIDAsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiYlwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAxMSwgNiwgMTMsIDgsIDE0LCAxMSwgMTQsIDEzLCAxMywgMTUsIDExLCAxNiwgOCwgMTYsIDYsIDE1LCAzLCAxMywgMSwgMTEsIDAsIDgsIDAsIDYsIDEsIDQsIDNdXSxcbiAgICBcImNcIjogWzE4LCBbMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiZFwiOiBbMTksIFsxNSwgMjEsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImVcIjogWzE4LCBbMywgOCwgMTUsIDgsIDE1LCAxMCwgMTQsIDEyLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiZlwiOiBbMTIsIFsxMCwgMjEsIDgsIDIxLCA2LCAyMCwgNSwgMTcsIDUsIDAsIC0xLCAtMSwgMiwgMTQsIDksIDE0XV0sXG4gICAgXCJnXCI6IFsxOSwgWzE1LCAxNCwgMTUsIC0yLCAxNCwgLTUsIDEzLCAtNiwgMTEsIC03LCA4LCAtNywgNiwgLTYsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiaFwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAxMCwgNywgMTMsIDksIDE0LCAxMiwgMTQsIDE0LCAxMywgMTUsIDEwLCAxNSwgMF1dLFxuICAgIFwiaVwiOiBbOCwgWzMsIDIxLCA0LCAyMCwgNSwgMjEsIDQsIDIyLCAzLCAyMSwgLTEsIC0xLCA0LCAxNCwgNCwgMF1dLFxuICAgIFwialwiOiBbMTAsIFs1LCAyMSwgNiwgMjAsIDcsIDIxLCA2LCAyMiwgNSwgMjEsIC0xLCAtMSwgNiwgMTQsIDYsIC0zLCA1LCAtNiwgMywgLTcsIDEsIC03XV0sXG4gICAgXCJrXCI6IFsxNywgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE0LCAxNCwgNCwgNCwgLTEsIC0xLCA4LCA4LCAxNSwgMF1dLFxuICAgIFwibFwiOiBbOCwgWzQsIDIxLCA0LCAwXV0sXG4gICAgXCJtXCI6IFszMCwgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMCwgMTgsIDEzLCAyMCwgMTQsIDIzLCAxNCwgMjUsIDEzLCAyNiwgMTAsIDI2LCAwXV0sXG4gICAgXCJuXCI6IFsxOSwgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwXV0sXG4gICAgXCJvXCI6IFsxOSwgWzgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDMsIDE2LCA2LCAxNiwgOCwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTRdXSxcbiAgICBcInBcIjogWzE5LCBbNCwgMTQsIDQsIC03LCAtMSwgLTEsIDQsIDExLCA2LCAxMywgOCwgMTQsIDExLCAxNCwgMTMsIDEzLCAxNSwgMTEsIDE2LCA4LCAxNiwgNiwgMTUsIDMsIDEzLCAxLCAxMSwgMCwgOCwgMCwgNiwgMSwgNCwgM11dLFxuICAgIFwicVwiOiBbMTksIFsxNSwgMTQsIDE1LCAtNywgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJyXCI6IFsxMywgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDgsIDUsIDExLCA3LCAxMywgOSwgMTQsIDEyLCAxNF1dLFxuICAgIFwic1wiOiBbMTcsIFsxNCwgMTEsIDEzLCAxMywgMTAsIDE0LCA3LCAxNCwgNCwgMTMsIDMsIDExLCA0LCA5LCA2LCA4LCAxMSwgNywgMTMsIDYsIDE0LCA0LCAxNCwgMywgMTMsIDEsIDEwLCAwLCA3LCAwLCA0LCAxLCAzLCAzXV0sXG4gICAgXCJ0XCI6IFsxMiwgWzUsIDIxLCA1LCA0LCA2LCAxLCA4LCAwLCAxMCwgMCwgLTEsIC0xLCAyLCAxNCwgOSwgMTRdXSxcbiAgICBcInVcIjogWzE5LCBbNCwgMTQsIDQsIDQsIDUsIDEsIDcsIDAsIDEwLCAwLCAxMiwgMSwgMTUsIDQsIC0xLCAtMSwgMTUsIDE0LCAxNSwgMF1dLFxuICAgIFwidlwiOiBbMTYsIFsyLCAxNCwgOCwgMCwgLTEsIC0xLCAxNCwgMTQsIDgsIDBdXSxcbiAgICBcIndcIjogWzIyLCBbMywgMTQsIDcsIDAsIC0xLCAtMSwgMTEsIDE0LCA3LCAwLCAtMSwgLTEsIDExLCAxNCwgMTUsIDAsIC0xLCAtMSwgMTksIDE0LCAxNSwgMF1dLFxuICAgIFwieFwiOiBbMTcsIFszLCAxNCwgMTQsIDAsIC0xLCAtMSwgMTQsIDE0LCAzLCAwXV0sXG4gICAgXCJ5XCI6IFsxNiwgWzIsIDE0LCA4LCAwLCAtMSwgLTEsIDE0LCAxNCwgOCwgMCwgNiwgLTQsIDQsIC02LCAyLCAtNywgMSwgLTddXSxcbiAgICBcInpcIjogWzE3LCBbMTQsIDE0LCAzLCAwLCAtMSwgLTEsIDMsIDE0LCAxNCwgMTQsIC0xLCAtMSwgMywgMCwgMTQsIDBdXSxcbiAgICBcIntcIjogWzE0LCBbOSwgMjUsIDcsIDI0LCA2LCAyMywgNSwgMjEsIDUsIDE5LCA2LCAxNywgNywgMTYsIDgsIDE0LCA4LCAxMiwgNiwgMTAsIC0xLCAtMSwgNywgMjQsIDYsIDIyLCA2LCAyMCwgNywgMTgsIDgsIDE3LCA5LCAxNSwgOSwgMTMsIDgsIDExLCA0LCA5LCA4LCA3LCA5LCA1LCA5LCAzLCA4LCAxLCA3LCAwLCA2LCAtMiwgNiwgLTQsIDcsIC02LCAtMSwgLTEsIDYsIDgsIDgsIDYsIDgsIDQsIDcsIDIsIDYsIDEsIDUsIC0xLCA1LCAtMywgNiwgLTUsIDcsIC02LCA5LCAtN11dLFxuICAgIFwifFwiOiBbOCwgWzQsIDI1LCA0LCAtN11dLFxuICAgIFwifVwiOiBbMTQsIFs1LCAyNSwgNywgMjQsIDgsIDIzLCA5LCAyMSwgOSwgMTksIDgsIDE3LCA3LCAxNiwgNiwgMTQsIDYsIDEyLCA4LCAxMCwgLTEsIC0xLCA3LCAyNCwgOCwgMjIsIDgsIDIwLCA3LCAxOCwgNiwgMTcsIDUsIDE1LCA1LCAxMywgNiwgMTEsIDEwLCA5LCA2LCA3LCA1LCA1LCA1LCAzLCA2LCAxLCA3LCAwLCA4LCAtMiwgOCwgLTQsIDcsIC02LCAtMSwgLTEsIDgsIDgsIDYsIDYsIDYsIDQsIDcsIDIsIDgsIDEsIDksIC0xLCA5LCAtMywgOCwgLTUsIDcsIC02LCA1LCAtN11dLFxuICAgIFwiflwiOiBbMjQsIFszLCA2LCAzLCA4LCA0LCAxMSwgNiwgMTIsIDgsIDEyLCAxMCwgMTEsIDE0LCA4LCAxNiwgNywgMTgsIDcsIDIwLCA4LCAyMSwgMTAsIC0xLCAtMSwgMywgOCwgNCwgMTAsIDYsIDExLCA4LCAxMSwgMTAsIDEwLCAxNCwgNywgMTYsIDYsIDE4LCA2LCAyMCwgNywgMjEsIDEwLCAyMSwgMTJdXVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0VmVydGljZXModGV4dCwgbGVmdCwgYmFzZWxpbmUsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxO1xuXG4gICAgdmFyIHN0cm9rZXMgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBqLCBsZW4yLCBnbHlwaCwgeCwgeSwgcHJldjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZ2x5cGggPSBzaW1wbGV4Rm9udFt0ZXh0W2ldXTtcbiAgICAgICAgaWYgKCFnbHlwaCkgY29udGludWU7XG4gICAgICAgIHByZXYgPSBudWxsO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjIgPSBnbHlwaFsxXS5sZW5ndGg7IGogPCBsZW4yOyBqICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChnbHlwaFsxXVtqXSA9PT0gLTEgJiYgZ2x5cGhbMV1baiArIDFdID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBudWxsO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBsZWZ0ICsgZ2x5cGhbMV1bal0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICB5ID0gYmFzZWxpbmUgLSBnbHlwaFsxXVtqICsgMV0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VzLnB1c2gocHJldi54LCBwcmV2LnksIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ID0ge3g6IHgsIHk6IHl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlZnQgKz0gZ2x5cGhbMF0gKiBzY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Ryb2tlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogbWFwYm94Z2wgaXMgYSBBIFdlYkdMIEphdmFTY3JpcHQgaW50ZXJhY3RpdmUgbWFwcyBsaWJyYXJ5IHRoYXQgY2FuIHJlbmRlclxuICogW01hcGJveCB2ZWN0b3IgdGlsZXNdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vYmxvZy92ZWN0b3ItdGlsZXMvKS5cbiAqXG4gKiBAbW9kdWxlIG1hcGJveGdsXG4gKiBAc3VtbWFyeSBXZWJHTCBKYXZhU2NyaXB0IG1hcCBsaWJyYXJ5XG4gKi9cblxuLy8ganNoaW50IC1XMDc5XG52YXIgbWFwYm94Z2wgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5tYXBib3hnbC5NYXAgPSByZXF1aXJlKCcuL3VpL21hcCcpO1xubWFwYm94Z2wuTmF2aWdhdGlvbiA9IHJlcXVpcmUoJy4vdWkvY29udHJvbC9uYXZpZ2F0aW9uJyk7XG5tYXBib3hnbC5BdHRyaWJ1dGlvbiA9IHJlcXVpcmUoJy4vdWkvY29udHJvbC9hdHRyaWJ1dGlvbicpO1xubWFwYm94Z2wuUG9wdXAgPSByZXF1aXJlKCcuL3VpL3BvcHVwJyk7XG5cbm1hcGJveGdsLkdlb0pTT05Tb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS9nZW9qc29uX3NvdXJjZScpO1xubWFwYm94Z2wuVmlkZW9Tb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZS92aWRlb19zb3VyY2UnKTtcblxubWFwYm94Z2wuU3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlL3N0eWxlJyk7XG5cbm1hcGJveGdsLkxhdExuZyA9IHJlcXVpcmUoJy4vZ2VvL2xhdF9sbmcnKTtcbm1hcGJveGdsLkxhdExuZ0JvdW5kcyA9IHJlcXVpcmUoJy4vZ2VvL2xhdF9sbmdfYm91bmRzJyk7XG5tYXBib3hnbC5Qb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1hcGJveGdsLkV2ZW50ZWQgPSByZXF1aXJlKCcuL3V0aWwvZXZlbnRlZCcpO1xubWFwYm94Z2wudXRpbCA9IHJlcXVpcmUoJy4vdXRpbC91dGlsJyk7XG5cbm1hcGJveGdsLnN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vdXRpbC9icm93c2VyJykuc3VwcG9ydGVkO1xuXG52YXIgYWpheCA9IHJlcXVpcmUoJy4vdXRpbC9hamF4Jyk7XG5tYXBib3hnbC51dGlsLmdldEpTT04gPSBhamF4LmdldEpTT047XG5tYXBib3hnbC51dGlsLmdldEFycmF5QnVmZmVyID0gYWpheC5nZXRBcnJheUJ1ZmZlcjtcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vdXRpbC9jb25maWcnKTtcbm1hcGJveGdsLmNvbmZpZyA9IGNvbmZpZztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcGJveGdsLCAnYWNjZXNzVG9rZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbmZpZy5BQ0NFU1NfVE9LRU47IH0sXG4gICAgc2V0OiBmdW5jdGlvbih0b2tlbikgeyBjb25maWcuQUNDRVNTX1RPS0VOID0gdG9rZW47IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0MyA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDM7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0JhY2tncm91bmQ7XG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIHZhciBjb2xvciA9IGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLWNvbG9yJ107XG4gICAgdmFyIGltYWdlID0gbGF5ZXIucGFpbnRbJ2JhY2tncm91bmQtaW1hZ2UnXTtcbiAgICB2YXIgb3BhY2l0eSA9IGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLW9wYWNpdHknXTtcbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgdmFyIGltYWdlUG9zQSA9IGltYWdlID8gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKSA6IG51bGw7XG4gICAgdmFyIGltYWdlUG9zQiA9IGltYWdlID8gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSkgOiBudWxsO1xuXG4gICAgaWYgKGltYWdlUG9zQSAmJiBpbWFnZVBvc0IpIHtcbiAgICAgICAgLy8gRHJhdyB0ZXh0dXJlIGZpbGxcbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5wYXR0ZXJuU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfaW1hZ2UsIDApO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fdGxfYSwgaW1hZ2VQb3NBLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyX2EsIGltYWdlUG9zQS5icik7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bF9iLCBpbWFnZVBvc0IudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fYnJfYiwgaW1hZ2VQb3NCLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X29wYWNpdHksIG9wYWNpdHkpO1xuXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBwYWludGVyLnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIHNpemVBID0gaW1hZ2VQb3NBLnNpemU7XG4gICAgICAgIHZhciBzaXplQiA9IGltYWdlUG9zQi5zaXplO1xuICAgICAgICB2YXIgY2VudGVyID0gdHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZSh0cmFuc2Zvcm0uY2VudGVyKTtcbiAgICAgICAgdmFyIHNjYWxlID0gMSAvIE1hdGgucG93KDIsIHRyYW5zZm9ybS56b29tRnJhY3Rpb24pO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taXgsIGltYWdlLnQpO1xuXG4gICAgICAgIHZhciBtYXRyaXhBID0gbWF0My5jcmVhdGUoKTtcbiAgICAgICAgbWF0My5zY2FsZShtYXRyaXhBLCBtYXRyaXhBLCBbXG4gICAgICAgICAgICAxIC8gKHNpemVBWzBdICogaW1hZ2UuZnJvbVNjYWxlKSxcbiAgICAgICAgICAgIDEgLyAoc2l6ZUFbMV0gKiBpbWFnZS5mcm9tU2NhbGUpXG4gICAgICAgIF0pO1xuICAgICAgICBtYXQzLnRyYW5zbGF0ZShtYXRyaXhBLCBtYXRyaXhBLCBbXG4gICAgICAgICAgICAoY2VudGVyLmNvbHVtbiAqIHRyYW5zZm9ybS50aWxlU2l6ZSkgJSAoc2l6ZUFbMF0gKiBpbWFnZS5mcm9tU2NhbGUpLFxuICAgICAgICAgICAgKGNlbnRlci5yb3cgICAgKiB0cmFuc2Zvcm0udGlsZVNpemUpICUgKHNpemVBWzFdICogaW1hZ2UuZnJvbVNjYWxlKVxuICAgICAgICBdKTtcbiAgICAgICAgbWF0My5yb3RhdGUobWF0cml4QSwgbWF0cml4QSwgLXRyYW5zZm9ybS5hbmdsZSk7XG4gICAgICAgIG1hdDMuc2NhbGUobWF0cml4QSwgbWF0cml4QSwgW1xuICAgICAgICAgICAgc2NhbGUgKiB0cmFuc2Zvcm0ud2lkdGggIC8gMixcbiAgICAgICAgICAgLXNjYWxlICogdHJhbnNmb3JtLmhlaWdodCAvIDJcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIG1hdHJpeEIgPSBtYXQzLmNyZWF0ZSgpO1xuICAgICAgICBtYXQzLnNjYWxlKG1hdHJpeEIsIG1hdHJpeEIsIFtcbiAgICAgICAgICAgIDEgLyAoc2l6ZUJbMF0gKiBpbWFnZS50b1NjYWxlKSxcbiAgICAgICAgICAgIDEgLyAoc2l6ZUJbMV0gKiBpbWFnZS50b1NjYWxlKVxuICAgICAgICBdKTtcbiAgICAgICAgbWF0My50cmFuc2xhdGUobWF0cml4QiwgbWF0cml4QiwgW1xuICAgICAgICAgICAgKGNlbnRlci5jb2x1bW4gKiB0cmFuc2Zvcm0udGlsZVNpemUpICUgKHNpemVCWzBdICogaW1hZ2UudG9TY2FsZSksXG4gICAgICAgICAgICAoY2VudGVyLnJvdyAgICAqIHRyYW5zZm9ybS50aWxlU2l6ZSkgJSAoc2l6ZUJbMV0gKiBpbWFnZS50b1NjYWxlKVxuICAgICAgICBdKTtcbiAgICAgICAgbWF0My5yb3RhdGUobWF0cml4QiwgbWF0cml4QiwgLXRyYW5zZm9ybS5hbmdsZSk7XG4gICAgICAgIG1hdDMuc2NhbGUobWF0cml4QiwgbWF0cml4QiwgW1xuICAgICAgICAgICAgc2NhbGUgKiB0cmFuc2Zvcm0ud2lkdGggIC8gMixcbiAgICAgICAgICAgLXNjYWxlICogdHJhbnNmb3JtLmhlaWdodCAvIDJcbiAgICAgICAgXSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudV9wYXR0ZXJubWF0cml4X2EsIGZhbHNlLCBtYXRyaXhBKTtcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudV9wYXR0ZXJubWF0cml4X2IsIGZhbHNlLCBtYXRyaXhCKTtcblxuICAgICAgICBwYWludGVyLnNwcml0ZUF0bGFzLmJpbmQoZ2wsIHRydWUpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBmaWxsaW5nIHJlY3RhbmdsZS5cbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5maWxsU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyLmFfY29sb3IpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0ZnYoc2hhZGVyLmFfY29sb3IsIGNvbG9yKTtcbiAgICB9XG5cbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIuYmFja2dyb3VuZEJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsIHBhaW50ZXIuYmFja2dyb3VuZEJ1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCBwYWludGVyLmJhY2tncm91bmRCdWZmZXIuaXRlbUNvdW50KTtcbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4MDApO1xuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweDgwLCAweDgwKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3UGxhY2VtZW50RGVidWc7XG5cbmZ1bmN0aW9uIGRyYXdQbGFjZW1lbnREZWJ1ZyhwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlKSB7XG5cbiAgICB2YXIgZWxlbWVudEdyb3VwcyA9IHRpbGUuZWxlbWVudEdyb3Vwc1tsYXllci5yZWYgfHwgbGF5ZXIuaWRdLmNvbGxpc2lvbkJveDtcbiAgICBpZiAoIWVsZW1lbnRHcm91cHMpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG4gICAgdmFyIGJ1ZmZlciA9IHRpbGUuYnVmZmVycy5jb2xsaXNpb25Cb3hWZXJ0ZXg7XG4gICAgdmFyIHNoYWRlciA9IHBhaW50ZXIuY29sbGlzaW9uQm94U2hhZGVyO1xuXG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuICAgIGJ1ZmZlci5iaW5kKGdsLCBzaGFkZXIpO1xuICAgIGdsLmxpbmVXaWR0aCgxKTtcblxuICAgIHZhciBzdHJpZGUgPSAxMjtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCBzdHJpZGUsIDApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfZXh0cnVkZSwgMiwgZ2wuU0hPUlQsIGZhbHNlLCBzdHJpZGUsIDQpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfZGF0YSwgMiwgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIHN0cmlkZSwgOCk7XG5cbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfc2NhbGUsIE1hdGgucG93KDIsIHBhaW50ZXIudHJhbnNmb3JtLnpvb20gLSB0aWxlLmNvb3JkLnopKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfem9vbSwgcGFpbnRlci50cmFuc2Zvcm0uem9vbSAqIDEwKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfbWF4em9vbSwgKHRpbGUuY29vcmQueiArIDEpICogMTApO1xuXG4gICAgdmFyIGJlZ2luID0gZWxlbWVudEdyb3Vwcy5ncm91cHNbMF0udmVydGV4U3RhcnRJbmRleDtcbiAgICB2YXIgbGVuID0gZWxlbWVudEdyb3Vwcy5ncm91cHNbMF0udmVydGV4TGVuZ3RoO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIGJlZ2luLCBsZW4pO1xuXG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGV4dFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vbGliL2RlYnVndGV4dCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3RGVidWc7XG5cbmZ1bmN0aW9uIGRyYXdEZWJ1ZyhwYWludGVyLCB0aWxlKSB7XG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIC8vIEJsZW5kIHRvIHRoZSBmcm9udCwgbm90IHRoZSBiYWNrLlxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG4gICAgZ2wuc3dpdGNoU2hhZGVyKHBhaW50ZXIuZGVidWdTaGFkZXIsIHRpbGUucG9zTWF0cml4KTtcblxuICAgIC8vIGRyYXcgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIuZGVidWdCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5kZWJ1Z1NoYWRlci5hX3BvcywgcGFpbnRlci5kZWJ1Z0J1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC51bmlmb3JtNGYocGFpbnRlci5kZWJ1Z1NoYWRlci51X2NvbG9yLCAxLCAwLCAwLCAxKTtcbiAgICBnbC5saW5lV2lkdGgoNCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FX1NUUklQLCAwLCBwYWludGVyLmRlYnVnQnVmZmVyLml0ZW1Db3VudCk7XG5cbiAgICB2YXIgdmVydGljZXMgPSB0ZXh0VmVydGljZXModGlsZS5jb29yZC50b1N0cmluZygpLCA1MCwgMjAwLCA1KTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLmRlYnVnVGV4dEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KHZlcnRpY2VzKSwgZ2wuU1RSRUFNX0RSQVcpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5kZWJ1Z1NoYWRlci5hX3BvcywgcGFpbnRlci5kZWJ1Z1RleHRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wubGluZVdpZHRoKDggKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIGdsLnVuaWZvcm00ZihwYWludGVyLmRlYnVnU2hhZGVyLnVfY29sb3IsIDEsIDEsIDEsIDEpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIHZlcnRpY2VzLmxlbmd0aCAvIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplKTtcbiAgICBnbC5saW5lV2lkdGgoMiAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgZ2wudW5pZm9ybTRmKHBhaW50ZXIuZGVidWdTaGFkZXIudV9jb2xvciwgMCwgMCwgMCwgMSk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUywgMCwgdmVydGljZXMubGVuZ3RoIC8gcGFpbnRlci5kZWJ1Z1RleHRCdWZmZXIuaXRlbVNpemUpO1xuXG4gICAgLy8gUmV2ZXJ0IGJsZW5kaW5nIG1vZGUgdG8gYmxlbmQgdG8gdGhlIGJhY2suXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgbWF0MyA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDM7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0ZpbGw7XG5cbmZ1bmN0aW9uIGRyYXdGaWxsKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgsIHRpbGUpIHtcbiAgICAvLyBObyBkYXRhXG4gICAgaWYgKCF0aWxlLmJ1ZmZlcnMpIHJldHVybjtcbiAgICB2YXIgZWxlbWVudEdyb3VwcyA9IHRpbGUuZWxlbWVudEdyb3Vwc1tsYXllci5yZWYgfHwgbGF5ZXIuaWRdO1xuICAgIGlmICghZWxlbWVudEdyb3VwcykgcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcbiAgICB2YXIgdHJhbnNsYXRlZFBvc01hdHJpeCA9IHBhaW50ZXIudHJhbnNsYXRlTWF0cml4KHBvc01hdHJpeCwgdGlsZSwgbGF5ZXIucGFpbnRbJ2ZpbGwtdHJhbnNsYXRlJ10sIGxheWVyLnBhaW50WydmaWxsLXRyYW5zbGF0ZS1hbmNob3InXSk7XG5cbiAgICB2YXIgY29sb3IgPSBsYXllci5wYWludFsnZmlsbC1jb2xvciddO1xuXG4gICAgdmFyIHZlcnRleCwgZWxlbWVudHMsIGdyb3VwLCBjb3VudDtcblxuICAgIC8vIERyYXcgdGhlIHN0ZW5jaWwgbWFzay5cblxuICAgIC8vIFdlJ3JlIG9ubHkgZHJhd2luZyB0byB0aGUgZmlyc3Qgc2V2ZW4gYml0cyAoPT0gc3VwcG9ydCBhIG1heGltdW0gb2ZcbiAgICAvLyAxMjcgb3ZlcmxhcHBpbmcgcG9seWdvbnMgaW4gb25lIHBsYWNlIGJlZm9yZSB3ZSBnZXQgcmVuZGVyaW5nIGVycm9ycykuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHgzRik7XG4gICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcblxuICAgIC8vIERyYXcgZnJvbnQgZmFjaW5nIHRyaWFuZ2xlcy4gV2hlcmV2ZXIgdGhlIDB4ODAgYml0IGlzIDEsIHdlIGFyZVxuICAgIC8vIGluY3JlYXNpbmcgdGhlIGxvd2VyIDcgYml0cyBieSBvbmUgaWYgdGhlIHRyaWFuZ2xlIGlzIGEgZnJvbnQtZmFjaW5nXG4gICAgLy8gdHJpYW5nbGUuIFRoaXMgbWVhbnMgdGhhdCBhbGwgdmlzaWJsZSBwb2x5Z29ucyBzaG91bGQgYmUgaW4gQ0NXXG4gICAgLy8gb3JpZW50YXRpb24sIHdoaWxlIGFsbCBob2xlcyAoc2VlIGJlbG93KSBhcmUgaW4gQ1cgb3JpZW50YXRpb24uXG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuTk9URVFVQUwsIDB4ODAsIDB4ODApO1xuXG4gICAgLy8gV2hlbiB3ZSBkbyBhIG5vbnplcm8gZmlsbCwgd2UgY291bnQgdGhlIG51bWJlciBvZiB0aW1lcyBhIHBpeGVsIGlzXG4gICAgLy8gY292ZXJlZCBieSBhIGNvdW50ZXJjbG9ja3dpc2UgcG9seWdvbiwgYW5kIHN1YnRyYWN0IHRoZSBudW1iZXIgb2ZcbiAgICAvLyB0aW1lcyBpdCBpcyBcInVuY292ZXJlZFwiIGJ5IGEgY2xvY2t3aXNlIHBvbHlnb24uXG4gICAgZ2wuc3RlbmNpbE9wU2VwYXJhdGUoZ2wuRlJPTlQsIGdsLklOQ1JfV1JBUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gICAgZ2wuc3RlbmNpbE9wU2VwYXJhdGUoZ2wuQkFDSywgZ2wuREVDUl9XUkFQLCBnbC5LRUVQLCBnbC5LRUVQKTtcblxuICAgIC8vIFdoZW4gZHJhd2luZyBhIHNoYXBlLCB3ZSBmaXJzdCBkcmF3IGFsbCBzaGFwZXMgdG8gdGhlIHN0ZW5jaWwgYnVmZmVyXG4gICAgLy8gYW5kIGluY3JlbWVudGluZyBhbGwgYXJlYXMgd2hlcmUgcG9seWdvbnMgYXJlXG4gICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIC8vIERyYXcgdGhlIGFjdHVhbCB0cmlhbmdsZSBmYW4gaW50byB0aGUgc3RlbmNpbCBidWZmZXIuXG4gICAgZ2wuc3dpdGNoU2hhZGVyKHBhaW50ZXIuZmlsbFNoYWRlciwgdHJhbnNsYXRlZFBvc01hdHJpeCk7XG5cbiAgICAvLyBEcmF3IGFsbCBidWZmZXJzXG4gICAgdmVydGV4ID0gdGlsZS5idWZmZXJzLmZpbGxWZXJ0ZXg7XG4gICAgdmVydGV4LmJpbmQoZ2wpO1xuICAgIGVsZW1lbnRzID0gdGlsZS5idWZmZXJzLmZpbGxFbGVtZW50O1xuICAgIGVsZW1lbnRzLmJpbmQoZ2wpO1xuXG4gICAgdmFyIG9mZnNldCwgZWxlbWVudE9mZnNldDtcblxuICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShwYWludGVyLmZpbGxTaGFkZXIuYV9jb2xvcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRHcm91cHMuZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZWxlbWVudEdyb3Vwcy5ncm91cHNbaV07XG4gICAgICAgIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5maWxsU2hhZGVyLmFfcG9zLCAyLCBnbC5TSE9SVCwgZmFsc2UsIDQsIG9mZnNldCArIDApO1xuXG4gICAgICAgIGNvdW50ID0gZ3JvdXAuZWxlbWVudExlbmd0aCAqIDM7XG4gICAgICAgIGVsZW1lbnRPZmZzZXQgPSBncm91cC5lbGVtZW50U3RhcnRJbmRleCAqIGVsZW1lbnRzLml0ZW1TaXplO1xuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgdGhlIHN0ZW5jaWwgbWFzayBpbiB0aGUgc3RlbmNpbCBidWZmZXIsIHdlIGNhbiBzdGFydFxuICAgIC8vIHdyaXRpbmcgdG8gdGhlIGNvbG9yIGJ1ZmZlci5cbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAvLyBGcm9tIG5vdyBvbiwgd2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgdGhlIHN0ZW5jaWwgYnVmZmVyIGFueW1vcmUuXG4gICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLktFRVApO1xuICAgIGdsLnN0ZW5jaWxNYXNrKDB4MCk7XG5cbiAgICB2YXIgc3Ryb2tlQ29sb3IgPSBsYXllci5wYWludFsnZmlsbC1vdXRsaW5lLWNvbG9yJ107XG5cbiAgICAvLyBCZWNhdXNlIHdlJ3JlIGRyYXdpbmcgdG9wLXRvLWJvdHRvbSwgYW5kIHdlIHVwZGF0ZSB0aGUgc3RlbmNpbCBtYXNrXG4gICAgLy8gYmVsb3csIHdlIGhhdmUgdG8gZHJhdyB0aGUgb3V0bGluZSBmaXJzdCAoISlcbiAgICBpZiAobGF5ZXIucGFpbnRbJ2ZpbGwtYW50aWFsaWFzJ10gPT09IHRydWUgJiYgIShsYXllci5wYWludFsnZmlsbC1pbWFnZSddICYmICFzdHJva2VDb2xvcikpIHtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHBhaW50ZXIub3V0bGluZVNoYWRlciwgdHJhbnNsYXRlZFBvc01hdHJpeCk7XG4gICAgICAgIGdsLmxpbmVXaWR0aCgyICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgICBpZiAoc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRlZmluZWQgYSBkaWZmZXJlbnQgY29sb3IgZm9yIHRoZSBmaWxsIG91dGxpbmUsIHdlIGFyZVxuICAgICAgICAgICAgLy8gZ29pbmcgdG8gaWdub3JlIHRoZSBiaXRzIGluIDB4M0YgYW5kIGp1c3QgY2FyZSBhYm91dCB0aGUgZ2xvYmFsXG4gICAgICAgICAgICAvLyBjbGlwcGluZyBtYXNrLlxuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBvbmx5IHdhbnQgdG8gZHJhdyB0aGUgYW50aWFsaWFzZWQgcGFydHMgdGhhdCBhcmVcbiAgICAgICAgICAgIC8vICpvdXRzaWRlKiB0aGUgY3VycmVudCBzaGFwZS4gVGhpcyBpcyBpbXBvcnRhbnQgaW4gY2FzZSB0aGUgZmlsbFxuICAgICAgICAgICAgLy8gb3Igc3Ryb2tlIGNvbG9yIGlzIHRyYW5zbHVjZW50LiBJZiB3ZSB3b3VsZG4ndCBjbGlwIHRvIG91dHNpZGVcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHNoYXBlLCBzb21lIHBpeGVscyBmcm9tIHRoZSBvdXRsaW5lIHN0cm9rZSBvdmVybGFwcGVkXG4gICAgICAgICAgICAvLyB0aGUgKG5vbi1hbnRpYWxpYXNlZCkgZmlsbC5cbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweDgwLCAweEJGKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnVuaWZvcm0yZihwYWludGVyLm91dGxpbmVTaGFkZXIudV93b3JsZCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcblxuICAgICAgICAvLyBEcmF3IGFsbCBidWZmZXJzXG4gICAgICAgIHZlcnRleCA9IHRpbGUuYnVmZmVycy5maWxsVmVydGV4O1xuICAgICAgICBlbGVtZW50cyA9IHRpbGUuYnVmZmVycy5vdXRsaW5lRWxlbWVudDtcbiAgICAgICAgZWxlbWVudHMuYmluZChnbCk7XG5cbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHBhaW50ZXIub3V0bGluZVNoYWRlci5hX2NvbG9yKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliNGZ2KHBhaW50ZXIub3V0bGluZVNoYWRlci5hX2NvbG9yLCBzdHJva2VDb2xvciA/IHN0cm9rZUNvbG9yIDogY29sb3IpO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZWxlbWVudEdyb3Vwcy5ncm91cHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gZWxlbWVudEdyb3Vwcy5ncm91cHNba107XG4gICAgICAgICAgICBvZmZzZXQgPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4ICogdmVydGV4Lml0ZW1TaXplO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwYWludGVyLm91dGxpbmVTaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgNCwgb2Zmc2V0ICsgMCk7XG5cbiAgICAgICAgICAgIGNvdW50ID0gZ3JvdXAuc2Vjb25kRWxlbWVudExlbmd0aCAqIDI7XG4gICAgICAgICAgICBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuc2Vjb25kRWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50cy5pdGVtU2l6ZTtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5MSU5FUywgY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCBlbGVtZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IGxheWVyLnBhaW50WydmaWxsLWltYWdlJ107XG4gICAgdmFyIG9wYWNpdHkgPSBsYXllci5wYWludFsnZmlsbC1vcGFjaXR5J10gfHwgMTtcbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgaWYgKGltYWdlKSB7XG4gICAgICAgIC8vIERyYXcgdGV4dHVyZSBmaWxsXG4gICAgICAgIHZhciBpbWFnZVBvc0EgPSBwYWludGVyLnNwcml0ZUF0bGFzLmdldFBvc2l0aW9uKGltYWdlLmZyb20sIHRydWUpO1xuICAgICAgICB2YXIgaW1hZ2VQb3NCID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSk7XG4gICAgICAgIGlmICghaW1hZ2VQb3NBIHx8ICFpbWFnZVBvc0IpIHJldHVybjtcblxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLnBhdHRlcm5TaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZSwgMCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bF9hLCBpbWFnZVBvc0EudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fYnJfYSwgaW1hZ2VQb3NBLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsX2IsIGltYWdlUG9zQi50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9icl9iLCBpbWFnZVBvc0IuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taXgsIGltYWdlLnQpO1xuXG4gICAgICAgIHZhciBmYWN0b3IgPSAodGlsZS50aWxlRXh0ZW50IC8gdGlsZS50aWxlU2l6ZSkgLyBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSAtIHRpbGUuY29vcmQueik7XG5cbiAgICAgICAgdmFyIG1hdHJpeEEgPSBtYXQzLmNyZWF0ZSgpO1xuICAgICAgICBtYXQzLnNjYWxlKG1hdHJpeEEsIG1hdHJpeEEsIFtcbiAgICAgICAgICAgIDEgLyAoaW1hZ2VQb3NBLnNpemVbMF0gKiBmYWN0b3IgKiBpbWFnZS5mcm9tU2NhbGUpLFxuICAgICAgICAgICAgMSAvIChpbWFnZVBvc0Euc2l6ZVsxXSAqIGZhY3RvciAqIGltYWdlLmZyb21TY2FsZSlcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIG1hdHJpeEIgPSBtYXQzLmNyZWF0ZSgpO1xuICAgICAgICBtYXQzLnNjYWxlKG1hdHJpeEIsIG1hdHJpeEIsIFtcbiAgICAgICAgICAgIDEgLyAoaW1hZ2VQb3NCLnNpemVbMF0gKiBmYWN0b3IgKiBpbWFnZS50b1NjYWxlKSxcbiAgICAgICAgICAgIDEgLyAoaW1hZ2VQb3NCLnNpemVbMV0gKiBmYWN0b3IgKiBpbWFnZS50b1NjYWxlKVxuICAgICAgICBdKTtcblxuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci51X3BhdHRlcm5tYXRyaXhfYSwgZmFsc2UsIG1hdHJpeEEpO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci51X3BhdHRlcm5tYXRyaXhfYiwgZmFsc2UsIG1hdHJpeEIpO1xuXG4gICAgICAgIHBhaW50ZXIuc3ByaXRlQXRsYXMuYmluZChnbCwgdHJ1ZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEcmF3IGZpbGxpbmcgcmVjdGFuZ2xlLlxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmZpbGxTaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCk7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXIuYV9jb2xvcik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjRmdihzaGFkZXIuYV9jb2xvciwgY29sb3IpO1xuICAgIH1cblxuICAgIC8vIE9ubHkgZHJhdyByZWdpb25zIHRoYXQgd2UgbWFya2VkXG4gICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuTk9URVFVQUwsIDB4MCwgMHgzRik7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIuaXRlbUNvdW50KTtcblxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4MDApO1xuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweDgwLCAweDgwKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBtYXQyID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0MjtcblxuLyoqXG4gKiBEcmF3IGEgbGluZS4gVW5kZXIgdGhlIGhvb2QgdGhpcyB3aWxsIHJlYWQgZWxlbWVudHMgZnJvbVxuICogYSB0aWxlLCBkYXNoIHRleHR1cmVzIGZyb20gYSBsaW5lQXRsYXMsIGFuZCBzdHlsZSBwcm9wZXJ0aWVzIGZyb20gYSBsYXllci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWludGVyXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NNYXRyaXhcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZVxuICogQHJldHVybnMge3VuZGVmaW5lZH0gZHJhd3Mgd2l0aCB0aGUgcGFpbnRlclxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkcmF3TGluZShwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlKSB7XG4gICAgLy8gTm8gZGF0YVxuICAgIGlmICghdGlsZS5idWZmZXJzKSByZXR1cm47XG4gICAgdmFyIGVsZW1lbnRHcm91cHMgPSB0aWxlLmVsZW1lbnRHcm91cHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXTtcbiAgICBpZiAoIWVsZW1lbnRHcm91cHMpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICAvLyBkb24ndCBkcmF3IHplcm8td2lkdGggbGluZXNcbiAgICBpZiAobGF5ZXIucGFpbnRbJ2xpbmUtd2lkdGgnXSA8PSAwKSByZXR1cm47XG5cbiAgICAvLyB0aGUgZGlzdGFuY2Ugb3ZlciB3aGljaCB0aGUgbGluZSBlZGdlIGZhZGVzIG91dC5cbiAgICAvLyBSZXRpbmEgZGV2aWNlcyBuZWVkIGEgc21hbGxlciBkaXN0YW5jZSB0byBhdm9pZCBhbGlhc2luZy5cbiAgICB2YXIgYW50aWFsaWFzaW5nID0gMSAvIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgIHZhciBibHVyID0gbGF5ZXIucGFpbnRbJ2xpbmUtYmx1ciddICsgYW50aWFsaWFzaW5nO1xuICAgIHZhciBlZGdlV2lkdGggPSBsYXllci5wYWludFsnbGluZS13aWR0aCddIC8gMjtcbiAgICB2YXIgaW5zZXQgPSAtMTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgc2hpZnQgPSAwO1xuXG4gICAgaWYgKGxheWVyLnBhaW50WydsaW5lLWdhcC13aWR0aCddID4gMCkge1xuICAgICAgICBpbnNldCA9IGxheWVyLnBhaW50WydsaW5lLWdhcC13aWR0aCddIC8gMiArIGFudGlhbGlhc2luZyAqIDAuNTtcbiAgICAgICAgZWRnZVdpZHRoID0gbGF5ZXIucGFpbnRbJ2xpbmUtd2lkdGgnXTtcblxuICAgICAgICAvLyBzaGlmdCBvdXRlciBsaW5lcyBoYWxmIGEgcGl4ZWwgdG93YXJkcyB0aGUgbWlkZGxlIHRvIGVsaW1pbmF0ZSB0aGUgY3JhY2tcbiAgICAgICAgb2Zmc2V0ID0gaW5zZXQgLSBhbnRpYWxpYXNpbmcgLyAyO1xuICAgIH1cblxuICAgIHZhciBvdXRzZXQgPSBvZmZzZXQgKyBlZGdlV2lkdGggKyBhbnRpYWxpYXNpbmcgLyAyICsgc2hpZnQ7XG5cbiAgICB2YXIgY29sb3IgPSBsYXllci5wYWludFsnbGluZS1jb2xvciddO1xuICAgIHZhciByYXRpbyA9IHBhaW50ZXIudHJhbnNmb3JtLnNjYWxlIC8gKDEgPDwgdGlsZS5jb29yZC56KSAvICh0aWxlLnRpbGVFeHRlbnQgLyB0aWxlLnRpbGVTaXplKTtcbiAgICB2YXIgdnR4TWF0cml4ID0gcGFpbnRlci50cmFuc2xhdGVNYXRyaXgocG9zTWF0cml4LCB0aWxlLCBsYXllci5wYWludFsnbGluZS10cmFuc2xhdGUnXSwgbGF5ZXIucGFpbnRbJ2xpbmUtdHJhbnNsYXRlLWFuY2hvciddKTtcblxuICAgIHZhciB0ciA9IHBhaW50ZXIudHJhbnNmb3JtO1xuXG5cbiAgICB2YXIgYW50aWFsaWFzaW5nTWF0cml4ID0gbWF0Mi5jcmVhdGUoKTtcbiAgICBtYXQyLnNjYWxlKGFudGlhbGlhc2luZ01hdHJpeCwgYW50aWFsaWFzaW5nTWF0cml4LCBbMSwgTWF0aC5jb3ModHIuX3BpdGNoKV0pO1xuICAgIG1hdDIucm90YXRlKGFudGlhbGlhc2luZ01hdHJpeCwgYW50aWFsaWFzaW5nTWF0cml4LCBwYWludGVyLnRyYW5zZm9ybS5hbmdsZSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgaG93IG11Y2ggbG9uZ2VyIHRoZSByZWFsIHdvcmxkIGRpc3RhbmNlIGlzIGF0IHRoZSB0b3Agb2YgdGhlIHNjcmVlblxuICAgIC8vIHRoYW4gYXQgdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLlxuICAgIHZhciB0b3BlZGdlbGVuZ3RoID0gTWF0aC5zcXJ0KHRyLmhlaWdodCAqIHRyLmhlaWdodCAvIDQgICogKDEgKyB0ci5hbHRpdHVkZSAqIHRyLmFsdGl0dWRlKSk7XG4gICAgdmFyIHggPSB0ci5oZWlnaHQgLyAyICogTWF0aC50YW4odHIuX3BpdGNoKTtcbiAgICB2YXIgZXh0cmEgPSAodG9wZWRnZWxlbmd0aCArIHgpIC8gdG9wZWRnZWxlbmd0aCAtIDE7XG5cbiAgICAvLyBob3cgbXVjaCB0aGUgdGlsZSBpcyBvdmVyc2NhbGVkIGJ5XG4gICAgdmFyIG92ZXJzY2FsaW5nID0gdGlsZS50aWxlU2l6ZSAvIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVTaXplO1xuXG4gICAgdmFyIHNoYWRlcjtcblxuXG4gICAgdmFyIGRhc2hhcnJheSA9IGxheWVyLnBhaW50WydsaW5lLWRhc2hhcnJheSddO1xuICAgIHZhciBpbWFnZSA9IGxheWVyLnBhaW50WydsaW5lLWltYWdlJ107XG5cbiAgICBpZiAoZGFzaGFycmF5KSB7XG5cbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5saW5lc2RmcGF0dGVyblNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgdnR4TWF0cml4LCB0aWxlLmV4TWF0cml4KTtcblxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfcmF0aW8sIHJhdGlvKTtcblxuICAgICAgICB2YXIgcG9zQSA9IHBhaW50ZXIubGluZUF0bGFzLmdldERhc2goZGFzaGFycmF5LmZyb20sIGxheWVyLmxheW91dFsnbGluZS1jYXAnXSA9PT0gJ3JvdW5kJyk7XG4gICAgICAgIHZhciBwb3NCID0gcGFpbnRlci5saW5lQXRsYXMuZ2V0RGFzaChkYXNoYXJyYXkudG8sIGxheWVyLmxheW91dFsnbGluZS1jYXAnXSA9PT0gJ3JvdW5kJyk7XG4gICAgICAgIHBhaW50ZXIubGluZUF0bGFzLmJpbmQoZ2wpO1xuXG4gICAgICAgIHZhciBwYXR0ZXJucmF0aW8gPSBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKHBhaW50ZXIudHJhbnNmb3JtLnNjYWxlKSAvIE1hdGguTE4yKSAtIHRpbGUuY29vcmQueikgLyA4ICogb3ZlcnNjYWxpbmc7XG4gICAgICAgIHZhciBzY2FsZUEgPSBbcGF0dGVybnJhdGlvIC8gcG9zQS53aWR0aCAvIGRhc2hhcnJheS5mcm9tU2NhbGUsIC1wb3NBLmhlaWdodCAvIDJdO1xuICAgICAgICB2YXIgZ2FtbWFBID0gcGFpbnRlci5saW5lQXRsYXMud2lkdGggLyAoZGFzaGFycmF5LmZyb21TY2FsZSAqIHBvc0Eud2lkdGggKiAyNTYgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pIC8gMjtcbiAgICAgICAgdmFyIHNjYWxlQiA9IFtwYXR0ZXJucmF0aW8gLyBwb3NCLndpZHRoIC8gZGFzaGFycmF5LnRvU2NhbGUsIC1wb3NCLmhlaWdodCAvIDJdO1xuICAgICAgICB2YXIgZ2FtbWFCID0gcGFpbnRlci5saW5lQXRsYXMud2lkdGggLyAoZGFzaGFycmF5LnRvU2NhbGUgKiBwb3NCLndpZHRoICogMjU2ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKSAvIDI7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuc2NhbGVfYSwgc2NhbGVBKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3RleF95X2EsIHBvc0EueSk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybnNjYWxlX2IsIHNjYWxlQik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV90ZXhfeV9iLCBwb3NCLnkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZSwgMCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zZGZnYW1tYSwgTWF0aC5tYXgoZ2FtbWFBLCBnYW1tYUIpKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21peCwgZGFzaGFycmF5LnQpO1xuXG4gICAgfSBlbHNlIGlmIChpbWFnZSkge1xuICAgICAgICB2YXIgaW1hZ2VQb3NBID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKTtcbiAgICAgICAgdmFyIGltYWdlUG9zQiA9IHBhaW50ZXIuc3ByaXRlQXRsYXMuZ2V0UG9zaXRpb24oaW1hZ2UudG8sIHRydWUpO1xuICAgICAgICBpZiAoIWltYWdlUG9zQSB8fCAhaW1hZ2VQb3NCKSByZXR1cm47XG4gICAgICAgIHZhciBmYWN0b3IgPSB0aWxlLnRpbGVFeHRlbnQgLyB0aWxlLnRpbGVTaXplIC8gTWF0aC5wb3coMiwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20gLSB0aWxlLmNvb3JkLnopICogb3ZlcnNjYWxpbmc7XG5cbiAgICAgICAgcGFpbnRlci5zcHJpdGVBdGxhcy5iaW5kKGdsLCB0cnVlKTtcblxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmxpbmVwYXR0ZXJuU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCB2dHhNYXRyaXgsIHRpbGUuZXhNYXRyaXgpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9yYXRpbywgcmF0aW8pO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9zaXplX2EsIFtpbWFnZVBvc0Euc2l6ZVswXSAqIGZhY3RvciAqIGltYWdlLmZyb21TY2FsZSwgaW1hZ2VQb3NCLnNpemVbMV0gXSk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9zaXplX2IsIFtpbWFnZVBvc0Iuc2l6ZVswXSAqIGZhY3RvciAqIGltYWdlLnRvU2NhbGUsIGltYWdlUG9zQi5zaXplWzFdIF0pO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fdGxfYSwgaW1hZ2VQb3NBLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyX2EsIGltYWdlUG9zQS5icik7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bF9iLCBpbWFnZVBvc0IudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fYnJfYiwgaW1hZ2VQb3NCLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2ZhZGUsIGltYWdlLnQpO1xuXG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXIuYV9vcGFjaXR5KTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliMWYoc2hhZGVyLmFfb3BhY2l0eSwgbGF5ZXIucGFpbnRbJ2xpbmUtb3BhY2l0eSddKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIubGluZVNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgdnR4TWF0cml4LCB0aWxlLmV4TWF0cml4KTtcblxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfcmF0aW8sIHJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2V4dHJhLCBleHRyYSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoc2hhZGVyLnVfYW50aWFsaWFzaW5nbWF0cml4LCBmYWxzZSwgYW50aWFsaWFzaW5nTWF0cml4KTtcbiAgICB9XG5cbiAgICAvLyBsaW5lcGF0dGVybiBkb2VzIG5vdCBoYXZlIGEgY29sb3IgYXR0cmlidXRlXG4gICAgaWYgKHNoYWRlci5hX2NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlci5hX2NvbG9yKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliNGZ2KHNoYWRlci5hX2NvbG9yLCBjb2xvcik7XG4gICAgfVxuXG4gICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlci5hX2xpbmV3aWR0aCk7XG4gICAgZ2wudmVydGV4QXR0cmliMmYoc2hhZGVyLmFfbGluZXdpZHRoLCBvdXRzZXQsIGluc2V0KTtcblxuICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXIuYV9ibHVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWIxZihzaGFkZXIuYV9ibHVyLCBibHVyKTtcblxuICAgIHZhciB2ZXJ0ZXggPSB0aWxlLmJ1ZmZlcnMubGluZVZlcnRleDtcbiAgICB2ZXJ0ZXguYmluZChnbCk7XG4gICAgdmFyIGVsZW1lbnQgPSB0aWxlLmJ1ZmZlcnMubGluZUVsZW1lbnQ7XG4gICAgZWxlbWVudC5iaW5kKGdsKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudEdyb3Vwcy5ncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZWxlbWVudEdyb3Vwcy5ncm91cHNbaV07XG4gICAgICAgIHZhciB2dHhPZmZzZXQgPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4ICogdmVydGV4Lml0ZW1TaXplO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCA4LCB2dHhPZmZzZXQgKyAwKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9kYXRhLCA0LCBnbC5CWVRFLCBmYWxzZSwgOCwgdnR4T2Zmc2V0ICsgNCk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gZ3JvdXAuZWxlbWVudExlbmd0aCAqIDM7XG4gICAgICAgIHZhciBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuZWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50Lml0ZW1TaXplO1xuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd1Jhc3RlcjtcblxuZnVuY3Rpb24gZHJhd1Jhc3RlcihwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlKSB7XG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIHZhciBzaGFkZXIgPSBwYWludGVyLnJhc3RlclNoYWRlcjtcbiAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuXG4gICAgLy8gY29sb3IgcGFyYW1ldGVyc1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9icmlnaHRuZXNzX2xvdywgbGF5ZXIucGFpbnRbJ3Jhc3Rlci1icmlnaHRuZXNzLW1pbiddKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYnJpZ2h0bmVzc19oaWdoLCBsYXllci5wYWludFsncmFzdGVyLWJyaWdodG5lc3MtbWF4J10pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zYXR1cmF0aW9uX2ZhY3Rvciwgc2F0dXJhdGlvbkZhY3RvcihsYXllci5wYWludFsncmFzdGVyLXNhdHVyYXRpb24nXSkpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9jb250cmFzdF9mYWN0b3IsIGNvbnRyYXN0RmFjdG9yKGxheWVyLnBhaW50WydyYXN0ZXItY29udHJhc3QnXSkpO1xuICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLnVfc3Bpbl93ZWlnaHRzLCBzcGluV2VpZ2h0cyhsYXllci5wYWludFsncmFzdGVyLWh1ZS1yb3RhdGUnXSkpO1xuXG4gICAgdmFyIHBhcmVudFRpbGUgPSB0aWxlLnNvdXJjZSAmJiB0aWxlLnNvdXJjZS5fcHlyYW1pZC5maW5kTG9hZGVkUGFyZW50KHRpbGUuY29vcmQsIDAsIHt9KSxcbiAgICAgICAgb3BhY2l0aWVzID0gZ2V0T3BhY2l0aWVzKHRpbGUsIHBhcmVudFRpbGUsIGxheWVyLCBwYWludGVyLnRyYW5zZm9ybSk7XG5cbiAgICB2YXIgcGFyZW50U2NhbGVCeSwgcGFyZW50VEw7XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aWxlLnRleHR1cmUpO1xuXG4gICAgaWYgKHBhcmVudFRpbGUpIHtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHBhcmVudFRpbGUudGV4dHVyZSk7XG5cbiAgICAgICAgcGFyZW50U2NhbGVCeSA9IE1hdGgucG93KDIsIHBhcmVudFRpbGUuY29vcmQueiAtIHRpbGUuY29vcmQueik7XG4gICAgICAgIHBhcmVudFRMID0gW3RpbGUuY29vcmQueCAqIHBhcmVudFNjYWxlQnkgJSAxLCB0aWxlLmNvb3JkLnkgKiBwYXJlbnRTY2FsZUJ5ICUgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3BhY2l0aWVzWzFdID0gMDtcbiAgICB9XG5cbiAgICAvLyBjcm9zcy1mYWRlIHBhcmFtZXRlcnNcbiAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3RsX3BhcmVudCwgcGFyZW50VEwgfHwgWzAsIDBdKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfc2NhbGVfcGFyZW50LCBwYXJlbnRTY2FsZUJ5IHx8IDEpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9idWZmZXJfc2NhbGUsIDEpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5MCwgb3BhY2l0aWVzWzBdKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eTEsIG9wYWNpdGllc1sxXSk7XG4gICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X2ltYWdlMCwgMCk7XG4gICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X2ltYWdlMSwgMSk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGlsZS5ib3VuZHNCdWZmZXIgfHwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyKTtcblxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCAgICAgICAgIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV90ZXh0dXJlX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCA4LCA0KTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblxuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xufVxuXG5mdW5jdGlvbiBzcGluV2VpZ2h0cyhhbmdsZSkge1xuICAgIGFuZ2xlICo9IE1hdGguUEkgLyAxODA7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKDIgKiBjICsgMSkgLyAzLFxuICAgICAgICAoLU1hdGguc3FydCgzKSAqIHMgLSBjICsgMSkgLyAzLFxuICAgICAgICAoTWF0aC5zcXJ0KDMpICogcyAtIGMgKyAxKSAvIDNcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBjb250cmFzdEZhY3Rvcihjb250cmFzdCkge1xuICAgIHJldHVybiBjb250cmFzdCA+IDAgP1xuICAgICAgICAxIC8gKDEgLSBjb250cmFzdCkgOlxuICAgICAgICAxICsgY29udHJhc3Q7XG59XG5cbmZ1bmN0aW9uIHNhdHVyYXRpb25GYWN0b3Ioc2F0dXJhdGlvbikge1xuICAgIHJldHVybiBzYXR1cmF0aW9uID4gMCA/XG4gICAgICAgIDEgLSAxIC8gKDEuMDAxIC0gc2F0dXJhdGlvbikgOlxuICAgICAgICAtc2F0dXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0T3BhY2l0aWVzKHRpbGUsIHBhcmVudFRpbGUsIGxheWVyLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoIXRpbGUuc291cmNlKSByZXR1cm4gWzEsIDBdO1xuXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgdmFyIGZhZGVEdXJhdGlvbiA9IGxheWVyLnBhaW50WydyYXN0ZXItZmFkZS1kdXJhdGlvbiddO1xuICAgIHZhciBzaW5jZVRpbGUgPSAobm93IC0gdGlsZS50aW1lQWRkZWQpIC8gZmFkZUR1cmF0aW9uO1xuICAgIHZhciBzaW5jZVBhcmVudCA9IHBhcmVudFRpbGUgPyAobm93IC0gcGFyZW50VGlsZS50aW1lQWRkZWQpIC8gZmFkZUR1cmF0aW9uIDogLTE7XG5cbiAgICB2YXIgaWRlYWxaID0gdGlsZS5zb3VyY2UuX3B5cmFtaWQuY292ZXJpbmdab29tTGV2ZWwodHJhbnNmb3JtKTtcbiAgICB2YXIgcGFyZW50RnVydGhlciA9IHBhcmVudFRpbGUgPyBNYXRoLmFicyhwYXJlbnRUaWxlLmNvb3JkLnogLSBpZGVhbFopID4gTWF0aC5hYnModGlsZS5jb29yZC56IC0gaWRlYWxaKSA6IGZhbHNlO1xuXG4gICAgdmFyIG9wYWNpdHkgPSBbXTtcbiAgICBpZiAoIXBhcmVudFRpbGUgfHwgcGFyZW50RnVydGhlcikge1xuICAgICAgICAvLyBpZiBubyBwYXJlbnQgb3IgcGFyZW50IGlzIG9sZGVyXG4gICAgICAgIG9wYWNpdHlbMF0gPSB1dGlsLmNsYW1wKHNpbmNlVGlsZSwgMCwgMSk7XG4gICAgICAgIG9wYWNpdHlbMV0gPSAxIC0gb3BhY2l0eVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXJlbnQgaXMgeW91bmdlciwgem9vbWluZyBvdXRcbiAgICAgICAgb3BhY2l0eVswXSA9IHV0aWwuY2xhbXAoMSAtIHNpbmNlUGFyZW50LCAwLCAxKTtcbiAgICAgICAgb3BhY2l0eVsxXSA9IDEgLSBvcGFjaXR5WzBdO1xuICAgIH1cblxuICAgIHZhciBvcCA9IGxheWVyLnBhaW50WydyYXN0ZXItb3BhY2l0eSddO1xuICAgIG9wYWNpdHlbMF0gKj0gb3A7XG4gICAgb3BhY2l0eVsxXSAqPSBvcDtcblxuICAgIHJldHVybiBvcGFjaXR5O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xuXG52YXIgZHJhd0NvbGxpc2lvbkRlYnVnID0gcmVxdWlyZSgnLi9kcmF3X2NvbGxpc2lvbl9kZWJ1ZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdTeW1ib2xzO1xuXG5mdW5jdGlvbiBkcmF3U3ltYm9scyhwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlKSB7XG4gICAgLy8gTm8gZGF0YVxuICAgIGlmICghdGlsZS5idWZmZXJzKSByZXR1cm47XG4gICAgdmFyIGVsZW1lbnRHcm91cHMgPSB0aWxlLmVsZW1lbnRHcm91cHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXTtcbiAgICBpZiAoIWVsZW1lbnRHcm91cHMpIHJldHVybjtcblxuICAgIHZhciBkcmF3QWNyb3NzRWRnZXMgPSAhKGxheWVyLmxheW91dFsndGV4dC1hbGxvdy1vdmVybGFwJ10gfHwgbGF5ZXIubGF5b3V0WydpY29uLWFsbG93LW92ZXJsYXAnXSB8fFxuICAgICAgICBsYXllci5sYXlvdXRbJ3RleHQtaWdub3JlLXBsYWNlbWVudCddIHx8IGxheWVyLmxheW91dFsnaWNvbi1pZ25vcmUtcGxhY2VtZW50J10pO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIGlmIChkcmF3QWNyb3NzRWRnZXMpIHtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgc3RlbmNpbCB0ZXN0IHNvIHRoYXQgbGFiZWxzIGFyZW4ndCBjbGlwcGVkIHRvIHRpbGUgYm91bmRhcmllcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTGF5ZXJzIHdpdGggZmVhdHVyZXMgdGhhdCBtYXkgYmUgZHJhd24gb3ZlcmxhcHBpbmcgYXJlbid0IGNsaXBwZWQuIFRoZXNlXG4gICAgICAgIC8vIGxheWVycyBhcmUgc29ydGVkIGluIHRoZSB5IGRpcmVjdGlvbiwgYW5kIHRvIGRyYXcgdGhlIGNvcnJlY3Qgb3JkZXJpbmcgbmVhclxuICAgICAgICAvLyB0aWxlIGVkZ2VzIHRoZSBpY29ucyBhcmUgaW5jbHVkZWQgaW4gYm90aCB0aWxlcyBhbmQgY2xpcHBlZCB3aGVuIGRyYXdpbmcuXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudEdyb3Vwcy50ZXh0Lmdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgZHJhd1N5bWJvbChwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlLCBlbGVtZW50R3JvdXBzLnRleHQsICd0ZXh0JywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50R3JvdXBzLmljb24uZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICBkcmF3U3ltYm9sKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgsIHRpbGUsIGVsZW1lbnRHcm91cHMuaWNvbiwgJ2ljb24nLCBlbGVtZW50R3JvdXBzLnNkZkljb25zKTtcbiAgICB9XG5cbiAgICBkcmF3Q29sbGlzaW9uRGVidWcocGFpbnRlciwgbGF5ZXIsIHBvc01hdHJpeCwgdGlsZSk7XG5cbiAgICBpZiAoZHJhd0Fjcm9zc0VkZ2VzKSB7XG4gICAgICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRTaXplcyA9IHtcbiAgICBpY29uOiAxLFxuICAgIHRleHQ6IDI0XG59O1xuXG5mdW5jdGlvbiBkcmF3U3ltYm9sKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgsIHRpbGUsIGVsZW1lbnRHcm91cHMsIHByZWZpeCwgc2RmKSB7XG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIHBvc01hdHJpeCA9IHBhaW50ZXIudHJhbnNsYXRlTWF0cml4KHBvc01hdHJpeCwgdGlsZSwgbGF5ZXIucGFpbnRbcHJlZml4ICsgJy10cmFuc2xhdGUnXSwgbGF5ZXIucGFpbnRbcHJlZml4ICsgJy10cmFuc2xhdGUtYW5jaG9yJ10pO1xuXG4gICAgdmFyIHRyID0gcGFpbnRlci50cmFuc2Zvcm07XG4gICAgdmFyIGFsaWduZWRXaXRoTWFwID0gbGF5ZXIubGF5b3V0W3ByZWZpeCArICctcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnO1xuICAgIHZhciBza2V3ZWQgPSBhbGlnbmVkV2l0aE1hcDtcbiAgICB2YXIgZXhNYXRyaXgsIHMsIGdhbW1hU2NhbGU7XG5cbiAgICBpZiAoc2tld2VkKSB7XG4gICAgICAgIGV4TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgcyA9IHRpbGUudGlsZUV4dGVudCAvIHRpbGUudGlsZVNpemUgLyBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS56b29tIC0gdGlsZS5jb29yZC56KTtcbiAgICAgICAgZ2FtbWFTY2FsZSA9IDEgLyBNYXRoLmNvcyh0ci5fcGl0Y2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV4TWF0cml4ID0gbWF0NC5jbG9uZSh0aWxlLmV4TWF0cml4KTtcbiAgICAgICAgcyA9IHBhaW50ZXIudHJhbnNmb3JtLmFsdGl0dWRlO1xuICAgICAgICBnYW1tYVNjYWxlID0gMTtcbiAgICB9XG4gICAgbWF0NC5zY2FsZShleE1hdHJpeCwgZXhNYXRyaXgsIFtzLCBzLCAxXSk7XG5cbiAgICAvLyBJZiBsYXllci5wYWludC5zaXplID4gbGF5ZXIubGF5b3V0W3ByZWZpeCArICctbWF4LXNpemUnXSB0aGVuIGxhYmVscyBtYXkgY29sbGlkZVxuICAgIHZhciBmb250U2l6ZSA9IGxheWVyLnBhaW50W3ByZWZpeCArICctc2l6ZSddO1xuICAgIHZhciBmb250U2NhbGUgPSBmb250U2l6ZSAvIGRlZmF1bHRTaXplc1twcmVmaXhdO1xuICAgIG1hdDQuc2NhbGUoZXhNYXRyaXgsIGV4TWF0cml4LCBbIGZvbnRTY2FsZSwgZm9udFNjYWxlLCAxIF0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIGhvdyBtdWNoIGxvbmdlciB0aGUgcmVhbCB3b3JsZCBkaXN0YW5jZSBpcyBhdCB0aGUgdG9wIG9mIHRoZSBzY3JlZW5cbiAgICAvLyB0aGFuIGF0IHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbi5cbiAgICB2YXIgdG9wZWRnZWxlbmd0aCA9IE1hdGguc3FydCh0ci5oZWlnaHQgKiB0ci5oZWlnaHQgLyA0ICAqICgxICsgdHIuYWx0aXR1ZGUgKiB0ci5hbHRpdHVkZSkpO1xuICAgIHZhciB4ID0gdHIuaGVpZ2h0IC8gMiAqIE1hdGgudGFuKHRyLl9waXRjaCk7XG4gICAgdmFyIGV4dHJhID0gKHRvcGVkZ2VsZW5ndGggKyB4KSAvIHRvcGVkZ2VsZW5ndGggLSAxO1xuXG4gICAgdmFyIHRleHQgPSBwcmVmaXggPT09ICd0ZXh0JztcbiAgICB2YXIgc2hhZGVyLCB2ZXJ0ZXgsIGVsZW1lbnRzLCB0ZXhzaXplO1xuXG4gICAgaWYgKCF0ZXh0ICYmICFwYWludGVyLnN0eWxlLnNwcml0ZS5sb2FkZWQoKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICBpZiAoc2RmKSB7XG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuc2RmU2hhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIuaWNvblNoYWRlcjtcbiAgICB9XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgICBwYWludGVyLmdseXBoQXRsYXMudXBkYXRlVGV4dHVyZShnbCk7XG4gICAgICAgIHZlcnRleCA9IHRpbGUuYnVmZmVycy5nbHlwaFZlcnRleDtcbiAgICAgICAgZWxlbWVudHMgPSB0aWxlLmJ1ZmZlcnMuZ2x5cGhFbGVtZW50O1xuICAgICAgICB0ZXhzaXplID0gW3BhaW50ZXIuZ2x5cGhBdGxhcy53aWR0aCAvIDQsIHBhaW50ZXIuZ2x5cGhBdGxhcy5oZWlnaHQgLyA0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYWludGVyLnNwcml0ZUF0bGFzLmJpbmQoZ2wsIGFsaWduZWRXaXRoTWFwIHx8IHBhaW50ZXIub3B0aW9ucy5yb3RhdGluZyB8fFxuICAgICAgICAgICAgcGFpbnRlci5vcHRpb25zLnpvb21pbmcgfHwgZm9udFNjYWxlICE9PSAxIHx8IHNkZiB8fCBwYWludGVyLnRyYW5zZm9ybS5waXRjaCk7XG4gICAgICAgIHZlcnRleCA9IHRpbGUuYnVmZmVycy5pY29uVmVydGV4O1xuICAgICAgICBlbGVtZW50cyA9IHRpbGUuYnVmZmVycy5pY29uRWxlbWVudDtcbiAgICAgICAgdGV4c2l6ZSA9IFtwYWludGVyLnNwcml0ZUF0bGFzLndpZHRoIC8gNCwgcGFpbnRlci5zcHJpdGVBdGxhcy5oZWlnaHQgLyA0XTtcbiAgICB9XG5cbiAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgsIGV4TWF0cml4KTtcbiAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfdGV4dHVyZSwgMCk7XG4gICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV90ZXhzaXplLCB0ZXhzaXplKTtcbiAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfc2tld2VkLCBza2V3ZWQpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9leHRyYSwgZXh0cmEpO1xuXG4gICAgLy8gYWRqdXN0IG1pbi9tYXggem9vbXMgZm9yIHZhcmlhYmxlIGZvbnQgc2llc1xuICAgIHZhciB6b29tQWRqdXN0ID0gTWF0aC5sb2coZm9udFNpemUgLyBsYXllci5sYXlvdXRbcHJlZml4ICsgJy1tYXgtc2l6ZSddKSAvIE1hdGguTE4yIHx8IDA7XG5cbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfem9vbSwgKHBhaW50ZXIudHJhbnNmb3JtLnpvb20gLSB6b29tQWRqdXN0KSAqIDEwKTsgLy8gY3VycmVudCB6b29tIGxldmVsXG5cbiAgICB2YXIgZiA9IHBhaW50ZXIuZnJhbWVIaXN0b3J5LmdldEZhZGVQcm9wZXJ0aWVzKDMwMCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2ZhZGVkaXN0LCBmLmZhZGVkaXN0ICogMTApO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taW5mYWRlem9vbSwgTWF0aC5mbG9vcihmLm1pbmZhZGV6b29tICogMTApKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfbWF4ZmFkZXpvb20sIE1hdGguZmxvb3IoZi5tYXhmYWRlem9vbSAqIDEwKSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2ZhZGV6b29tLCAocGFpbnRlci50cmFuc2Zvcm0uem9vbSArIGYuYnVtcCkgKiAxMCk7XG5cbiAgICB2YXIgZ3JvdXAsIG9mZnNldCwgY291bnQsIGVsZW1lbnRPZmZzZXQ7XG5cbiAgICBlbGVtZW50cy5iaW5kKGdsKTtcblxuICAgIGlmIChzZGYpIHtcbiAgICAgICAgdmFyIHNkZlB4ID0gODtcbiAgICAgICAgdmFyIGJsdXJPZmZzZXQgPSAxLjE5O1xuICAgICAgICB2YXIgaGFsb09mZnNldCA9IDY7XG4gICAgICAgIHZhciBnYW1tYSA9IDAuMTA1ICogZGVmYXVsdFNpemVzW3ByZWZpeF0gLyBmb250U2l6ZSAvIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyLmFfZ2FtbWEpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZihzaGFkZXIuYV9nYW1tYSwgZ2FtbWEgKiBnYW1tYVNjYWxlKTtcblxuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyLmFfY29sb3IpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0ZnYoc2hhZGVyLmFfY29sb3IsIGxheWVyLnBhaW50W3ByZWZpeCArICctY29sb3InXSk7XG5cbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlci5hX2J1ZmZlcik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHNoYWRlci5hX2J1ZmZlciwgKDI1NiAtIDY0KSAvIDI1Nik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50R3JvdXBzLmdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ3JvdXAgPSBlbGVtZW50R3JvdXBzLmdyb3Vwc1tpXTtcbiAgICAgICAgICAgIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgICAgICB2ZXJ0ZXguYmluZChnbCwgc2hhZGVyLCBvZmZzZXQpO1xuXG4gICAgICAgICAgICBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICAgICAgZWxlbWVudE9mZnNldCA9IGdyb3VwLmVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheWVyLnBhaW50W3ByZWZpeCArICctaGFsby1jb2xvciddKSB7XG5cbiAgICAgICAgICAgIC8vIHZlcnRleCBhdHRyaWIgYXJyYXlzIGRpc2FibGVkIGFib3ZlXG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0ZnYoc2hhZGVyLmFfY29sb3IsIGxheWVyLnBhaW50W3ByZWZpeCArICctaGFsby1jb2xvciddKTtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHNoYWRlci5hX2J1ZmZlciwgKGhhbG9PZmZzZXQgLSBsYXllci5wYWludFtwcmVmaXggKyAnLWhhbG8td2lkdGgnXSAvIGZvbnRTY2FsZSkgLyBzZGZQeCk7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZihzaGFkZXIuYV9nYW1tYSwgKGxheWVyLnBhaW50W3ByZWZpeCArICctaGFsby1ibHVyJ10gKiBibHVyT2Zmc2V0IC8gZm9udFNjYWxlIC8gc2RmUHggKyBnYW1tYSkgKiBnYW1tYVNjYWxlKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50R3JvdXBzLmdyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGdyb3VwID0gZWxlbWVudEdyb3Vwcy5ncm91cHNbal07XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZ3JvdXAudmVydGV4U3RhcnRJbmRleCAqIHZlcnRleC5pdGVtU2l6ZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXguYmluZChnbCwgc2hhZGVyLCBvZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgY291bnQgPSBncm91cC5lbGVtZW50TGVuZ3RoICogMztcbiAgICAgICAgICAgICAgICBlbGVtZW50T2Zmc2V0ID0gZ3JvdXAuZWxlbWVudFN0YXJ0SW5kZXggKiBlbGVtZW50cy5pdGVtU2l6ZTtcbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlci5hX29wYWNpdHkpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZihzaGFkZXIuYV9vcGFjaXR5LCBsYXllci5wYWludFsnaWNvbi1vcGFjaXR5J10pO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZWxlbWVudEdyb3Vwcy5ncm91cHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gZWxlbWVudEdyb3Vwcy5ncm91cHNba107XG4gICAgICAgICAgICBvZmZzZXQgPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4ICogdmVydGV4Lml0ZW1TaXplO1xuICAgICAgICAgICAgdmVydGV4LmJpbmQoZ2wsIHNoYWRlciwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgY291bnQgPSBncm91cC5lbGVtZW50TGVuZ3RoICogMztcbiAgICAgICAgICAgIGVsZW1lbnRPZmZzZXQgPSBncm91cC5lbGVtZW50U3RhcnRJbmRleCAqIGVsZW1lbnRzLml0ZW1TaXplO1xuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCBlbGVtZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3VmVydGljZXM7XG5cbmZ1bmN0aW9uIGRyYXdWZXJ0aWNlcyhwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlKSB7XG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIGlmICghdGlsZSB8fCAhdGlsZS5idWZmZXJzKSByZXR1cm47XG4gICAgdmFyIGVsZW1lbnRHcm91cHMgPSB0aWxlLmVsZW1lbnRHcm91cHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXTtcbiAgICBpZiAoIWVsZW1lbnRHcm91cHMpIHJldHVybjtcblxuICAgIC8vIEJsZW5kIHRvIHRoZSBmcm9udCwgbm90IHRoZSBiYWNrLlxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG4gICAgLy8gRHJhdyBhbGwgYnVmZmVyc1xuICAgIGlmIChsYXllci50eXBlID09PSAnZmlsbCcpIHtcbiAgICAgICAgZHJhd1BvaW50cyh0aWxlLmJ1ZmZlcnMuZmlsbFZlcnRleCwgZWxlbWVudEdyb3Vwcy5ncm91cHMsIHBvc01hdHJpeCwgNCk7XG4gICAgfSBlbHNlIGlmIChsYXllci50eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICBkcmF3UG9pbnRzKHRpbGUuYnVmZmVycy5pY29uVmVydGV4LCBlbGVtZW50R3JvdXBzLmljb24uZ3JvdXBzLCBwb3NNYXRyaXgsIDE2KTtcbiAgICAgICAgZHJhd1BvaW50cyh0aWxlLmJ1ZmZlcnMuZ2x5cGhWZXJ0ZXgsIGVsZW1lbnRHcm91cHMudGV4dC5ncm91cHMsIHBvc01hdHJpeCwgMTYpO1xuICAgIH0gZWxzZSBpZiAobGF5ZXIudHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgIHZhciBuZXdQb3NNYXRyaXggPSBtYXQ0LmNsb25lKHBvc01hdHJpeCk7XG4gICAgICAgIG1hdDQuc2NhbGUobmV3UG9zTWF0cml4LCBuZXdQb3NNYXRyaXgsIFswLjUsIDAuNSwgMV0pO1xuICAgICAgICBkcmF3UG9pbnRzKHRpbGUuYnVmZmVycy5saW5lVmVydGV4LCBlbGVtZW50R3JvdXBzLmdyb3VwcywgbmV3UG9zTWF0cml4LCA4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3UG9pbnRzKHZlcnRleCwgZ3JvdXBzLCBtYXRyaXgsIHN0cmlkZSkge1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIocGFpbnRlci5kb3RTaGFkZXIsIG1hdHJpeCk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFmKHBhaW50ZXIuZG90U2hhZGVyLnVfc2l6ZSwgNCAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwYWludGVyLmRvdFNoYWRlci51X2JsdXIsIDAuMjUpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHBhaW50ZXIuZG90U2hhZGVyLnVfY29sb3IsIFswLjEsIDAsIDAsIDAuMV0pO1xuXG4gICAgICAgIHZlcnRleC5iaW5kKGdsLCBwYWludGVyLmRvdFNoYWRlciwgMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgICAgICB2YXIgYmVnaW4gPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4O1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gZ3JvdXAudmVydGV4TGVuZ3RoO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwYWludGVyLmRvdFNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCBzdHJpZGUsIDApO1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIGJlZ2luLCBjb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXZlcnQgYmxlbmRpbmcgbW9kZSB0byBibGVuZCB0byB0aGUgYmFjay5cbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuT05FKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBGcmFtZUhpc3Rvcnk7XG5cbmZ1bmN0aW9uIEZyYW1lSGlzdG9yeSgpIHtcbiAgICB0aGlzLmZyYW1lSGlzdG9yeSA9IFtdO1xufVxuXG5GcmFtZUhpc3RvcnkucHJvdG90eXBlLmdldEZhZGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkgZHVyYXRpb24gPSAzMDA7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIC8vIFJlbW92ZSBmcmFtZXMgdW50aWwgb25seSBvbmUgaXMgb3V0c2lkZSB0aGUgZHVyYXRpb24sIG9yIHVudGlsIHRoZXJlIGFyZSBvbmx5IHRocmVlXG4gICAgd2hpbGUgKHRoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aCA+IDMgJiYgdGhpcy5mcmFtZUhpc3RvcnlbMV0udGltZSArIGR1cmF0aW9uIDwgY3VycmVudFRpbWUpIHtcbiAgICAgICAgdGhpcy5mcmFtZUhpc3Rvcnkuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mcmFtZUhpc3RvcnlbMV0udGltZSArIGR1cmF0aW9uIDwgY3VycmVudFRpbWUpIHtcbiAgICAgICAgdGhpcy5mcmFtZUhpc3RvcnlbMF0ueiA9IHRoaXMuZnJhbWVIaXN0b3J5WzFdLno7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lTGVuID0gdGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoO1xuICAgIGlmIChmcmFtZUxlbiA8IDMpIGNvbnNvbGUud2FybigndGhlcmUgc2hvdWxkIG5ldmVyIGJlIGxlc3MgdGhhbiB0aHJlZSBmcmFtZXMgaW4gdGhlIGhpc3RvcnknKTtcblxuICAgIC8vIEZpbmQgdGhlIHJhbmdlIG9mIHpvb20gbGV2ZWxzIHdlIHdhbnQgdG8gZmFkZSBiZXR3ZWVuXG4gICAgdmFyIHN0YXJ0aW5nWiA9IHRoaXMuZnJhbWVIaXN0b3J5WzBdLnosXG4gICAgICAgIGxhc3RGcmFtZSA9IHRoaXMuZnJhbWVIaXN0b3J5W2ZyYW1lTGVuIC0gMV0sXG4gICAgICAgIGVuZGluZ1ogPSBsYXN0RnJhbWUueixcbiAgICAgICAgbG93WiA9IE1hdGgubWluKHN0YXJ0aW5nWiwgZW5kaW5nWiksXG4gICAgICAgIGhpZ2haID0gTWF0aC5tYXgoc3RhcnRpbmdaLCBlbmRpbmdaKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3BlZWQgb2Ygem9vbWluZywgYW5kIGhvdyBmYXIgaXQgd291bGQgem9vbSBpbiB0ZXJtcyBvZiB6b29tIGxldmVscyBpbiBvbmUgZHVyYXRpb25cbiAgICB2YXIgem9vbURpZmYgPSBsYXN0RnJhbWUueiAtIHRoaXMuZnJhbWVIaXN0b3J5WzFdLnosXG4gICAgICAgIHRpbWVEaWZmID0gbGFzdEZyYW1lLnRpbWUgLSB0aGlzLmZyYW1lSGlzdG9yeVsxXS50aW1lO1xuICAgIHZhciBmYWRlZGlzdCA9IHpvb21EaWZmIC8gKHRpbWVEaWZmIC8gZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzTmFOKGZhZGVkaXN0KSkgY29uc29sZS53YXJuKCdmYWRlZGlzdCBzaG91bGQgbmV2ZXIgYmUgTmFOJyk7XG5cbiAgICAvLyBBdCBlbmQgb2YgYSB6b29tIHdoZW4gdGhlIHpvb20gc3RvcHMgY2hhbmdpbmcgY29udGludWUgcHJldGVuZGluZyB0byB6b29tIGF0IHRoYXQgc3BlZWRcbiAgICAvLyBidW1wIGlzIGhvdyBtdWNoIGZhcnRoZXIgaXQgd291bGQgaGF2ZSBiZWVuIGlmIGl0IGhhZCBjb250aW51ZWQgem9vbWluZyBhdCB0aGUgc2FtZSByYXRlXG4gICAgdmFyIGJ1bXAgPSAoY3VycmVudFRpbWUgLSBsYXN0RnJhbWUudGltZSkgLyBkdXJhdGlvbiAqIGZhZGVkaXN0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmFkZWRpc3Q6IGZhZGVkaXN0LFxuICAgICAgICBtaW5mYWRlem9vbTogbG93WixcbiAgICAgICAgbWF4ZmFkZXpvb206IGhpZ2haLFxuICAgICAgICBidW1wOiBidW1wXG4gICAgfTtcbn07XG5cbi8vIFJlY29yZCBmcmFtZSBoaXN0b3J5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNhbGN1bGF0ZSBmYWRpbmcgcGFyYW1zXG5GcmFtZUhpc3RvcnkucHJvdG90eXBlLnJlY29yZCA9IGZ1bmN0aW9uKHpvb20pIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgLy8gZmlyc3QgZnJhbWUgZXZlclxuICAgIGlmICghdGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZnJhbWVIaXN0b3J5LnB1c2goe3RpbWU6IDAsIHo6IHpvb20gfSwge3RpbWU6IDAsIHo6IHpvb20gfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aCA9PT0gMiB8fCB0aGlzLmZyYW1lSGlzdG9yeVt0aGlzLmZyYW1lSGlzdG9yeS5sZW5ndGggLSAxXS56ICE9PSB6b29tKSB7XG4gICAgICAgIHRoaXMuZnJhbWVIaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgdGltZTogY3VycmVudFRpbWUsXG4gICAgICAgICAgICB6OiB6b29tXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzaGFkZXJzID0gcmVxdWlyZSgnLi9zaGFkZXJzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgb3JpZ0xpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoLFxuICAgICAgICBsaW5lV2lkdGhSYW5nZSA9IGNvbnRleHQuZ2V0UGFyYW1ldGVyKGNvbnRleHQuQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFKTtcblxuICAgIGNvbnRleHQubGluZVdpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgb3JpZ0xpbmVXaWR0aC5jYWxsKGNvbnRleHQsIHV0aWwuY2xhbXAod2lkdGgsIGxpbmVXaWR0aFJhbmdlWzBdLCBsaW5lV2lkdGhSYW5nZVsxXSkpO1xuICAgIH07XG5cbiAgICBjb250ZXh0LmdldFNoYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgdmFyIGtpbmQgPSB0eXBlID09PSB0aGlzLkZSQUdNRU5UX1NIQURFUiA/ICdmcmFnbWVudCcgOiAndmVydGV4JztcbiAgICAgICAgaWYgKCFzaGFkZXJzW25hbWVdIHx8ICFzaGFkZXJzW25hbWVdW2tpbmRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBzaGFkZXIgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHNoYWRlcnNbbmFtZV1ba2luZF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcmllbnRhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgdXNlIGhpZ2hwIHByZWNpc2lvbiBvbiBtb2JpbGUgYnJvd3NlcnNcbiAgICAgICAgICAgIHNoYWRlclNvdXJjZSA9IHNoYWRlclNvdXJjZS5yZXBsYWNlKC8gaGlnaHAgL2csICcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG4gICAgICAgIHRoaXMuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICBpZiAoIXRoaXMuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9O1xuXG4gICAgY29udGV4dC5pbml0aWFsaXplU2hhZGVyID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdW5pZm9ybXMpIHtcbiAgICAgICAgdmFyIHNoYWRlciA9IHtcbiAgICAgICAgICAgIHByb2dyYW06IHRoaXMuY3JlYXRlUHJvZ3JhbSgpLFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHRoaXMuZ2V0U2hhZGVyKG5hbWUsIHRoaXMuRlJBR01FTlRfU0hBREVSKSxcbiAgICAgICAgICAgIHZlcnRleDogdGhpcy5nZXRTaGFkZXIobmFtZSwgdGhpcy5WRVJURVhfU0hBREVSKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZGVyKHNoYWRlci5wcm9ncmFtLCBzaGFkZXIudmVydGV4KTtcbiAgICAgICAgdGhpcy5hdHRhY2hTaGFkZXIoc2hhZGVyLnByb2dyYW0sIHNoYWRlci5mcmFnbWVudCk7XG5cbiAgICAgICAgLy8gRGlzYWJsaW5nIGF0dHJpYiBsb2NhdGlvbiAwIGNhdXNlcyB3ZWlyZCBiZWhhdmlvdXIuIFRvIGF2b2lkIHRoZSBwcm9ibGVtLCB3ZSBhc3NpZ25cbiAgICAgICAgLy8gJ2FfcG9zJyB0byBhdHRyaWIgbG9jYXRpb24gMCBtYWtpbmcgdGhlIGFzc3VtcHRpb25zIHRoYXRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAtIGBhX3Bvc2AgaXMgbmV2ZXIgZGlzYWJsZWRcbiAgICAgICAgLy8gICAtIGV2ZXJ5IHNoYWRlciBoYXMgYW4gYGFfcG9zYCBhdHRyaWJ1dGVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gc2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9XZWJHTC9XZWJHTF9iZXN0X3ByYWN0aWNlc1xuICAgICAgICB0aGlzLmJpbmRBdHRyaWJMb2NhdGlvbihzaGFkZXIucHJvZ3JhbSwgMCwgJ2FfcG9zJyk7XG5cbiAgICAgICAgdGhpcy5saW5rUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyLnByb2dyYW0sIHRoaXMuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKHRoaXMuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyLnByb2dyYW0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNoYWRlclthdHRyaWJ1dGVzW2ldXSA9IHRoaXMuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIGF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICAgICAgICAgIHNoYWRlci5hdHRyaWJ1dGVzLnB1c2goc2hhZGVyW2F0dHJpYnV0ZXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdW5pZm9ybXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBzaGFkZXJbdW5pZm9ybXNba11dID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIHVuaWZvcm1zW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfTtcblxuICAgIC8vIFN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IHNoYWRlciBwcm9ncmFtLlxuICAgIGNvbnRleHQuc3dpdGNoU2hhZGVyID0gZnVuY3Rpb24oc2hhZGVyLCBwb3NNYXRyaXgsIGV4TWF0cml4KSB7XG4gICAgICAgIGlmICghcG9zTWF0cml4KSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCdwb3NNYXRyaXggZG9lcyBub3QgaGF2ZSByZXF1aXJlZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNoYWRlciAhPT0gc2hhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuXG4gICAgICAgICAgICAvLyBEaXNhYmxlIGFsbCBhdHRyaWJ1dGUgYXJyYXlzIHVzZWQgYnkgdGhlIHByZXZpb3VzIHNoYWRlciBhbmQgZW5hYmxlIGFsbCB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvLyBhcnJheXMgdXNlZCBieSB0aGUgbmV4dCBzaGFkZXIuIElkZWFsbHkgd2Ugd291bGQgZG8gYSBiZXR0ZXIgam9iIGRpZmZpbmcgdGhlc2UgdG9cbiAgICAgICAgICAgIC8vIG1pbmltaXplIG9wZXJhdGlvbnMgKGFzIHdlIGRpZCBpbiBwcmV2aW91c2x5KSBidXQgaXQgaXMgaGFyZCB0byBrZWVwIHRyYWNrIG9mIHN0YXRlXG4gICAgICAgICAgICAvLyBpbiBzcGFnaGV0dGkgc2hhZGVyIGJvaWxlcnBsYXRlIGNvZGUgYW5kIGhhcmQgdG8gZGVidWcgd2hlbiB0aGluZ3MgZ28gd3JvbmcuXG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmN1cnJlbnRTaGFkZXIgPyB0aGlzLmN1cnJlbnRTaGFkZXIuYXR0cmlidXRlcyA6IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2aW91cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHByZXZpb3VzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0ID0gc2hhZGVyLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5leHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG5leHRbal0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTaGFkZXIgPSBzaGFkZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1hdHJpY2VzIGlmIG5lY2Vzc2FyeS4gTm90ZTogVGhpcyByZWxpZXMgb24gb2JqZWN0IGlkZW50aXR5IVxuICAgICAgICAvLyBUaGlzIG1lYW5zIGNoYW5naW5nIHRoZSBtYXRyaXggdmFsdWVzIHdpdGhvdXQgdGhlIGFjdHVhbCBtYXRyaXggb2JqZWN0XG4gICAgICAgIC8vIHdpbGwgRkFJTCB0byB1cGRhdGUgdGhlIG1hdHJpeCBwcm9wZXJseS5cbiAgICAgICAgaWYgKHNoYWRlci5wb3NNYXRyaXggIT09IHBvc01hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtTWF0cml4NGZ2KHNoYWRlci51X21hdHJpeCwgZmFsc2UsIHBvc01hdHJpeCk7XG4gICAgICAgICAgICBzaGFkZXIucG9zTWF0cml4ID0gcG9zTWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChleE1hdHJpeCAmJiBzaGFkZXIuZXhNYXRyaXggIT09IGV4TWF0cml4ICYmIHNoYWRlci51X2V4bWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyLnVfZXhtYXRyaXgsIGZhbHNlLCBleE1hdHJpeCk7XG4gICAgICAgICAgICBzaGFkZXIuZXhNYXRyaXggPSBleE1hdHJpeDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb250ZXh0LnZlcnRleEF0dHJpYjJmdiA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgdmFsdWVzKSB7XG4gICAgICAgIGNvbnRleHQudmVydGV4QXR0cmliMmYoYXR0cmlidXRlLCB2YWx1ZXNbMF0sIHZhbHVlc1sxXSk7XG4gICAgfTtcblxuICAgIGNvbnRleHQudmVydGV4QXR0cmliM2Z2ID0gZnVuY3Rpb24oYXR0cmlidXRlLCB2YWx1ZXMpIHtcbiAgICAgICAgY29udGV4dC52ZXJ0ZXhBdHRyaWIzZihhdHRyaWJ1dGUsIHZhbHVlc1swXSwgdmFsdWVzWzFdLCB2YWx1ZXNbMl0pO1xuICAgIH07XG5cbiAgICBjb250ZXh0LnZlcnRleEF0dHJpYjRmdiA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgdmFsdWVzKSB7XG4gICAgICAgIGNvbnRleHQudmVydGV4QXR0cmliNGYoYXR0cmlidXRlLCB2YWx1ZXNbMF0sIHZhbHVlc1sxXSwgdmFsdWVzWzJdLCB2YWx1ZXNbM10pO1xuICAgIH07XG5cbiAgICByZXR1cm4gY29udGV4dDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZUF0bGFzO1xuXG4vKipcbiAqIE11Y2ggbGlrZSBhIEdseXBoQXRsYXMsIGEgTGluZUF0bGFzIGxldHMgdXMgcmV1c2UgcmVuZGVyZWQgZGFzaGVkIGxpbmVzXG4gKiBieSB3cml0aW5nIG1hbnkgb2YgdGhlbSB0byBhIHRleHR1cmUgYW5kIHRoZW4gZmV0Y2hpbmcgdGhlaXIgcG9zaXRpb25zXG4gKiB1c2luZyAuZ2V0RGFzaC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIExpbmVBdGxhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubmV4dFJvdyA9IDA7XG5cbiAgICB0aGlzLmJ5dGVzID0gNDtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiB0aGlzLmJ5dGVzKTtcblxuICAgIHRoaXMucG9zaXRpb25zID0ge307XG59XG5cbkxpbmVBdGxhcy5wcm90b3R5cGUuc2V0U3ByaXRlID0gZnVuY3Rpb24oc3ByaXRlKSB7XG4gICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XG59O1xuXG4vKipcbiAqIEdldCBvciBjcmVhdGUgYSBkYXNoIGxpbmUgcGF0dGVybi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGRhc2hhcnJheVxuICogQHBhcmFtIHtib29sZWFufSByb3VuZCB3aGV0aGVyIHRvIGFkZCBjaXJjbGUgY2FwcyBpbiBiZXR3ZWVuIGRhc2ggc2VnbWVudHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvc2l0aW9uIG9mIGRhc2ggdGV4dHVyZSBpbiB7IHksIGhlaWdodCwgd2lkdGggfVxuICogQHByaXZhdGVcbiAqL1xuTGluZUF0bGFzLnByb3RvdHlwZS5nZXREYXNoID0gZnVuY3Rpb24oZGFzaGFycmF5LCByb3VuZCkge1xuICAgIHZhciBrZXkgPSBkYXNoYXJyYXkuam9pbihcIixcIikgKyByb3VuZDtcblxuICAgIGlmICghdGhpcy5wb3NpdGlvbnNba2V5XSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uc1trZXldID0gdGhpcy5hZGREYXNoKGRhc2hhcnJheSwgcm91bmQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnNba2V5XTtcbn07XG5cbkxpbmVBdGxhcy5wcm90b3R5cGUuYWRkRGFzaCA9IGZ1bmN0aW9uKGRhc2hhcnJheSwgcm91bmQpIHtcblxuICAgIHZhciBuID0gcm91bmQgPyA3IDogMDtcbiAgICB2YXIgaGVpZ2h0ID0gMiAqIG4gKyAxO1xuICAgIHZhciBvZmZzZXQgPSAxMjg7XG5cbiAgICBpZiAodGhpcy5uZXh0Um93ICsgaGVpZ2h0ID4gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdMaW5lQXRsYXMgb3V0IG9mIHNwYWNlJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGFzaGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aCArPSBkYXNoYXJyYXlbaV07XG4gICAgfVxuXG4gICAgdmFyIHN0cmV0Y2ggPSB0aGlzLndpZHRoIC8gbGVuZ3RoO1xuICAgIHZhciBoYWxmV2lkdGggPSBzdHJldGNoIC8gMjtcblxuICAgIC8vIElmIGRhc2hhcnJheSBoYXMgYW4gb2RkIGxlbmd0aCwgYm90aCB0aGUgZmlyc3QgYW5kIGxhc3QgcGFydHNcbiAgICAvLyBhcmUgZGFzaGVzIGFuZCBzaG91bGQgYmUgam9pbmVkIHNlYW1sZXNzbHkuXG4gICAgdmFyIG9kZExlbmd0aCA9IGRhc2hhcnJheS5sZW5ndGggJSAyID09PSAxO1xuXG4gICAgZm9yICh2YXIgeSA9IC1uOyB5IDw9IG47IHkrKykge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5uZXh0Um93ICsgbiArIHk7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMud2lkdGggKiByb3c7XG5cbiAgICAgICAgdmFyIGxlZnQgPSBvZGRMZW5ndGggPyAtZGFzaGFycmF5W2Rhc2hhcnJheS5sZW5ndGggLSAxXSA6IDA7XG4gICAgICAgIHZhciByaWdodCA9IGRhc2hhcnJheVswXTtcbiAgICAgICAgdmFyIHBhcnRJbmRleCA9IDE7XG5cbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcblxuICAgICAgICAgICAgd2hpbGUgKHJpZ2h0IDwgeCAvIHN0cmV0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodCArIGRhc2hhcnJheVtwYXJ0SW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9kZExlbmd0aCAmJiBwYXJ0SW5kZXggPT09IGRhc2hhcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICs9IGRhc2hhcnJheVswXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpc3RMZWZ0ID0gTWF0aC5hYnMoeCAtIGxlZnQgKiBzdHJldGNoKTtcbiAgICAgICAgICAgIHZhciBkaXN0UmlnaHQgPSBNYXRoLmFicyh4IC0gcmlnaHQgKiBzdHJldGNoKTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5taW4oZGlzdExlZnQsIGRpc3RSaWdodCk7XG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gKHBhcnRJbmRleCAlIDIpID09PSAxO1xuICAgICAgICAgICAgdmFyIHNpZ25lZERpc3RhbmNlO1xuXG4gICAgICAgICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgY2lyY2xlIGNhcHNcbiAgICAgICAgICAgICAgICB2YXIgZGlzdE1pZGRsZSA9IG4gPyB5IC8gbiAqIChoYWxmV2lkdGggKyAxKSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdEVkZ2UgPSBoYWxmV2lkdGggLSBNYXRoLmFicyhkaXN0TWlkZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVkRGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdCAqIGRpc3QgKyBkaXN0RWRnZSAqIGRpc3RFZGdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaWduZWREaXN0YW5jZSA9IGhhbGZXaWR0aCAtIE1hdGguc3FydChkaXN0ICogZGlzdCArIGRpc3RNaWRkbGUgKiBkaXN0TWlkZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ25lZERpc3RhbmNlID0gKGluc2lkZSA/IDEgOiAtMSkgKiBkaXN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRhdGFbMyArIChpbmRleCArIHgpICogNF0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHNpZ25lZERpc3RhbmNlICsgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcG9zID0ge1xuICAgICAgICB5OiAodGhpcy5uZXh0Um93ICsgbiArIDAuNSkgLyB0aGlzLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiAyICogbiAvIHRoaXMuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogbGVuZ3RoXG4gICAgfTtcblxuICAgIHRoaXMubmV4dFJvdyArPSBoZWlnaHQ7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gcG9zO1xufTtcblxuTGluZUF0bGFzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZ2wpIHtcbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLlJFUEVBVCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5kYXRhKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5MaW5lQXRsYXMucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBjYW52YXMuc3R5bGUudG9wID0gMDtcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9IDA7XG4gICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAnI2ZmMCc7XG5cbiAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnNkZikge1xuICAgICAgICAgICAgdmFyIGsgPSBpICogNDtcbiAgICAgICAgICAgIGRhdGEuZGF0YVtrXSA9IGRhdGEuZGF0YVtrICsgMV0gPSBkYXRhLmRhdGFbayArIDJdID0gMDtcbiAgICAgICAgICAgIGRhdGEuZGF0YVtrICsgM10gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3R4LnB1dEltYWdlRGF0YShkYXRhLCAwLCAwKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbHV0aWwgPSByZXF1aXJlKCcuL2dsX3V0aWwnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG52YXIgRnJhbWVIaXN0b3J5ID0gcmVxdWlyZSgnLi9mcmFtZV9oaXN0b3J5Jyk7XG5cbi8qXG4gKiBJbml0aWFsaXplIGEgbmV3IHBhaW50ZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzfSBnbCBhbiBleHBlcmltZW50YWwtd2ViZ2wgZHJhd2luZyBjb250ZXh0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUGFpbnRlcjtcbmZ1bmN0aW9uIFBhaW50ZXIoZ2wsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZ2wgPSBnbHV0aWwuZXh0ZW5kKGdsKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuICAgIHRoaXMucmV1c2FibGVUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMucHJlRmJvcyA9IHt9O1xuXG4gICAgdGhpcy5mcmFtZUhpc3RvcnkgPSBuZXcgRnJhbWVIaXN0b3J5KCk7XG5cbiAgICB0aGlzLnNldHVwKCk7XG59XG5cbi8qXG4gKiBVcGRhdGUgdGhlIEdMIHZpZXdwb3J0LCBwcm9qZWN0aW9uIG1hdHJpeCwgYW5kIHRyYW5zZm9ybXMgdG8gY29tcGVuc2F0ZVxuICogZm9yIGEgbmV3IHdpZHRoIGFuZCBoZWlnaHQgdmFsdWUuXG4gKi9cblBhaW50ZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxufTtcblxuXG5QYWludGVyLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC52ZXJib3NlID0gdHJ1ZTtcblxuICAgIC8vIFdlIGFyZSBibGVuZGluZyB0aGUgbmV3IHBpeGVscyAqYmVoaW5kKiB0aGUgZXhpc3RpbmcgcGl4ZWxzLiBUaGF0IHdheSB3ZSBjYW5cbiAgICAvLyBkcmF3IGZyb250LXRvLWJhY2sgYW5kIHVzZSB0aGVuIHN0ZW5jaWwgYnVmZmVyIHRvIGN1bGwgb3BhcXVlIHBpeGVscyBlYXJseS5cbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkUpO1xuXG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHNoYWRlcnNcbiAgICB0aGlzLmRlYnVnU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignZGVidWcnLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9wb2ludHNpemUnLCAndV9jb2xvciddKTtcblxuICAgIHRoaXMuZ2F1c3NpYW5TaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdnYXVzc2lhbicsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2ltYWdlJywgJ3Vfb2Zmc2V0J10pO1xuXG4gICAgdGhpcy5yYXN0ZXJTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdyYXN0ZXInLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfdGV4dHVyZV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2JyaWdodG5lc3NfbG93JywgJ3VfYnJpZ2h0bmVzc19oaWdoJywgJ3Vfc2F0dXJhdGlvbl9mYWN0b3InLCAndV9zcGluX3dlaWdodHMnLCAndV9jb250cmFzdF9mYWN0b3InLCAndV9vcGFjaXR5MCcsICd1X29wYWNpdHkxJywgJ3VfaW1hZ2UwJywgJ3VfaW1hZ2UxJywgJ3VfdGxfcGFyZW50JywgJ3Vfc2NhbGVfcGFyZW50JywgJ3VfYnVmZmVyX3NjYWxlJ10pO1xuXG4gICAgdGhpcy5saW5lU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignbGluZScsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9kYXRhJywgJ2FfY29sb3InLCAnYV9saW5ld2lkdGgnLCAnYV9ibHVyJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9yYXRpbycsICd1X2V4dHJhJywgJ3VfYW50aWFsaWFzaW5nbWF0cml4J10pO1xuXG4gICAgdGhpcy5saW5lcGF0dGVyblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2xpbmVwYXR0ZXJuJyxcbiAgICAgICAgWydhX3BvcycsICdhX2RhdGEnLCAnYV9saW5ld2lkdGgnLCAnYV9ibHVyJywgJ2Ffb3BhY2l0eSddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfZXhtYXRyaXgnLCAndV9yYXRpbycsICd1X3BhdHRlcm5fc2l6ZV9hJywgJ3VfcGF0dGVybl9zaXplX2InLCAndV9wYXR0ZXJuX3RsX2EnLCAndV9wYXR0ZXJuX2JyX2EnLCAndV9wYXR0ZXJuX3RsX2InLCAndV9wYXR0ZXJuX2JyX2InLCAndV9mYWRlJ10pO1xuXG4gICAgdGhpcy5saW5lc2RmcGF0dGVyblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2xpbmVzZGZwYXR0ZXJuJyxcbiAgICAgICAgWydhX3BvcycsICdhX2RhdGEnLCAnYV9jb2xvcicsICdhX2xpbmV3aWR0aCcsICdhX2JsdXInXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2V4bWF0cml4JywgJ3VfcmF0aW8nLCAndV9wYXR0ZXJuc2NhbGVfYScsICd1X3RleF95X2EnLCAndV9wYXR0ZXJuc2NhbGVfYicsICd1X3RleF95X2InLCAndV9pbWFnZScsICd1X3NkZmdhbW1hJywgJ3VfbWl4J10pO1xuXG4gICAgdGhpcy5kb3RTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdkb3QnLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9zaXplJywgJ3VfY29sb3InLCAndV9ibHVyJ10pO1xuXG4gICAgdGhpcy5zZGZTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdzZGYnLFxuICAgICAgICBbJ2FfcG9zJywgJ2Ffb2Zmc2V0JywgJ2FfZGF0YTEnLCAnYV9kYXRhMicsICdhX2NvbG9yJywgJ2FfYnVmZmVyJywgJ2FfZ2FtbWEnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2V4bWF0cml4JywgJ3VfdGV4dHVyZScsICd1X3RleHNpemUnLCAndV96b29tJywgJ3VfZmFkZWRpc3QnLCAndV9taW5mYWRlem9vbScsICd1X21heGZhZGV6b29tJywgJ3VfZmFkZXpvb20nLCAndV9za2V3ZWQnLCAndV9leHRyYSddKTtcblxuICAgIHRoaXMuaWNvblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2ljb24nLFxuICAgICAgICBbJ2FfcG9zJywgJ2Ffb2Zmc2V0JywgJ2FfZGF0YTEnLCAnYV9kYXRhMicsICdhX29wYWNpdHknXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2V4bWF0cml4JywgJ3VfdGV4dHVyZScsICd1X3RleHNpemUnLCAndV96b29tJywgJ3VfZmFkZWRpc3QnLCAndV9taW5mYWRlem9vbScsICd1X21heGZhZGV6b29tJywgJ3VfZmFkZXpvb20nLCAndV9za2V3ZWQnLCAndV9leHRyYSddKTtcblxuICAgIHRoaXMub3V0bGluZVNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ291dGxpbmUnLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfY29sb3InXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X3dvcmxkJ11cbiAgICApO1xuXG4gICAgdGhpcy5wYXR0ZXJuU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcigncGF0dGVybicsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X3BhdHRlcm5fdGxfYScsICd1X3BhdHRlcm5fYnJfYScsICd1X3BhdHRlcm5fdGxfYicsICd1X3BhdHRlcm5fYnJfYicsICd1X21peCcsICd1X3BhdHRlcm5tYXRyaXhfYScsICd1X3BhdHRlcm5tYXRyaXhfYicsICd1X29wYWNpdHknLCAndV9pbWFnZSddXG4gICAgKTtcblxuICAgIHRoaXMuZmlsbFNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2ZpbGwnLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfY29sb3InXSxcbiAgICAgICAgWyd1X21hdHJpeCddXG4gICAgKTtcblxuICAgIHRoaXMuY29sbGlzaW9uQm94U2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignY29sbGlzaW9uYm94JyxcbiAgICAgICAgWydhX3BvcycsICdhX2V4dHJ1ZGUnLCAnYV9kYXRhJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9zY2FsZScsICd1X3pvb20nLCAndV9tYXh6b29tJ11cbiAgICApO1xuXG4gICAgdGhpcy5pZGVudGl0eU1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgICAvLyBUaGUgYmFja2dyb3VuZEJ1ZmZlciBpcyB1c2VkIHdoZW4gZHJhd2luZyB0byB0aGUgZnVsbCAqY2FudmFzKlxuICAgIHRoaXMuYmFja2dyb3VuZEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuYmFja2dyb3VuZEJ1ZmZlci5pdGVtU2l6ZSA9IDI7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyLml0ZW1Db3VudCA9IDQ7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYmFja2dyb3VuZEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KFstMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgMV0pLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICB0aGlzLnNldEV4dGVudCg0MDk2KTtcblxuICAgIC8vIFRoZSBkZWJ1Z1RleHRCdWZmZXIgaXMgdXNlZCB0byBkcmF3IHRpbGUgSURzIGZvciBkZWJ1Z2dpbmdcbiAgICB0aGlzLmRlYnVnVGV4dEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplID0gMjtcbn07XG5cbi8qKlxuICogUmViaW5kIHRoZSBuZWNlc3NhcnkgYnVmZmVycyB0byByZW5kZXIgYXQgYSBkaWZmZXJlbnQgZXh0ZW50IHRoYW5cbiAqIHRoZSBjdXJyZW50IG9uZS4gTm8tb3BzIGlmIHRoZSBleHRlbnQgaXMgbm90IGNoYW5naW5nLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdFeHRlbnRcbiAqIEBleGFtcGxlXG4gKiB0aGlzLnNldEV4dGVudCg0MDk2KTtcbiAqIEBwcml2YXRlXG4gKi9cblBhaW50ZXIucHJvdG90eXBlLnNldEV4dGVudCA9IGZ1bmN0aW9uKG5ld0V4dGVudCkge1xuICAgIGlmICghbmV3RXh0ZW50IHx8IG5ld0V4dGVudCA9PT0gdGhpcy50aWxlRXh0ZW50KSByZXR1cm47XG5cbiAgICB0aGlzLnRpbGVFeHRlbnQgPSBuZXdFeHRlbnQ7XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gVGhlIHRpbGVFeHRlbnRCdWZmZXIgaXMgdXNlZCB3aGVuIGRyYXdpbmcgdG8gYSBmdWxsICp0aWxlKlxuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtU2l6ZSA9IDQ7XG4gICAgdGhpcy50aWxlRXh0ZW50QnVmZmVyLml0ZW1Db3VudCA9IDQ7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudGlsZUV4dGVudEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShcbiAgICAgICAgZ2wuQVJSQVlfQlVGRkVSLFxuICAgICAgICBuZXcgSW50MTZBcnJheShbXG4gICAgICAgICAgICAvLyB0aWxlIGNvb3JkIHgsIHRpbGUgY29vcmQgeSwgdGV4dHVyZSBjb29yZCB4LCB0ZXh0dXJlIGNvb3JkIHlcbiAgICAgICAgICAgIDAsIDAsIDAsIDAsXG4gICAgICAgICAgICB0aGlzLnRpbGVFeHRlbnQsIDAsIDMyNzY3LCAwLFxuICAgICAgICAgICAgMCwgdGhpcy50aWxlRXh0ZW50LCAwLCAzMjc2NyxcbiAgICAgICAgICAgIHRoaXMudGlsZUV4dGVudCwgdGhpcy50aWxlRXh0ZW50LCAgMzI3NjcsIDMyNzY3XG4gICAgICAgIF0pLFxuICAgICAgICBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvLyBUaGUgZGVidWdCdWZmZXIgaXMgdXNlZCB0byBkcmF3IHRpbGUgb3V0bGluZXMgZm9yIGRlYnVnZ2luZ1xuICAgIHRoaXMuZGVidWdCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmRlYnVnQnVmZmVyLml0ZW1TaXplID0gMjtcbiAgICB0aGlzLmRlYnVnQnVmZmVyLml0ZW1Db3VudCA9IDU7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuZGVidWdCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgICAgIGdsLkFSUkFZX0JVRkZFUixcbiAgICAgICAgbmV3IEludDE2QXJyYXkoW1xuICAgICAgICAgICAgMCwgMCwgdGhpcy50aWxlRXh0ZW50IC0gMSwgMCwgdGhpcy50aWxlRXh0ZW50IC0gMSwgdGhpcy50aWxlRXh0ZW50IC0gMSwgMCwgdGhpcy50aWxlRXh0ZW50IC0gMSwgMCwgMF0pLFxuICAgICAgICBnbC5TVEFUSUNfRFJBVyk7XG59O1xuXG4vKlxuICogUmVzZXQgdGhlIGNvbG9yIGJ1ZmZlcnMgb2YgdGhlIGRyYXdpbmcgY2FudmFzLlxuICovXG5QYWludGVyLnByb3RvdHlwZS5jbGVhckNvbG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xufTtcblxuLypcbiAqIFJlc2V0IHRoZSBkcmF3aW5nIGNhbnZhcyBieSBjbGVhcmluZyB0aGUgc3RlbmNpbCBidWZmZXIgc28gdGhhdCB3ZSBjYW4gZHJhd1xuICogbmV3IHRpbGVzIGF0IHRoZSBzYW1lIGxvY2F0aW9uLCB3aGlsZSByZXRhaW5pbmcgcHJldmlvdXNseSBkcmF3biBwaXhlbHMuXG4gKi9cblBhaW50ZXIucHJvdG90eXBlLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuY2xlYXJTdGVuY2lsKDB4MCk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHhGRik7XG4gICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlLmRyYXdDbGlwcGluZ01hc2sgPSBmdW5jdGlvbih0aWxlKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5zd2l0Y2hTaGFkZXIodGhpcy5maWxsU2hhZGVyLCB0aWxlLnBvc01hdHJpeCk7XG4gICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIC8vIENsZWFyIHRoZSBlbnRpcmUgc3RlbmNpbCBidWZmZXIsIGV4Y2VwdCBmb3IgdGhlIDd0aCBiaXQsIHdoaWNoIHN0b3Jlc1xuICAgIC8vIHRoZSBnbG9iYWwgY2xpcHBpbmcgbWFzayB0aGF0IGFsbG93cyB1cyB0byBhdm9pZCBkcmF3aW5nIGluIHJlZ2lvbnMgb2ZcbiAgICAvLyB0aWxlcyB3ZSd2ZSBhbHJlYWR5IHBhaW50ZWQgaW4uXG4gICAgZ2wuY2xlYXJTdGVuY2lsKDB4MCk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHhCRik7XG4gICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcblxuICAgIC8vIFRoZSBzdGVuY2lsIHRlc3Qgd2lsbCBmYWlsIGFsd2F5cywgbWVhbmluZyB3ZSBzZXQgYWxsIHBpeGVscyBjb3ZlcmVkXG4gICAgLy8gYnkgdGhpcyBnZW9tZXRyeSB0byAweDgwLiBXZSB1c2UgdGhlIGhpZ2hlc3QgYml0IDB4ODAgdG8gbWFyayB0aGUgcmVnaW9uc1xuICAgIC8vIHdlIHdhbnQgdG8gZHJhdyBpbi4gQWxsIHBpeGVscyB0aGF0IGhhdmUgdGhpcyBiaXQgKm5vdCogc2V0IHdpbGwgbmV2ZXIgYmVcbiAgICAvLyBkcmF3biBpbi5cbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHhDMCwgMHg0MCk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHhDMCk7XG4gICAgZ2wuc3RlbmNpbE9wKGdsLlJFUExBQ0UsIGdsLktFRVAsIGdsLktFRVApO1xuXG4gICAgLy8gRHJhdyB0aGUgY2xpcHBpbmcgbWFza1xuICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmZpbGxTaGFkZXIuYV9jb2xvcik7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudGlsZUV4dGVudEJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmZpbGxTaGFkZXIuYV9wb3MsIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCA4LCAwKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbUNvdW50KTtcblxuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweDgwLCAweDgwKTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuUkVQTEFDRSk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuZmlsbFNoYWRlci5hX2NvbG9yKTtcbn07XG5cbi8vIE92ZXJyaWRkZW4gYnkgaGVhZGxlc3MgdGVzdHMuXG5QYWludGVyLnByb3RvdHlwZS5wcmVwYXJlQnVmZmVycyA9IGZ1bmN0aW9uKCkge307XG5QYWludGVyLnByb3RvdHlwZS5iaW5kRGVmYXVsdEZyYW1lYnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xufTtcblxudmFyIGRyYXcgPSB7XG4gICAgc3ltYm9sOiByZXF1aXJlKCcuL2RyYXdfc3ltYm9sJyksXG4gICAgbGluZTogcmVxdWlyZSgnLi9kcmF3X2xpbmUnKSxcbiAgICBmaWxsOiByZXF1aXJlKCcuL2RyYXdfZmlsbCcpLFxuICAgIHJhc3RlcjogcmVxdWlyZSgnLi9kcmF3X3Jhc3RlcicpLFxuICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4vZHJhd19iYWNrZ3JvdW5kJyksXG4gICAgZGVidWc6IHJlcXVpcmUoJy4vZHJhd19kZWJ1ZycpLFxuICAgIHZlcnRpY2VzOiByZXF1aXJlKCcuL2RyYXdfdmVydGljZXMnKVxufTtcblxuUGFpbnRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMubGluZUF0bGFzID0gc3R5bGUubGluZUF0bGFzO1xuXG4gICAgdGhpcy5zcHJpdGVBdGxhcyA9IHN0eWxlLnNwcml0ZUF0bGFzO1xuICAgIHRoaXMuc3ByaXRlQXRsYXMuc2V0U3ByaXRlKHN0eWxlLnNwcml0ZSk7XG5cbiAgICB0aGlzLmdseXBoQXRsYXMgPSBzdHlsZS5nbHlwaEF0bGFzO1xuICAgIHRoaXMuZ2x5cGhBdGxhcy5iaW5kKHRoaXMuZ2wpO1xuXG4gICAgdGhpcy5mcmFtZUhpc3RvcnkucmVjb3JkKHRoaXMudHJhbnNmb3JtLnpvb20pO1xuXG4gICAgdGhpcy5wcmVwYXJlQnVmZmVycygpO1xuICAgIHRoaXMuY2xlYXJDb2xvcigpO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0eWxlLl9ncm91cHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGdyb3VwID0gc3R5bGUuX2dyb3Vwc1tpXTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHN0eWxlLnNvdXJjZXNbZ3JvdXAuc291cmNlXTtcblxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU3RlbmNpbCgpO1xuICAgICAgICAgICAgc291cmNlLnJlbmRlcihncm91cCwgdGhpcyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChncm91cC5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3TGF5ZXJzKGdyb3VwLCB0aGlzLmlkZW50aXR5TWF0cml4KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblBhaW50ZXIucHJvdG90eXBlLmRyYXdUaWxlID0gZnVuY3Rpb24odGlsZSwgbGF5ZXJzKSB7XG4gICAgdGhpcy5zZXRFeHRlbnQodGlsZS50aWxlRXh0ZW50KTtcbiAgICB0aGlzLmRyYXdDbGlwcGluZ01hc2sodGlsZSk7XG4gICAgdGhpcy5kcmF3TGF5ZXJzKGxheWVycywgdGlsZS5wb3NNYXRyaXgsIHRpbGUpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICBkcmF3LmRlYnVnKHRoaXMsIHRpbGUpO1xuICAgIH1cbn07XG5cblBhaW50ZXIucHJvdG90eXBlLmRyYXdMYXllcnMgPSBmdW5jdGlvbihsYXllcnMsIG1hdHJpeCwgdGlsZSkge1xuICAgIGZvciAodmFyIGkgPSBsYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuXG4gICAgICAgIGlmIChsYXllci5oaWRkZW4pXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBkcmF3W2xheWVyLnR5cGVdKHRoaXMsIGxheWVyLCBtYXRyaXgsIHRpbGUpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVydGljZXMpIHtcbiAgICAgICAgICAgIGRyYXcudmVydGljZXModGhpcywgbGF5ZXIsIG1hdHJpeCwgdGlsZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBEcmF3cyBub24tb3BhcXVlIGFyZWFzLiBUaGlzIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5QYWludGVyLnByb3RvdHlwZS5kcmF3U3RlbmNpbEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuc3dpdGNoU2hhZGVyKHRoaXMuZmlsbFNoYWRlciwgdGhpcy5pZGVudGl0eU1hdHJpeCk7XG5cbiAgICAvLyBCbGVuZCB0byB0aGUgZnJvbnQsIG5vdCB0aGUgYmFjay5cbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XG5cbiAgICAvLyBEcncgdGhlIGZpbGxpbmcgcXVhZCB3aGVyZSB0aGUgc3RlbmNpbCBidWZmZXIgaXNuJ3Qgc2V0LlxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJhY2tncm91bmRCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5maWxsU2hhZGVyLmFfcG9zLCB0aGlzLmJhY2tncm91bmRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuZmlsbFNoYWRlci5hX2NvbG9yKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWI0ZnYodGhpcy5maWxsU2hhZGVyLmFfY29sb3IsIFswLCAwLCAwLCAwLjVdKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbUNvdW50KTtcblxuICAgIC8vIFJldmVydCBibGVuZGluZyBtb2RlIHRvIGJsZW5kIHRvIHRoZSBiYWNrLlxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkUpO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUudHJhbnNsYXRlTWF0cml4ID0gZnVuY3Rpb24obWF0cml4LCB0aWxlLCB0cmFuc2xhdGUsIGFuY2hvcikge1xuICAgIGlmICghdHJhbnNsYXRlWzBdICYmICF0cmFuc2xhdGVbMV0pIHJldHVybiBtYXRyaXg7XG5cbiAgICBpZiAoYW5jaG9yID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgIHZhciBzaW5BID0gTWF0aC5zaW4oLXRoaXMudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICAgICAgdmFyIGNvc0EgPSBNYXRoLmNvcygtdGhpcy50cmFuc2Zvcm0uYW5nbGUpO1xuICAgICAgICB0cmFuc2xhdGUgPSBbXG4gICAgICAgICAgICB0cmFuc2xhdGVbMF0gKiBjb3NBIC0gdHJhbnNsYXRlWzFdICogc2luQSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVswXSAqIHNpbkEgKyB0cmFuc2xhdGVbMV0gKiBjb3NBXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdmFyIHRpbGVQaXhlbFJhdGlvID0gdGhpcy50cmFuc2Zvcm0uc2NhbGUgLyAoMSA8PCB0aWxlLmNvb3JkLnopIC8gKHRpbGUudGlsZUV4dGVudCAvIHRpbGUudGlsZVNpemUpO1xuICAgIHZhciB0cmFuc2xhdGlvbiA9IFtcbiAgICAgICAgdHJhbnNsYXRlWzBdIC8gdGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIHRyYW5zbGF0ZVsxXSAvIHRpbGVQaXhlbFJhdGlvLFxuICAgICAgICAwXG4gICAgXTtcblxuICAgIHZhciB0cmFuc2xhdGVkTWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgbWF0NC50cmFuc2xhdGUodHJhbnNsYXRlZE1hdHJpeCwgbWF0cml4LCB0cmFuc2xhdGlvbik7XG4gICAgcmV0dXJuIHRyYW5zbGF0ZWRNYXRyaXg7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5zYXZlVGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnJldXNhYmxlVGV4dHVyZXNbdGV4dHVyZS5zaXplXTtcbiAgICBpZiAoIXRleHR1cmVzKSB7XG4gICAgICAgIHRoaXMucmV1c2FibGVUZXh0dXJlc1t0ZXh0dXJlLnNpemVdID0gW3RleHR1cmVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgfVxufTtcblxuXG5QYWludGVyLnByb3RvdHlwZS5nZXRUZXh0dXJlID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMucmV1c2FibGVUZXh0dXJlc1tzaXplXTtcbiAgICByZXR1cm4gdGV4dHVyZXMgJiYgdGV4dHVyZXMubGVuZ3RoID4gMCA/IHRleHR1cmVzLnBvcCgpIDogbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbGlmeSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgXCJkZWJ1Z1wiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O2F0dHJpYnV0ZSB2ZWMyIGFfcG9zO3VuaWZvcm0gZmxvYXQgdV9wb2ludHNpemU7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3ZvaWQgbWFpbigpe2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3Msc3RlcCgzMjc2Ny4sYV9wb3MueCksMSk7Z2xfUG9pbnRTaXplPXVfcG9pbnRzaXplO31cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDt1bmlmb3JtIHZlYzQgdV9jb2xvcjt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dV9jb2xvcjt9XCJ9LFxuICAgIFwiZG90XCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gZmxvYXQgdV9zaXplO2F0dHJpYnV0ZSB2ZWMyIGFfcG9zO3ZvaWQgbWFpbigpe2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTtnbF9Qb2ludFNpemU9dV9zaXplO31cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDt1bmlmb3JtIHZlYzQgdV9jb2xvcjt1bmlmb3JtIGZsb2F0IHVfYmx1cjt2b2lkIG1haW4oKXtmbG9hdCBhLGI7YT1sZW5ndGgoZ2xfUG9pbnRDb29yZC0uNSk7Yj1zbW9vdGhzdGVwKC41LC41LXVfYmx1cixhKTtnbF9GcmFnQ29sb3I9dV9jb2xvcipiO31cIn0sXG4gICAgXCJmaWxsXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O2F0dHJpYnV0ZSB2ZWMyIGFfcG9zO2F0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7dmFyeWluZyB2ZWM0IGE7dm9pZCBtYWluKCl7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO2dsX1BvaW50U2l6ZT0yLjthPWFfY29sb3I7fVwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O3ZhcnlpbmcgdmVjNCBhO3ZvaWQgbWFpbigpe2dsX0ZyYWdDb2xvcj1hO31cIn0sXG4gICAgXCJnYXVzc2lhblwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O2F0dHJpYnV0ZSB2ZWMyIGFfcG9zO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV9vZmZzZXQ7dmFyeWluZyB2ZWMyIGFbM107dm9pZCBtYWluKCl7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO3ZlYzIgYj1nbF9Qb3NpdGlvbi54eS8yLisuNTthWzBdPWI7YVsxXT1iK3Vfb2Zmc2V0KjEuMTgyNDI1NTIzODA2MzU2MzthWzJdPWItdV9vZmZzZXQqMS4xODI0MjU1MjM4MDYzNTYzO31cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3ZhcnlpbmcgdmVjMiBhWzNdO3ZvaWQgbWFpbigpe3ZlYzQgYj12ZWM0KDApO2IrPXRleHR1cmUyRCh1X2ltYWdlLGFbMF0pKi40MDI2MTk5NDY4OTQyNDc0NjtiKz10ZXh0dXJlMkQodV9pbWFnZSxhWzFdKSouMjk4NjkwMDI2NTUyODc2MztiKz10ZXh0dXJlMkQodV9pbWFnZSxhWzJdKSouMjk4NjkwMDI2NTUyODc2MztnbF9GcmFnQ29sb3I9Yjt9XCJ9LFxuICAgIFwibGluZVwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O2F0dHJpYnV0ZSB2ZWMyIGFfcG9zLGFfbGluZXdpZHRoO2F0dHJpYnV0ZSB2ZWM0IGFfZGF0YSxhX2NvbG9yO2F0dHJpYnV0ZSBmbG9hdCBhX2JsdXI7dW5pZm9ybSBoaWdocCBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gZmxvYXQgdV9yYXRpbyx1X2V4dHJhO3VuaWZvcm0gbWF0MiB1X2FudGlhbGlhc2luZ21hdHJpeDt2YXJ5aW5nIHZlYzIgYSxlO3ZhcnlpbmcgZmxvYXQgYixkLGY7dmFyeWluZyB2ZWM0IGM7dm9pZCBtYWluKCl7dmVjMiBnLGg7Zz1hX2RhdGEueHk7aD1tb2QoYV9wb3MsMi4pO2gueT1zaWduKGgueS0uNSk7YT1oO3ZlYzQgaT12ZWM0KGFfbGluZXdpZHRoLnMqZyouMDE1ODczMDE2LDAsMCk7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChmbG9vcihhX3BvcyouNSkraS54eS91X3JhdGlvLDAsMSk7ZmxvYXQgaixrLGw7aj1nbF9Qb3NpdGlvbi55L2dsX1Bvc2l0aW9uLnc7az1sZW5ndGgoZykvbGVuZ3RoKHVfYW50aWFsaWFzaW5nbWF0cml4KmcpO2w9MS4vKDEuLWoqdV9leHRyYSk7ZD1sKms7Yz1hX2NvbG9yO2U9YV9saW5ld2lkdGg7Zj1hX2JsdXI7fVwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O3VuaWZvcm0gdmVjMiB1X2Rhc2hhcnJheTt2YXJ5aW5nIHZlYzQgYzt2YXJ5aW5nIHZlYzIgYSxlO3ZhcnlpbmcgZmxvYXQgYixkLGY7dm9pZCBtYWluKCl7ZmxvYXQgZyxoLGk7Zz1sZW5ndGgoYSkqZS5zO2g9ZipkO2k9Y2xhbXAobWluKGctKGUudC1oKSxlLnMtZykvaCwwLiwxLik7Z2xfRnJhZ0NvbG9yPWMqaTt9XCJ9LFxuICAgIFwibGluZXBhdHRlcm5cIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDthdHRyaWJ1dGUgdmVjMiBhX3BvcyxhX2xpbmV3aWR0aDthdHRyaWJ1dGUgdmVjNCBhX2RhdGE7YXR0cmlidXRlIGZsb2F0IGFfYmx1cixhX29wYWNpdHk7dW5pZm9ybSBoaWdocCBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gbWF0NCB1X2V4bWF0cml4O3VuaWZvcm0gZmxvYXQgdV9yYXRpbzt2YXJ5aW5nIHZlYzIgYSxjO3ZhcnlpbmcgZmxvYXQgYixkLGU7dm9pZCBtYWluKCl7dmVjMiBmLGgsaSxqO2Y9YV9kYXRhLnh5O2Zsb2F0IGc9YV9kYXRhLnoqMTI4LithX2RhdGEudztoPW1vZChhX3BvcywyLik7aC55PXNpZ24oaC55LS41KTthPWg7aT1mKi4wMTU4NzMwMTY7aj1hX2xpbmV3aWR0aC5zKmk7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChmbG9vcihhX3BvcyouNSkrai54eS91X3JhdGlvLDAsMSk7Yj1nO2M9YV9saW5ld2lkdGg7ZD1hX2JsdXI7ZT1hX29wYWNpdHk7fVwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O3VuaWZvcm0gZmxvYXQgdV9wb2ludCx1X2ZhZGU7dW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9zaXplX2EsdV9wYXR0ZXJuX3NpemVfYix1X3BhdHRlcm5fdGxfYSx1X3BhdHRlcm5fYnJfYSx1X3BhdHRlcm5fdGxfYix1X3BhdHRlcm5fYnJfYjt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3ZhcnlpbmcgdmVjMiBhLGM7dmFyeWluZyBmbG9hdCBiLGQsZTt2b2lkIG1haW4oKXtmbG9hdCBmLGcsaCxpLGosaztmPWxlbmd0aChhKSpjLnM7Zz1jbGFtcChtaW4oZi0oYy50LWQpLGMucy1mKS9kLDAuLDEuKTtoPW1vZChiL3VfcGF0dGVybl9zaXplX2EueCwxLik7aT1tb2QoYi91X3BhdHRlcm5fc2l6ZV9iLngsMS4pO2o9LjUrYS55KmMucy91X3BhdHRlcm5fc2l6ZV9hLnk7az0uNSthLnkqYy5zL3VfcGF0dGVybl9zaXplX2IueTt2ZWMyIGwsbTtsPW1peCh1X3BhdHRlcm5fdGxfYSx1X3BhdHRlcm5fYnJfYSx2ZWMyKGgsaikpO209bWl4KHVfcGF0dGVybl90bF9iLHVfcGF0dGVybl9icl9iLHZlYzIoaSxrKSk7dmVjNCBuPW1peCh0ZXh0dXJlMkQodV9pbWFnZSxsKSx0ZXh0dXJlMkQodV9pbWFnZSxtKSx1X2ZhZGUpO2cqPWU7Z2xfRnJhZ0NvbG9yPW4qZzt9XCJ9LFxuICAgIFwibGluZXNkZnBhdHRlcm5cIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDthdHRyaWJ1dGUgdmVjMiBhX3BvcyxhX2xpbmV3aWR0aDthdHRyaWJ1dGUgdmVjNCBhX2RhdGEsYV9jb2xvcjthdHRyaWJ1dGUgZmxvYXQgYV9ibHVyO3VuaWZvcm0gaGlnaHAgbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1hdDQgdV9leG1hdHJpeDt1bmlmb3JtIGZsb2F0IHVfcmF0aW8sdV90ZXhfeV9hLHVfdGV4X3lfYjt1bmlmb3JtIHZlYzIgdV9wYXR0ZXJuc2NhbGVfYSx1X3BhdHRlcm5zY2FsZV9iO3ZhcnlpbmcgdmVjMiBhLGIsYyxlO3ZhcnlpbmcgdmVjNCBkO3ZhcnlpbmcgZmxvYXQgZjt2b2lkIG1haW4oKXt2ZWMyIGcsaTtnPWFfZGF0YS54eTtmbG9hdCBoPWFfZGF0YS56KjEyOC4rYV9kYXRhLnc7aT1tb2QoYV9wb3MsMi4pO2kueT1zaWduKGkueS0uNSk7YT1pO3ZlYzQgaj12ZWM0KGFfbGluZXdpZHRoLnMqZyouMDE1ODczMDE2LDAsMCk7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChmbG9vcihhX3BvcyouNSkrai54eS91X3JhdGlvLDAsMSk7Yj12ZWMyKGgqdV9wYXR0ZXJuc2NhbGVfYS54LGkueSp1X3BhdHRlcm5zY2FsZV9hLnkrdV90ZXhfeV9hKTtjPXZlYzIoaCp1X3BhdHRlcm5zY2FsZV9iLngsaS55KnVfcGF0dGVybnNjYWxlX2IueSt1X3RleF95X2IpO2Q9YV9jb2xvcjtlPWFfbGluZXdpZHRoO2Y9YV9ibHVyO31cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3VuaWZvcm0gZmxvYXQgdV9zZGZnYW1tYSx1X21peDt2YXJ5aW5nIHZlYzIgYSxiLGMsZTt2YXJ5aW5nIHZlYzQgZDt2YXJ5aW5nIGZsb2F0IGY7dm9pZCBtYWluKCl7ZmxvYXQgZyxoLGksaixrO2c9bGVuZ3RoKGEpKmUucztoPWNsYW1wKG1pbihnLShlLnQtZiksZS5zLWcpL2YsMC4sMS4pO2k9dGV4dHVyZTJEKHVfaW1hZ2UsYikuYTtqPXRleHR1cmUyRCh1X2ltYWdlLGMpLmE7az1taXgoaSxqLHVfbWl4KTtoKj1zbW9vdGhzdGVwKC41LXVfc2RmZ2FtbWEsLjUrdV9zZGZnYW1tYSxrKTtnbF9GcmFnQ29sb3I9ZCpoO31cIn0sXG4gICAgXCJvdXRsaW5lXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7YXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIHZlYzQgYV9jb2xvcjt1bmlmb3JtIGhpZ2hwIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSB2ZWMyIHVfd29ybGQ7dmFyeWluZyB2ZWM0IGE7dmFyeWluZyB2ZWMyIGI7dm9pZCBtYWluKCl7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO2I9KGdsX1Bvc2l0aW9uLnh5L2dsX1Bvc2l0aW9uLncrMS4pLzIuKnVfd29ybGQ7YT1hX2NvbG9yO31cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDt2YXJ5aW5nIHZlYzQgYTt2YXJ5aW5nIHZlYzIgYjt2b2lkIG1haW4oKXtmbG9hdCBjLGQ7Yz1sZW5ndGgoYi1nbF9GcmFnQ29vcmQueHkpO2Q9c21vb3Roc3RlcCgxLiwwLixjKTtnbF9GcmFnQ29sb3I9YSpkO31cIn0sXG4gICAgXCJwYXR0ZXJuXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gbWF0MyB1X3BhdHRlcm5tYXRyaXhfYSx1X3BhdHRlcm5tYXRyaXhfYjthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzIgYSxiO3ZvaWQgbWFpbigpe2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTthPSh1X3BhdHRlcm5tYXRyaXhfYSp2ZWMzKGFfcG9zLDEpKS54eTtiPSh1X3BhdHRlcm5tYXRyaXhfYip2ZWMzKGFfcG9zLDEpKS54eTt9XCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7dW5pZm9ybSBmbG9hdCB1X29wYWNpdHksdV9taXg7dW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9hLHVfcGF0dGVybl9icl9hLHVfcGF0dGVybl90bF9iLHVfcGF0dGVybl9icl9iO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIGEsYjt2b2lkIG1haW4oKXt2ZWMyIGMsZCxmLGc7Yz1tb2QoYSwxLik7ZD1taXgodV9wYXR0ZXJuX3RsX2EsdV9wYXR0ZXJuX2JyX2EsYyk7dmVjNCBlLGg7ZT10ZXh0dXJlMkQodV9pbWFnZSxkKTtmPW1vZChiLDEuKTtnPW1peCh1X3BhdHRlcm5fdGxfYix1X3BhdHRlcm5fYnJfYixmKTtoPXRleHR1cmUyRCh1X2ltYWdlLGcpO2dsX0ZyYWdDb2xvcj1taXgoZSxoLHVfbWl4KSp1X29wYWNpdHk7fVwifSxcbiAgICBcInJhc3RlclwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV90bF9wYXJlbnQ7dW5pZm9ybSBmbG9hdCB1X3NjYWxlX3BhcmVudCx1X2J1ZmZlcl9zY2FsZTthdHRyaWJ1dGUgdmVjMiBhX3BvcyxhX3RleHR1cmVfcG9zO3ZhcnlpbmcgdmVjMiBhLGI7dm9pZCBtYWluKCl7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO2E9KGFfdGV4dHVyZV9wb3MvMzI3NjcuLS41KS91X2J1ZmZlcl9zY2FsZSsuNTtiPWEqdV9zY2FsZV9wYXJlbnQrdV90bF9wYXJlbnQ7fVwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O3VuaWZvcm0gZmxvYXQgdV9vcGFjaXR5MCx1X29wYWNpdHkxLHVfYnJpZ2h0bmVzc19sb3csdV9icmlnaHRuZXNzX2hpZ2gsdV9zYXR1cmF0aW9uX2ZhY3Rvcix1X2NvbnRyYXN0X2ZhY3Rvcjt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMCx1X2ltYWdlMTt2YXJ5aW5nIHZlYzIgYSxiO3VuaWZvcm0gdmVjMyB1X3NwaW5fd2VpZ2h0czt2b2lkIG1haW4oKXt2ZWM0IGMsZCxlO2M9dGV4dHVyZTJEKHVfaW1hZ2UwLGEpO2Q9dGV4dHVyZTJEKHVfaW1hZ2UxLGIpO2U9Yyp1X29wYWNpdHkwK2QqdV9vcGFjaXR5MTt2ZWMzIGYsaCxpO2Y9ZS5yZ2I7Zj12ZWMzKGRvdChmLHVfc3Bpbl93ZWlnaHRzLnh5eiksZG90KGYsdV9zcGluX3dlaWdodHMuenh5KSxkb3QoZix1X3NwaW5fd2VpZ2h0cy55engpKTtmbG9hdCBnPShlLnIrZS5nK2UuYikvMy47Zis9KGctZikqdV9zYXR1cmF0aW9uX2ZhY3RvcjtmPShmLS41KSp1X2NvbnRyYXN0X2ZhY3RvcisuNTtoPXZlYzModV9icmlnaHRuZXNzX2xvdyk7aT12ZWMzKHVfYnJpZ2h0bmVzc19oaWdoKTtnbF9GcmFnQ29sb3I9dmVjNChtaXgoaCxpLGYpLGUuYSk7fVwifSxcbiAgICBcImljb25cIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDthdHRyaWJ1dGUgdmVjMiBhX3BvcyxhX29mZnNldDthdHRyaWJ1dGUgdmVjNCBhX2RhdGExLGFfZGF0YTI7YXR0cmlidXRlIGZsb2F0IGFfb3BhY2l0eTt1bmlmb3JtIGhpZ2hwIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfZXhtYXRyaXg7dW5pZm9ybSBmbG9hdCB1X3pvb20sdV9mYWRlZGlzdCx1X21pbmZhZGV6b29tLHVfbWF4ZmFkZXpvb20sdV9mYWRlem9vbSx1X2V4dHJhO3VuaWZvcm0gYm9vbCB1X3NrZXdlZDt1bmlmb3JtIHZlYzIgdV90ZXhzaXplO3ZhcnlpbmcgdmVjMiBhO3ZhcnlpbmcgZmxvYXQgYjt2b2lkIG1haW4oKXt2ZWMyIGMsZTtjPWFfZGF0YTEueHk7ZmxvYXQgZCxmLGcsaCxpLGo7ZD1hX2RhdGExWzJdO2U9YV9kYXRhMi5zdDtmPWVbMF07Zz1lWzFdO2g9MTAuO2k9Mi4tc3RlcChmLHVfem9vbSktKDEuLXN0ZXAoZyx1X3pvb20pKTtqPWNsYW1wKCh1X2ZhZGV6b29tLWQpL3VfZmFkZWRpc3QsMC4sMS4pO2lmKHVfZmFkZWRpc3Q+PTAuKWI9ajtlbHNlIGI9MS4tajtpZih1X21heGZhZGV6b29tPGQpYj0wLjtpZih1X21pbmZhZGV6b29tPj1kKWI9MS47aSs9c3RlcChiLDAuKTtpZih1X3NrZXdlZCl7dmVjNCBrPXVfZXhtYXRyaXgqdmVjNChhX29mZnNldC82NC4sMCwwKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zK2sueHksMCwxKTtnbF9Qb3NpdGlvbi56Kz1pKmdsX1Bvc2l0aW9uLnc7fWVsc2V7dmVjNCBrPXVfZXhtYXRyaXgqdmVjNChhX29mZnNldC82NC4saSwwKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLDAsMSkrazt9YT1jL3VfdGV4c2l6ZTtiKj1hX29wYWNpdHk7fVwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O3VuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTt2YXJ5aW5nIHZlYzIgYTt2YXJ5aW5nIGZsb2F0IGI7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRCh1X3RleHR1cmUsYSkqYjt9XCJ9LFxuICAgIFwic2RmXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7YXR0cmlidXRlIHZlYzIgYV9wb3MsYV9vZmZzZXQ7YXR0cmlidXRlIHZlYzQgYV9kYXRhMSxhX2RhdGEyLGFfY29sb3I7YXR0cmlidXRlIGZsb2F0IGFfYnVmZmVyLGFfZ2FtbWE7dW5pZm9ybSBoaWdocCBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gbWF0NCB1X2V4bWF0cml4O3VuaWZvcm0gZmxvYXQgdV96b29tLHVfZmFkZWRpc3QsdV9taW5mYWRlem9vbSx1X21heGZhZGV6b29tLHVfZmFkZXpvb20sdV9leHRyYTt1bmlmb3JtIGJvb2wgdV9za2V3ZWQ7dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt2YXJ5aW5nIHZlYzIgYTt2YXJ5aW5nIGZsb2F0IGIsYyxlLGY7dmFyeWluZyB2ZWM0IGQ7dm9pZCBtYWluKCl7dmVjMiBnLGk7Zz1hX2RhdGExLnh5O2Zsb2F0IGgsaixrLGwsbSxuLG87aD1hX2RhdGExWzJdO2k9YV9kYXRhMi5zdDtqPWlbMF07az1pWzFdO2w9Mi4tc3RlcChqLHVfem9vbSktKDEuLXN0ZXAoayx1X3pvb20pKTttPWNsYW1wKCh1X2ZhZGV6b29tLWgpL3VfZmFkZWRpc3QsMC4sMS4pO2lmKHVfZmFkZWRpc3Q+PTAuKWI9bTtlbHNlIGI9MS4tbTtpZih1X21heGZhZGV6b29tPGgpYj0wLjtpZih1X21pbmZhZGV6b29tPj1oKWI9MS47bCs9c3RlcChiLDAuKTtpZih1X3NrZXdlZCl7dmVjNCBuPXVfZXhtYXRyaXgqdmVjNChhX29mZnNldC82NC4sMCwwKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zK24ueHksMCwxKTtnbF9Qb3NpdGlvbi56Kz1sKmdsX1Bvc2l0aW9uLnc7fWVsc2V7dmVjNCBuPXVfZXhtYXRyaXgqdmVjNChhX29mZnNldC82NC4sbCwwKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLDAsMSkrbjt9bj1nbF9Qb3NpdGlvbi55L2dsX1Bvc2l0aW9uLnc7bz0xLi8oMS4tbip1X2V4dHJhKTtjPW87YT1nL3VfdGV4c2l6ZTtkPWFfY29sb3I7ZT1hX2J1ZmZlcjtmPWFfZ2FtbWE7fVwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O3VuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTt2YXJ5aW5nIHZlYzIgYTt2YXJ5aW5nIGZsb2F0IGIsYyxlLGY7dmFyeWluZyB2ZWM0IGQ7dm9pZCBtYWluKCl7ZmxvYXQgZyxoLGk7Zz1mKmM7aD10ZXh0dXJlMkQodV90ZXh0dXJlLGEpLmE7aT1zbW9vdGhzdGVwKGUtZyxlK2csaCkqYjtnbF9GcmFnQ29sb3I9ZCppO31cIn0sXG4gICAgXCJjb2xsaXNpb25ib3hcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDthdHRyaWJ1dGUgdmVjMiBhX3BvcyxhX2V4dHJ1ZGUsYV9kYXRhO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIGZsb2F0IHVfc2NhbGU7dmFyeWluZyBmbG9hdCBhLGI7dm9pZCBtYWluKCl7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcythX2V4dHJ1ZGUvdV9zY2FsZSwwLDEpO2E9YV9kYXRhLng7Yj1hX2RhdGEueTt9XCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7dW5pZm9ybSBmbG9hdCB1X3pvb20sdV9tYXh6b29tO3ZhcnlpbmcgZmxvYXQgYSxiO3ZvaWQgbWFpbigpe2Zsb2F0IGM9LjU7Z2xfRnJhZ0NvbG9yPXZlYzQoMCwxLDAsMSkqYztpZihiPnVfem9vbSlnbF9GcmFnQ29sb3I9dmVjNCgxLDAsMCwxKSpjO2lmKHVfem9vbT49YSlnbF9GcmFnQ29sb3I9dmVjNCgwLDAsMCwxKSpjKi4yNTtpZihiPj11X21heHpvb20pZ2xfRnJhZ0NvbG9yPXZlYzQoMCwwLDEsMSkqYyouMjt9XCJ9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBUaWxlUHlyYW1pZCA9IHJlcXVpcmUoJy4vdGlsZV9weXJhbWlkJyk7XG52YXIgU291cmNlID0gcmVxdWlyZSgnLi9zb3VyY2UnKTtcbnZhciB1cmxSZXNvbHZlID0gcmVxdWlyZSgncmVzb2x2ZS11cmwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW9KU09OU291cmNlO1xuXG4vKipcbiAqIENyZWF0ZSBhIEdlb0pTT04gZGF0YSBzb3VyY2UgaW5zdGFuY2UgZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3RcbiAqIEBjbGFzcyBHZW9KU09OU291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9wdGlvbnMuZGF0YSBBIEdlb0pTT04gZGF0YSBvYmplY3Qgb3IgVVJMIHRvIGl0LiBUaGUgbGF0dGVyIGlzIHByZWZlcmFibGUgaW4gY2FzZSBvZiBsYXJnZSBHZW9KU09OIGZpbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heHpvb209MTRdIE1heGltdW0gem9vbSB0byBwcmVzZXJ2ZSBkZXRhaWwgYXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYnVmZmVyXSBUaWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudG9sZXJhbmNlXSBTaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2UgKGhpZ2hlciBtZWFucyBzaW1wbGVyKS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgc291cmNlT2JqID0gbmV3IG1hcGJveGdsLkdlb0pTT05Tb3VyY2Uoe1xuICogICAgZGF0YToge1xuICogICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgICAgICAgXCJmZWF0dXJlc1wiOiBbe1xuICogICAgICAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1xuICogICAgICAgICAgICAgICAgICAgIC03Ni41MzA2MzI5NzI3MTcyOSxcbiAqICAgICAgICAgICAgICAgICAgICAzOS4xODE3NDA3Nzk5NDEwOFxuICogICAgICAgICAgICAgICAgXVxuICogICAgICAgICAgICB9XG4gKiAgICAgICAgfV1cbiAqICAgIH1cbiAqIH0pO1xuICogbWFwLmFkZFNvdXJjZSgnc29tZSBpZCcsIHNvdXJjZU9iaik7IC8vIGFkZFxuICogbWFwLnJlbW92ZVNvdXJjZSgnc29tZSBpZCcpOyAgLy8gcmVtb3ZlXG4gKi9cbmZ1bmN0aW9uIEdlb0pTT05Tb3VyY2Uob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5fZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIGlmIChvcHRpb25zLm1heHpvb20gIT09IHVuZGVmaW5lZCkgdGhpcy5tYXh6b29tID0gb3B0aW9ucy5tYXh6b29tO1xuXG4gICAgdGhpcy5nZW9qc29uVnRPcHRpb25zID0geyBtYXhab29tOiB0aGlzLm1heHpvb20gfTtcbiAgICBpZiAob3B0aW9ucy5idWZmZXIgIT09IHVuZGVmaW5lZCkgdGhpcy5nZW9qc29uVnRPcHRpb25zLmJ1ZmZlciA9IG9wdGlvbnMuYnVmZmVyO1xuICAgIGlmIChvcHRpb25zLnRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkKSB0aGlzLmdlb2pzb25WdE9wdGlvbnMudG9sZXJhbmNlID0gb3B0aW9ucy50b2xlcmFuY2U7XG5cbiAgICB0aGlzLl9weXJhbWlkID0gbmV3IFRpbGVQeXJhbWlkKHtcbiAgICAgICAgdGlsZVNpemU6IDUxMixcbiAgICAgICAgbWluem9vbTogdGhpcy5taW56b29tLFxuICAgICAgICBtYXh6b29tOiB0aGlzLm1heHpvb20sXG4gICAgICAgIGNhY2hlU2l6ZTogMjAsXG4gICAgICAgIGxvYWQ6IHRoaXMuX2xvYWRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgIGFib3J0OiB0aGlzLl9hYm9ydFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgdW5sb2FkOiB0aGlzLl91bmxvYWRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgIGFkZDogdGhpcy5fYWRkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICByZW1vdmU6IHRoaXMuX3JlbW92ZVRpbGUuYmluZCh0aGlzKVxuICAgIH0pO1xufVxuXG5HZW9KU09OU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCAvKiogQGxlbmRzIEdlb0pTT05Tb3VyY2UucHJvdG90eXBlICove1xuICAgIG1pbnpvb206IDAsXG4gICAgbWF4em9vbTogMTQsXG4gICAgX2RpcnR5OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNvdXJjZSBnZW9qc29uIGRhdGEgYW5kIHJlcmVuZGVyIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBkYXRhIEEgR2VvSlNPTiBkYXRhIG9iamVjdCBvciBVUkwgdG8gaXQuIFRoZSBsYXR0ZXIgaXMgcHJlZmVyYWJsZSBpbiBjYXNlIG9mIGxhcmdlIEdlb0pTT04gZmlsZXMuXG4gICAgICogQHJldHVybnMge0dlb0pTT05Tb3VyY2V9IHRoaXNcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcblxuICAgICAgICBpZiAodGhpcy5tYXApXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLm1hcC50cmFuc2Zvcm0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH0sXG5cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkICYmIHRoaXMuX3B5cmFtaWQubG9hZGVkKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHlyYW1pZC51cGRhdGUodGhpcy51c2VkLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3B5cmFtaWQucmVsb2FkKCk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogU291cmNlLl9yZW5kZXJUaWxlcyxcbiAgICBmZWF0dXJlc0F0OiBTb3VyY2UuX3ZlY3RvckZlYXR1cmVzQXQsXG5cbiAgICBfdXBkYXRlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YSA9IHVybFJlc29sdmUod2luZG93LmxvY2F0aW9uLmhyZWYsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud29ya2VySUQgPSB0aGlzLmRpc3BhdGNoZXIuc2VuZCgncGFyc2UgZ2VvanNvbicsIHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB0aWxlU2l6ZTogNTEyLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgZ2VvanNvblZ0T3B0aW9uczogdGhpcy5nZW9qc29uVnRPcHRpb25zXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3B5cmFtaWQucmVsb2FkKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIF9sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB2YXIgb3ZlcnNjYWxpbmcgPSB0aWxlLmNvb3JkLnogPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB0aWxlLmNvb3JkLnogLSB0aGlzLm1heHpvb20pIDogMTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHVpZDogdGlsZS51aWQsXG4gICAgICAgICAgICBjb29yZDogdGlsZS5jb29yZCxcbiAgICAgICAgICAgIHpvb206IHRpbGUuY29vcmQueixcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4em9vbSxcbiAgICAgICAgICAgIHRpbGVTaXplOiA1MTIsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICBvdmVyc2NhbGluZzogb3ZlcnNjYWxpbmcsXG4gICAgICAgICAgICBhbmdsZTogdGhpcy5tYXAudHJhbnNmb3JtLmFuZ2xlLFxuICAgICAgICAgICAgcGl0Y2g6IHRoaXMubWFwLnRyYW5zZm9ybS5waXRjaCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkRlYnVnOiB0aGlzLm1hcC5jb2xsaXNpb25EZWJ1Z1xuICAgICAgICB9O1xuXG4gICAgICAgIHRpbGUud29ya2VySUQgPSB0aGlzLmRpc3BhdGNoZXIuc2VuZCgnbG9hZCBnZW9qc29uIHRpbGUnLCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuXG4gICAgICAgICAgICB0aWxlLnVubG9hZFZlY3RvckRhdGEodGhpcy5tYXAucGFpbnRlcik7XG5cbiAgICAgICAgICAgIGlmICh0aWxlLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlLmVycm9yJywge3RpbGU6IHRpbGV9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbGUubG9hZFZlY3RvckRhdGEoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUubG9hZCcsIHt0aWxlOiB0aWxlfSk7XG5cbiAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLndvcmtlcklEKTtcbiAgICB9LFxuXG4gICAgX2Fib3J0VGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUudW5sb2FkVmVjdG9yRGF0YSh0aGlzLm1hcC5wYWludGVyKTtcbiAgICAgICAgdGhpcy5nbHlwaEF0bGFzLnJlbW92ZUdseXBocyh0aWxlLnVpZCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdyZW1vdmUgdGlsZScsIHsgdWlkOiB0aWxlLnVpZCwgc291cmNlOiB0aGlzLmlkIH0sIG51bGwsIHRpbGUud29ya2VySUQpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIFZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgndmVjdG9yLXRpbGUnKS5WZWN0b3JUaWxlRmVhdHVyZTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW9KU09OV3JhcHBlcjtcblxuLy8gY29uZm9ybSB0byB2ZWN0b3J0aWxlIGFwaVxuZnVuY3Rpb24gR2VvSlNPTldyYXBwZXIoZmVhdHVyZXMpIHtcbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgdGhpcy5sZW5ndGggPSBmZWF0dXJlcy5sZW5ndGg7XG59XG5cbkdlb0pTT05XcmFwcGVyLnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBuZXcgRmVhdHVyZVdyYXBwZXIodGhpcy5mZWF0dXJlc1tpXSk7XG59O1xuXG5mdW5jdGlvbiBGZWF0dXJlV3JhcHBlcihmZWF0dXJlKSB7XG4gICAgdGhpcy50eXBlID0gZmVhdHVyZS50eXBlO1xuICAgIHRoaXMucmF3R2VvbWV0cnkgPSBmZWF0dXJlLnR5cGUgPT09IDEgPyBbZmVhdHVyZS5nZW9tZXRyeV0gOiBmZWF0dXJlLmdlb21ldHJ5O1xuICAgIHRoaXMucHJvcGVydGllcyA9IGZlYXR1cmUudGFncztcbiAgICB0aGlzLmV4dGVudCA9IDQwOTY7XG59XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmluZ3MgPSB0aGlzLnJhd0dlb21ldHJ5O1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXSxcbiAgICAgICAgICAgIG5ld1JpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBuZXdSaW5nLnB1c2gobmV3IFBvaW50KHJpbmdbal1bMF0sIHJpbmdbal1bMV0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlb21ldHJ5LnB1c2gobmV3UmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5O1xufTtcblxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cnkpIHRoaXMubG9hZEdlb21ldHJ5KCk7XG5cbiAgICB2YXIgcmluZ3MgPSB0aGlzLmdlb21ldHJ5LFxuICAgICAgICB4MSA9IEluZmluaXR5LFxuICAgICAgICB4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgeTEgPSBJbmZpbml0eSxcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSByaW5nW2pdO1xuXG4gICAgICAgICAgICB4MSA9IE1hdGgubWluKHgxLCBjb29yZC54KTtcbiAgICAgICAgICAgIHgyID0gTWF0aC5tYXgoeDIsIGNvb3JkLngpO1xuICAgICAgICAgICAgeTEgPSBNYXRoLm1pbih5MSwgY29vcmQueSk7XG4gICAgICAgICAgICB5MiA9IE1hdGgubWF4KHkyLCBjb29yZC55KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xufTtcblxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLnRvR2VvSlNPTiA9IFZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS50b0dlb0pTT047XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBTb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZScpO1xudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplVGlsZVVSTDtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXN0ZXJUaWxlU291cmNlO1xuXG5mdW5jdGlvbiBSYXN0ZXJUaWxlU291cmNlKG9wdGlvbnMpIHtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLCB1dGlsLnBpY2sob3B0aW9ucywgWyd1cmwnLCAndGlsZVNpemUnXSkpO1xuXG4gICAgU291cmNlLl9sb2FkVGlsZUpTT04uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUmFzdGVyVGlsZVNvdXJjZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwge1xuICAgIG1pbnpvb206IDAsXG4gICAgbWF4em9vbTogMjIsXG4gICAgdGlsZVNpemU6IDUxMixcbiAgICBfbG9hZGVkOiBmYWxzZSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfSxcblxuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9weXJhbWlkICYmIHRoaXMuX3B5cmFtaWQubG9hZGVkKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLl9weXJhbWlkKSB7XG4gICAgICAgICAgICB0aGlzLl9weXJhbWlkLnVwZGF0ZSh0aGlzLnVzZWQsIHRyYW5zZm9ybSwgdGhpcy5tYXAuc3R5bGUucmFzdGVyRmFkZUR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIHJlbmRlcjogU291cmNlLl9yZW5kZXJUaWxlcyxcblxuICAgIF9sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICBhamF4LmdldEltYWdlKG5vcm1hbGl6ZVVSTCh0aWxlLmNvb3JkLnVybCh0aGlzLnRpbGVzKSwgdGhpcy51cmwpLCBmdW5jdGlvbihlcnIsIGltZykge1xuICAgICAgICAgICAgaWYgKHRpbGUuYWJvcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuZXJyb3InLCB7dGlsZTogdGlsZX0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5tYXAucGFpbnRlci5nbDtcbiAgICAgICAgICAgIHRpbGUudGV4dHVyZSA9IHRoaXMubWFwLnBhaW50ZXIuZ2V0VGV4dHVyZShpbWcud2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRpbGUudGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRpbGUudGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aWxlLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGlsZS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XG4gICAgICAgICAgICAgICAgdGlsZS50ZXh0dXJlLnNpemUgPSBpbWcud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcblxuICAgICAgICAgICAgdGlsZS50aW1lQWRkZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMubWFwLmFuaW1hdGlvbkxvb3Auc2V0KHRoaXMuc3R5bGUucmFzdGVyRmFkZUR1cmF0aW9uKTtcblxuICAgICAgICAgICAgdGlsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICAgICAgdGlsZS5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUubG9hZCcsIHt0aWxlOiB0aWxlfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIF9hYm9ydFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGlsZS5hYm9ydGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX2FkZFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLmFkZCcsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgndGlsZS5yZW1vdmUnLCB7dGlsZTogdGlsZX0pO1xuICAgIH0sXG5cbiAgICBfdW5sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICBpZiAodGlsZS50ZXh0dXJlKSB0aGlzLm1hcC5wYWludGVyLnNhdmVUZXh0dXJlKHRpbGUudGV4dHVyZSk7XG4gICAgfSxcblxuICAgIGZlYXR1cmVzQXQ6IGZ1bmN0aW9uKHBvaW50LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIFRpbGVQeXJhbWlkID0gcmVxdWlyZSgnLi90aWxlX3B5cmFtaWQnKTtcbnZhciBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVfY29vcmQnKTtcbnZhciBub3JtYWxpemVVUkwgPSByZXF1aXJlKCcuLi91dGlsL21hcGJveCcpLm5vcm1hbGl6ZVNvdXJjZVVSTDtcblxuZXhwb3J0cy5fbG9hZFRpbGVKU09OID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBsb2FkZWQgPSBmdW5jdGlvbihlcnIsIHRpbGVKU09OKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5leHRlbmQodGhpcywgdXRpbC5waWNrKHRpbGVKU09OLFxuICAgICAgICAgICAgWyd0aWxlcycsICdtaW56b29tJywgJ21heHpvb20nLCAnYXR0cmlidXRpb24nXSkpO1xuXG4gICAgICAgIHRoaXMuX3B5cmFtaWQgPSBuZXcgVGlsZVB5cmFtaWQoe1xuICAgICAgICAgICAgdGlsZVNpemU6IHRoaXMudGlsZVNpemUsXG4gICAgICAgICAgICBjYWNoZVNpemU6IDIwLFxuICAgICAgICAgICAgbWluem9vbTogdGhpcy5taW56b29tLFxuICAgICAgICAgICAgbWF4em9vbTogdGhpcy5tYXh6b29tLFxuICAgICAgICAgICAgcmVwYXJzZU92ZXJzY2FsZWQ6IHRoaXMucmVwYXJzZU92ZXJzY2FsZWQsXG4gICAgICAgICAgICBsb2FkOiB0aGlzLl9sb2FkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgYWJvcnQ6IHRoaXMuX2Fib3J0VGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgdW5sb2FkOiB0aGlzLl91bmxvYWRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBhZGQ6IHRoaXMuX2FkZFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJlbW92ZTogdGhpcy5fcmVtb3ZlVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVkb1BsYWNlbWVudDogdGhpcy5fcmVkb1RpbGVQbGFjZW1lbnQgPyB0aGlzLl9yZWRvVGlsZVBsYWNlbWVudC5iaW5kKHRoaXMpIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGlmIChvcHRpb25zLnVybCkge1xuICAgICAgICBhamF4LmdldEpTT04obm9ybWFsaXplVVJMKG9wdGlvbnMudXJsKSwgbG9hZGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBicm93c2VyLmZyYW1lKGxvYWRlZC5iaW5kKHRoaXMsIG51bGwsIG9wdGlvbnMpKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLl9yZW5kZXJUaWxlcyA9IGZ1bmN0aW9uKGxheWVycywgcGFpbnRlcikge1xuICAgIGlmICghdGhpcy5fcHlyYW1pZClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIGlkcyA9IHRoaXMuX3B5cmFtaWQucmVuZGVyZWRJRHMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3B5cmFtaWQuZ2V0VGlsZShpZHNbaV0pLFxuICAgICAgICAgICAgLy8gY29vcmQgaXMgZGlmZmVyZW50IHRoYW4gdGlsZS5jb29yZCBmb3Igd3JhcHBlZCB0aWxlcyBzaW5jZSB0aGUgYWN0dWFsXG4gICAgICAgICAgICAvLyB0aWxlIG9iamVjdCBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlIHZpc2libGUgY29waWVzIG9mIHRoYXQgdGlsZS5cbiAgICAgICAgICAgIGNvb3JkID0gVGlsZUNvb3JkLmZyb21JRChpZHNbaV0pLFxuICAgICAgICAgICAgeiA9IGNvb3JkLnosXG4gICAgICAgICAgICB4ID0gY29vcmQueCxcbiAgICAgICAgICAgIHkgPSBjb29yZC55LFxuICAgICAgICAgICAgdyA9IGNvb3JkLnc7XG5cbiAgICAgICAgLy8gaWYgeiA+IG1heHpvb20gdGhlbiB0aGUgdGlsZSBpcyBhY3R1YWxseSBhIG92ZXJzY2FsZWQgbWF4em9vbSB0aWxlLFxuICAgICAgICAvLyBzbyBjYWxjdWxhdGUgdGhlIG1hdHJpeCB0aGUgbWF4em9vbSB0aWxlIHdvdWxkIHVzZS5cbiAgICAgICAgeiA9IE1hdGgubWluKHosIHRoaXMubWF4em9vbSk7XG5cbiAgICAgICAgeCArPSB3ICogKDEgPDwgeik7XG4gICAgICAgIHRpbGUuY2FsY3VsYXRlTWF0cmljZXMoeiwgeCwgeSwgcGFpbnRlci50cmFuc2Zvcm0sIHBhaW50ZXIpO1xuXG4gICAgICAgIHBhaW50ZXIuZHJhd1RpbGUodGlsZSwgbGF5ZXJzKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLl92ZWN0b3JGZWF0dXJlc0F0ID0gZnVuY3Rpb24oY29vcmQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3B5cmFtaWQpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcHlyYW1pZC50aWxlQXQoY29vcmQpO1xuICAgIGlmICghcmVzdWx0KVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgW10pO1xuXG4gICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3F1ZXJ5IGZlYXR1cmVzJywge1xuICAgICAgICB1aWQ6IHJlc3VsdC50aWxlLnVpZCxcbiAgICAgICAgeDogcmVzdWx0LngsXG4gICAgICAgIHk6IHJlc3VsdC55LFxuICAgICAgICBzY2FsZTogcmVzdWx0LnNjYWxlLFxuICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgfSwgY2FsbGJhY2ssIHJlc3VsdC50aWxlLndvcmtlcklEKTtcbn07XG5cbi8qXG4gKiBDcmVhdGUgYSB0aWxlZCBkYXRhIHNvdXJjZSBpbnN0YW5jZSBnaXZlbiBhbiBvcHRpb25zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50eXBlIEVpdGhlciBgcmFzdGVyYCBvciBgdmVjdG9yYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVybCBBIHRpbGUgc291cmNlIFVSTC4gVGhpcyBzaG91bGQgZWl0aGVyIGJlIGBtYXBib3g6Ly97bWFwaWR9YCBvciBhIGZ1bGwgYGh0dHBbc11gIHVybCB0aGF0IHBvaW50cyB0byBhIFRpbGVKU09OIGVuZHBvaW50LlxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy50aWxlcyBBbiBhcnJheSBvZiB0aWxlIHNvdXJjZXMuIElmIGB1cmxgIGlzIG5vdCBzcGVjaWZpZWQsIGB0aWxlc2AgY2FuIGJlIHVzZWQgaW5zdGVhZCB0byBzcGVjaWZ5IHRpbGUgc291cmNlcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIE90aGVyIFRpbGVKU09OIGtleXMgc3VjaCBhcyBgbWluem9vbWAgYW5kIGBtYXh6b29tYCBjYW4gYmUgc3BlY2lmaWVkIGluIGEgc291cmNlIG9iamVjdCBpZiBgdGlsZXNgIGlzIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5pZCBBbiBvcHRpb25hbCBgaWRgIHRvIGFzc2lnbiB0byB0aGUgc291cmNlXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudGlsZVNpemU9NTEyXSBPcHRpb25hbCB0aWxlIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQgaW4gcGl4ZWxzLCBhc3N1bWluZyB0aWxlcyBhcmUgc3F1YXJlKS4gVGhpcyBvcHRpb24gaXMgb25seSBjb25maWd1cmFibGUgZm9yIHJhc3RlciBzb3VyY2VzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jYWNoZVNpemUgT3B0aW9uYWwgbWF4IG51bWJlciBvZiB0aWxlcyB0byBjYWNoZSBhdCBhbnkgZ2l2ZW4gdGltZVxuICogQGV4YW1wbGVcbiAqIHZhciBzb3VyY2VPYmogPSBuZXcgbWFwYm94Z2wuU291cmNlLmNyZWF0ZSh7XG4gKiAgICB0eXBlOiAndmVjdG9yJyxcbiAqICAgIHVybDogJ21hcGJveDovL21hcGJveC5tYXBib3gtc3RyZWV0cy12NSdcbiAqIH0pO1xuICogbWFwLmFkZFNvdXJjZSgnc29tZSBpZCcsIHNvdXJjZU9iaik7IC8vIGFkZFxuICogbWFwLnJlbW92ZVNvdXJjZSgnc29tZSBpZCcpOyAgLy8gcmVtb3ZlXG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYXQgZmlsZSBzY29wZSBpbiBvcmRlciB0byBhdm9pZCBhIGNpcmN1bGFyIHJlcXVpcmUuXG4gICAgdmFyIHNvdXJjZXMgPSB7XG4gICAgICAgIHZlY3RvcjogcmVxdWlyZSgnLi92ZWN0b3JfdGlsZV9zb3VyY2UnKSxcbiAgICAgICAgcmFzdGVyOiByZXF1aXJlKCcuL3Jhc3Rlcl90aWxlX3NvdXJjZScpLFxuICAgICAgICBnZW9qc29uOiByZXF1aXJlKCcuL2dlb2pzb25fc291cmNlJyksXG4gICAgICAgIHZpZGVvOiByZXF1aXJlKCcuL3ZpZGVvX3NvdXJjZScpXG4gICAgfTtcblxuICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlcykge1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2Ygc291cmNlc1t0eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgc291cmNlc1tzb3VyY2UudHlwZV0oc291cmNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG1hdHJpeCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpO1xudmFyIG1hdDIgPSBnbG1hdHJpeC5tYXQyO1xudmFyIG1hdDQgPSBnbG1hdHJpeC5tYXQ0O1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBCdWZmZXJTZXQgPSByZXF1aXJlKCcuLi9kYXRhL2J1ZmZlci9idWZmZXJfc2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZTtcblxuLyoqXG4gKiBBIHRpbGUgb2JqZWN0IGlzIHRoZSBjb21iaW5hdGlvbiBvZiBhIENvb3JkaW5hdGUsIHdoaWNoIGRlZmluZXNcbiAqIGl0cyBwbGFjZSwgYXMgd2VsbCBhcyBhIHVuaXF1ZSBJRCBhbmQgZGF0YSB0cmFja2luZyBmb3IgaXRzIGNvbnRlbnRcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVGlsZShjb29yZCwgc2l6ZSkge1xuICAgIHRoaXMuY29vcmQgPSBjb29yZDtcbiAgICB0aGlzLnVpZCA9IHV0aWwudW5pcXVlSWQoKTtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMudXNlcyA9IDA7XG4gICAgdGhpcy50aWxlU2l6ZSA9IHNpemU7XG59XG5cblRpbGUucHJvdG90eXBlID0ge1xuICAgIC8vIHRvZG8gdW5oYXJkY29kZVxuICAgIHRpbGVFeHRlbnQ6IDQwOTYsXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGludGVybmFsIHBvc01hdHJpeCB0aGF0IHRoaXMgdGlsZSB1c2VzIHRvIGRpc3BsYXlcbiAgICAgKiBpdHNlbGYgaW4gYSBtYXAsIGdpdmVuIGEgY29vcmRpbmF0ZSBhcyAoeiwgeCwgeSkgYW5kIGEgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2FsY3VsYXRlTWF0cmljZXM6IGZ1bmN0aW9uKHosIHgsIHksIHRyYW5zZm9ybSkge1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgbW9kZWwtdmlldyBtYXRyaXggdGhhdCBjb252ZXJ0cyBmcm9tIHRoZSB0aWxlIGNvb3JkaW5hdGVzXG4gICAgICAgIC8vIHRvIHNjcmVlbiBjb29yZGluYXRlcy5cbiAgICAgICAgdmFyIHRpbGVTY2FsZSA9IE1hdGgucG93KDIsIHopO1xuICAgICAgICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0ud29ybGRTaXplIC8gdGlsZVNjYWxlO1xuXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG5cbiAgICAgICAgLy8gVGhlIHBvc2l0aW9uIG1hdHJpeFxuICAgICAgICB0aGlzLnBvc01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMucG9zTWF0cml4KTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy5wb3NNYXRyaXgsIHRoaXMucG9zTWF0cml4LCBbeCAqIHNjYWxlLCB5ICogc2NhbGUsIDBdKTtcblxuICAgICAgICBtYXQ0LnNjYWxlKHRoaXMucG9zTWF0cml4LCB0aGlzLnBvc01hdHJpeCwgWyBzY2FsZSAvIHRoaXMudGlsZUV4dGVudCwgc2NhbGUgLyB0aGlzLnRpbGVFeHRlbnQsIDEgXSk7XG4gICAgICAgIG1hdDQubXVsdGlwbHkodGhpcy5wb3NNYXRyaXgsIHRyYW5zZm9ybS5nZXRQcm9qTWF0cml4KCksIHRoaXMucG9zTWF0cml4KTtcblxuICAgICAgICAvLyBUaGUgZXh0cnVzaW9uIG1hdHJpeC5cbiAgICAgICAgdGhpcy5leE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIG1hdDQub3J0aG8odGhpcy5leE1hdHJpeCwgMCwgdHJhbnNmb3JtLndpZHRoLCB0cmFuc2Zvcm0uaGVpZ2h0LCAwLCAwLCAtMSk7XG4gICAgICAgIC8vbWF0NC5yb3RhdGVaKHRoaXMuZXhNYXRyaXgsIHRoaXMuZXhNYXRyaXgsIC10cmFuc2Zvcm0uYW5nbGUpO1xuXG4gICAgICAgIC8vIDJ4MiBtYXRyaXggZm9yIHJvdGF0aW5nIHBvaW50c1xuICAgICAgICB0aGlzLnJvdGF0aW9uTWF0cml4ID0gbWF0Mi5jcmVhdGUoKTtcbiAgICAgICAgbWF0Mi5yb3RhdGUodGhpcy5yb3RhdGlvbk1hdHJpeCwgdGhpcy5yb3RhdGlvbk1hdHJpeCwgdHJhbnNmb3JtLmFuZ2xlKTtcblxuICAgICAgICB0aGlzLnBvc01hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5wb3NNYXRyaXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGNvb3JkaW5hdGUgcG9zaXRpb24sIHpvb20gdGhhdCBjb29yZGluYXRlIHRvIG15IHpvb20gYW5kXG4gICAgICogc2NhbGUgYW5kIHJldHVybiBhIHBvc2l0aW9uIGluIHgsIHksIHNjYWxlXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwb3NpdGlvbkF0OiBmdW5jdGlvbihjb29yZCwgc291cmNlTWF4Wm9vbSkge1xuICAgICAgICBjb29yZCA9IGNvb3JkLnpvb21UbyhNYXRoLm1pbih0aGlzLmNvb3JkLnosIHNvdXJjZU1heFpvb20pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IChjb29yZC5jb2x1bW4gLSB0aGlzLmNvb3JkLngpICogNDA5NixcbiAgICAgICAgICAgIHk6IChjb29yZC5yb3cgLSB0aGlzLmNvb3JkLnkpICogNDA5NixcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgZGF0YSBvYmplY3Qgd2l0aCBhICdidWZmZXJzJyBwcm9wZXJ0eSwgbG9hZCBpdCBpbnRvXG4gICAgICogdGhpcyB0aWxlJ3MgZWxlbWVudEdyb3VwcyBhbmQgYnVmZmVycyBwcm9wZXJ0aWVzIGFuZCBzZXQgbG9hZGVkXG4gICAgICogdG8gdHJ1ZS4gSWYgdGhlIGRhdGEgaXMgbnVsbCwgbGlrZSBpbiB0aGUgY2FzZSBvZiBhbiBlbXB0eVxuICAgICAqIEdlb0pTT04gdGlsZSwgbm8tb3AgYnV0IHN0aWxsIHNldCBsb2FkZWQgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsb2FkVmVjdG9yRGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gZW1wdHkgR2VvSlNPTiB0aWxlXG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG5ldyBCdWZmZXJTZXQoZGF0YS5idWZmZXJzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50R3JvdXBzID0gZGF0YS5lbGVtZW50R3JvdXBzO1xuICAgICAgICB0aGlzLnRpbGVFeHRlbnQgPSBkYXRhLmV4dGVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYSBkYXRhIG9iamVjdCBhbmQgYSBHTCBwYWludGVyLCBkZXN0cm95IGFuZCByZS1jcmVhdGVcbiAgICAgKiBhbGwgb2YgaXRzIGJ1ZmZlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFpbnRlclxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZWxvYWRTeW1ib2xEYXRhOiBmdW5jdGlvbihkYXRhLCBwYWludGVyKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIC8vIHRoZSB0aWxlIGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWZmZXJzLmdseXBoVmVydGV4LmRlc3Ryb3kocGFpbnRlci5nbCk7XG4gICAgICAgIHRoaXMuYnVmZmVycy5nbHlwaEVsZW1lbnQuZGVzdHJveShwYWludGVyLmdsKTtcbiAgICAgICAgdGhpcy5idWZmZXJzLmljb25WZXJ0ZXguZGVzdHJveShwYWludGVyLmdsKTtcbiAgICAgICAgdGhpcy5idWZmZXJzLmljb25FbGVtZW50LmRlc3Ryb3kocGFpbnRlci5nbCk7XG4gICAgICAgIHRoaXMuYnVmZmVycy5jb2xsaXNpb25Cb3hWZXJ0ZXguZGVzdHJveShwYWludGVyLmdsKTtcblxuICAgICAgICB2YXIgYnVmZmVycyA9IG5ldyBCdWZmZXJTZXQoZGF0YS5idWZmZXJzKTtcbiAgICAgICAgdGhpcy5idWZmZXJzLmdseXBoVmVydGV4ID0gYnVmZmVycy5nbHlwaFZlcnRleDtcbiAgICAgICAgdGhpcy5idWZmZXJzLmdseXBoRWxlbWVudCA9IGJ1ZmZlcnMuZ2x5cGhFbGVtZW50O1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuaWNvblZlcnRleCA9IGJ1ZmZlcnMuaWNvblZlcnRleDtcbiAgICAgICAgdGhpcy5idWZmZXJzLmljb25FbGVtZW50ID0gYnVmZmVycy5pY29uRWxlbWVudDtcbiAgICAgICAgdGhpcy5idWZmZXJzLmNvbGxpc2lvbkJveFZlcnRleCA9IGJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4O1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIGRhdGEuZWxlbWVudEdyb3Vwcykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50R3JvdXBzW2lkXSA9IGRhdGEuZWxlbWVudEdyb3Vwc1tpZF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHRoYXQgdGhpcyB0aWxlIGRvZXNuJ3Qgb3duIGFueSBkYXRhIHdpdGhpbiBhIGdpdmVuXG4gICAgICogcGFpbnRlciwgc28gdGhhdCBpdCBkb2Vzbid0IGNvbnN1bWUgYW55IG1lbW9yeSBvciBtYWludGFpblxuICAgICAqIGFueSByZWZlcmVuY2VzIHRvIHRoZSBwYWludGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWludGVyIGdsIHBhaW50ZXIgb2JqZWN0XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVubG9hZFZlY3RvckRhdGE6IGZ1bmN0aW9uKHBhaW50ZXIpIHtcbiAgICAgICAgZm9yICh2YXIgYiBpbiB0aGlzLmJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyc1tiXS5kZXN0cm95KHBhaW50ZXIuZ2wpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG51bGw7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUaWxlQ29vcmQ7XG5cbmZ1bmN0aW9uIFRpbGVDb29yZCh6LCB4LCB5LCB3KSB7XG4gICAgaWYgKHcgPT09IHVuZGVmaW5lZCkgdyA9IDA7XG4gICAgdGhpcy56ID0gejtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53ID0gdztcblxuICAgIC8vIGNhbGN1bGF0ZSBpZFxuICAgIHcgKj0gMjtcbiAgICBpZiAodyA8IDApIHcgPSB3ICogLTEgLSAxO1xuICAgIHZhciBkaW0gPSAxIDw8IHRoaXMuejtcbiAgICB0aGlzLmlkID0gKChkaW0gKiBkaW0gKiB3ICsgZGltICogdGhpcy55ICsgdGhpcy54KSAqIDMyKSArIHRoaXMuejtcbn1cblxuVGlsZUNvb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnogKyBcIi9cIiArIHRoaXMueCArIFwiL1wiICsgdGhpcy55O1xufTtcblxuLy8gUGFyc2UgYSBwYWNrZWQgaW50ZWdlciBpZCBpbnRvIGEgVGlsZUNvb3JkIG9iamVjdFxuVGlsZUNvb3JkLmZyb21JRCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHogPSBpZCAlIDMyLCBkaW0gPSAxIDw8IHo7XG4gICAgdmFyIHh5ID0gKChpZCAtIHopIC8gMzIpO1xuICAgIHZhciB4ID0geHkgJSBkaW0sIHkgPSAoKHh5IC0geCkgLyBkaW0pICUgZGltO1xuICAgIHZhciB3ID0gTWF0aC5mbG9vcih4eSAvIChkaW0gKiBkaW0pKTtcbiAgICBpZiAodyAlIDIgIT09IDApIHcgPSB3ICogLTEgLSAxO1xuICAgIHcgLz0gMjtcbiAgICByZXR1cm4gbmV3IFRpbGVDb29yZCh6LCB4LCB5LCB3KTtcbn07XG5cbi8vIGdpdmVuIGEgbGlzdCBvZiB1cmxzLCBjaG9vc2UgYSB1cmwgdGVtcGxhdGUgYW5kIHJldHVybiBhIHRpbGUgVVJMXG5UaWxlQ29vcmQucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uKHVybHMsIHNvdXJjZU1heFpvb20pIHtcbiAgICByZXR1cm4gdXJsc1sodGhpcy54ICsgdGhpcy55KSAlIHVybHMubGVuZ3RoXVxuICAgICAgICAucmVwbGFjZSgne3ByZWZpeH0nLCAodGhpcy54ICUgMTYpLnRvU3RyaW5nKDE2KSArICh0aGlzLnkgJSAxNikudG9TdHJpbmcoMTYpKVxuICAgICAgICAucmVwbGFjZSgne3p9JywgTWF0aC5taW4odGhpcy56LCBzb3VyY2VNYXhab29tIHx8IHRoaXMueikpXG4gICAgICAgIC5yZXBsYWNlKCd7eH0nLCB0aGlzLngpXG4gICAgICAgIC5yZXBsYWNlKCd7eX0nLCB0aGlzLnkpO1xufTtcblxuLy8gUmV0dXJuIHRoZSBjb29yZGluYXRlIG9mIHRoZSBwYXJlbnQgdGlsZVxuVGlsZUNvb3JkLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbihzb3VyY2VNYXhab29tKSB7XG4gICAgaWYgKHRoaXMueiA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyB0aGUgaWQgcmVwcmVzZW50cyBhbiBvdmVyc2NhbGVkIHRpbGUsIHJldHVybiB0aGUgc2FtZSBjb29yZGluYXRlcyB3aXRoIGEgbG93ZXIgelxuICAgIGlmICh0aGlzLnogPiBzb3VyY2VNYXhab29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHRoaXMueiAtIDEsIHRoaXMueCwgdGhpcy55LCB0aGlzLncpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHRoaXMueiAtIDEsIE1hdGguZmxvb3IodGhpcy54IC8gMiksIE1hdGguZmxvb3IodGhpcy55IC8gMiksIHRoaXMudyk7XG59O1xuXG5UaWxlQ29vcmQucHJvdG90eXBlLndyYXBwZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFRpbGVDb29yZCh0aGlzLnosIHRoaXMueCwgdGhpcy55LCAwKTtcbn07XG5cbi8vIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHRpbGUncyBjaGlsZHJlblxuVGlsZUNvb3JkLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHNvdXJjZU1heFpvb20pIHtcblxuICAgIGlmICh0aGlzLnogPj0gc291cmNlTWF4Wm9vbSkge1xuICAgICAgICAvLyByZXR1cm4gYSBzaW5nbGUgdGlsZSBjb29yZCByZXByZXNlbnRpbmcgYSBhbiBvdmVyc2NhbGVkIHRpbGVcbiAgICAgICAgcmV0dXJuIFtuZXcgVGlsZUNvb3JkKHRoaXMueiArIDEsIHRoaXMueCwgdGhpcy55LCB0aGlzLncpXTtcbiAgICB9XG5cbiAgICB2YXIgeiA9IHRoaXMueiArIDE7XG4gICAgdmFyIHggPSB0aGlzLnggKiAyO1xuICAgIHZhciB5ID0gdGhpcy55ICogMjtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVGlsZUNvb3JkKHosIHgsIHksIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCArIDEsIHksIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCwgeSArIDEsIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCArIDEsIHkgKyAxLCB0aGlzLncpXG4gICAgXTtcbn07XG5cbi8vIFRha2VuIGZyb20gcG9seW1hcHMgc3JjL0xheWVyLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2ltcGxlZ2VvL3BvbHltYXBzL2Jsb2IvbWFzdGVyL3NyYy9MYXllci5qcyNMMzMzLUwzODNcblxuZnVuY3Rpb24gZWRnZShhLCBiKSB7XG4gICAgaWYgKGEucm93ID4gYi5yb3cpIHsgdmFyIHQgPSBhOyBhID0gYjsgYiA9IHQ7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4MDogYS5jb2x1bW4sXG4gICAgICAgIHkwOiBhLnJvdyxcbiAgICAgICAgeDE6IGIuY29sdW1uLFxuICAgICAgICB5MTogYi5yb3csXG4gICAgICAgIGR4OiBiLmNvbHVtbiAtIGEuY29sdW1uLFxuICAgICAgICBkeTogYi5yb3cgLSBhLnJvd1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNjYW5TcGFucyhlMCwgZTEsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XG4gICAgdmFyIHkwID0gTWF0aC5tYXgoeW1pbiwgTWF0aC5mbG9vcihlMS55MCkpO1xuICAgIHZhciB5MSA9IE1hdGgubWluKHltYXgsIE1hdGguY2VpbChlMS55MSkpO1xuXG4gICAgLy8gc29ydCBlZGdlcyBieSB4LWNvb3JkaW5hdGVcbiAgICBpZiAoKGUwLngwID09PSBlMS54MCAmJiBlMC55MCA9PT0gZTEueTApID9cbiAgICAgICAgICAgIChlMC54MCArIGUxLmR5IC8gZTAuZHkgKiBlMC5keCA8IGUxLngxKSA6XG4gICAgICAgICAgICAoZTAueDEgLSBlMS5keSAvIGUwLmR5ICogZTAuZHggPCBlMS54MCkpIHtcbiAgICAgICAgdmFyIHQgPSBlMDsgZTAgPSBlMTsgZTEgPSB0O1xuICAgIH1cblxuICAgIC8vIHNjYW4gbGluZXMhXG4gICAgdmFyIG0wID0gZTAuZHggLyBlMC5keTtcbiAgICB2YXIgbTEgPSBlMS5keCAvIGUxLmR5O1xuICAgIHZhciBkMCA9IGUwLmR4ID4gMDsgLy8gdXNlIHkgKyAxIHRvIGNvbXB1dGUgeDBcbiAgICB2YXIgZDEgPSBlMS5keCA8IDA7IC8vIHVzZSB5ICsgMSB0byBjb21wdXRlIHgxXG4gICAgZm9yICh2YXIgeSA9IHkwOyB5IDwgeTE7IHkrKykge1xuICAgICAgICB2YXIgeDAgPSBtMCAqIE1hdGgubWF4KDAsIE1hdGgubWluKGUwLmR5LCB5ICsgZDAgLSBlMC55MCkpICsgZTAueDA7XG4gICAgICAgIHZhciB4MSA9IG0xICogTWF0aC5tYXgoMCwgTWF0aC5taW4oZTEuZHksIHkgKyBkMSAtIGUxLnkwKSkgKyBlMS54MDtcbiAgICAgICAgc2NhbkxpbmUoTWF0aC5mbG9vcih4MSksIE1hdGguY2VpbCh4MCksIHkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2NhblRyaWFuZ2xlKGEsIGIsIGMsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XG4gICAgdmFyIGFiID0gZWRnZShhLCBiKSxcbiAgICAgICAgYmMgPSBlZGdlKGIsIGMpLFxuICAgICAgICBjYSA9IGVkZ2UoYywgYSk7XG5cbiAgICB2YXIgdDtcblxuICAgIC8vIHNvcnQgZWRnZXMgYnkgeS1sZW5ndGhcbiAgICBpZiAoYWIuZHkgPiBiYy5keSkgeyB0ID0gYWI7IGFiID0gYmM7IGJjID0gdDsgfVxuICAgIGlmIChhYi5keSA+IGNhLmR5KSB7IHQgPSBhYjsgYWIgPSBjYTsgY2EgPSB0OyB9XG4gICAgaWYgKGJjLmR5ID4gY2EuZHkpIHsgdCA9IGJjOyBiYyA9IGNhOyBjYSA9IHQ7IH1cblxuICAgIC8vIHNjYW4gc3BhbiEgc2NhbiBzcGFuIVxuICAgIGlmIChhYi5keSkgc2NhblNwYW5zKGNhLCBhYiwgeW1pbiwgeW1heCwgc2NhbkxpbmUpO1xuICAgIGlmIChiYy5keSkgc2NhblNwYW5zKGNhLCBiYywgeW1pbiwgeW1heCwgc2NhbkxpbmUpO1xufVxuXG5UaWxlQ29vcmQuY292ZXIgPSBmdW5jdGlvbih6LCBib3VuZHMsIGFjdHVhbFopIHtcbiAgICB2YXIgdGlsZXMgPSAxIDw8IHo7XG4gICAgdmFyIHQgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHNjYW5MaW5lKHgwLCB4MSwgeSkge1xuICAgICAgICB2YXIgeCwgd3g7XG4gICAgICAgIGlmICh5ID49IDAgJiYgeSA8PSB0aWxlcykge1xuICAgICAgICAgICAgZm9yICh4ID0geDA7IHggPCB4MTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgd3ggPSAoeCArIHRpbGVzKSAlIHRpbGVzO1xuICAgICAgICAgICAgICAgIHZhciBjb29yZCA9IG5ldyBUaWxlQ29vcmQoYWN0dWFsWiwgd3gsIHksIE1hdGguZmxvb3IoeCAvIHRpbGVzKSk7XG4gICAgICAgICAgICAgICAgdFtjb29yZC5pZF0gPSBjb29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpdmlkZSB0aGUgc2NyZWVuIHVwIGluIHR3byB0cmlhbmdsZXMgYW5kIHNjYW4gZWFjaCBvZiB0aGVtOlxuICAgIC8vICstLS0vXG4gICAgLy8gfCAvIHxcbiAgICAvLyAvLS0tK1xuICAgIHNjYW5UcmlhbmdsZShib3VuZHNbMF0sIGJvdW5kc1sxXSwgYm91bmRzWzJdLCAwLCB0aWxlcywgc2NhbkxpbmUpO1xuICAgIHNjYW5UcmlhbmdsZShib3VuZHNbMl0sIGJvdW5kc1szXSwgYm91bmRzWzBdLCAwLCB0aWxlcywgc2NhbkxpbmUpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdFtpZF07XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZScpO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZV9jb29yZCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBDYWNoZSA9IHJlcXVpcmUoJy4uL3V0aWwvbXJ1X2NhY2hlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVQeXJhbWlkO1xuXG4vKipcbiAqIEEgdGlsZSBweXJhbWlkIGlzIGEgc3BlY2lhbGl6ZWQgY2FjaGUgYW5kIGRhdGFzdHJ1Y3R1cmVcbiAqIHRoYXQgY29udGFpbnMgdGlsZXMuIEl0J3MgdXNlZCBieSBzb3VyY2VzIHRvIG1hbmFnZSB0aGVpclxuICogZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudGlsZVNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1pbnpvb21cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heHpvb21cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFRpbGVQeXJhbWlkKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRpbGVTaXplID0gb3B0aW9ucy50aWxlU2l6ZTtcbiAgICB0aGlzLm1pbnpvb20gPSBvcHRpb25zLm1pbnpvb207XG4gICAgdGhpcy5tYXh6b29tID0gb3B0aW9ucy5tYXh6b29tO1xuICAgIHRoaXMucmVwYXJzZU92ZXJzY2FsZWQgPSBvcHRpb25zLnJlcGFyc2VPdmVyc2NhbGVkO1xuXG4gICAgdGhpcy5fbG9hZCA9IG9wdGlvbnMubG9hZDtcbiAgICB0aGlzLl9hYm9ydCA9IG9wdGlvbnMuYWJvcnQ7XG4gICAgdGhpcy5fdW5sb2FkID0gb3B0aW9ucy51bmxvYWQ7XG4gICAgdGhpcy5fYWRkID0gb3B0aW9ucy5hZGQ7XG4gICAgdGhpcy5fcmVtb3ZlID0gb3B0aW9ucy5yZW1vdmU7XG4gICAgdGhpcy5fcmVkb1BsYWNlbWVudCA9IG9wdGlvbnMucmVkb1BsYWNlbWVudDtcblxuICAgIHRoaXMuX3RpbGVzID0ge307XG4gICAgdGhpcy5fY2FjaGUgPSBuZXcgQ2FjaGUob3B0aW9ucy5jYWNoZVNpemUsIGZ1bmN0aW9uKHRpbGUpIHsgcmV0dXJuIHRoaXMuX3VubG9hZCh0aWxlKTsgfS5iaW5kKHRoaXMpKTtcbn1cblxuVGlsZVB5cmFtaWQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENvbmZpcm0gdGhhdCBldmVyeSB0cmFja2VkIHRpbGUgaXMgbG9hZGVkLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIGFsbCB0aWxlcyBhcmUgbG9hZGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90aWxlc1t0XS5sb2FkZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIHRpbGUgaWRzIG9yZGVyZWQgd2l0aCB6LW9yZGVyLCBhbmQgY2FzdCB0byBudW1iZXJzXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGlkc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb3JkZXJlZElEczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl90aWxlcylcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIChiICUgMzIpIC0gKGEgJSAzMik7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGlkKSB7IHJldHVybiAraWQ7IH0pO1xuICAgIH0sXG5cbiAgICByZW5kZXJlZElEczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yZGVyZWRJRHMoKS5maWx0ZXIoZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWxlc1tpZF0ubG9hZGVkICYmICF0aGlzLl9jb3ZlcmVkVGlsZXNbaWRdO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jYWNoZS5yZXNldCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkKHRoaXMuX3RpbGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzcGVjaWZpYyB0aWxlIGJ5IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpZCB0aWxlIGlkXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0VGlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVzW2lkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB6b29tIGxldmVsIGFkanVzdGVkIGZvciB0aGUgZGlmZmVyZW5jZSBpbiBtYXAgYW5kIHNvdXJjZSB0aWxlc2l6ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtXG4gICAgICogQHJldHVybnMge251bWJlcn0gem9vbSBsZXZlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0Wm9vbTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0uem9vbSArIE1hdGgubG9nKHRyYW5zZm9ybS50aWxlU2l6ZSAvIHRoaXMudGlsZVNpemUpIC8gTWF0aC5MTjI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHpvb20gbGV2ZWwgdGhhdCB3aWxsIGNvdmVyIGFsbCB0aWxlcyBpbiBhIGdpdmVuIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB6b29tIGxldmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb3ZlcmluZ1pvb21MZXZlbDogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZ2V0Wm9vbSh0cmFuc2Zvcm0pKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSB0cmFuc2Zvcm0sIHJldHVybiBhbGwgY29vcmRpbmF0ZXMgdGhhdCBjb3VsZCBjb3ZlciB0aGF0XG4gICAgICogdHJhbnNmb3JtIGZvciBhIGNvdmVyaW5nIHpvb20gbGV2ZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxUaWxlPn0gdGlsZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvdmVyaW5nVGlsZXM6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgeiA9IHRoaXMuY292ZXJpbmdab29tTGV2ZWwodHJhbnNmb3JtKTtcbiAgICAgICAgdmFyIGFjdHVhbFogPSB6O1xuXG4gICAgICAgIGlmICh6IDwgdGhpcy5taW56b29tKSByZXR1cm4gW107XG4gICAgICAgIGlmICh6ID4gdGhpcy5tYXh6b29tKSB6ID0gdGhpcy5tYXh6b29tO1xuXG4gICAgICAgIHZhciB0ciA9IHRyYW5zZm9ybSxcbiAgICAgICAgICAgIHRpbGVDZW50ZXIgPSB0ci5sb2NhdGlvbkNvb3JkaW5hdGUodHIuY2VudGVyKS5fem9vbVRvKHopLFxuICAgICAgICAgICAgY2VudGVyUG9pbnQgPSBuZXcgUG9pbnQodGlsZUNlbnRlci5jb2x1bW4gLSAwLjUsIHRpbGVDZW50ZXIucm93IC0gMC41KTtcblxuICAgICAgICByZXR1cm4gVGlsZUNvb3JkLmNvdmVyKHosIFtcbiAgICAgICAgICAgIHRyLnBvaW50Q29vcmRpbmF0ZShuZXcgUG9pbnQoMCwgMCkpLl96b29tVG8oeiksXG4gICAgICAgICAgICB0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KHRyLndpZHRoLCAwKSkuX3pvb21Ubyh6KSxcbiAgICAgICAgICAgIHRyLnBvaW50Q29vcmRpbmF0ZShuZXcgUG9pbnQodHIud2lkdGgsIHRyLmhlaWdodCkpLl96b29tVG8oeiksXG4gICAgICAgICAgICB0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KDAsIHRyLmhlaWdodCkpLl96b29tVG8oeilcbiAgICAgICAgXSwgdGhpcy5yZXBhcnNlT3ZlcnNjYWxlZCA/IGFjdHVhbFogOiB6KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjZW50ZXJQb2ludC5kaXN0KGEpIC0gY2VudGVyUG9pbnQuZGlzdChiKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZpbmQgY2hpbGRyZW4gb2YgdGhlIGdpdmVuIHRpbGUgKHVwIHRvIG1heENvdmVyaW5nWm9vbSkgdGhhdCBhcmUgYWxyZWFkeSBsb2FkZWQ7XG4gICAgICogYWRkcyBmb3VuZCB0aWxlcyB0byByZXRhaW4gb2JqZWN0OyByZXR1cm5zIHRydWUgaWYgY2hpbGRyZW4gY29tcGxldGVseSBjb3ZlciB0aGUgdGlsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhDb3ZlcmluZ1pvb21cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldGFpblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBvcGVyYXRpb24gd2FzIGNvbXBsZXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaW5kTG9hZGVkQ2hpbGRyZW46IGZ1bmN0aW9uKGNvb3JkLCBtYXhDb3ZlcmluZ1pvb20sIHJldGFpbikge1xuICAgICAgICB2YXIgY29tcGxldGUgPSB0cnVlO1xuICAgICAgICB2YXIgeiA9IGNvb3JkLno7XG4gICAgICAgIHZhciBjb29yZHMgPSBjb29yZC5jaGlsZHJlbih0aGlzLm1heHpvb20pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gY29vcmRzW2ldLmlkO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RpbGVzW2lkXSAmJiB0aGlzLl90aWxlc1tpZF0ubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0YWluW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHogPCBtYXhDb3ZlcmluZ1pvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR28gZnVydGhlciBkb3duIHRoZSBoaWVyYXJjaHkgdG8gZmluZCBtb3JlIHVubG9hZGVkIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRMb2FkZWRDaGlsZHJlbihjb29yZHNbaV0sIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgbG9hZGVkIHBhcmVudCBvZiB0aGUgZ2l2ZW4gdGlsZSAodXAgdG8gbWluQ292ZXJpbmdab29tKTtcbiAgICAgKiBhZGRzIHRoZSBmb3VuZCB0aWxlIHRvIHJldGFpbiBvYmplY3QgYW5kIHJldHVybnMgdGhlIHRpbGUgaWYgZm91bmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluQ292ZXJpbmdab29tXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXRhaW5cbiAgICAgKiBAcmV0dXJucyB7VGlsZX0gdGlsZSBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZpbmRMb2FkZWRQYXJlbnQ6IGZ1bmN0aW9uKGNvb3JkLCBtaW5Db3ZlcmluZ1pvb20sIHJldGFpbikge1xuICAgICAgICBmb3IgKHZhciB6ID0gY29vcmQueiAtIDE7IHogPj0gbWluQ292ZXJpbmdab29tOyB6LS0pIHtcbiAgICAgICAgICAgIGNvb3JkID0gY29vcmQucGFyZW50KHRoaXMubWF4em9vbSk7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2Nvb3JkLmlkXTtcbiAgICAgICAgICAgIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0YWluW2Nvb3JkLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aWxlcyB0aGF0IGFyZSBvdXRzaWRlIHRoZSB2aWV3cG9ydCBhbmQgYWRkcyBuZXcgdGlsZXMgdGhhdFxuICAgICAqIGFyZSBpbnNpZGUgdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbih1c2VkLCB0cmFuc2Zvcm0sIGZhZGVEdXJhdGlvbikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGNvb3JkO1xuICAgICAgICB2YXIgdGlsZTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG92ZXJ6b29taW5nL3VuZGVyem9vbWluZyBhbW91bnRzLlxuICAgICAgICB2YXIgem9vbSA9IE1hdGguZmxvb3IodGhpcy5nZXRab29tKHRyYW5zZm9ybSkpO1xuICAgICAgICB2YXIgbWluQ292ZXJpbmdab29tID0gdXRpbC5jbGFtcCh6b29tIC0gMTAsIHRoaXMubWluem9vbSwgdGhpcy5tYXh6b29tKTtcbiAgICAgICAgdmFyIG1heENvdmVyaW5nWm9vbSA9IHV0aWwuY2xhbXAoem9vbSArIDEsICB0aGlzLm1pbnpvb20sIHRoaXMubWF4em9vbSk7XG5cbiAgICAgICAgLy8gUmV0YWluIGlzIGEgbGlzdCBvZiB0aWxlcyB0aGF0IHdlIHNob3VsZG4ndCBkZWxldGUsIGV2ZW4gaWYgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHRoZSBtb3N0IGlkZWFsIHRpbGUgZm9yIHRoZSBjdXJyZW50IHZpZXdwb3J0LiBUaGlzIG1heSBpbmNsdWRlIHRpbGVzIGxpa2VcbiAgICAgICAgLy8gcGFyZW50IG9yIGNoaWxkIHRpbGVzIHRoYXQgYXJlICphbHJlYWR5KiBsb2FkZWQuXG4gICAgICAgIHZhciByZXRhaW4gPSB7fTtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIC8vIENvdmVyZWQgaXMgYSBsaXN0IG9mIHJldGFpbmVkIHRpbGVzIHdobydzIGFyZWFzIGFyZSBmdWxsIGNvdmVyZWQgYnkgb3RoZXIsXG4gICAgICAgIC8vIGJldHRlciwgcmV0YWluZWQgdGlsZXMuIFRoZXkgYXJlIG5vdCBkcmF3biBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9jb3ZlcmVkVGlsZXMgPSB7fTtcblxuICAgICAgICB2YXIgcmVxdWlyZWQgPSB1c2VkID8gdGhpcy5jb3ZlcmluZ1RpbGVzKHRyYW5zZm9ybSkgOiBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb29yZCA9IHJlcXVpcmVkW2ldO1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuYWRkVGlsZShjb29yZCk7XG5cbiAgICAgICAgICAgIHJldGFpbltjb29yZC5pZF0gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGlsZS5sb2FkZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIFRoZSB0aWxlIHdlIHJlcXVpcmUgaXMgbm90IHlldCBsb2FkZWQuXG4gICAgICAgICAgICAvLyBSZXRhaW4gY2hpbGQgb3IgcGFyZW50IHRpbGVzIHRoYXQgY292ZXIgdGhlIHNhbWUgYXJlYS5cbiAgICAgICAgICAgIGlmICghdGhpcy5maW5kTG9hZGVkQ2hpbGRyZW4oY29vcmQsIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluZExvYWRlZFBhcmVudChjb29yZCwgbWluQ292ZXJpbmdab29tLCByZXRhaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gcmV0YWluKSB7XG4gICAgICAgICAgICBjb29yZCA9IFRpbGVDb29yZC5mcm9tSUQoaWQpO1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2lkXTtcbiAgICAgICAgICAgIGlmICh0aWxlICYmIHRpbGUudGltZUFkZGVkID4gbm93IC0gKGZhZGVEdXJhdGlvbiB8fCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgdGlsZSBpcyBzdGlsbCBmYWRpbmcgaW4uIEZpbmQgdGlsZXMgdG8gY3Jvc3MtZmFkZSB3aXRoIGl0LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRMb2FkZWRDaGlsZHJlbihjb29yZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvdmVyZWRUaWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXRhaW5baWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRMb2FkZWRQYXJlbnQoY29vcmQsIG1pbkNvdmVyaW5nWm9vbSwgcmV0YWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRpbGVzIHdlIGRvbid0IG5lZWQgYW55bW9yZS5cbiAgICAgICAgdmFyIHJlbW92ZSA9IHV0aWwua2V5c0RpZmZlcmVuY2UodGhpcy5fdGlsZXMsIHJldGFpbik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZSgrcmVtb3ZlW2ldKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0aWxlLCBnaXZlbiBpdHMgY29vcmRpbmF0ZSwgdG8gdGhlIHB5cmFtaWQuXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSB0aGUgY29vcmRpbmF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFkZFRpbGU6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbY29vcmQuaWRdO1xuICAgICAgICBpZiAodGlsZSlcbiAgICAgICAgICAgIHJldHVybiB0aWxlO1xuXG4gICAgICAgIHZhciB3cmFwcGVkID0gY29vcmQud3JhcHBlZCgpO1xuICAgICAgICB0aWxlID0gdGhpcy5fdGlsZXNbd3JhcHBlZC5pZF07XG5cbiAgICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgICAgICB0aWxlID0gdGhpcy5fY2FjaGUuZ2V0KHdyYXBwZWQuaWQpO1xuICAgICAgICAgICAgaWYgKHRpbGUgJiYgdGhpcy5fcmVkb1BsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZG9QbGFjZW1lbnQodGlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIHZhciB6b29tID0gY29vcmQuejtcbiAgICAgICAgICAgIHZhciBvdmVyc2NhbGluZyA9IHpvb20gPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB6b29tIC0gdGhpcy5tYXh6b29tKSA6IDE7XG4gICAgICAgICAgICB0aWxlID0gbmV3IFRpbGUod3JhcHBlZCwgdGhpcy50aWxlU2l6ZSAqIG92ZXJzY2FsaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX2xvYWQodGlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aWxlLnVzZXMrKztcbiAgICAgICAgdGhpcy5fdGlsZXNbY29vcmQuaWRdID0gdGlsZTtcbiAgICAgICAgdGhpcy5fYWRkKHRpbGUsIGNvb3JkKTtcblxuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgdGlsZSwgZ2l2ZW4gaXRzIGlkLCBmcm9tIHRoZSBweXJhbWlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpZCB0aWxlIGlkXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH0gbm90aGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVtb3ZlVGlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tpZF07XG4gICAgICAgIGlmICghdGlsZSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aWxlLnVzZXMtLTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3RpbGVzW2lkXTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlKHRpbGUpO1xuXG4gICAgICAgIGlmICh0aWxlLnVzZXMgPiAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aWxlLmxvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUuYWRkKHRpbGUuY29vcmQud3JhcHBlZCgpLmlkLCB0aWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0KHRpbGUpO1xuICAgICAgICAgICAgdGhpcy5fdW5sb2FkKHRpbGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgdGlsZXMgZnJvbSB0aGlzIHB5cmFtaWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsZWFyVGlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl90aWxlcylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZShpZCk7XG4gICAgICAgIHRoaXMuX2NhY2hlLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvciBhIGdpdmVuIGNvb3JkaW5hdGUsIHNlYXJjaCB0aHJvdWdoIG91ciBjdXJyZW50IHRpbGVzIGFuZCBhdHRlbXB0XG4gICAgICogdG8gZmluZCBhIHRpbGUgYXQgdGhhdCBwb2ludFxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aWxlQXQ6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgIHZhciBpZHMgPSB0aGlzLm9yZGVyZWRJRHMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbaWRzW2ldXTtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aWxlLnBvc2l0aW9uQXQoY29vcmQsIHRoaXMubWF4em9vbSk7XG4gICAgICAgICAgICBpZiAocG9zICYmIHBvcy54ID49IDAgJiYgcG9zLnggPCA0MDk2ICYmIHBvcy55ID49IDAgJiYgcG9zLnkgPCA0MDk2KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNsaWNrIGlzIHdpdGhpbiB0aGUgdmlld3BvcnQuIFRoZXJlIGlzIG9ubHkgZXZlciBvbmUgdGlsZSBpblxuICAgICAgICAgICAgICAgIC8vIGEgbGF5ZXIgdGhhdCBoYXMgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICAgICAgICAgICAgeTogcG9zLnksXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBwb3Muc2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgU291cmNlID0gcmVxdWlyZSgnLi9zb3VyY2UnKTtcbnZhciBQYWtvID0gcmVxdWlyZSgncGFrbycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVTb3VyY2U7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVTb3VyY2Uob3B0aW9ucykge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhvcHRpb25zLCBbJ3VybCcsICd0aWxlU2l6ZSddKSk7XG5cbiAgICBpZiAodGhpcy50aWxlU2l6ZSAhPT0gNTEyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVjdG9yIHRpbGUgc291cmNlcyBtdXN0IGhhdmUgYSB0aWxlU2l6ZSBvZiA1MTInKTtcbiAgICB9XG5cbiAgICBTb3VyY2UuX2xvYWRUaWxlSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5WZWN0b3JUaWxlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCB7XG4gICAgbWluem9vbTogMCxcbiAgICBtYXh6b29tOiAyMixcbiAgICB0aWxlU2l6ZTogNTEyLFxuICAgIHJlcGFyc2VPdmVyc2NhbGVkOiB0cnVlLFxuICAgIF9sb2FkZWQ6IGZhbHNlLFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B5cmFtaWQgJiYgdGhpcy5fcHlyYW1pZC5sb2FkZWQoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3B5cmFtaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3B5cmFtaWQudXBkYXRlKHRoaXMudXNlZCwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9weXJhbWlkLnJlbG9hZCgpO1xuICAgIH0sXG5cbiAgICByZWRvUGxhY2VtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9weXJhbWlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWRzID0gdGhpcy5fcHlyYW1pZC5vcmRlcmVkSURzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3B5cmFtaWQuZ2V0VGlsZShpZHNbaV0pO1xuICAgICAgICAgICAgdGhpcy5fcmVkb1RpbGVQbGFjZW1lbnQodGlsZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyOiBTb3VyY2UuX3JlbmRlclRpbGVzLFxuICAgIGZlYXR1cmVzQXQ6IFNvdXJjZS5fdmVjdG9yRmVhdHVyZXNBdCxcblxuICAgIF9sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB2YXIgb3ZlcnNjYWxpbmcgPSB0aWxlLmNvb3JkLnogPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB0aWxlLmNvb3JkLnogLSB0aGlzLm1heHpvb20pIDogMTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHVybDogdGlsZS5jb29yZC51cmwodGhpcy50aWxlcywgdGhpcy5tYXh6b29tKSxcbiAgICAgICAgICAgIHVpZDogdGlsZS51aWQsXG4gICAgICAgICAgICBjb29yZDogdGlsZS5jb29yZCxcbiAgICAgICAgICAgIHpvb206IHRpbGUuY29vcmQueixcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4em9vbSxcbiAgICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplICogb3ZlcnNjYWxpbmcsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICBvdmVyc2NhbGluZzogb3ZlcnNjYWxpbmcsXG4gICAgICAgICAgICBhbmdsZTogdGhpcy5tYXAudHJhbnNmb3JtLmFuZ2xlLFxuICAgICAgICAgICAgcGl0Y2g6IHRoaXMubWFwLnRyYW5zZm9ybS5waXRjaCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkRlYnVnOiB0aGlzLm1hcC5jb2xsaXNpb25EZWJ1Z1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aWxlLndvcmtlcklEKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc2VuZCgncmVsb2FkIHRpbGUnLCBwYXJhbXMsIHRoaXMuX3RpbGVMb2FkZWQuYmluZCh0aGlzLCB0aWxlKSwgdGlsZS53b3JrZXJJRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgdmFyIHVybCA9IHBhcmFtcy51cmwuc3BsaXQoJy8nKSxcbiAgICAgICAgICAgICAgICB6ID0gdXJsWzBdLFxuICAgICAgICAgICAgICAgIHggPSB1cmxbMV0sXG4gICAgICAgICAgICAgICAgeSA9IHVybFsyXTtcbiAgICAgICAgICAgIHkgPSAoMSA8PCB6KSAtIDEgLSB5O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRiID0gd2luZG93LnNxbGl0ZVBsdWdpbi5vcGVuRGF0YWJhc2Uoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMuc291cmNlICsgJy5tYnRpbGVzJyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IDIsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZyb21Mb2NhdGlvbjogMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uKHR4KSB7XG4gICAgICAgICAgICAgICAgdHguZXhlY3V0ZVNxbCgnU0VMRUNUIHRpbGVfZGF0YSBGUk9NIHRpbGVzIFdIRVJFIHpvb21fbGV2ZWwgPSA/IEFORCB0aWxlX2NvbHVtbiA9ID8gQU5EIHRpbGVfcm93ID0gPycsIFt6LCB4LCB5XSwgZnVuY3Rpb24odHgsIHJlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGlsZURhdGEgPSByZXMucm93cy5pdGVtKDApLnRpbGVfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVEYXRhRGVjb2RlZCA9IHdpbmRvdy5hdG9iKHRpbGVEYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVEYXRhRGVjb2RlZExlbmd0aCA9IHRpbGVEYXRhRGVjb2RlZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlRGF0YVR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0aWxlRGF0YURlY29kZWRMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVEYXRhRGVjb2RlZExlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlRGF0YVR5cGVkQXJyYXlbaV0gPSB0aWxlRGF0YURlY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGlsZURhdGFJbmZsYXRlZCA9IFBha28uaW5mbGF0ZSh0aWxlRGF0YVR5cGVkQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGlsZURhdGEgPSB0aWxlRGF0YUluZmxhdGVkO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLndvcmtlcklEID0gdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ2xvYWQgdGlsZScsIHBhcmFtcywgdGhpcy5fdGlsZUxvYWRlZC5iaW5kKHRoaXMsIHRpbGUpKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uKHR4LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEYXRhYmFzZSBFcnJvcjogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3RpbGVMb2FkZWQ6IGZ1bmN0aW9uKHRpbGUsIGVyciwgZGF0YSkge1xuICAgICAgICBpZiAodGlsZS5hYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5lcnJvcicsIHt0aWxlOiB0aWxlfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aWxlLmxvYWRWZWN0b3JEYXRhKGRhdGEpO1xuXG4gICAgICAgIGlmICh0aWxlLnJlZG9XaGVuRG9uZSkge1xuICAgICAgICAgICAgdGlsZS5yZWRvV2hlbkRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3JlZG9UaWxlUGxhY2VtZW50KHRpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLmxvYWQnLCB7dGlsZTogdGlsZX0pO1xuICAgIH0sXG5cbiAgICBfYWJvcnRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdhYm9ydCB0aWxlJywgeyB1aWQ6IHRpbGUudWlkLCBzb3VyY2U6IHRoaXMuaWQgfSwgbnVsbCwgdGlsZS53b3JrZXJJRCk7XG4gICAgfSxcblxuICAgIF9hZGRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgndGlsZS5hZGQnLCB7dGlsZTogdGlsZX0pO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUucmVtb3ZlJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3VubG9hZFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGlsZS51bmxvYWRWZWN0b3JEYXRhKHRoaXMubWFwLnBhaW50ZXIpO1xuICAgICAgICB0aGlzLmdseXBoQXRsYXMucmVtb3ZlR2x5cGhzKHRpbGUudWlkKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3JlbW92ZSB0aWxlJywgeyB1aWQ6IHRpbGUudWlkLCBzb3VyY2U6IHRoaXMuaWQgfSwgbnVsbCwgdGlsZS53b3JrZXJJRCk7XG4gICAgfSxcblxuICAgIF9yZWRvVGlsZVBsYWNlbWVudDogZnVuY3Rpb24odGlsZSkge1xuXG4gICAgICAgIGlmICghdGlsZS5sb2FkZWQgfHwgdGlsZS5yZWRvaW5nUGxhY2VtZW50KSB7XG4gICAgICAgICAgICB0aWxlLnJlZG9XaGVuRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aWxlLnJlZG9pbmdQbGFjZW1lbnQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdyZWRvIHBsYWNlbWVudCcsIHtcbiAgICAgICAgICAgIHVpZDogdGlsZS51aWQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICBhbmdsZTogdGhpcy5tYXAudHJhbnNmb3JtLmFuZ2xlLFxuICAgICAgICAgICAgcGl0Y2g6IHRoaXMubWFwLnRyYW5zZm9ybS5waXRjaCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkRlYnVnOiB0aGlzLm1hcC5jb2xsaXNpb25EZWJ1Z1xuICAgICAgICB9LCBkb25lLmJpbmQodGhpcyksIHRpbGUud29ya2VySUQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoXywgZGF0YSkge1xuICAgICAgICAgICAgdGlsZS5yZWxvYWRTeW1ib2xEYXRhKGRhdGEsIHRoaXMubWFwLnBhaW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCd0aWxlLmxvYWQnLCB7dGlsZTogdGlsZX0pO1xuXG4gICAgICAgICAgICB0aWxlLnJlZG9pbmdQbGFjZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aWxlLnJlZG9XaGVuRG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZG9UaWxlUGxhY2VtZW50KHRpbGUpO1xuICAgICAgICAgICAgICAgIHRpbGUucmVkb1doZW5Eb25lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBUaWxlID0gcmVxdWlyZSgnLi90aWxlJyk7XG52YXIgTGF0TG5nID0gcmVxdWlyZSgnLi4vZ2VvL2xhdF9sbmcnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIENvb3JkaW5hdGUgPSByZXF1aXJlKCcuLi9nZW8vY29vcmRpbmF0ZScpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWRlb1NvdXJjZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBWaWRlbyBkYXRhIHNvdXJjZSBpbnN0YW5jZSBnaXZlbiBhbiBvcHRpb25zIG9iamVjdFxuICogQGNsYXNzIFZpZGVvU291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gb3B0aW9ucy51cmwgQSBzdHJpbmcgb3IgYXJyYXkgb2YgVVJMKHMpIHRvIHZpZGVvIGZpbGVzXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmNvb3JkaW5hdGVzIGxhdCxsbmcgY29vcmRpbmF0ZXMgaW4gb3JkZXIgY2xvY2t3aXNlIHN0YXJ0aW5nIGF0IHRoZSB0b3AgbGVmdDogdGwsIHRyLCBiciwgYmxcbiAqIEBleGFtcGxlXG4gKiB2YXIgc291cmNlT2JqID0gbmV3IG1hcGJveGdsLlZpZGVvU291cmNlKHtcbiAqICAgIHVybDogW1xuICogICAgICAgICdodHRwczovL3d3dy5tYXBib3guY29tL3ZpZGVvcy9iYWx0aW1vcmUtc21va2UubXA0JyxcbiAqICAgICAgICAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS92aWRlb3MvYmFsdGltb3JlLXNtb2tlLndlYm0nXG4gKiAgICBdLFxuICogICAgY29vcmRpbmF0ZXM6IFtcbiAqICAgICAgICBbMzkuMTg1Nzk5MDcyMjk3NDgsIC03Ni41NDMzNTczNzIyODM5NF0sXG4gKiAgICAgICAgWzM5LjE4MzgzNjQ4NDc1ODcsIC03Ni41MjgwMzY1OTQzOTA4N10sXG4gKiAgICAgICAgWzM5LjE3NjgzMzkyNTA3NjA2LCAtNzYuNTI5NTM4NjMxNDM5Ml0sXG4gKiAgICAgICAgWzM5LjE3ODc2MzQ0MTA2NjQyLCAtNzYuNTQ1MjAyNzMyMDg2MThdXG4gKiAgICBdXG4gKiB9KTtcbiAqIG1hcC5hZGRTb3VyY2UoJ3NvbWUgaWQnLCBzb3VyY2VPYmopOyAvLyBhZGRcbiAqIG1hcC5yZW1vdmVTb3VyY2UoJ3NvbWUgaWQnKTsgIC8vIHJlbW92ZVxuICovXG5mdW5jdGlvbiBWaWRlb1NvdXJjZShvcHRpb25zKSB7XG4gICAgdGhpcy5jb29yZGluYXRlcyA9IG9wdGlvbnMuY29vcmRpbmF0ZXM7XG5cbiAgICBhamF4LmdldFZpZGVvKG9wdGlvbnMudXJsLCBmdW5jdGlvbihlcnIsIHZpZGVvKSB7XG4gICAgICAgIC8vIEBUT0RPIGhhbmRsZSBlcnJvcnMgdmlhIGV2ZW50LlxuICAgICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy52aWRlbyA9IHZpZGVvO1xuICAgICAgICB0aGlzLnZpZGVvLmxvb3AgPSB0cnVlO1xuXG4gICAgICAgIHZhciBsb29wSUQ7XG5cbiAgICAgICAgLy8gc3RhcnQgcmVwYWludGluZyB3aGVuIHZpZGVvIHN0YXJ0cyBwbGF5aW5nXG4gICAgICAgIHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbG9vcElEID0gdGhpcy5tYXAuc3R5bGUuYW5pbWF0aW9uTG9vcC5zZXQoSW5maW5pdHkpO1xuICAgICAgICAgICAgdGhpcy5tYXAuX3JlcmVuZGVyKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gc3RvcCByZXBhaW50aW5nIHdoZW4gdmlkZW8gc3RvcHNcbiAgICAgICAgdGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5tYXAuc3R5bGUuYW5pbWF0aW9uTG9vcC5jYW5jZWwobG9vcElEKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRpbGUoKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xufVxuXG5WaWRlb1NvdXJjZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwgLyoqIEBsZW5kcyBWaWRlb1NvdXJjZS5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBIVE1MIHZpZGVvIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZpZGVvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW87XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVGlsZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBDYWxjdWxhdGUgd2hpY2ggbWVyY2F0b3IgdGlsZSBpcyBzdWl0YWJsZSBmb3IgcmVuZGVyaW5nIHRoZSB2aWRlbyBpblxuICAgICAgICAgKiBhbmQgY3JlYXRlIGEgYnVmZmVyIHdpdGggdGhlIGNvcm5lciBjb29yZGluYXRlcy4gVGhlc2UgY29vcmRpbmF0ZXNcbiAgICAgICAgICogbWF5IGJlIG91dHNpZGUgdGhlIHRpbGUsIGJlY2F1c2UgcmFzdGVyIHRpbGVzIGFyZW4ndCBjbGlwcGVkIHdoZW4gcmVuZGVyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwO1xuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24obGF0bG5nKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gTGF0TG5nLmNvbnZlcnQobGF0bG5nKTtcbiAgICAgICAgICAgIHJldHVybiBtYXAudHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZShsb2MpLnpvb21UbygwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgY29vcmRzW2ldLmNvbHVtbik7XG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgY29vcmRzW2ldLnJvdyk7XG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgY29vcmRzW2ldLmNvbHVtbik7XG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgY29vcmRzW2ldLnJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSBtYXhYIC0gbWluWDtcbiAgICAgICAgdmFyIGR5ID0gbWF4WSAtIG1pblk7XG4gICAgICAgIHZhciBkTWF4ID0gTWF0aC5tYXgoZHgsIGR5KTtcbiAgICAgICAgdmFyIGNlbnRlciA9IG5ldyBDb29yZGluYXRlKChtaW5YICsgbWF4WCkgLyAyLCAobWluWSArIG1heFkpIC8gMiwgMClcbiAgICAgICAgICAgIC56b29tVG8oTWF0aC5mbG9vcigtTWF0aC5sb2coZE1heCkgLyBNYXRoLkxOMikpO1xuXG4gICAgICAgIHZhciB0aWxlRXh0ZW50ID0gNDA5NjtcbiAgICAgICAgdmFyIHRpbGVDb29yZHMgPSBjb29yZHMubWFwKGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICB2YXIgem9vbWVkQ29vcmQgPSBjb29yZC56b29tVG8oY2VudGVyLnpvb20pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh6b29tZWRDb29yZC5jb2x1bW4gLSBjZW50ZXIuY29sdW1uKSAqIHRpbGVFeHRlbnQpLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHpvb21lZENvb3JkLnJvdyAtIGNlbnRlci5yb3cpICogdGlsZUV4dGVudCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZ2wgPSBtYXAucGFpbnRlci5nbDtcbiAgICAgICAgdmFyIG1heEludDE2ID0gMzI3Njc7XG4gICAgICAgIHZhciBhcnJheSA9IG5ldyBJbnQxNkFycmF5KFtcbiAgICAgICAgICAgIHRpbGVDb29yZHNbMF0ueCwgdGlsZUNvb3Jkc1swXS55LCAwLCAwLFxuICAgICAgICAgICAgdGlsZUNvb3Jkc1sxXS54LCB0aWxlQ29vcmRzWzFdLnksIG1heEludDE2LCAwLFxuICAgICAgICAgICAgdGlsZUNvb3Jkc1szXS54LCB0aWxlQ29vcmRzWzNdLnksIDAsIG1heEludDE2LFxuICAgICAgICAgICAgdGlsZUNvb3Jkc1syXS54LCB0aWxlQ29vcmRzWzJdLnksIG1heEludDE2LCBtYXhJbnQxNlxuICAgICAgICBdKTtcblxuICAgICAgICB0aGlzLnRpbGUgPSBuZXcgVGlsZSgpO1xuICAgICAgICB0aGlzLnRpbGUuYnVja2V0cyA9IHt9O1xuXG4gICAgICAgIHRoaXMudGlsZS5ib3VuZHNCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudGlsZS5ib3VuZHNCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW8gJiYgdGhpcy52aWRlby5yZWFkeVN0YXRlID49IDI7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgcmVsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGxheWVycywgcGFpbnRlcikge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZCkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy52aWRlby5yZWFkeVN0YXRlIDwgMikgcmV0dXJuOyAvLyBub3QgZW5vdWdoIGRhdGEgZm9yIGN1cnJlbnQgcG9zaXRpb25cblxuICAgICAgICB2YXIgYyA9IHRoaXMuY2VudGVyO1xuICAgICAgICB0aGlzLnRpbGUuY2FsY3VsYXRlTWF0cmljZXMoYy56b29tLCBjLmNvbHVtbiwgYy5yb3csIHRoaXMubWFwLnRyYW5zZm9ybSwgcGFpbnRlcik7XG5cbiAgICAgICAgdmFyIGdsID0gcGFpbnRlci5nbDtcbiAgICAgICAgaWYgKCF0aGlzLnRpbGUudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy50aWxlLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRpbGUudGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy52aWRlbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRpbGUudGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudmlkZW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFpbnRlci5kcmF3TGF5ZXJzKGxheWVycywgdGhpcy50aWxlLnBvc01hdHJpeCwgdGhpcy50aWxlKTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXNBdDogZnVuY3Rpb24ocG9pbnQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFjdG9yID0gcmVxdWlyZSgnLi4vdXRpbC9hY3RvcicpO1xudmFyIFdvcmtlclRpbGUgPSByZXF1aXJlKCcuL3dvcmtlcl90aWxlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcbnZhciB2dCA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcblxudmFyIGdlb2pzb252dCA9IHJlcXVpcmUoJ2dlb2pzb24tdnQnKTtcbnZhciBHZW9KU09OV3JhcHBlciA9IHJlcXVpcmUoJy4vZ2VvanNvbl93cmFwcGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VsZikge1xuICAgIHJldHVybiBuZXcgV29ya2VyKHNlbGYpO1xufTtcblxuZnVuY3Rpb24gV29ya2VyKHNlbGYpIHtcbiAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICAgIHRoaXMuYWN0b3IgPSBuZXcgQWN0b3Ioc2VsZiwgdGhpcyk7XG4gICAgdGhpcy5sb2FkaW5nID0ge307XG5cbiAgICB0aGlzLmxvYWRlZCA9IHt9O1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgdGhpcy5nZW9KU09OSW5kZXhlcyA9IHt9O1xufVxuXG51dGlsLmV4dGVuZChXb3JrZXIucHJvdG90eXBlLCB7XG4gICAgJ3NldCBsYXllcnMnOiBmdW5jdGlvbihsYXllcnMpIHtcbiAgICAgICAgdGhpcy5sYXllcnMgPSBsYXllcnM7XG4gICAgfSxcblxuICAgICdsb2FkIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aWxlRGF0YSA9IHBhcmFtcy50aWxlRGF0YTtcbiAgICAgICAgZGVsZXRlIHBhcmFtcy50aWxlRGF0YTtcblxuICAgICAgICB2YXIgc291cmNlID0gcGFyYW1zLnNvdXJjZSxcbiAgICAgICAgICAgIHVpZCA9IHBhcmFtcy51aWQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxvYWRpbmdbc291cmNlXSlcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1tzb3VyY2VdID0ge307XG5cbiAgICAgICAgdmFyIHRpbGUgPSBuZXcgV29ya2VyVGlsZShwYXJhbXMpO1xuICAgICAgICB0aWxlLmRhdGEgPSBuZXcgdnQuVmVjdG9yVGlsZShuZXcgUHJvdG9idWYodGlsZURhdGEpKTtcbiAgICAgICB0aWxlLnBhcnNlKHRpbGUuZGF0YSwgdGhpcy5sYXllcnMsIHRoaXMuYWN0b3IsIGNhbGxiYWNrKTtcblxuICAgICAgICB0aGlzLmxvYWRlZFtzb3VyY2VdID0gdGhpcy5sb2FkZWRbc291cmNlXSB8fCB7fTtcbiAgICAgICAgdGhpcy5sb2FkZWRbc291cmNlXVt1aWRdID0gdGlsZTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubG9hZGluZ1tzb3VyY2VdW3VpZF07XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuXG4gICAgICAgICAgICB0aWxlLmRhdGEgPSBuZXcgdnQuVmVjdG9yVGlsZShuZXcgUHJvdG9idWYobmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcbiAgICAgICAgICAgIHRpbGUucGFyc2UodGlsZS5kYXRhLCB0aGlzLmxheWVycywgdGhpcy5hY3RvciwgY2FsbGJhY2spO1xuXG4gICAgICAgICAgICB0aGlzLmxvYWRlZFtzb3VyY2VdID0gdGhpcy5sb2FkZWRbc291cmNlXSB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkW3NvdXJjZV1bdWlkXSA9IHRpbGU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3JlbG9hZCB0aWxlJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbG9hZGVkID0gdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV0sXG4gICAgICAgICAgICB1aWQgPSBwYXJhbXMudWlkO1xuICAgICAgICBpZiAobG9hZGVkICYmIGxvYWRlZFt1aWRdKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IGxvYWRlZFt1aWRdO1xuICAgICAgICAgICAgdGlsZS5wYXJzZSh0aWxlLmRhdGEsIHRoaXMubGF5ZXJzLCB0aGlzLmFjdG9yLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2Fib3J0IHRpbGUnOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxvYWRpbmcgPSB0aGlzLmxvYWRpbmdbcGFyYW1zLnNvdXJjZV0sXG4gICAgICAgICAgICB1aWQgPSBwYXJhbXMudWlkO1xuICAgICAgICBpZiAobG9hZGluZyAmJiBsb2FkaW5nW3VpZF0pIHtcbiAgICAgICAgICAgIGxvYWRpbmdbdWlkXS54aHIuYWJvcnQoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBsb2FkaW5nW3VpZF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3JlbW92ZSB0aWxlJzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsb2FkZWQgPSB0aGlzLmxvYWRlZFtwYXJhbXMuc291cmNlXSxcbiAgICAgICAgICAgIHVpZCA9IHBhcmFtcy51aWQ7XG4gICAgICAgIGlmIChsb2FkZWQgJiYgbG9hZGVkW3VpZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsb2FkZWRbdWlkXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAncmVkbyBwbGFjZW1lbnQnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBsb2FkZWQgPSB0aGlzLmxvYWRlZFtwYXJhbXMuc291cmNlXSxcbiAgICAgICAgICAgIGxvYWRpbmcgPSB0aGlzLmxvYWRpbmdbcGFyYW1zLnNvdXJjZV0sXG4gICAgICAgICAgICB1aWQgPSBwYXJhbXMudWlkO1xuXG4gICAgICAgIGlmIChsb2FkZWQgJiYgbG9hZGVkW3VpZF0pIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gbG9hZGVkW3VpZF07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGlsZS5yZWRvUGxhY2VtZW50KHBhcmFtcy5hbmdsZSwgcGFyYW1zLnBpdGNoLCBwYXJhbXMuY29sbGlzaW9uRGVidWcpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQsIHJlc3VsdC50cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGxvYWRpbmcgJiYgbG9hZGluZ1t1aWRdKSB7XG4gICAgICAgICAgICBsb2FkaW5nW3VpZF0uYW5nbGUgPSBwYXJhbXMuYW5nbGU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3BhcnNlIGdlb2pzb24nOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbmRleERhdGEgPSBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgdGhpcy5nZW9KU09OSW5kZXhlc1twYXJhbXMuc291cmNlXSA9IGdlb2pzb252dChkYXRhLCBwYXJhbXMuZ2VvanNvblZ0T3B0aW9ucyk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFRPRE8gYWNjZXB0IHBhcmFtcy51cmwgZm9yIHVybHMgaW5zdGVhZFxuXG4gICAgICAgIC8vIE5vdCwgYmVjYXVzZSBvZiBzYW1lIG9yaWdpbiBpc3N1ZXMsIHVybHMgbXVzdCBlaXRoZXIgaW5jbHVkZSBhblxuICAgICAgICAvLyBleHBsaWNpdCBvcmlnaW4gb3IgYWJzb2x1dGUgcGF0aC5cbiAgICAgICAgLy8gaWU6IC9mb28vYmFyLmpzb24gb3IgaHR0cDovL2V4YW1wbGUuY29tL2Jhci5qc29uXG4gICAgICAgIC8vIGJ1dCBub3QgLi4vZm9vL2Jhci5qc29uXG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhamF4LmdldEpTT04ocGFyYW1zLmRhdGEsIGluZGV4RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpbmRleERhdGEobnVsbCwgcGFyYW1zLmRhdGEpO1xuICAgIH0sXG5cbiAgICAnbG9hZCBnZW9qc29uIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBwYXJhbXMuc291cmNlLFxuICAgICAgICAgICAgY29vcmQgPSBwYXJhbXMuY29vcmQ7XG5cbiAgICAgICAgLy8gY29uc29sZS50aW1lKCd0aWxlICcgKyBjb29yZC56ICsgJyAnICsgY29vcmQueCArICcgJyArIGNvb3JkLnkpO1xuXG4gICAgICAgIHZhciBnZW9KU09OVGlsZSA9IHRoaXMuZ2VvSlNPTkluZGV4ZXNbc291cmNlXS5nZXRUaWxlKGNvb3JkLnosIGNvb3JkLngsIGNvb3JkLnkpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUudGltZUVuZCgndGlsZSAnICsgY29vcmQueiArICcgJyArIGNvb3JkLnggKyAnICcgKyBjb29yZC55KTtcblxuICAgICAgICAvLyBpZiAoIWdlb0pTT05UaWxlKSBjb25zb2xlLmxvZygnbm90IGZvdW5kJywgdGhpcy5nZW9KU09OSW5kZXhlc1tzb3VyY2VdLCBjb29yZCk7XG5cbiAgICAgICAgaWYgKCFnZW9KU09OVGlsZSkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpOyAvLyBub3RoaW5nIGluIHRoZSBnaXZlbiB0aWxlXG5cbiAgICAgICAgdmFyIHRpbGUgPSBuZXcgV29ya2VyVGlsZShwYXJhbXMpO1xuICAgICAgICB0aWxlLnBhcnNlKG5ldyBHZW9KU09OV3JhcHBlcihnZW9KU09OVGlsZS5mZWF0dXJlcyksIHRoaXMubGF5ZXJzLCB0aGlzLmFjdG9yLCBjYWxsYmFjayk7XG5cbiAgICAgICAgdGhpcy5sb2FkZWRbc291cmNlXSA9IHRoaXMubG9hZGVkW3NvdXJjZV0gfHwge307XG4gICAgICAgIHRoaXMubG9hZGVkW3NvdXJjZV1bcGFyYW1zLnVpZF0gPSB0aWxlO1xuICAgIH0sXG5cbiAgICAncXVlcnkgZmVhdHVyZXMnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV0gJiYgdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV1bcGFyYW1zLnVpZF07XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICB0aWxlLmZlYXR1cmVUcmVlLnF1ZXJ5KHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlVHJlZSA9IHJlcXVpcmUoJy4uL2RhdGEvZmVhdHVyZV90cmVlJyk7XG52YXIgQ29sbGlzaW9uVGlsZSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9jb2xsaXNpb25fdGlsZScpO1xudmFyIEJ1ZmZlclNldCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVmZmVyL2J1ZmZlcl9zZXQnKTtcbnZhciBjcmVhdGVCdWNrZXQgPSByZXF1aXJlKCcuLi9kYXRhL2NyZWF0ZV9idWNrZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZXJUaWxlO1xuXG5mdW5jdGlvbiBXb3JrZXJUaWxlKHBhcmFtcykge1xuICAgIHRoaXMuY29vcmQgPSBwYXJhbXMuY29vcmQ7XG4gICAgdGhpcy51aWQgPSBwYXJhbXMudWlkO1xuICAgIHRoaXMuem9vbSA9IHBhcmFtcy56b29tO1xuICAgIHRoaXMubWF4Wm9vbSA9IHBhcmFtcy5tYXhab29tO1xuICAgIHRoaXMudGlsZVNpemUgPSBwYXJhbXMudGlsZVNpemU7XG4gICAgdGhpcy5zb3VyY2UgPSBwYXJhbXMuc291cmNlO1xuICAgIHRoaXMub3ZlcnNjYWxpbmcgPSBwYXJhbXMub3ZlcnNjYWxpbmc7XG4gICAgdGhpcy5hbmdsZSA9IHBhcmFtcy5hbmdsZTtcbiAgICB0aGlzLnBpdGNoID0gcGFyYW1zLnBpdGNoO1xuICAgIHRoaXMuY29sbGlzaW9uRGVidWcgPSBwYXJhbXMuY29sbGlzaW9uRGVidWc7XG5cbiAgICB0aGlzLnN0YWNrcyA9IHt9O1xufVxuXG5Xb3JrZXJUaWxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIGxheWVycywgYWN0b3IsIGNhbGxiYWNrKSB7XG5cbiAgICB0aGlzLnN0YXR1cyA9ICdwYXJzaW5nJztcblxuICAgIHRoaXMuZmVhdHVyZVRyZWUgPSBuZXcgRmVhdHVyZVRyZWUodGhpcy5jb29yZCwgdGhpcy5vdmVyc2NhbGluZyk7XG5cbiAgICB2YXIgaSwgayxcbiAgICAgICAgdGlsZSA9IHRoaXMsXG4gICAgICAgIGxheWVyLFxuICAgICAgICBidWNrZXQsXG4gICAgICAgIGJ1ZmZlcnMgPSBuZXcgQnVmZmVyU2V0KCksXG4gICAgICAgIGNvbGxpc2lvblRpbGUgPSBuZXcgQ29sbGlzaW9uVGlsZSh0aGlzLmFuZ2xlLCB0aGlzLnBpdGNoKSxcbiAgICAgICAgYnVja2V0cyA9IHt9LFxuICAgICAgICBidWNrZXRzSW5PcmRlciA9IHRoaXMuYnVja2V0c0luT3JkZXIgPSBbXSxcbiAgICAgICAgYnVja2V0c0J5U291cmNlTGF5ZXIgPSB7fTtcblxuICAgIC8vIE1hcCBub24tcmVmIGxheWVycyB0byBidWNrZXRzLlxuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSAhPT0gdGhpcy5zb3VyY2UpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBpZiAobGF5ZXIucmVmKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIG1pbnpvb20gPSBsYXllci5taW56b29tO1xuICAgICAgICBpZiAobWluem9vbSAmJiB0aGlzLnpvb20gPCBtaW56b29tICYmIG1pbnpvb20gPCB0aGlzLm1heFpvb20pXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB2YXIgbWF4em9vbSA9IGxheWVyLm1heHpvb207XG4gICAgICAgIGlmIChtYXh6b29tICYmIHRoaXMuem9vbSA+PSBtYXh6b29tKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIHZpc2liaWxpdHkgPSBsYXllci5sYXlvdXQudmlzaWJpbGl0eTtcbiAgICAgICAgaWYgKHZpc2liaWxpdHkgPT09ICdub25lJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGJ1Y2tldCA9IGNyZWF0ZUJ1Y2tldChsYXllciwgYnVmZmVycywgdGhpcy56b29tLCB0aGlzLm92ZXJzY2FsaW5nLCB0aGlzLmNvbGxpc2lvbkRlYnVnKTtcbiAgICAgICAgYnVja2V0LmxheWVycyA9IFtsYXllci5pZF07XG5cbiAgICAgICAgYnVja2V0c1tidWNrZXQuaWRdID0gYnVja2V0O1xuICAgICAgICBidWNrZXRzSW5PcmRlci5wdXNoKGJ1Y2tldCk7XG5cbiAgICAgICAgaWYgKGRhdGEubGF5ZXJzKSB7XG4gICAgICAgICAgICAvLyB2ZWN0b3J0aWxlXG4gICAgICAgICAgICB2YXIgc291cmNlTGF5ZXIgPSBsYXllclsnc291cmNlLWxheWVyJ107XG4gICAgICAgICAgICBpZiAoIWJ1Y2tldHNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVyXSlcbiAgICAgICAgICAgICAgICBidWNrZXRzQnlTb3VyY2VMYXllcltzb3VyY2VMYXllcl0gPSB7fTtcbiAgICAgICAgICAgIGJ1Y2tldHNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVyXVtidWNrZXQuaWRdID0gYnVja2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2VvanNvbiB0aWxlXG4gICAgICAgICAgICBidWNrZXRzQnlTb3VyY2VMYXllcltidWNrZXQuaWRdID0gYnVja2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5kZXggcmVmIGxheWVycy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxheWVyID0gbGF5ZXJzW2ldO1xuXG4gICAgICAgIGlmIChsYXllci5zb3VyY2UgIT09IHRoaXMuc291cmNlKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgaWYgKCFsYXllci5yZWYpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBidWNrZXQgPSBidWNrZXRzW2xheWVyLnJlZl07XG4gICAgICAgIGlmICghYnVja2V0KVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgYnVja2V0LmxheWVycy5wdXNoKGxheWVyLmlkKTtcbiAgICB9XG5cbiAgICB2YXIgZXh0ZW50ID0gNDA5NjtcblxuICAgIC8vIHJlYWQgZWFjaCBsYXllciwgYW5kIHNvcnQgaXRzIGZlYXR1cmVzIGludG8gYnVja2V0c1xuICAgIGlmIChkYXRhLmxheWVycykge1xuICAgICAgICAvLyB2ZWN0b3J0aWxlXG4gICAgICAgIGZvciAoayBpbiBidWNrZXRzQnlTb3VyY2VMYXllcikge1xuICAgICAgICAgICAgbGF5ZXIgPSBkYXRhLmxheWVyc1trXTtcbiAgICAgICAgICAgIGlmICghbGF5ZXIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGxheWVyLmV4dGVudCkgZXh0ZW50ID0gbGF5ZXIuZXh0ZW50O1xuICAgICAgICAgICAgc29ydExheWVySW50b0J1Y2tldHMobGF5ZXIsIGJ1Y2tldHNCeVNvdXJjZUxheWVyW2tdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdlb2pzb25cbiAgICAgICAgc29ydExheWVySW50b0J1Y2tldHMoZGF0YSwgYnVja2V0c0J5U291cmNlTGF5ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnRMYXllckludG9CdWNrZXRzKGxheWVyLCBidWNrZXRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gbGF5ZXIuZmVhdHVyZShpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBidWNrZXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1Y2tldCA9IGJ1Y2tldHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoYnVja2V0LmZpbHRlcihmZWF0dXJlKSkge1xuICAgICAgICAgICAgICAgICAgICBidWNrZXQuZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldlBsYWNlbWVudEJ1Y2tldDtcbiAgICB2YXIgcmVtYWluaW5nID0gYnVja2V0c0luT3JkZXIubGVuZ3RoO1xuXG4gICAgLypcbiAgICAgKiAgVGhlIGFzeW5jIHBhcnNpbmcgaGVyZSBpcyBhIGJpdCB0cmlja3kuXG4gICAgICogIFNvbWUgYnVja2V0cyBkZXBlbmQgb24gcmVzb3VyY2VzIHRoYXQgbWF5IG5lZWQgdG8gYmUgbG9hZGVkIGFzeW5jIChnbHlwaHMpLlxuICAgICAqICBTb21lIGJ1Y2tldHMgbmVlZCB0byBiZSBwYXJzZWQgaW4gb3JkZXIgKHRvIGdldCBjb2xsaXNpb24gcHJpb3JpdGllcyByaWdodCkuXG4gICAgICpcbiAgICAgKiAgRGVwZW5kZW5jaWVzIGNhbGxzIGFyZSBpbml0aWF0ZWQgZmlyc3QgdG8gZ2V0IHRob3NlIHJvbGxpbmcuXG4gICAgICogIEJ1Y2tldHMgdGhhdCBkb24ndCBuZWVkIHRvIGJlIHBhcnNlZCBpbiBvcmRlciwgYXJlbid0IHRvIHNhdmUgdGltZS5cbiAgICAgKi9cblxuICAgIGZvciAoaSA9IDA7IGkgPCBidWNrZXRzSW5PcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWNrZXQgPSBidWNrZXRzSW5PcmRlcltpXTtcblxuICAgICAgICAvLyBMaW5rIGJ1Y2tldHMgdGhhdCBuZWVkIHRvIGJlIHBhcnNlZCBpbiBvcmRlclxuICAgICAgICBpZiAoYnVja2V0Lm5lZWRzUGxhY2VtZW50KSB7XG4gICAgICAgICAgICBpZiAocHJldlBsYWNlbWVudEJ1Y2tldCkge1xuICAgICAgICAgICAgICAgIHByZXZQbGFjZW1lbnRCdWNrZXQubmV4dCA9IGJ1Y2tldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVja2V0LnByZXZpb3VzUGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZQbGFjZW1lbnRCdWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVja2V0LmdldERlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgYnVja2V0LmdldERlcGVuZGVuY2llcyh0aGlzLCBhY3RvciwgZGVwZW5kZW5jaWVzRG9uZShidWNrZXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHBhcnNlIGJ1Y2tldHMgd2hlcmUgb3JkZXIgZG9lc24ndCBtYXR0ZXIgYW5kIG5vIGRlcGVuZGVuY2llc1xuICAgICAgICBpZiAoIWJ1Y2tldC5uZWVkc1BsYWNlbWVudCAmJiAhYnVja2V0LmdldERlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgcGFyc2VCdWNrZXQodGlsZSwgYnVja2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcGVuZGVuY2llc0RvbmUoYnVja2V0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5kZXBlbmRlbmNpZXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgcGFyc2VCdWNrZXQodGlsZSwgYnVja2V0LCBlcnIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQnVja2V0KHRpbGUsIGJ1Y2tldCwgc2tpcCkge1xuICAgICAgICBpZiAoYnVja2V0LmdldERlcGVuZGVuY2llcyAmJiAhYnVja2V0LmRlcGVuZGVuY2llc0xvYWRlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoYnVja2V0Lm5lZWRzUGxhY2VtZW50ICYmICFidWNrZXQucHJldmlvdXNQbGFjZWQpIHJldHVybjtcblxuICAgICAgICBpZiAoIXNraXApIHtcbiAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC5mZWF0dXJlcy5sZW5ndGgpIGJ1Y2tldC5hZGRGZWF0dXJlcyhjb2xsaXNpb25UaWxlKTtcbiAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKSAtIG5vdztcbiAgICAgICAgICAgIGlmIChidWNrZXQuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldC5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGJ1Y2tldC5mZWF0dXJlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5mZWF0dXJlVHJlZS5pbnNlcnQoZmVhdHVyZS5iYm94KCksIGJ1Y2tldC5sYXllcnMsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJ1Y2tldFN0YXRzID0gc2VsZi5idWNrZXRTdGF0cyB8fCB7X3RvdGFsOiAwfTtcbiAgICAgICAgICAgICAgICBzZWxmLmJ1Y2tldFN0YXRzLl90b3RhbCArPSB0aW1lO1xuICAgICAgICAgICAgICAgIHNlbGYuYnVja2V0U3RhdHNbYnVja2V0LmlkXSA9IChzZWxmLmJ1Y2tldFN0YXRzW2J1Y2tldC5pZF0gfHwgMCkgKyB0aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVtYWluaW5nLS07XG5cbiAgICAgICAgaWYgKCFyZW1haW5pbmcpIHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSBwYXJzaW5nIHRoZSBuZXh0IGJ1Y2tldCwgaWYgaXQgaXMgcmVhZHlcbiAgICAgICAgaWYgKGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgICBidWNrZXQubmV4dC5wcmV2aW91c1BsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICBwYXJzZUJ1Y2tldCh0aWxlLCBidWNrZXQubmV4dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuXG4gICAgICAgIHRpbGUuc3RhdHVzID0gJ2RvbmUnO1xuXG4gICAgICAgIGlmICh0aWxlLnJlZG9QbGFjZW1lbnRBZnRlckRvbmUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aWxlLnJlZG9QbGFjZW1lbnQodGlsZS5hbmdsZSwgdGlsZS5waXRjaCkucmVzdWx0O1xuICAgICAgICAgICAgYnVmZmVycy5nbHlwaFZlcnRleCA9IHJlc3VsdC5idWZmZXJzLmdseXBoVmVydGV4O1xuICAgICAgICAgICAgYnVmZmVycy5pY29uVmVydGV4ID0gcmVzdWx0LmJ1ZmZlcnMuaWNvblZlcnRleDtcbiAgICAgICAgICAgIGJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4ID0gcmVzdWx0LmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbXSxcbiAgICAgICAgICAgIGVsZW1lbnRHcm91cHMgPSB7fTtcblxuICAgICAgICBmb3IgKGsgaW4gYnVmZmVycykge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGJ1ZmZlcnNba10uYXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrIGluIGJ1Y2tldHMpIHtcbiAgICAgICAgICAgIGVsZW1lbnRHcm91cHNba10gPSBidWNrZXRzW2tdLmVsZW1lbnRHcm91cHM7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXBzOiBlbGVtZW50R3JvdXBzLFxuICAgICAgICAgICAgYnVmZmVyczogYnVmZmVycyxcbiAgICAgICAgICAgIGV4dGVudDogZXh0ZW50XG4gICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpO1xuICAgIH1cbn07XG5cbldvcmtlclRpbGUucHJvdG90eXBlLnJlZG9QbGFjZW1lbnQgPSBmdW5jdGlvbihhbmdsZSwgcGl0Y2gsIGNvbGxpc2lvbkRlYnVnKSB7XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgIT09ICdkb25lJykge1xuICAgICAgICB0aGlzLnJlZG9QbGFjZW1lbnRBZnRlckRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB2YXIgYnVmZmVycyA9IG5ldyBCdWZmZXJTZXQoKTtcbiAgICB2YXIgdHJhbnNmZXJhYmxlcyA9IFtdO1xuICAgIHZhciBlbGVtZW50R3JvdXBzID0ge307XG4gICAgdmFyIGNvbGxpc2lvblRpbGUgPSBuZXcgQ29sbGlzaW9uVGlsZShhbmdsZSwgcGl0Y2gpO1xuXG4gICAgdmFyIGJ1Y2tldHNJbk9yZGVyID0gdGhpcy5idWNrZXRzSW5PcmRlcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldHNJbk9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzSW5PcmRlcltpXTtcblxuICAgICAgICBpZiAoYnVja2V0LnR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICBidWNrZXQucGxhY2VGZWF0dXJlcyhjb2xsaXNpb25UaWxlLCBidWZmZXJzLCBjb2xsaXNpb25EZWJ1Zyk7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXBzW2J1Y2tldC5pZF0gPSBidWNrZXQuZWxlbWVudEdyb3VwcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgaW4gYnVmZmVycykge1xuICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2goYnVmZmVyc1trXS5hcnJheSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXBzOiBlbGVtZW50R3JvdXBzLFxuICAgICAgICAgICAgYnVmZmVyczogYnVmZmVyc1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlcmFibGVzOiB0cmFuc2ZlcmFibGVzXG4gICAgfTtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb25Mb29wO1xuXG5mdW5jdGlvbiBBbmltYXRpb25Mb29wKCkge1xuICAgIHRoaXMubiA9IDA7XG4gICAgdGhpcy50aW1lcyA9IFtdO1xufVxuXG4vLyBBcmUgYWxsIGFuaW1hdGlvbnMgZG9uZT9cbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLnN0b3BwZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRpbWVzID0gdGhpcy50aW1lcy5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC50aW1lID49IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICF0aGlzLnRpbWVzLmxlbmd0aDtcbn07XG5cbi8vIEFkZCBhIG5ldyBhbmltYXRpb24gdGhhdCB3aWxsIHJ1biB0IG1pbGxpc2Vjb25kc1xuLy8gUmV0dXJucyBhbiBpZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCBpdCBsYXllclxuQW5pbWF0aW9uTG9vcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGltZXMucHVzaCh7IGlkOiB0aGlzLm4sIHRpbWU6IHQgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH0pO1xuICAgIHJldHVybiB0aGlzLm4rKztcbn07XG5cbi8vIENhbmNlbCBhbiBhbmltYXRpb25cbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLnRpbWVzID0gdGhpcy50aW1lcy5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC5pZCAhPT0gbjtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVNwcml0ZTtcblxuZnVuY3Rpb24gSW1hZ2VTcHJpdGUoYmFzZSkge1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgdGhpcy5yZXRpbmEgPSBicm93c2VyLmRldmljZVBpeGVsUmF0aW8gPiAxO1xuXG4gICAgYmFzZSA9IHRoaXMuYmFzZSArICh0aGlzLnJldGluYSA/ICdAMngnIDogJycpO1xuXG4gICAgYWpheC5nZXRKU09OKGJhc2UgKyAnLmpzb24nLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAodGhpcy5pbWcpIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICBhamF4LmdldEltYWdlKGJhc2UgKyAnLnBuZycsIGZ1bmN0aW9uKGVyciwgaW1nKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlbXVsdGlwbHkgdGhlIHNwcml0ZVxuICAgICAgICB2YXIgZGF0YSA9IGltZy5nZXREYXRhKCk7XG4gICAgICAgIHZhciBuZXdkYXRhID0gaW1nLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gZGF0YVtpICsgM10gLyAyNTU7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAwXSA9IGRhdGFbaSArIDBdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAxXSA9IGRhdGFbaSArIDFdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAyXSA9IGRhdGFbaSArIDJdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAzXSA9IGRhdGFbaSArIDNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWcgPSBpbWc7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRlZCk7XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlO1xufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiYgdGhpcy5pbWcpO1xufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKC8qZ2wqLykge1xuICAgIGlmIChicm93c2VyLmRldmljZVBpeGVsUmF0aW8gPiAxICE9PSB0aGlzLnJldGluYSkge1xuICAgICAgICB2YXIgbmV3U3ByaXRlID0gbmV3IEltYWdlU3ByaXRlKHRoaXMuYmFzZSk7XG4gICAgICAgIG5ld1Nwcml0ZS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5pbWcgPSBuZXdTcHJpdGUuaW1nO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3U3ByaXRlLmRhdGE7XG4gICAgICAgICAgICB0aGlzLnJldGluYSA9IG5ld1Nwcml0ZS5yZXRpbmE7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gU3ByaXRlUG9zaXRpb24oKSB7fVxuU3ByaXRlUG9zaXRpb24ucHJvdG90eXBlID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBwaXhlbFJhdGlvOiAxLCBzZGY6IGZhbHNlIH07XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS5nZXRTcHJpdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMubG9hZGVkKCkpIHJldHVybiBuZXcgU3ByaXRlUG9zaXRpb24oKTtcblxuICAgIHZhciBwb3MgPSB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhW25hbWVdO1xuICAgIGlmIChwb3MgJiYgdGhpcy5pbWcpIHJldHVybiBwb3M7XG5cbiAgICByZXR1cm4gbmV3IFNwcml0ZVBvc2l0aW9uKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVmZXJlbmNlID0gcmVxdWlyZSgnLi9yZWZlcmVuY2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucmVmZXJlbmNlLmxheW91dC5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBwcm9wcykge1xuICAgICAgICAgICAgdGhpc1twXSA9IHByb3BzW3BdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gcmVmZXJlbmNlW2NsYXNzTmFtZV07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzW3Byb3BdLmRlZmF1bHQgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgIFByb3BlcnRpZXMucHJvdG90eXBlW3Byb3BdID0gcHJvcGVydGllc1twcm9wXS5kZWZhdWx0O1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0c1tjbGFzc05hbWUucmVwbGFjZSgnbGF5b3V0XycsICcnKV0gPSBQcm9wZXJ0aWVzO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWZlcmVuY2UgPSByZXF1aXJlKCcuL3JlZmVyZW5jZScpO1xudmFyIHBhcnNlQ1NTQ29sb3IgPSByZXF1aXJlKCdjc3Njb2xvcnBhcnNlcicpLnBhcnNlQ1NTQ29sb3I7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cbnJlZmVyZW5jZS5wYWludC5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHZhciBDYWxjdWxhdGVkID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gcmVmZXJlbmNlW2NsYXNzTmFtZV07XG4gICAgZm9yICh2YXIgcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcGVydGllc1twXSxcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcC5kZWZhdWx0O1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gJ2NvbG9yJykgdmFsdWUgPSBwYXJzZUNTU0NvbG9yKHZhbHVlKTtcblxuICAgICAgICBDYWxjdWxhdGVkLnByb3RvdHlwZVtwXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIENhbGN1bGF0ZWQucHJvdG90eXBlLmhpZGRlbiA9IGZhbHNlO1xuICAgIG1vZHVsZS5leHBvcnRzW2NsYXNzTmFtZS5yZXBsYWNlKCdwYWludF8nLCAnJyldID0gQ2FsY3VsYXRlZDtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdtYXBib3gtZ2wtc3R5bGUtc3BlYy9yZWZlcmVuY2UvbGF0ZXN0Jyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgc3R5bGVCYXRjaCA9IHJlcXVpcmUoJy4vc3R5bGVfYmF0Y2gnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi9zdHlsZV9sYXllcicpO1xudmFyIEltYWdlU3ByaXRlID0gcmVxdWlyZSgnLi9pbWFnZV9zcHJpdGUnKTtcbnZhciBHbHlwaFNvdXJjZSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9nbHlwaF9zb3VyY2UnKTtcbnZhciBHbHlwaEF0bGFzID0gcmVxdWlyZSgnLi4vc3ltYm9sL2dseXBoX2F0bGFzJyk7XG52YXIgU3ByaXRlQXRsYXMgPSByZXF1aXJlKCcuLi9zeW1ib2wvc3ByaXRlX2F0bGFzJyk7XG52YXIgTGluZUF0bGFzID0gcmVxdWlyZSgnLi4vcmVuZGVyL2xpbmVfYXRsYXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplU3R5bGVVUkw7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi91dGlsL2Rpc3BhdGNoZXInKTtcbnZhciBBbmltYXRpb25Mb29wID0gcmVxdWlyZSgnLi9hbmltYXRpb25fbG9vcCcpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL2xhdGVzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuXG5mdW5jdGlvbiBTdHlsZShzdHlsZXNoZWV0LCBhbmltYXRpb25Mb29wKSB7XG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gYW5pbWF0aW9uTG9vcCB8fCBuZXcgQW5pbWF0aW9uTG9vcCgpO1xuICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKE1hdGgubWF4KGJyb3dzZXIuaGFyZHdhcmVDb25jdXJyZW5jeSAtIDEsIDEpLCB0aGlzKTtcbiAgICB0aGlzLmdseXBoQXRsYXMgPSBuZXcgR2x5cGhBdGxhcygxMDI0LCAxMDI0KTtcbiAgICB0aGlzLnNwcml0ZUF0bGFzID0gbmV3IFNwcml0ZUF0bGFzKDUxMiwgNTEyKTtcbiAgICB0aGlzLnNwcml0ZUF0bGFzLnJlc2l6ZShicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIHRoaXMubGluZUF0bGFzID0gbmV3IExpbmVBdGxhcygyNTYsIDUxMik7XG5cbiAgICB0aGlzLl9sYXllcnMgPSB7fTtcbiAgICB0aGlzLl9vcmRlciAgPSBbXTtcbiAgICB0aGlzLl9ncm91cHMgPSBbXTtcbiAgICB0aGlzLnNvdXJjZXMgPSB7fTtcblxuICAgIHRoaXMuem9vbUhpc3RvcnkgPSB7fTtcblxuICAgIHV0aWwuYmluZEFsbChbXG4gICAgICAgICdfZm9yd2FyZFNvdXJjZUV2ZW50JyxcbiAgICAgICAgJ19mb3J3YXJkVGlsZUV2ZW50JyxcbiAgICAgICAgJ19yZWRvUGxhY2VtZW50J1xuICAgIF0sIHRoaXMpO1xuXG4gICAgdmFyIGxvYWRlZCA9IGZ1bmN0aW9uKGVyciwgc3R5bGVzaGVldCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWxpZCA9IHZhbGlkYXRlKHN0eWxlc2hlZXQpO1xuICAgICAgICBpZiAodmFsaWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWxpZC5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0ID0gc3R5bGVzaGVldDtcblxuICAgICAgICB2YXIgc291cmNlcyA9IHN0eWxlc2hlZXQuc291cmNlcztcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRTb3VyY2UoaWQsIHNvdXJjZXNbaWRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHlsZXNoZWV0LnNwcml0ZSkge1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSBuZXcgSW1hZ2VTcHJpdGUoc3R5bGVzaGVldC5zcHJpdGUpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUub24oJ2xvYWQnLCB0aGlzLmZpcmUuYmluZCh0aGlzLCAnY2hhbmdlJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbHlwaFNvdXJjZSA9IG5ldyBHbHlwaFNvdXJjZShzdHlsZXNoZWV0LmdseXBocywgdGhpcy5nbHlwaEF0bGFzKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBpZiAodHlwZW9mIHN0eWxlc2hlZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFqYXguZ2V0SlNPTihub3JtYWxpemVVUkwoc3R5bGVzaGVldCksIGxvYWRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnJvd3Nlci5mcmFtZShsb2FkZWQuYmluZCh0aGlzLCBudWxsLCBzdHlsZXNoZWV0KSk7XG4gICAgfVxufVxuXG5TdHlsZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwge1xuICAgIF9sb2FkZWQ6IGZhbHNlLFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zb3VyY2VzKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNvdXJjZXNbaWRdLmxvYWRlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5zcHJpdGUgJiYgIXRoaXMuc3ByaXRlLmxvYWRlZCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBfcmVzb2x2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCwgbGF5ZXI7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJzID0ge307XG4gICAgICAgIHRoaXMuX29yZGVyICA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdHlsZXNoZWV0LmxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGF5ZXIgPSBuZXcgU3R5bGVMYXllcih0aGlzLnN0eWxlc2hlZXQubGF5ZXJzW2ldLCB0aGlzLnN0eWxlc2hlZXQuY29uc3RhbnRzIHx8IHt9KTtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tsYXllci5pZF0gPSBsYXllcjtcbiAgICAgICAgICAgIHRoaXMuX29yZGVyLnB1c2gobGF5ZXIuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzb2x2ZSBsYXlvdXQgcHJvcGVydGllcy5cbiAgICAgICAgZm9yIChpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzb2x2ZUxheW91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzb2x2ZSByZWZlcmVuY2UgYW5kIHBhaW50IHByb3BlcnRpZXMuXG4gICAgICAgIGZvciAoaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLnJlc29sdmVSZWZlcmVuY2UodGhpcy5fbGF5ZXJzKTtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzb2x2ZVBhaW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ncm91cExheWVycygpO1xuICAgICAgICB0aGlzLl9icm9hZGNhc3RMYXllcnMoKTtcbiAgICB9LFxuXG4gICAgX2dyb3VwTGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyb3VwO1xuXG4gICAgICAgIHRoaXMuX2dyb3VwcyA9IFtdO1xuXG4gICAgICAgIC8vIFNwbGl0IGludG8gZ3JvdXBzIG9mIGNvbnNlY3V0aXZlIHRvcC1sZXZlbCBsYXllcnMgd2l0aCB0aGUgc2FtZSBzb3VyY2UuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3JkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t0aGlzLl9vcmRlcltpXV07XG5cbiAgICAgICAgICAgIGlmICghZ3JvdXAgfHwgbGF5ZXIuc291cmNlICE9PSBncm91cC5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBncm91cCA9IFtdO1xuICAgICAgICAgICAgICAgIGdyb3VwLnNvdXJjZSA9IGxheWVyLnNvdXJjZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ncm91cHMucHVzaChncm91cCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLnB1c2gobGF5ZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9icm9hZGNhc3RMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3JkZXJlZCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgb3JkZXJlZC5wdXNoKHRoaXMuX2xheWVyc1tpZF0uanNvbigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5icm9hZGNhc3QoJ3NldCBsYXllcnMnLCBvcmRlcmVkKTtcbiAgICB9LFxuXG4gICAgX2Nhc2NhZGU6IGZ1bmN0aW9uKGNsYXNzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHJldHVybjtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLmNhc2NhZGUoY2xhc3Nlcywgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXQudHJhbnNpdGlvbiB8fCB7fSxcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkxvb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICB9LFxuXG4gICAgX3JlY2FsY3VsYXRlOiBmdW5jdGlvbih6KSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuc291cmNlcylcbiAgICAgICAgICAgIHRoaXMuc291cmNlc1tpZF0udXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVpvb21IaXN0b3J5KHopO1xuXG4gICAgICAgIHRoaXMucmFzdGVyRmFkZUR1cmF0aW9uID0gMzAwO1xuICAgICAgICBmb3IgKGlkIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblxuICAgICAgICAgICAgaWYgKGxheWVyLnJlY2FsY3VsYXRlKHosIHRoaXMuem9vbUhpc3RvcnkpICYmIGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlc1tsYXllci5zb3VyY2VdLnVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heFpvb21UcmFuc2l0aW9uRHVyYXRpb24gPSAzMDA7XG4gICAgICAgIGlmIChNYXRoLmZsb29yKHRoaXMueikgIT09IE1hdGguZmxvb3IoeikpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zZXQobWF4Wm9vbVRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICB0aGlzLmZpcmUoJ3pvb20nKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVpvb21IaXN0b3J5OiBmdW5jdGlvbih6KSB7XG5cbiAgICAgICAgdmFyIHpoID0gdGhpcy56b29tSGlzdG9yeTtcblxuICAgICAgICBpZiAoemgubGFzdEludGVnZXJab29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbSA9IE1hdGguZmxvb3Ioeik7XG4gICAgICAgICAgICB6aC5sYXN0SW50ZWdlclpvb21UaW1lID0gMDtcbiAgICAgICAgICAgIHpoLmxhc3Rab29tID0gejtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYW4gaW50ZWdlciB6b29tIGxldmVsIGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZVxuICAgICAgICAvLyBhbmQgaWYgeWVzLCByZWNvcmQgaXQgd2l0aCB0aGUgdGltZS4gVXNlZCBmb3IgdHJhbnNpdGlvbmluZyBwYXR0ZXJucy5cbiAgICAgICAgaWYgKE1hdGguZmxvb3IoemgubGFzdFpvb20pIDwgTWF0aC5mbG9vcih6KSkge1xuICAgICAgICAgICAgemgubGFzdEludGVnZXJab29tID0gTWF0aC5mbG9vcih6KTtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5mbG9vcih6aC5sYXN0Wm9vbSkgPiBNYXRoLmZsb29yKHopKSB7XG4gICAgICAgICAgICB6aC5sYXN0SW50ZWdlclpvb20gPSBNYXRoLmZsb29yKHogKyAxKTtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgemgubGFzdFpvb20gPSB6O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBtdWx0aXBsZSBzdHlsZSBtdXRhdGlvbnMgaW4gYSBiYXRjaFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHdvcmsgRnVuY3Rpb24gd2hpY2ggYWNjZXB0cyB0aGUgU3R5bGVCYXRjaCBpbnRlcmZhY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJhdGNoOiBmdW5jdGlvbih3b3JrKSB7XG4gICAgICAgIHN0eWxlQmF0Y2godGhpcywgd29yayk7XG4gICAgfSxcblxuICAgIGFkZFNvdXJjZTogZnVuY3Rpb24oaWQsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLmJhdGNoKGZ1bmN0aW9uKGJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaC5hZGRTb3VyY2UoaWQsIHNvdXJjZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzb3VyY2UgZnJvbSB0aGlzIHN0eWxlc2hlZXQsIGdpdmVuIGl0cyBpZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgaWQgb2YgdGhlIHNvdXJjZSB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJucyB7U3R5bGV9IHRoaXMgc3R5bGVcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gc291cmNlIGlzIGZvdW5kIHdpdGggdGhlIGdpdmVuIElEXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHRoaXMuYmF0Y2goZnVuY3Rpb24oYmF0Y2gpIHtcbiAgICAgICAgICAgIGJhdGNoLnJlbW92ZVNvdXJjZShpZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzb3VyY2UgYnkgaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGlkIG9mIHRoZSBkZXNpcmVkIHNvdXJjZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHNvdXJjZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzW2lkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGF5ZXIgdG8gdGhlIG1hcCBzdHlsZS4gVGhlIGxheWVyIHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBsYXllciB3aXRoXG4gICAgICogSUQgYGJlZm9yZWAsIG9yIGFwcGVuZGVkIGlmIGBiZWZvcmVgIGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtTdHlsZUxheWVyfE9iamVjdH0gbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJlZm9yZSAgSUQgb2YgYW4gZXhpc3RpbmcgbGF5ZXIgdG8gaW5zZXJ0IGJlZm9yZVxuICAgICAqIEBmaXJlcyBsYXllci5hZGRcbiAgICAgKiBAcmV0dXJucyB7U3R5bGV9IGB0aGlzYFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyLCBiZWZvcmUpIHtcbiAgICAgICAgdGhpcy5iYXRjaChmdW5jdGlvbihiYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2guYWRkTGF5ZXIobGF5ZXIsIGJlZm9yZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsYXllciBmcm9tIHRoaXMgc3R5bGVzaGVldCwgZ2l2ZW4gaXRzIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBpZCBvZiB0aGUgbGF5ZXIgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMge1N0eWxlfSB0aGlzIHN0eWxlXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGxheWVyIGlzIGZvdW5kIHdpdGggdGhlIGdpdmVuIElEXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5iYXRjaChmdW5jdGlvbihiYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2gucmVtb3ZlTGF5ZXIoaWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGF5ZXIgYnkgaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGlkIG9mIHRoZSBkZXNpcmVkIGxheWVyXG4gICAgICogQHJldHVybnMge0xheWVyfSBsYXllclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiBhIGxheWVyIGhhcyBhIGByZWZgIHByb3BlcnR5IHRoYXQgbWFrZXMgaXQgZGVyaXZlIHNvbWUgdmFsdWVzXG4gICAgICogZnJvbSBhbm90aGVyIGxheWVyLCByZXR1cm4gdGhhdCByZWZlcmVudCBsYXllci4gT3RoZXJ3aXNlLFxuICAgICAqIHJldHVybnMgdGhlIGxheWVyIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGxheWVyJ3MgaWRcbiAgICAgKiBAcmV0dXJucyB7TGF5ZXJ9IHRoZSByZWZlcmVudCBsYXllciBvciB0aGUgbGF5ZXIgaXRzZWxmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRSZWZlcmVudExheWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKGlkKTtcbiAgICAgICAgaWYgKGxheWVyLnJlZikge1xuICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLmdldExheWVyKGxheWVyLnJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH0sXG5cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5iYXRjaChmdW5jdGlvbihiYXRjaCkge1xuICAgICAgICAgICAgYmF0Y2guc2V0RmlsdGVyKGxheWVyLCBmaWx0ZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGF5ZXIncyBmaWx0ZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIHRoZSBsYXllciB0byBpbnNwZWN0XG4gICAgICogQHJldHVybnMgeyp9IHRoZSBsYXllcidzIGZpbHRlciwgaWYgYW55XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlZmVyZW50TGF5ZXIobGF5ZXIpLmZpbHRlcjtcbiAgICB9LFxuXG4gICAgc2V0TGF5b3V0UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJhdGNoKGZ1bmN0aW9uKGJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaC5zZXRMYXlvdXRQcm9wZXJ0eShsYXllciwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGF5b3V0IHByb3BlcnR5J3MgdmFsdWUgZnJvbSBhIGdpdmVuIGxheWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIHRoZSBsYXllciB0byBpbnNwZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGxheW91dCBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWZlcmVudExheWVyKGxheWVyKS5nZXRMYXlvdXRQcm9wZXJ0eShuYW1lKTtcbiAgICB9LFxuXG4gICAgc2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIHZhbHVlLCBrbGFzcykge1xuICAgICAgICB0aGlzLmJhdGNoKGZ1bmN0aW9uKGJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaC5zZXRQYWludFByb3BlcnR5KGxheWVyLCBuYW1lLCB2YWx1ZSwga2xhc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIGtsYXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVyKGxheWVyKS5nZXRQYWludFByb3BlcnR5KG5hbWUsIGtsYXNzKTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXNBdDogZnVuY3Rpb24oY29vcmQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgICAgIHZhciBlcnJvciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5sYXllcikge1xuICAgICAgICAgICAgcGFyYW1zLmxheWVyID0geyBpZDogcGFyYW1zLmxheWVyIH07XG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmFzeW5jRWFjaChPYmplY3Qua2V5cyh0aGlzLnNvdXJjZXMpLCBmdW5jdGlvbihpZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbaWRdO1xuICAgICAgICAgICAgc291cmNlLmZlYXR1cmVzQXQoY29vcmQsIHBhcmFtcywgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSBmZWF0dXJlcyA9IGZlYXR1cmVzLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcblxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZmVhdHVyZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1tmZWF0dXJlLmxheWVyXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5sYXllciA9IHRoaXMuX2xheWVyc1tmZWF0dXJlLmxheWVyXS5qc29uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSkpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnJlbW92ZSgpO1xuICAgIH0sXG5cbiAgICBfcmVsb2FkU291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB0aGlzLnNvdXJjZXNbaWRdLnJlbG9hZCgpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlU291cmNlczogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzW2lkXS51cGRhdGUodHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVkb1BsYWNlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuc291cmNlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlc1tpZF0ucmVkb1BsYWNlbWVudCkgdGhpcy5zb3VyY2VzW2lkXS5yZWRvUGxhY2VtZW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZvcndhcmRTb3VyY2VFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3NvdXJjZS4nICsgZS50eXBlLCB1dGlsLmV4dGVuZCh7c291cmNlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX2ZvcndhcmRUaWxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKGUudHlwZSwgdXRpbC5leHRlbmQoe3NvdXJjZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIC8vIENhbGxiYWNrcyBmcm9tIHdlYiB3b3JrZXJzXG5cbiAgICAnZ2V0IHNwcml0ZSBqc29uJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5zcHJpdGU7XG4gICAgICAgIGlmIChzcHJpdGUubG9hZGVkKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgc3ByaXRlOiBzcHJpdGUuZGF0YSwgcmV0aW5hOiBzcHJpdGUucmV0aW5hIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ByaXRlLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBzcHJpdGU6IHNwcml0ZS5kYXRhLCByZXRpbmE6IHNwcml0ZS5yZXRpbmEgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnZ2V0IGljb25zJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5zcHJpdGU7XG4gICAgICAgIHZhciBzcHJpdGVBdGxhcyA9IHRoaXMuc3ByaXRlQXRsYXM7XG4gICAgICAgIGlmIChzcHJpdGUubG9hZGVkKCkpIHtcbiAgICAgICAgICAgIHNwcml0ZUF0bGFzLnNldFNwcml0ZShzcHJpdGUpO1xuICAgICAgICAgICAgc3ByaXRlQXRsYXMuYWRkSWNvbnMocGFyYW1zLmljb25zLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcHJpdGUub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzcHJpdGVBdGxhcy5zZXRTcHJpdGUoc3ByaXRlKTtcbiAgICAgICAgICAgICAgICBzcHJpdGVBdGxhcy5hZGRJY29ucyhwYXJhbXMuaWNvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdnZXQgZ2x5cGhzJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmdseXBoU291cmNlLmdldFNpbXBsZUdseXBocyhwYXJhbXMuZm9udHN0YWNrLCBwYXJhbXMuY29kZXBvaW50cywgcGFyYW1zLnVpZCwgY2FsbGJhY2spO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU291cmNlID0gcmVxdWlyZSgnLi4vc291cmNlL3NvdXJjZScpO1xudmFyIFN0eWxlTGF5ZXIgPSByZXF1aXJlKCcuL3N0eWxlX2xheWVyJyk7XG5cbmZ1bmN0aW9uIHN0eWxlQmF0Y2goc3R5bGUsIHdvcmspIHtcbiAgICBpZiAoIXN0eWxlLl9sb2FkZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHlsZSBpcyBub3QgZG9uZSBsb2FkaW5nJyk7XG4gICAgfVxuXG4gICAgdmFyIGJhdGNoID0gT2JqZWN0LmNyZWF0ZShzdHlsZUJhdGNoLnByb3RvdHlwZSk7XG5cbiAgICBiYXRjaC5fc3R5bGUgPSBzdHlsZTtcbiAgICBiYXRjaC5fZ3JvdXBMYXllcnMgPSBmYWxzZTtcbiAgICBiYXRjaC5fYnJvYWRjYXN0TGF5ZXJzID0gZmFsc2U7XG4gICAgYmF0Y2guX3JlbG9hZFNvdXJjZXMgPSB7fTtcbiAgICBiYXRjaC5fZXZlbnRzID0gW107XG4gICAgYmF0Y2guX2NoYW5nZSA9IGZhbHNlO1xuXG4gICAgd29yayhiYXRjaCk7XG5cbiAgICBpZiAoYmF0Y2guX2dyb3VwTGF5ZXJzKSB7XG4gICAgICAgIGJhdGNoLl9zdHlsZS5fZ3JvdXBMYXllcnMoKTtcbiAgICB9XG5cbiAgICBpZiAoYmF0Y2guX2Jyb2FkY2FzdExheWVycykge1xuICAgICAgICBiYXRjaC5fc3R5bGUuX2Jyb2FkY2FzdExheWVycygpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKGJhdGNoLl9yZWxvYWRTb3VyY2VzKS5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZUlkKSB7XG4gICAgICAgIGJhdGNoLl9zdHlsZS5fcmVsb2FkU291cmNlKHNvdXJjZUlkKTtcbiAgICB9KTtcblxuICAgIGJhdGNoLl9ldmVudHMuZm9yRWFjaChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIGJhdGNoLl9zdHlsZS5maXJlLmFwcGx5KGJhdGNoLl9zdHlsZSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICBpZiAoYmF0Y2guX2NoYW5nZSkge1xuICAgICAgICBiYXRjaC5fc3R5bGUuZmlyZSgnY2hhbmdlJyk7XG4gICAgfVxufVxuXG5zdHlsZUJhdGNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFkZExheWVyOiBmdW5jdGlvbihsYXllciwgYmVmb3JlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZS5fbGF5ZXJzW2xheWVyLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIGFscmVhZHkgYSBsYXllciB3aXRoIHRoaXMgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShsYXllciBpbnN0YW5jZW9mIFN0eWxlTGF5ZXIpKSB7XG4gICAgICAgICAgICBsYXllciA9IG5ldyBTdHlsZUxheWVyKGxheWVyLCB0aGlzLl9zdHlsZS5zdHlsZXNoZWV0LmNvbnN0YW50cyB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3R5bGUuX2xheWVyc1tsYXllci5pZF0gPSBsYXllcjtcbiAgICAgICAgdGhpcy5fc3R5bGUuX29yZGVyLnNwbGljZShiZWZvcmUgPyB0aGlzLl9zdHlsZS5fb3JkZXIuaW5kZXhPZihiZWZvcmUpIDogSW5maW5pdHksIDAsIGxheWVyLmlkKTtcbiAgICAgICAgbGF5ZXIucmVzb2x2ZUxheW91dCgpO1xuICAgICAgICBsYXllci5yZXNvbHZlUmVmZXJlbmNlKHRoaXMuX3N0eWxlLl9sYXllcnMpO1xuICAgICAgICBsYXllci5yZXNvbHZlUGFpbnQoKTtcblxuICAgICAgICB0aGlzLl9ncm91cExheWVycyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Jyb2FkY2FzdExheWVycyA9IHRydWU7XG4gICAgICAgIGlmIChsYXllci5zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbG9hZFNvdXJjZXNbbGF5ZXIuc291cmNlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goWydsYXllci5hZGQnLCB7bGF5ZXI6IGxheWVyfV0pO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fc3R5bGUuX2xheWVyc1tpZF07XG4gICAgICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIGxheWVyIHdpdGggdGhpcyBJRCcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fc3R5bGUuX2xheWVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlLl9sYXllcnNbaV0ucmVmID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX3N0eWxlLl9sYXllcnNbaWRdO1xuICAgICAgICB0aGlzLl9zdHlsZS5fb3JkZXIuc3BsaWNlKHRoaXMuX3N0eWxlLl9vcmRlci5pbmRleE9mKGlkKSwgMSk7XG5cbiAgICAgICAgdGhpcy5fZ3JvdXBMYXllcnMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9icm9hZGNhc3RMYXllcnMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChbJ2xheWVyLnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9XSk7XG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lLCB2YWx1ZSwga2xhc3MpIHtcbiAgICAgICAgdGhpcy5fc3R5bGUuZ2V0TGF5ZXIobGF5ZXIpLnNldFBhaW50UHJvcGVydHkobmFtZSwgdmFsdWUsIGtsYXNzKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0TGF5b3V0UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsYXllciA9IHRoaXMuX3N0eWxlLmdldFJlZmVyZW50TGF5ZXIobGF5ZXIpO1xuICAgICAgICBsYXllci5zZXRMYXlvdXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5fYnJvYWRjYXN0TGF5ZXJzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVsb2FkU291cmNlc1tsYXllci5zb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyLCBmaWx0ZXIpIHtcbiAgICAgICAgbGF5ZXIgPSB0aGlzLl9zdHlsZS5nZXRSZWZlcmVudExheWVyKGxheWVyKTtcbiAgICAgICAgbGF5ZXIuZmlsdGVyID0gZmlsdGVyO1xuXG4gICAgICAgIHRoaXMuX2Jyb2FkY2FzdExheWVycyA9IHRydWU7XG4gICAgICAgIGlmIChsYXllci5zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbG9hZFNvdXJjZXNbbGF5ZXIuc291cmNlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbmdlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkU291cmNlOiBmdW5jdGlvbihpZCwgc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3R5bGUuX2xvYWRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHlsZSBpcyBub3QgZG9uZSBsb2FkaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0eWxlLnNvdXJjZXNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgYWxyZWFkeSBhIHNvdXJjZSB3aXRoIHRoaXMgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBTb3VyY2UuY3JlYXRlKHNvdXJjZSk7XG4gICAgICAgIHRoaXMuX3N0eWxlLnNvdXJjZXNbaWRdID0gc291cmNlO1xuICAgICAgICBzb3VyY2UuaWQgPSBpZDtcbiAgICAgICAgc291cmNlLnN0eWxlID0gdGhpcy5fc3R5bGU7XG4gICAgICAgIHNvdXJjZS5kaXNwYXRjaGVyID0gdGhpcy5fc3R5bGUuZGlzcGF0Y2hlcjtcbiAgICAgICAgc291cmNlLmdseXBoQXRsYXMgPSB0aGlzLl9zdHlsZS5nbHlwaEF0bGFzO1xuICAgICAgICBzb3VyY2VcbiAgICAgICAgICAgIC5vbignbG9hZCcsIHRoaXMuX3N0eWxlLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub24oJ2Vycm9yJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vbignY2hhbmdlJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5hZGQnLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5sb2FkJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUuZXJyb3InLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5yZW1vdmUnLCB0aGlzLl9zdHlsZS5fZm9yd2FyZFRpbGVFdmVudCk7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goWydzb3VyY2UuYWRkJywge3NvdXJjZTogc291cmNlfV0pO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZS5zb3VyY2VzW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIHNvdXJjZSB3aXRoIHRoaXMgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fc3R5bGUuc291cmNlc1tpZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdHlsZS5zb3VyY2VzW2lkXTtcbiAgICAgICAgc291cmNlXG4gICAgICAgICAgICAub2ZmKCdsb2FkJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ2Vycm9yJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ2NoYW5nZScsIHRoaXMuX3N0eWxlLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCd0aWxlLmFkZCcsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5sb2FkJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCd0aWxlLmVycm9yJywgdGhpcy5fc3R5bGUuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCd0aWxlLnJlbW92ZScsIHRoaXMuX3N0eWxlLl9mb3J3YXJkVGlsZUV2ZW50KTtcblxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChbJ3NvdXJjZS5yZW1vdmUnLCB7c291cmNlOiBzb3VyY2V9XSk7XG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZUJhdGNoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSwgY29uc3RhbnRzKSB7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJ0AnID8gY29uc3RhbnRzW3ZhbHVlXSA6IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBpO1xuXG4gICAgdmFsdWUgPSByZXNvbHZlKHZhbHVlKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVbaV0gaW4gY29uc3RhbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gPSByZXNvbHZlKHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZS5zdG9wcykge1xuICAgICAgICB2YWx1ZSA9IHV0aWwuZXh0ZW5kKHt9LCB2YWx1ZSk7XG4gICAgICAgIHZhbHVlLnN0b3BzID0gdmFsdWUuc3RvcHMuc2xpY2UoKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUuc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdG9wc1tpXVsxXSBpbiBjb25zdGFudHMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5zdG9wc1tpXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3RvcHNbaV1bMF0sXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUuc3RvcHNbaV1bMV0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbmV4cG9ydHMucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBjb25zdGFudHMpIHtcbiAgICBpZiAoIWNvbnN0YW50cylcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG5cbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICByZXN1bHRba2V5XSA9IGV4cG9ydHMucmVzb2x2ZShwcm9wZXJ0aWVzW2tleV0sIGNvbnN0YW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZUNTU0NvbG9yID0gcmVxdWlyZSgnY3NzY29sb3JwYXJzZXInKS5wYXJzZUNTU0NvbG9yO1xudmFyIG1hcGJveEdMRnVuY3Rpb24gPSByZXF1aXJlKCdtYXBib3gtZ2wtZnVuY3Rpb24nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVEZWNsYXJhdGlvbjtcblxuZnVuY3Rpb24gU3R5bGVEZWNsYXJhdGlvbihyZWZlcmVuY2UsIHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gcmVmZXJlbmNlLnR5cGU7XG4gICAgdGhpcy50cmFuc2l0aW9uYWJsZSA9IHJlZmVyZW5jZS50cmFuc2l0aW9uO1xuXG4gICAgLy8gaW1tdXRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHZhbHVlLiB1c2VkIGZvciBjb21wYXJpc29uXG4gICAgdGhpcy5qc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2NvbG9yJykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS5zdG9wcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJlcGFyZUNvbG9yRnVuY3Rpb24odmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZUNvbG9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAocmVmZXJlbmNlLmZ1bmN0aW9uID09PSAnaW50ZXJwb2xhdGVkJykge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZSA9IG1hcGJveEdMRnVuY3Rpb24uaW50ZXJwb2xhdGVkKHRoaXMudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlID0gbWFwYm94R0xGdW5jdGlvblsncGllY2V3aXNlLWNvbnN0YW50J10odGhpcy52YWx1ZSk7XG4gICAgICAgIGlmIChyZWZlcmVuY2UudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGUgPSB0cmFuc2l0aW9uZWQodGhpcy5jYWxjdWxhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uZWQoY2FsY3VsYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHosIHpoLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgZnJhY3Rpb24gPSB6ICUgMTtcbiAgICAgICAgdmFyIHQgPSBNYXRoLm1pbigoRGF0ZS5ub3coKSAtIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUpIC8gZHVyYXRpb24sIDEpO1xuICAgICAgICB2YXIgZnJvbVNjYWxlID0gMTtcbiAgICAgICAgdmFyIHRvU2NhbGUgPSAxO1xuICAgICAgICB2YXIgbWl4LCBmcm9tLCB0bztcblxuICAgICAgICBpZiAoeiA+IHpoLmxhc3RJbnRlZ2VyWm9vbSkge1xuICAgICAgICAgICAgbWl4ID0gZnJhY3Rpb24gKyAoMSAtIGZyYWN0aW9uKSAqIHQ7XG4gICAgICAgICAgICBmcm9tU2NhbGUgKj0gMjtcbiAgICAgICAgICAgIGZyb20gPSBjYWxjdWxhdGUoeiAtIDEpO1xuICAgICAgICAgICAgdG8gPSBjYWxjdWxhdGUoeik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaXggPSAxIC0gKDEgLSB0KSAqIGZyYWN0aW9uO1xuICAgICAgICAgICAgdG8gPSBjYWxjdWxhdGUoeik7XG4gICAgICAgICAgICBmcm9tID0gY2FsY3VsYXRlKHogKyAxKTtcbiAgICAgICAgICAgIGZyb21TY2FsZSAvPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICBmcm9tU2NhbGU6IGZyb21TY2FsZSxcbiAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgIHRvU2NhbGU6IHRvU2NhbGUsXG4gICAgICAgICAgICB0OiBtaXhcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG52YXIgY29sb3JDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBwYXJzZUNvbG9yKHZhbHVlKSB7XG4gICAgaWYgKGNvbG9yQ2FjaGVbdmFsdWVdKSByZXR1cm4gY29sb3JDYWNoZVt2YWx1ZV07XG4gICAgdmFyIGNvbG9yID0gcHJlcGFyZUNvbG9yKHBhcnNlQ1NTQ29sb3IodmFsdWUpKTtcbiAgICBjb2xvckNhY2hlW3ZhbHVlXSA9IGNvbG9yO1xuICAgIHJldHVybiBjb2xvcjtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNvbG9yKGMpIHtcbiAgICByZXR1cm4gW2NbMF0gLyAyNTUsIGNbMV0gLyAyNTUsIGNbMl0gLyAyNTUsIGNbM10gLyAxXTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNvbG9yRnVuY3Rpb24oZikge1xuICAgIHJldHVybiB1dGlsLmV4dGVuZCh7fSwgZiwge3N0b3BzOiBmLnN0b3BzLm1hcChmdW5jdGlvbihzdG9wKSB7XG4gICAgICAgIHJldHVybiBbc3RvcFswXSwgcGFyc2VDb2xvcihzdG9wWzFdKV07XG4gICAgfSl9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciByZWZlcmVuY2UgPSByZXF1aXJlKCcuL3JlZmVyZW5jZScpO1xudmFyIFN0eWxlQ29uc3RhbnQgPSByZXF1aXJlKCcuL3N0eWxlX2NvbnN0YW50Jyk7XG52YXIgU3R5bGVEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vc3R5bGVfZGVjbGFyYXRpb24nKTtcblxudmFyIGxvb2t1cCA9IHtcbiAgICBwYWludDoge30sXG4gICAgbGF5b3V0OiB7fVxufTtcblxucmVmZXJlbmNlLmxheWVyLnR5cGUudmFsdWVzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIGxvb2t1cC5wYWludFt0eXBlXSA9IG1ha2VDb25zdHJ1Y3RvcihyZWZlcmVuY2VbJ3BhaW50XycgKyB0eXBlXSk7XG4gICAgbG9va3VwLmxheW91dFt0eXBlXSA9IG1ha2VDb25zdHJ1Y3RvcihyZWZlcmVuY2VbJ2xheW91dF8nICsgdHlwZV0pO1xufSk7XG5cbmZ1bmN0aW9uIG1ha2VDb25zdHJ1Y3RvcihyZWZlcmVuY2UpIHtcbiAgICBmdW5jdGlvbiBTdHlsZURlY2xhcmF0aW9uU2V0KHByb3BlcnRpZXMsIGNvbnN0YW50cykge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbnMgPSB7fTtcblxuICAgICAgICB0aGlzLl9jb25zdGFudHMgPSBjb25zdGFudHM7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzW2tdID0gU3R5bGVDb25zdGFudC5yZXNvbHZlKHByb3BlcnRpZXNba10sIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhyZWZlcmVuY2UpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSByZWZlcmVuY2Vba107XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0eWxlRGVjbGFyYXRpb25TZXQucHJvdG90eXBlLCBrLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNba10gPSBuZXcgU3R5bGVEZWNsYXJhdGlvbihwcm9wZXJ0eSwgU3R5bGVDb25zdGFudC5yZXNvbHZlKHYsIHRoaXMuX2NvbnN0YW50cykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1trXS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5LnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHlsZURlY2xhcmF0aW9uU2V0LnByb3RvdHlwZSwgayArICctdHJhbnNpdGlvbicsIHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbnNba10gPSB2O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25zW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBTdHlsZURlY2xhcmF0aW9uU2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcztcbiAgICB9O1xuXG4gICAgU3R5bGVEZWNsYXJhdGlvblNldC5wcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGssIGdsb2JhbCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuX3RyYW5zaXRpb25zW2tdIHx8IHt9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZHVyYXRpb246IHV0aWwuY29hbGVzY2UodC5kdXJhdGlvbiwgZ2xvYmFsLmR1cmF0aW9uLCAzMDApLFxuICAgICAgICAgICAgZGVsYXk6IHV0aWwuY29hbGVzY2UodC5kZWxheSwgZ2xvYmFsLmRlbGF5LCAwKVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBTdHlsZURlY2xhcmF0aW9uU2V0LnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciB2IGluIHRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgcmVzdWx0W3ZdID0gdGhpcy5fdmFsdWVzW3ZdLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl90cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgcmVzdWx0W3QgKyAnLXRyYW5zaXRpb24nXSA9IHRoaXMuX3RyYW5zaXRpb25zW3ZdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0eWxlRGVjbGFyYXRpb25TZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVuZGVyVHlwZSwgbGF5ZXJUeXBlLCBwcm9wZXJ0aWVzLCBjb25zdGFudHMpIHtcbiAgICByZXR1cm4gbmV3IGxvb2t1cFtyZW5kZXJUeXBlXVtsYXllclR5cGVdKHByb3BlcnRpZXMsIGNvbnN0YW50cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlQ29uc3RhbnQgPSByZXF1aXJlKCcuL3N0eWxlX2NvbnN0YW50Jyk7XG52YXIgU3R5bGVUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi9zdHlsZV90cmFuc2l0aW9uJyk7XG52YXIgU3R5bGVEZWNsYXJhdGlvblNldCA9IHJlcXVpcmUoJy4vc3R5bGVfZGVjbGFyYXRpb25fc2V0Jyk7XG52YXIgTGF5b3V0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vbGF5b3V0X3Byb3BlcnRpZXMnKTtcbnZhciBQYWludFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3BhaW50X3Byb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZUxheWVyO1xuXG5mdW5jdGlvbiBTdHlsZUxheWVyKGxheWVyLCBjb25zdGFudHMpIHtcbiAgICB0aGlzLl9sYXllciA9IGxheWVyO1xuICAgIHRoaXMuX2NvbnN0YW50cyA9IGNvbnN0YW50cztcblxuICAgIHRoaXMuaWQgPSBsYXllci5pZDtcbiAgICB0aGlzLnJlZiA9IGxheWVyLnJlZjtcblxuICAgIC8vIFJlc29sdmVkIGFuZCBjYXNjYWRlZCBwYWludCBwcm9wZXJ0aWVzLlxuICAgIHRoaXMuX3Jlc29sdmVkID0ge307IC8vIGNsYXNzIG5hbWUgLT4gU3R5bGVEZWNsYXJhdGlvblNldFxuICAgIHRoaXMuX2Nhc2NhZGVkID0ge307IC8vIHByb3BlcnR5IG5hbWUgLT4gU3R5bGVUcmFuc2l0aW9uXG5cbiAgICB0aGlzLmFzc2lnbihsYXllcik7XG59XG5cblN0eWxlTGF5ZXIucHJvdG90eXBlID0ge1xuICAgIHJlc29sdmVMYXlvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dCA9IG5ldyBMYXlvdXRQcm9wZXJ0aWVzW3RoaXMudHlwZV0oXG4gICAgICAgICAgICAgICAgU3R5bGVDb25zdGFudC5yZXNvbHZlQWxsKHRoaXMuX2xheWVyLmxheW91dCwgdGhpcy5fY29uc3RhbnRzKSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0Lmhhc093blByb3BlcnR5KCd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0Wyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddID0gJ21hcCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQuaGFzT3duUHJvcGVydHkoJ2ljb24tcm90YXRpb24tYWxpZ25tZW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gPSAnbWFwJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRbJ3N5bWJvbC1hdm9pZC1lZGdlcyddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sYXlvdXRbbmFtZV0gPSBTdHlsZUNvbnN0YW50LnJlc29sdmUodmFsdWUsIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgfSxcblxuICAgIGdldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dFtuYW1lXTtcbiAgICB9LFxuXG4gICAgcmVzb2x2ZVJlZmVyZW5jZTogZnVuY3Rpb24obGF5ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5hc3NpZ24obGF5ZXJzW3RoaXMucmVmXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzb2x2ZVBhaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiB0aGlzLl9sYXllcikge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gcC5tYXRjaCgvXnBhaW50KD86XFwuKC4qKSk/JC8pO1xuICAgICAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVkW21hdGNoWzFdIHx8ICcnXSA9XG4gICAgICAgICAgICAgICAgbmV3IFN0eWxlRGVjbGFyYXRpb25TZXQoJ3BhaW50JywgdGhpcy50eXBlLCB0aGlzLl9sYXllcltwXSwgdGhpcy5fY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwga2xhc3MpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMuX3Jlc29sdmVkW2tsYXNzIHx8ICcnXTtcbiAgICAgICAgaWYgKCFkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9ucyA9IHRoaXMuX3Jlc29sdmVkW2tsYXNzIHx8ICcnXSA9XG4gICAgICAgICAgICAgICAgbmV3IFN0eWxlRGVjbGFyYXRpb25TZXQoJ3BhaW50JywgdGhpcy50eXBlLCB7fSwgdGhpcy5fY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNsYXJhdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwga2xhc3MpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMuX3Jlc29sdmVkW2tsYXNzIHx8ICcnXTtcbiAgICAgICAgaWYgKCFkZWNsYXJhdGlvbnMpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGVjbGFyYXRpb25zW25hbWVdO1xuICAgIH0sXG5cbiAgICBjYXNjYWRlOiBmdW5jdGlvbihjbGFzc2VzLCBvcHRpb25zLCBnbG9iYWxUcmFucywgYW5pbWF0aW9uTG9vcCkge1xuICAgICAgICBmb3IgKHZhciBrbGFzcyBpbiB0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICAgICAgaWYgKGtsYXNzICE9PSBcIlwiICYmICFjbGFzc2VzW2tsYXNzXSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMuX3Jlc29sdmVkW2tsYXNzXSxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBkZWNsYXJhdGlvbnMudmFsdWVzKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0RlY2xhcmF0aW9uID0gdmFsdWVzW2tdO1xuICAgICAgICAgICAgICAgIHZhciBvbGRUcmFuc2l0aW9uID0gb3B0aW9ucy50cmFuc2l0aW9uID8gdGhpcy5fY2FzY2FkZWRba10gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBhIG5ldyB0cmFuc2l0aW9uIGlmIHRoZSBkZWNsYXJhdGlvbiBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYgKCFvbGRUcmFuc2l0aW9uIHx8IG9sZFRyYW5zaXRpb24uZGVjbGFyYXRpb24uanNvbiAhPT0gbmV3RGVjbGFyYXRpb24uanNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3R5bGVUcmFucyA9IGRlY2xhcmF0aW9ucy50cmFuc2l0aW9uKGssIGdsb2JhbFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1RyYW5zaXRpb24gPSB0aGlzLl9jYXNjYWRlZFtrXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgU3R5bGVUcmFuc2l0aW9uKG5ld0RlY2xhcmF0aW9uLCBvbGRUcmFuc2l0aW9uLCBuZXdTdHlsZVRyYW5zKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdGhlIGFuaW1hdGlvbiBsb29wIHVudGlsIHRoZSBlbmQgb2YgdGhlIHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdUcmFuc2l0aW9uLmluc3RhbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJhbnNpdGlvbi5sb29wSUQgPSBhbmltYXRpb25Mb29wLnNldChuZXdUcmFuc2l0aW9uLmVuZFRpbWUgLSAobmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Mb29wLmNhbmNlbChvbGRUcmFuc2l0aW9uLmxvb3BJRCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVjYWxjdWxhdGU6IGZ1bmN0aW9uKHosIHpvb21IaXN0b3J5KSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgICAgICAgY2FsY3VsYXRlZCA9IHRoaXMucGFpbnQgPSBuZXcgUGFpbnRQcm9wZXJ0aWVzW3R5cGVdKCk7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLl9jYXNjYWRlZCkge1xuICAgICAgICAgICAgY2FsY3VsYXRlZFtrXSA9IHRoaXMuX2Nhc2NhZGVkW2tdLmF0KHosIHpvb21IaXN0b3J5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGlkZGVuID0gKHRoaXMubWluem9vbSAmJiB6IDwgdGhpcy5taW56b29tKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1heHpvb20gJiYgeiA+PSB0aGlzLm1heHpvb20pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaW5jbHVkZSB2aXNpYmlsaXR5IGNoZWNrIGZvciBub24tYnVja2V0ZWQgYmFja2dyb3VuZCBsYXllcnNcbiAgICAgICAgICAgICAgICAgICAgICAodGhpcy5sYXlvdXQudmlzaWJpbGl0eSA9PT0gJ25vbmUnKTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIGlmICgoY2FsY3VsYXRlZFsndGV4dC1vcGFjaXR5J10gPT09IDAgfHwgIXRoaXMubGF5b3V0Wyd0ZXh0LWZpZWxkJ10pICYmXG4gICAgICAgICAgICAgICAgKGNhbGN1bGF0ZWRbJ2ljb24tb3BhY2l0eSddID09PSAwIHx8ICF0aGlzLmxheW91dFsnaWNvbi1pbWFnZSddKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlbXVsdGlwbHlMYXllcihjYWxjdWxhdGVkLCAndGV4dCcpO1xuICAgICAgICAgICAgICAgIHByZW11bHRpcGx5TGF5ZXIoY2FsY3VsYXRlZCwgJ2ljb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGNhbGN1bGF0ZWRbdHlwZSArICctb3BhY2l0eSddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVtdWx0aXBseUxheWVyKGNhbGN1bGF0ZWQsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2Nhc2NhZGVkWydsaW5lLWRhc2hhcnJheSddKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbGluZSBpcyBkYXNoZWQsIHNjYWxlIHRoZSBkYXNoIGxlbmd0aHMgYnkgdGhlIGxpbmVcbiAgICAgICAgICAgIC8vIHdpZHRoIGF0IHRoZSBwcmV2aW91cyByb3VuZCB6b29tIGxldmVsLlxuICAgICAgICAgICAgdmFyIGRhc2hBcnJheSA9IGNhbGN1bGF0ZWRbJ2xpbmUtZGFzaGFycmF5J107XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5fY2FzY2FkZWRbJ2xpbmUtd2lkdGgnXSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FzY2FkZWRbJ2xpbmUtd2lkdGgnXS5hdChNYXRoLmZsb29yKHopLCBJbmZpbml0eSkgOlxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRbJ2xpbmUtd2lkdGgnXTtcblxuICAgICAgICAgICAgZGFzaEFycmF5LmZyb21TY2FsZSAqPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICBkYXNoQXJyYXkudG9TY2FsZSAqPSBsaW5lV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXRoaXMuaGlkZGVuO1xuICAgIH0sXG5cbiAgICBhc3NpZ246IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhsYXllcixcbiAgICAgICAgICAgIFsndHlwZScsICdzb3VyY2UnLCAnc291cmNlLWxheWVyJyxcbiAgICAgICAgICAgICdtaW56b29tJywgJ21heHpvb20nLCAnZmlsdGVyJyxcbiAgICAgICAgICAgICdsYXlvdXQnXSkpO1xuICAgIH0sXG5cbiAgICBqc29uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHt9LFxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIsXG4gICAgICAgICAgICB1dGlsLnBpY2sodGhpcyxcbiAgICAgICAgICAgICAgICBbJ3R5cGUnLCAnc291cmNlJywgJ3NvdXJjZS1sYXllcicsXG4gICAgICAgICAgICAgICAgJ21pbnpvb20nLCAnbWF4em9vbScsICdmaWx0ZXInLFxuICAgICAgICAgICAgICAgICdsYXlvdXQnLCAncGFpbnQnXSkpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHByZW11bHRpcGx5TGF5ZXIobGF5ZXIsIHR5cGUpIHtcbiAgICB2YXIgY29sb3JQcm9wID0gdHlwZSArICctY29sb3InLFxuICAgICAgICBoYWxvUHJvcCA9IHR5cGUgKyAnLWhhbG8tY29sb3InLFxuICAgICAgICBvdXRsaW5lUHJvcCA9IHR5cGUgKyAnLW91dGxpbmUtY29sb3InLFxuICAgICAgICBjb2xvciA9IGxheWVyW2NvbG9yUHJvcF0sXG4gICAgICAgIGhhbG9Db2xvciA9IGxheWVyW2hhbG9Qcm9wXSxcbiAgICAgICAgb3V0bGluZUNvbG9yID0gbGF5ZXJbb3V0bGluZVByb3BdLFxuICAgICAgICBvcGFjaXR5ID0gbGF5ZXJbdHlwZSArICctb3BhY2l0eSddO1xuXG4gICAgdmFyIGNvbG9yT3BhY2l0eSA9IGNvbG9yICYmIChvcGFjaXR5ICogY29sb3JbM10pO1xuICAgIHZhciBoYWxvT3BhY2l0eSA9IGhhbG9Db2xvciAmJiAob3BhY2l0eSAqIGhhbG9Db2xvclszXSk7XG4gICAgdmFyIG91dGxpbmVPcGFjaXR5ID0gb3V0bGluZUNvbG9yICYmIChvcGFjaXR5ICogb3V0bGluZUNvbG9yWzNdKTtcblxuICAgIGlmIChjb2xvck9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBjb2xvck9wYWNpdHkgPCAxKSB7XG4gICAgICAgIGxheWVyW2NvbG9yUHJvcF0gPSB1dGlsLnByZW11bHRpcGx5KFtjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBjb2xvck9wYWNpdHldKTtcbiAgICB9XG4gICAgaWYgKGhhbG9PcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgaGFsb09wYWNpdHkgPCAxKSB7XG4gICAgICAgIGxheWVyW2hhbG9Qcm9wXSA9IHV0aWwucHJlbXVsdGlwbHkoW2hhbG9Db2xvclswXSwgaGFsb0NvbG9yWzFdLCBoYWxvQ29sb3JbMl0sIGhhbG9PcGFjaXR5XSk7XG4gICAgfVxuICAgIGlmIChvdXRsaW5lT3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIG91dGxpbmVPcGFjaXR5IDwgMSkge1xuICAgICAgICBsYXllcltvdXRsaW5lUHJvcF0gPSB1dGlsLnByZW11bHRpcGx5KFtvdXRsaW5lQ29sb3JbMF0sIG91dGxpbmVDb2xvclsxXSwgb3V0bGluZUNvbG9yWzJdLCBvdXRsaW5lT3BhY2l0eV0pO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvaW50ZXJwb2xhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZVRyYW5zaXRpb247XG5cbi8qXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNpdGlvbiBiZXR3ZWVuIHR3byBkZWNsYXJhdGlvbnNcbiAqL1xuZnVuY3Rpb24gU3R5bGVUcmFuc2l0aW9uKGRlY2xhcmF0aW9uLCBvbGRUcmFuc2l0aW9uLCB2YWx1ZSkge1xuXG4gICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5lbmRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIHZhciB0eXBlID0gZGVjbGFyYXRpb24udHlwZTtcbiAgICBpZiAoKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdhcnJheScpICYmIGRlY2xhcmF0aW9uLnRyYW5zaXRpb25hYmxlKSB7XG4gICAgICAgIHRoaXMuaW50ZXJwID0gaW50ZXJwWm9vbVRyYW5zaXRpb25lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludGVycCA9IGludGVycG9sYXRlW3R5cGVdO1xuICAgIH1cblxuICAgIHRoaXMub2xkVHJhbnNpdGlvbiA9IG9sZFRyYW5zaXRpb247XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZhbHVlLmR1cmF0aW9uIHx8IDA7XG4gICAgdGhpcy5kZWxheSA9IHZhbHVlLmRlbGF5IHx8IDA7XG5cbiAgICBpZiAoIXRoaXMuaW5zdGFudCgpKSB7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lICsgdGhpcy5kdXJhdGlvbiArIHRoaXMuZGVsYXk7XG4gICAgICAgIHRoaXMuZWFzZSA9IHV0aWwuZWFzZUN1YmljSW5PdXQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFRyYW5zaXRpb24gJiYgb2xkVHJhbnNpdGlvbi5lbmRUaW1lIDw9IHRoaXMuc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE9sZCB0cmFuc2l0aW9uIGlzIGRvbmUgcnVubmluZywgc28gd2UgY2FuXG4gICAgICAgIC8vIGRlbGV0ZSBpdHMgcmVmZXJlbmNlIHRvIGl0cyBvbGQgdHJhbnNpdGlvbi5cblxuICAgICAgICBkZWxldGUgb2xkVHJhbnNpdGlvbi5vbGRUcmFuc2l0aW9uO1xuICAgIH1cbn1cblxuU3R5bGVUcmFuc2l0aW9uLnByb3RvdHlwZS5pbnN0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLm9sZFRyYW5zaXRpb24gfHwgIXRoaXMuaW50ZXJwIHx8ICh0aGlzLmR1cmF0aW9uID09PSAwICYmIHRoaXMuZGVsYXkgPT09IDApO1xufTtcblxuLypcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHRyYW5zaXRpb25pbmcgcHJvcGVydHkgYXQgem9vbSBsZXZlbCBgemAgYW5kIG9wdGlvbmFsIHRpbWUgYHRgXG4gKi9cblN0eWxlVHJhbnNpdGlvbi5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbih6LCB6b29tSGlzdG9yeSwgdCkge1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5kZWNsYXJhdGlvbi5jYWxjdWxhdGUoeiwgem9vbUhpc3RvcnksIHRoaXMuZHVyYXRpb24pO1xuXG4gICAgaWYgKHRoaXMuaW5zdGFudCgpKSByZXR1cm4gdmFsdWU7XG5cbiAgICB0ID0gdCB8fCBEYXRlLm5vdygpO1xuXG4gICAgaWYgKHQgPCB0aGlzLmVuZFRpbWUpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5vbGRUcmFuc2l0aW9uLmF0KHosIHpvb21IaXN0b3J5LCB0aGlzLnN0YXJ0VGltZSk7XG4gICAgICAgIHZhciBlYXNlZCA9IHRoaXMuZWFzZSgodCAtIHRoaXMuc3RhcnRUaW1lIC0gdGhpcy5kZWxheSkgLyB0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmludGVycChvbGRWYWx1ZSwgdmFsdWUsIGVhc2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG5cbn07XG5cbmZ1bmN0aW9uIGludGVycFpvb21UcmFuc2l0aW9uZWQoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBmcm9tLnRvLFxuICAgICAgICBmcm9tU2NhbGU6IGZyb20udG9TY2FsZSxcbiAgICAgICAgdG86IHRvLnRvLFxuICAgICAgICB0b1NjYWxlOiB0by50b1NjYWxlLFxuICAgICAgICB0OiB0XG4gICAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmNob3I7XG5cbmZ1bmN0aW9uIEFuY2hvcih4LCB5LCBhbmdsZSwgc2VnbWVudCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmFuZ2xlID0gYW5nbGU7XG5cbiAgICBpZiAoc2VnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxufVxuXG5BbmNob3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQb2ludC5wcm90b3R5cGUpO1xuXG5BbmNob3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBBbmNob3IodGhpcy54LCB0aGlzLnksIHRoaXMuYW5nbGUsIHRoaXMuc2VnbWVudCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpblBhY2s7XG5mdW5jdGlvbiBCaW5QYWNrKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5mcmVlID0gW3sgeDogMCwgeTogMCwgdzogd2lkdGgsIGg6IGhlaWdodCB9XTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgYWxnb3JpdGhtIHRvIHJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBuZXdseSByZWxlYXNlZCBjZWxsIHdpdGggaXRzXG4gKiBuZWlnaGJvci4gVGhpcyBkb2Vzbid0IG1lcmdlIG1vcmUgdGhhbiB0d28gY2VsbHMgYXQgYSB0aW1lLCBhbmQgZmFpbHNcbiAqIGZvciBjb21wbGljYXRlZCBtZXJnZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5CaW5QYWNrLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24ocmVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmcmVlID0gdGhpcy5mcmVlW2ldO1xuXG4gICAgICAgIGlmIChmcmVlLnkgPT09IHJlY3QueSAmJiBmcmVlLmggPT09IHJlY3QuaCAmJiBmcmVlLnggKyBmcmVlLncgPT09IHJlY3QueCkge1xuICAgICAgICAgICAgZnJlZS53ICs9IHJlY3QudztcblxuICAgICAgICB9IGVsc2UgaWYgKGZyZWUueCA9PT0gcmVjdC54ICYmIGZyZWUudyA9PT0gcmVjdC53ICYmIGZyZWUueSArIGZyZWUuaCA9PT0gcmVjdC55KSB7XG4gICAgICAgICAgICBmcmVlLmggKz0gcmVjdC5oO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjdC55ID09PSBmcmVlLnkgJiYgcmVjdC5oID09PSBmcmVlLmggJiYgcmVjdC54ICsgcmVjdC53ID09PSBmcmVlLngpIHtcbiAgICAgICAgICAgIGZyZWUueCA9IHJlY3QueDtcbiAgICAgICAgICAgIGZyZWUudyArPSByZWN0Lnc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWN0LnggPT09IGZyZWUueCAmJiByZWN0LncgPT09IGZyZWUudyAmJiByZWN0LnkgKyByZWN0LmggPT09IGZyZWUueSkge1xuICAgICAgICAgICAgZnJlZS55ID0gcmVjdC55O1xuICAgICAgICAgICAgZnJlZS5oICs9IHJlY3QuaDtcblxuICAgICAgICB9IGVsc2UgY29udGludWU7XG5cbiAgICAgICAgdGhpcy5mcmVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5yZWxlYXNlKGZyZWUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICB9XG4gICAgdGhpcy5mcmVlLnB1c2gocmVjdCk7XG59O1xuXG5CaW5QYWNrLnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBGaW5kIHRoZSBzbWFsbGVzdCBmcmVlIHJlY3QgYW5nbGVcbiAgICB2YXIgcmVjdCA9IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB3OiBJbmZpbml0eSwgaDogSW5maW5pdHkgfTtcbiAgICB2YXIgc21hbGxlc3QgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5mcmVlW2ldO1xuICAgICAgICBpZiAod2lkdGggPD0gcmVmLncgJiYgaGVpZ2h0IDw9IHJlZi5oICYmIHJlZi55IDw9IHJlY3QueSAmJiByZWYueCA8PSByZWN0LngpIHtcbiAgICAgICAgICAgIHJlY3QgPSByZWY7XG4gICAgICAgICAgICBzbWFsbGVzdCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc21hbGxlc3QgPCAwKSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gc3BhY2UgbGVmdCBmb3IgdGhpcyBjaGFyLlxuICAgICAgICByZXR1cm4geyB4OiAtMSwgeTogLTEgfTtcbiAgICB9XG5cbiAgICB0aGlzLmZyZWUuc3BsaWNlKHNtYWxsZXN0LCAxKTtcblxuICAgIC8vIFNob3J0ZXIvTG9uZ2VyIEF4aXMgU3BsaXQgUnVsZSAoU0FTKVxuICAgIC8vIGh0dHA6Ly9jbGIuZGVtb24uZmkvZmlsZXMvUmVjdGFuZ2xlQmluUGFjay5wZGYgcC4gMTVcbiAgICAvLyBJZ25vcmUgdGhlIGRpbWVuc2lvbiBvZiBSIGFuZCBqdXN0IHNwbGl0IGxvbmcgdGhlIHNob3J0ZXIgZGltZW5zaW9uXG4gICAgLy8gU2VlIEFsc286IGh0dHA6Ly93d3cuY3MucHJpbmNldG9uLmVkdS9+Y2hhemVsbGUvcHVicy9ibGJpbnBhY2tpbmcucGRmXG4gICAgaWYgKHJlY3QudyA8IHJlY3QuaCkge1xuICAgICAgICAvLyBzcGxpdCBob3Jpem9udGFsbHlcbiAgICAgICAgLy8gKy0tKy0tLStcbiAgICAgICAgLy8gfF9ffF9fX3wgIDwtLSBiMVxuICAgICAgICAvLyArLS0tLS0tKyAgPC0tIGIyXG4gICAgICAgIGlmIChyZWN0LncgPiB3aWR0aCkgdGhpcy5mcmVlLnB1c2goeyB4OiByZWN0LnggKyB3aWR0aCwgeTogcmVjdC55LCB3OiByZWN0LncgLSB3aWR0aCwgaDogaGVpZ2h0IH0pO1xuICAgICAgICBpZiAocmVjdC5oID4gaGVpZ2h0KSB0aGlzLmZyZWUucHVzaCh7IHg6IHJlY3QueCwgeTogcmVjdC55ICsgaGVpZ2h0LCB3OiByZWN0LncsIGg6IHJlY3QuaCAtIGhlaWdodCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzcGxpdCB2ZXJ0aWNhbGx5XG4gICAgICAgIC8vICstLSstLS0rXG4gICAgICAgIC8vIHxfX3wgICB8IDwtLSBiMVxuICAgICAgICAvLyArLS18LS0tKyA8LS0gYjJcbiAgICAgICAgaWYgKHJlY3QudyA+IHdpZHRoKSB0aGlzLmZyZWUucHVzaCh7IHg6IHJlY3QueCArIHdpZHRoLCB5OiByZWN0LnksIHc6IHJlY3QudyAtIHdpZHRoLCBoOiByZWN0LmggfSk7XG4gICAgICAgIGlmIChyZWN0LmggPiBoZWlnaHQpIHRoaXMuZnJlZS5wdXNoKHsgeDogcmVjdC54LCB5OiByZWN0LnkgKyBoZWlnaHQsIHc6IHdpZHRoLCBoOiByZWN0LmggLSBoZWlnaHQgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgeDogcmVjdC54LCB5OiByZWN0LnksIHc6IHdpZHRoLCBoOiBoZWlnaHQgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tNYXhBbmdsZTtcblxuLyoqXG4gKiBMYWJlbHMgcGxhY2VkIGFyb3VuZCByZWFsbHkgc2hhcnAgYW5nbGVzIGFyZW4ndCByZWFkYWJsZS4gQ2hlY2sgaWYgYW55XG4gKiBwYXJ0IG9mIHRoZSBwb3RlbnRpYWwgbGFiZWwgaGFzIGEgY29tYmluZWQgYW5nbGUgdGhhdCBpcyB0b28gYmlnLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBsaW5lXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yIFRoZSBwb2ludCBvbiB0aGUgbGluZSBhcm91bmQgd2hpY2ggdGhlIGxhYmVsIGlzIGFuY2hvcmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsTGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIGxhYmVsIGluIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpbmRvd1NpemUgVGhlIGNoZWNrIGZhaWxzIGlmIHRoZSBjb21iaW5lZCBhbmdsZXMgd2l0aGluIGEgcGFydCBvZiB0aGUgbGluZSB0aGF0IGlzIGB3aW5kb3dTaXplYCBsb25nIGlzIHRvbyBiaWcuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4QW5nbGUgVGhlIG1heGltdW0gY29tYmluZWQgYW5nbGUgdGhhdCBhbnkgd2luZG93IGFsb25nIHRoZSBsYWJlbCBpcyBhbGxvd2VkIHRvIGhhdmUuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBiZSBwbGFjZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrTWF4QW5nbGUobGluZSwgYW5jaG9yLCBsYWJlbExlbmd0aCwgd2luZG93U2l6ZSwgbWF4QW5nbGUpIHtcblxuICAgIC8vIGhvcml6b250YWwgbGFiZWxzIGFsd2F5cyBwYXNzXG4gICAgaWYgKGFuY2hvci5zZWdtZW50ID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIHAgPSBhbmNob3I7XG4gICAgdmFyIGluZGV4ID0gYW5jaG9yLnNlZ21lbnQgKyAxO1xuICAgIHZhciBhbmNob3JEaXN0YW5jZSA9IDA7XG5cbiAgICAvLyBtb3ZlIGJhY2t3YXJkcyBhbG9uZyB0aGUgbGluZSB0byB0aGUgZmlyc3Qgc2VnbWVudCB0aGUgbGFiZWwgYXBwZWFycyBvblxuICAgIHdoaWxlIChhbmNob3JEaXN0YW5jZSA+IC1sYWJlbExlbmd0aCAvIDIpIHtcbiAgICAgICAgaW5kZXgtLTtcblxuICAgICAgICAvLyB0aGVyZSBpc24ndCBlbm91Z2ggcm9vbSBmb3IgdGhlIGxhYmVsIGFmdGVyIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGFuY2hvckRpc3RhbmNlIC09IGxpbmVbaW5kZXhdLmRpc3QocCk7XG4gICAgICAgIHAgPSBsaW5lW2luZGV4XTtcbiAgICB9XG5cbiAgICBhbmNob3JEaXN0YW5jZSArPSBsaW5lW2luZGV4XS5kaXN0KGxpbmVbaW5kZXggKyAxXSk7XG4gICAgaW5kZXgrKztcblxuICAgIC8vIHN0b3JlIHJlY2VudCBjb3JuZXJzIGFuZCB0aGVpciB0b3RhbCBhbmdsZSBkaWZmZXJlbmNlXG4gICAgdmFyIHJlY2VudENvcm5lcnMgPSBbXTtcbiAgICB2YXIgcmVjZW50QW5nbGVEZWx0YSA9IDA7XG5cbiAgICAvLyBtb3ZlIGZvcndhcmRzIGJ5IHRoZSBsZW5ndGggb2YgdGhlIGxhYmVsIGFuZCBjaGVjayBhbmdsZXMgYWxvbmcgdGhlIHdheVxuICAgIHdoaWxlIChhbmNob3JEaXN0YW5jZSA8IGxhYmVsTGVuZ3RoIC8gMikge1xuICAgICAgICB2YXIgcHJldiA9IGxpbmVbaW5kZXggLSAxXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBsaW5lW2luZGV4XTtcbiAgICAgICAgdmFyIG5leHQgPSBsaW5lW2luZGV4ICsgMV07XG5cbiAgICAgICAgLy8gdGhlcmUgaXNuJ3QgZW5vdWdoIHJvb20gZm9yIHRoZSBsYWJlbCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICBpZiAoIW5leHQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgYW5nbGVEZWx0YSA9IHByZXYuYW5nbGVUbyhjdXJyZW50KSAtIGN1cnJlbnQuYW5nbGVUbyhuZXh0KTtcbiAgICAgICAgLy8gcmVzdHJpY3QgYW5nbGUgdG8gLXBpLi5waSByYW5nZVxuICAgICAgICBhbmdsZURlbHRhID0gKChhbmdsZURlbHRhICsgMyAqIE1hdGguUEkpICUgKE1hdGguUEkgKiAyKSkgLSBNYXRoLlBJO1xuXG4gICAgICAgIHJlY2VudENvcm5lcnMucHVzaCh7XG4gICAgICAgICAgICBkaXN0YW5jZTogYW5jaG9yRGlzdGFuY2UsXG4gICAgICAgICAgICBhbmdsZURlbHRhOiBhbmdsZURlbHRhXG4gICAgICAgIH0pO1xuICAgICAgICByZWNlbnRBbmdsZURlbHRhICs9IGFuZ2xlRGVsdGE7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNvcm5lcnMgdGhhdCBhcmUgZmFyIGVub3VnaCBhd2F5IGZyb20gdGhlIGxpc3Qgb2YgcmVjZW50IGFuY2hvcnNcbiAgICAgICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlIC0gcmVjZW50Q29ybmVyc1swXS5kaXN0YW5jZSA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHJlY2VudEFuZ2xlRGVsdGEgLT0gcmVjZW50Q29ybmVycy5zaGlmdCgpLmFuZ2xlRGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgc3VtIG9mIGFuZ2xlcyB3aXRoaW4gdGhlIHdpbmRvdyBhcmVhIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS4gY2hlY2sgZmFpbHMuXG4gICAgICAgIGlmIChNYXRoLmFicyhyZWNlbnRBbmdsZURlbHRhKSA+IG1heEFuZ2xlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgYW5jaG9yRGlzdGFuY2UgKz0gY3VycmVudC5kaXN0KG5leHQpO1xuICAgIH1cblxuICAgIC8vIG5vIHBhcnQgb2YgdGhlIGxpbmUgaGFkIGFuIGFuZ2xlIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkLiBjaGVjayBwYXNzZXMuXG4gICAgcmV0dXJuIHRydWU7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xpcExpbmU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFydCBvZiBhIG11bHRpbGluZSB0aGF0IGludGVyc2VjdHMgd2l0aCB0aGUgcHJvdmlkZWQgcmVjdGFuZ3VsYXIgYm94LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8UG9pbnQ+Pn0gbGluZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSB0aGUgbGVmdCBlZGdlIG9mIHRoZSBib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgyIHRoZSByaWdodCBlZGdlIG9mIHRoZSBib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGJveFxuICogQHJldHVybnMge0FycmF5PEFycmF5PFBvaW50Pj59IGxpbmVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGlwTGluZShsaW5lcywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgY2xpcHBlZExpbmVzID0gW107XG5cbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbbF07XG4gICAgICAgIHZhciBjbGlwcGVkTGluZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcDAgPSBsaW5lW2ldO1xuICAgICAgICAgICAgdmFyIHAxID0gbGluZVtpICsgMV07XG5cblxuICAgICAgICAgICAgaWYgKHAwLnggPCB4MSAmJiBwMS54IDwgeDEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDAueCA8IHgxKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBuZXcgUG9pbnQoeDEsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MSAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMS54IDwgeDEpIHtcbiAgICAgICAgICAgICAgICBwMSA9IG5ldyBQb2ludCh4MSwgcDAueSArIChwMS55IC0gcDAueSkgKiAoKHgxIC0gcDAueCkgLyAocDEueCAtIHAwLngpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwMC55IDwgeTEgJiYgcDEueSA8IHkxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAwLnkgPCB5MSkge1xuICAgICAgICAgICAgICAgIHAwID0gbmV3IFBvaW50KHAwLnggKyAocDEueCAtIHAwLngpICogKCh5MSAtIHAwLnkpIC8gKHAxLnkgLSBwMC55KSksIHkxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDEueSA8IHkxKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQocDAueCArIChwMS54IC0gcDAueCkgKiAoKHkxIC0gcDAueSkgLyAocDEueSAtIHAwLnkpKSwgeTEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocDAueCA+PSB4MiAmJiBwMS54ID49IHgyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAwLnggPj0geDIpIHtcbiAgICAgICAgICAgICAgICBwMCA9IG5ldyBQb2ludCh4MiwgcDAueSArIChwMS55IC0gcDAueSkgKiAoKHgyIC0gcDAueCkgLyAocDEueCAtIHAwLngpKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxLnggPj0geDIpIHtcbiAgICAgICAgICAgICAgICBwMSA9IG5ldyBQb2ludCh4MiwgcDAueSArIChwMS55IC0gcDAueSkgKiAoKHgyIC0gcDAueCkgLyAocDEueCAtIHAwLngpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwMC55ID49IHkyICYmIHAxLnkgPj0geTIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDAueSA+PSB5Mikge1xuICAgICAgICAgICAgICAgIHAwID0gbmV3IFBvaW50KHAwLnggKyAocDEueCAtIHAwLngpICogKCh5MiAtIHAwLnkpIC8gKHAxLnkgLSBwMC55KSksIHkyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDEueSA+PSB5Mikge1xuICAgICAgICAgICAgICAgIHAxID0gbmV3IFBvaW50KHAwLnggKyAocDEueCAtIHAwLngpICogKCh5MiAtIHAwLnkpIC8gKHAxLnkgLSBwMC55KSksIHkyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjbGlwcGVkTGluZSB8fCAhcDAuZXF1YWxzKGNsaXBwZWRMaW5lW2NsaXBwZWRMaW5lLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgICAgIGNsaXBwZWRMaW5lID0gW3AwXTtcbiAgICAgICAgICAgICAgICBjbGlwcGVkTGluZXMucHVzaChjbGlwcGVkTGluZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsaXBwZWRMaW5lLnB1c2gocDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBwZWRMaW5lcztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaXNpb25Cb3g7XG5cbi8qKlxuICogQSBjb2xsaXNpb24gYm94IHJlcHJlc2VudHMgYW4gYXJlYSBvZiB0aGUgbWFwIHRoYXQgdGhhdCBpcyBjb3ZlcmVkIGJ5IGFcbiAqIGxhYmVsLiBDb2xsaXNpb25GZWF0dXJlIHVzZXMgb25lIG9yIG1vcmUgb2YgdGhlc2UgY29sbGlzaW9uIGJveGVzIHRvXG4gKiByZXByZXNlbnQgYWxsIHRoZSBhcmVhIGNvdmVyZWQgYnkgYSBzaW5nbGUgbGFiZWwuIFRoZXkgYXJlIHVzZWQgdG9cbiAqIHByZXZlbnQgY29sbGlzaW9ucyBiZXR3ZWVuIGxhYmVscy5cbiAqXG4gKiBBIGNvbGxpc2lvbiBib3ggYWN0dWFsbHkgcmVwcmVzZW50cyBhIDNkIHZvbHVtZS4gVGhlIGZpcnN0IHR3byBkaW1lbnNpb25zLFxuICogeCBhbmQgeSwgYXJlIHNwZWNpZmllZCB3aXRoIGBhbmNob3JgIGFsb25nIHdpdGggYHgxYCwgYHkxYCwgYHgyYCwgYHkyYC5cbiAqIFRoZSB0aGlyZCBkaW1lbnNpb24sIHpvb20sIGlzIGxpbWl0ZWQgYnkgYG1heFNjYWxlYCB3aGljaCBkZXRlcm1pbmVzXG4gKiBob3cgZmFyIGluIHRoZSB6IGRpbWVuc2lvbnMgdGhlIGJveCBleHRlbmRzLlxuICpcbiAqIEFzIHlvdSB6b29tIGluIG9uIGEgbWFwLCBhbGwgcG9pbnRzIG9uIHRoZSBtYXAgZ2V0IGZ1cnRoZXIgYW5kIGZ1cnRoZXIgYXBhcnRcbiAqIGJ1dCBsYWJlbHMgc3RheSByb3VnaGx5IHRoZSBzYW1lIHNpemUuIExhYmVscyBjb3ZlciBsZXNzIHJlYWwgd29ybGQgYXJlYSBvblxuICogdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMgdGhhbiB0aGV5IGRvIGF0IGxvd2VyIHpvb20gbGV2ZWxzLiBUaGlzIGlzIHdoeVxuICogYXJlYXMgYXJlIGFyZSByZXByZXNlbnRlZCB3aXRoIGFuIGFuY2hvciBwb2ludCBhbmQgb2Zmc2V0cyBmcm9tIHRoYXQgcG9pbnRcbiAqIGluc3RlYWQgb2YganVzdCB1c2luZyBmb3VyIGFic29sdXRlIHBvaW50cy5cbiAqXG4gKiBMaW5lIGxhYmVscyBhcmUgcmVwcmVzZW50ZWQgYnkgYSBzZXQgb2YgdGhlc2UgYm94ZXMgc3BhY2VkIG91dCBhbG9uZyBhIGxpbmUuXG4gKiBXaGVuIHlvdSB6b29tIGluLCBsaW5lIGxhYmVscyBjb3ZlciBsZXNzIHJlYWwgd29ybGQgZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmVcbiAqIHRoYW4gdGhleSB1c2VkIHRvLiBDb2xsaXNpb24gYm94ZXMgbmVhciB0aGUgZWRnZXMgdGhhdCB1c2VkIHRvIGNvdmVyIGxhYmVsXG4gKiBubyBsb25nZXIgZG8uIElmIGEgYm94IGRvZXNuJ3QgY292ZXIgdGhlIGxhYmVsIGFueW1vcmUgaXQgc2hvdWxkIGJlIGlnbm9yZWRcbiAqIHdoZW4gZG9pbmcgY29sbGlzaW9uIGNoZWNrcy4gYG1heFNjYWxlYCBpcyBob3cgbXVjaCB5b3UgY2FuIHNjYWxlIHRoZSBtYXBcbiAqIGJlZm9yZSB0aGUgbGFiZWwgaXNuJ3Qgd2l0aGluIHRoZSBib3ggYW55bW9yZS5cbiAqIEZvciBleGFtcGxlXG4gKiBsb3dlciB6b29tOlxuICogaHR0cHM6Ly9jbG91ZC5naXRodWJ1c2VyY29udGVudC5jb20vYXNzZXRzLzE0MjE2NTIvODA2MDA5NC80ZDk3NWY3Ni0wZTkxLTExZTUtODRiMS00ZWRlYjMwYTU4NzUucG5nXG4gKiBzbGlnaHRseSBoaWdoZXIgem9vbTpcbiAqIGh0dHBzOi8vY2xvdWQuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fzc2V0cy8xNDIxNjUyLzgwNjAwNjEvMjZhZTFjMzgtMGU5MS0xMWU1LThjNWEtOWYzODBiZjI5ZjBhLnBuZ1xuICogSW4gdGhlIHpvb21lZCBpbiBpbWFnZSB0aGUgdHdvIGdyZXkgYm94ZXMgb24gZWl0aGVyIHNpZGUgZG9uJ3QgY292ZXIgdGhlXG4gKiBsYWJlbCBhbnltb3JlLiBUaGVpciBtYXhTY2FsZSBpcyBzbWFsbGVyIHRoYW4gdGhlIGN1cnJlbnQgc2NhbGUuXG4gKlxuICpcbiAqIEBjbGFzcyBDb2xsaXNpb25Cb3hcbiAqIEBwYXJhbSB7UG9pbnR9IGFuY2hvclBvaW50IFRoZSBhbmNob3IgcG9pbnQgdGhlIGJveCBpcyBjZW50ZXJlZCBhcm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgVGhlIGRpc3RhbmNlIGZyb20gdGhlIGFuY2hvciB0byB0aGUgbGVmdCBlZGdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkxIFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBhbmNob3IgdG8gdGhlIHRvcCBlZGdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHgyIFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBhbmNob3IgdG8gdGhlIHJpZ2h0IGVkZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgVGhlIGRpc3RhbmNlIGZyb20gdGhlIGFuY2hvciB0byB0aGUgYm90dG9tIGVkZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4U2NhbGUgVGhlIG1heGltdW0gc2NhbGUgdGhpcyBib3ggY2FuIGJsb2NrIG90aGVyIGJveGVzIGF0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29sbGlzaW9uQm94KGFuY2hvclBvaW50LCB4MSwgeTEsIHgyLCB5MiwgbWF4U2NhbGUpIHtcbiAgICAvLyB0aGUgYm94IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYW5jaG9yIHBvaW50XG4gICAgdGhpcy5hbmNob3JQb2ludCA9IGFuY2hvclBvaW50O1xuXG4gICAgLy8gZGlzdGFuY2VzIHRvIHRoZSBlZGdlcyBmcm9tIHRoZSBhbmNob3JcbiAgICB0aGlzLngxID0geDE7XG4gICAgdGhpcy55MSA9IHkxO1xuICAgIHRoaXMueDIgPSB4MjtcbiAgICB0aGlzLnkyID0geTI7XG5cbiAgICAvLyB0aGUgYm94IGlzIG9ubHkgdmFsaWQgZm9yIHNjYWxlcyA8IG1heFNjYWxlLlxuICAgIC8vIFRoZSBib3ggZG9lcyBub3QgYmxvY2sgb3RoZXIgYm94ZXMgYXQgc2NhbGVzID49IG1heFNjYWxlO1xuICAgIHRoaXMubWF4U2NhbGUgPSBtYXhTY2FsZTtcblxuICAgIC8vIHRoZSBzY2FsZSBhdCB3aGljaCB0aGUgbGFiZWwgY2FuIGZpcnN0IGJlIHNob3duXG4gICAgdGhpcy5wbGFjZW1lbnRTY2FsZSA9IDA7XG5cbiAgICAvLyByb3RhdGVkIGFuZCBzY2FsZWQgYmJveCB1c2VkIGZvciBpbmRleGluZ1xuICAgIHRoaXNbMF0gPSB0aGlzWzFdID0gdGhpc1syXSA9IHRoaXNbM10gPSAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29sbGlzaW9uQm94ID0gcmVxdWlyZSgnLi9jb2xsaXNpb25fYm94Jyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvbkZlYXR1cmU7XG5cbi8qKlxuICogQSBDb2xsaXNpb25GZWF0dXJlIHJlcHJlc2VudHMgdGhlIGFyZWEgb2YgdGhlIHRpbGUgY292ZXJlZCBieSBhIHNpbmdsZSBsYWJlbC5cbiAqIEl0IGlzIHVzZWQgd2l0aCBDb2xsaXNpb25UaWxlIHRvIGNoZWNrIGlmIHRoZSBsYWJlbCBvdmVybGFwcyB3aXRoIGFueVxuICogcHJldmlvdXMgbGFiZWxzLiBBIENvbGxpc2lvbkZlYXR1cmUgaXMgbW9zdGx5IGp1c3QgYSBzZXQgb2YgQ29sbGlzaW9uQm94XG4gKiBvYmplY3RzLlxuICpcbiAqIEBjbGFzcyBDb2xsaXNpb25GZWF0dXJlXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gbGluZSBUaGUgZ2VvbWV0cnkgdGhlIGxhYmVsIGlzIHBsYWNlZCBvbi5cbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3IgVGhlIHBvaW50IGFsb25nIHRoZSBsaW5lIGFyb3VuZCB3aGljaCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gc2hhcGVkIFRoZSB0ZXh0IG9yIGljb24gc2hhcGluZyByZXN1bHRzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJveFNjYWxlIEEgbWFnaWMgbnVtYmVyIHVzZWQgdG8gY29udmVydCBmcm9tIGdseXBoIG1ldHJpY3MgdW5pdHMgdG8gZ2VvbWV0cnkgdW5pdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyBUaGUgYW1vdW50IG9mIHBhZGRpbmcgdG8gYWRkIGFyb3VuZCB0aGUgbGFiZWwgZWRnZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsaWduTGluZSBXaGV0aGVyIHRoZSBsYWJlbCBpcyBhbGlnbmVkIHdpdGggdGhlIGxpbmUgb3IgdGhlIHZpZXdwb3J0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENvbGxpc2lvbkZlYXR1cmUobGluZSwgYW5jaG9yLCBzaGFwZWQsIGJveFNjYWxlLCBwYWRkaW5nLCBhbGlnbkxpbmUpIHtcblxuICAgIHZhciB5MSA9IHNoYXBlZC50b3AgKiBib3hTY2FsZSAtIHBhZGRpbmc7XG4gICAgdmFyIHkyID0gc2hhcGVkLmJvdHRvbSAqIGJveFNjYWxlICsgcGFkZGluZztcbiAgICB2YXIgeDEgPSBzaGFwZWQubGVmdCAqIGJveFNjYWxlIC0gcGFkZGluZztcbiAgICB2YXIgeDIgPSBzaGFwZWQucmlnaHQgKiBib3hTY2FsZSArIHBhZGRpbmc7XG5cbiAgICB0aGlzLmJveGVzID0gW107XG5cbiAgICBpZiAoYWxpZ25MaW5lKSB7XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHkyIC0geTE7XG4gICAgICAgIHZhciBsZW5ndGggPSB4MiAtIHgxO1xuXG4gICAgICAgIGlmIChoZWlnaHQgPD0gMCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHNldCBtaW5pbXVtIGJveCBoZWlnaHQgdG8gYXZvaWQgdmVyeSBtYW55IHNtYWxsIGxhYmVsc1xuICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgxMCAqIGJveFNjYWxlLCBoZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuX2FkZExpbmVDb2xsaXNpb25Cb3hlcyhsaW5lLCBhbmNob3IsIGxlbmd0aCwgaGVpZ2h0KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm94ZXMucHVzaChuZXcgQ29sbGlzaW9uQm94KG5ldyBQb2ludChhbmNob3IueCwgYW5jaG9yLnkpLCB4MSwgeTEsIHgyLCB5MiwgSW5maW5pdHkpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2V0IG9mIENvbGxpc2lvbkJveCBvYmplY3RzIGZvciBhIGxpbmUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmVcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbExlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBsYWJlbCBpbiBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3hTaXplIFRoZSBzaXplIG9mIHRoZSBjb2xsaXNpb24gYm94ZXMgdGhhdCB3aWxsIGJlIGNyZWF0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ29sbGlzaW9uRmVhdHVyZS5wcm90b3R5cGUuX2FkZExpbmVDb2xsaXNpb25Cb3hlcyA9IGZ1bmN0aW9uKGxpbmUsIGFuY2hvciwgbGFiZWxMZW5ndGgsIGJveFNpemUpIHtcbiAgICB2YXIgc3RlcCA9IGJveFNpemUgLyAyO1xuICAgIHZhciBuQm94ZXMgPSBNYXRoLmZsb29yKGxhYmVsTGVuZ3RoIC8gc3RlcCk7XG5cbiAgICAvLyBvZmZzZXQgdGhlIGNlbnRlciBvZiB0aGUgZmlyc3QgYm94IGJ5IGhhbGYgYSBib3ggc28gdGhhdCB0aGUgZWRnZSBvZiB0aGVcbiAgICAvLyBib3ggaXMgYXQgdGhlIGVkZ2Ugb2YgdGhlIGxhYmVsLlxuICAgIHZhciBmaXJzdEJveE9mZnNldCA9IC1ib3hTaXplIC8gMjtcblxuICAgIHZhciBiYm94ZXMgPSB0aGlzLmJveGVzO1xuXG4gICAgdmFyIHAgPSBhbmNob3I7XG4gICAgdmFyIGluZGV4ID0gYW5jaG9yLnNlZ21lbnQgKyAxO1xuICAgIHZhciBhbmNob3JEaXN0YW5jZSA9IGZpcnN0Qm94T2Zmc2V0O1xuXG4gICAgLy8gbW92ZSBiYWNrd2FyZHMgYWxvbmcgdGhlIGxpbmUgdG8gdGhlIGZpcnN0IHNlZ21lbnQgdGhlIGxhYmVsIGFwcGVhcnMgb25cbiAgICBkbyB7XG4gICAgICAgIGluZGV4LS07XG5cbiAgICAgICAgLy8gdGhlcmUgaXNuJ3QgZW5vdWdoIHJvb20gZm9yIHRoZSBsYWJlbCBhZnRlciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAgIC8vIGNoZWNrTWF4QW5nbGUgc2hvdWxkIGhhdmUgYWxyZWFkeSBjYXVnaHQgdGhpc1xuICAgICAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gYmJveGVzO1xuXG4gICAgICAgIGFuY2hvckRpc3RhbmNlIC09IGxpbmVbaW5kZXhdLmRpc3QocCk7XG4gICAgICAgIHAgPSBsaW5lW2luZGV4XTtcbiAgICB9IHdoaWxlIChhbmNob3JEaXN0YW5jZSA+IC1sYWJlbExlbmd0aCAvIDIpO1xuXG4gICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsaW5lW2luZGV4XS5kaXN0KGxpbmVbaW5kZXggKyAxXSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Cb3hlczsgaSsrKSB7XG4gICAgICAgIC8vIHRoZSBkaXN0YW5jZSB0aGUgYm94IHdpbGwgYmUgZnJvbSB0aGUgYW5jaG9yXG4gICAgICAgIHZhciBib3hEaXN0YW5jZVRvQW5jaG9yID0gLWxhYmVsTGVuZ3RoIC8gMiArIGkgKiBzdGVwO1xuXG4gICAgICAgIC8vIHRoZSBib3ggaXMgbm90IG9uIHRoZSBjdXJyZW50IHNlZ21lbnQuIE1vdmUgdG8gdGhlIG5leHQgc2VnbWVudC5cbiAgICAgICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlICsgc2VnbWVudExlbmd0aCA8IGJveERpc3RhbmNlVG9BbmNob3IpIHtcbiAgICAgICAgICAgIGFuY2hvckRpc3RhbmNlICs9IHNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgICAgICAvLyBUaGVyZSBpc24ndCBlbm91Z2ggcm9vbSBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAgICAgICAgIGlmIChpbmRleCArIDEgPj0gbGluZS5sZW5ndGgpIHJldHVybiBiYm94ZXM7XG5cbiAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggPSBsaW5lW2luZGV4XS5kaXN0KGxpbmVbaW5kZXggKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZGlzdGFuY2UgdGhlIGJveCB3aWxsIGJlIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2VnbWVudFxuICAgICAgICB2YXIgc2VnbWVudEJveERpc3RhbmNlID0gYm94RGlzdGFuY2VUb0FuY2hvciAtIGFuY2hvckRpc3RhbmNlO1xuXG4gICAgICAgIHZhciBwMCA9IGxpbmVbaW5kZXhdO1xuICAgICAgICB2YXIgcDEgPSBsaW5lW2luZGV4ICsgMV07XG4gICAgICAgIHZhciBib3hBbmNob3JQb2ludCA9IHAxLnN1YihwMCkuX3VuaXQoKS5fbXVsdChzZWdtZW50Qm94RGlzdGFuY2UpLl9hZGQocDApO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZVRvSW5uZXJFZGdlID0gTWF0aC5tYXgoTWF0aC5hYnMoYm94RGlzdGFuY2VUb0FuY2hvciAtIGZpcnN0Qm94T2Zmc2V0KSAtIHN0ZXAgLyAyLCAwKTtcbiAgICAgICAgdmFyIG1heFNjYWxlID0gbGFiZWxMZW5ndGggLyAyIC8gZGlzdGFuY2VUb0lubmVyRWRnZTtcblxuICAgICAgICBiYm94ZXMucHVzaChuZXcgQ29sbGlzaW9uQm94KGJveEFuY2hvclBvaW50LCAtYm94U2l6ZSAvIDIsIC1ib3hTaXplIC8gMiwgYm94U2l6ZSAvIDIsIGJveFNpemUgLyAyLCBtYXhTY2FsZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBiYm94ZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvblRpbGU7XG5cbi8qKlxuICogQSBjb2xsaXNpb24gdGlsZSB1c2VkIHRvIHByZXZlbnQgc3ltYm9scyBmcm9tIG92ZXJsYXBwaW5nLiBJdCBrZWVwIHRyYWNrcyBvZlxuICogd2hlcmUgcHJldmlvdXMgc3ltYm9scyBoYXZlIGJlZW4gcGxhY2VkIGFuZCBpcyB1c2VkIHRvIGNoZWNrIGlmIGEgbmV3XG4gKiBzeW1ib2wgb3ZlcmxhcHMgd2l0aCBhbnkgcHJldmlvdXNseSBhZGRlZCBzeW1ib2xzLlxuICpcbiAqIEBjbGFzcyBDb2xsaXNpb25UaWxlXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXRjaFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29sbGlzaW9uVGlsZShhbmdsZSwgcGl0Y2gpIHtcbiAgICB0aGlzLnRyZWUgPSByYnVzaCgpO1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcblxuICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB0aGlzLnJvdGF0aW9uTWF0cml4ID0gW2NvcywgLXNpbiwgc2luLCBjb3NdO1xuXG4gICAgLy8gU3RyZXRjaCBib3hlcyBpbiB5IGRpcmVjdGlvbiB0byBhY2NvdW50IGZvciB0aGUgbWFwIHRpbHQuXG4gICAgdGhpcy55U3RyZXRjaCA9IDEgLyBNYXRoLmNvcyhwaXRjaCAvIDE4MCAqIE1hdGguUEkpO1xuXG4gICAgLy8gVGhlIGFtb3VudCB0aGUgbWFwIGlzIHNxdWlzaGVkIGRlcGVuZHMgb24gdGhlIHkgcG9zaXRpb24uXG4gICAgLy8gU29ydCBvZiBhY2NvdW50IGZvciB0aGlzIGJ5IG1ha2luZyBhbGwgYm94ZXMgYSBiaXQgYmlnZ2VyLlxuICAgIHRoaXMueVN0cmV0Y2ggPSBNYXRoLnBvdyh0aGlzLnlTdHJldGNoLCAxLjMpO1xufVxuXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5taW5TY2FsZSA9IDAuMjU7XG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5tYXhTY2FsZSA9IDI7XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY29sbGlzaW9uRmVhdHVyZSBjYW4gYmUgc2hvd24gd2l0aG91dFxuICogb3ZlcmxhcHBpbmcgd2l0aCBvdGhlciBmZWF0dXJlcy5cbiAqXG4gKiBAcGFyYW0ge0NvbGxpc2lvbkZlYXR1cmV9IGNvbGxpc2lvbkZlYXR1cmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHBsYWNlbWVudFNjYWxlXG4gKiBAcHJpdmF0ZVxuICovXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5wbGFjZUNvbGxpc2lvbkZlYXR1cmUgPSBmdW5jdGlvbihjb2xsaXNpb25GZWF0dXJlKSB7XG5cbiAgICB2YXIgbWluUGxhY2VtZW50U2NhbGUgPSB0aGlzLm1pblNjYWxlO1xuICAgIHZhciByb3RhdGlvbk1hdHJpeCA9IHRoaXMucm90YXRpb25NYXRyaXg7XG4gICAgdmFyIHlTdHJldGNoID0gdGhpcy55U3RyZXRjaDtcblxuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29sbGlzaW9uRmVhdHVyZS5ib3hlcy5sZW5ndGg7IGIrKykge1xuXG4gICAgICAgIHZhciBib3ggPSBjb2xsaXNpb25GZWF0dXJlLmJveGVzW2JdO1xuXG4gICAgICAgIHZhciBhbmNob3JQb2ludCA9IGJveC5hbmNob3JQb2ludC5tYXRNdWx0KHJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgdmFyIHggPSBhbmNob3JQb2ludC54O1xuICAgICAgICB2YXIgeSA9IGFuY2hvclBvaW50Lnk7XG5cbiAgICAgICAgYm94WzBdID0geCArIGJveC54MTtcbiAgICAgICAgYm94WzFdID0geSArIGJveC55MSAqIHlTdHJldGNoO1xuICAgICAgICBib3hbMl0gPSB4ICsgYm94LngyO1xuICAgICAgICBib3hbM10gPSB5ICsgYm94LnkyICogeVN0cmV0Y2g7XG5cbiAgICAgICAgdmFyIGJsb2NraW5nQm94ZXMgPSB0aGlzLnRyZWUuc2VhcmNoKGJveCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja2luZ0JveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tpbmcgPSBibG9ja2luZ0JveGVzW2ldO1xuICAgICAgICAgICAgdmFyIGJsb2NraW5nQW5jaG9yUG9pbnQgPSBibG9ja2luZy5hbmNob3JQb2ludC5tYXRNdWx0KHJvdGF0aW9uTWF0cml4KTtcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgbG93ZXN0IHNjYWxlIGF0IHdoaWNoIHRoZSB0d28gYm94ZXMgY2FuIGZpdCBzaWRlIGJ5IHNpZGUgd2l0aG91dCBvdmVybGFwcGluZy5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGFsZ29yaXRobTpcbiAgICAgICAgICAgIHZhciBzMSA9IChibG9ja2luZy54MSAtIGJveC54MikgLyAoeCAtIGJsb2NraW5nQW5jaG9yUG9pbnQueCk7IC8vIHNjYWxlIGF0IHdoaWNoIG5ldyBib3ggaXMgdG8gdGhlIGxlZnQgb2Ygb2xkIGJveFxuICAgICAgICAgICAgdmFyIHMyID0gKGJsb2NraW5nLngyIC0gYm94LngxKSAvICh4IC0gYmxvY2tpbmdBbmNob3JQb2ludC54KTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgcmlnaHQgb2Ygb2xkIGJveFxuICAgICAgICAgICAgdmFyIHMzID0gKGJsb2NraW5nLnkxIC0gYm94LnkyKSAqIHlTdHJldGNoIC8gKHkgLSBibG9ja2luZ0FuY2hvclBvaW50LnkpOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSB0b3Agb2Ygb2xkIGJveFxuICAgICAgICAgICAgdmFyIHM0ID0gKGJsb2NraW5nLnkyIC0gYm94LnkxKSAqIHlTdHJldGNoIC8gKHkgLSBibG9ja2luZ0FuY2hvclBvaW50LnkpOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSBib3R0b20gb2Ygb2xkIGJveFxuXG4gICAgICAgICAgICBpZiAoaXNOYU4oczEpIHx8IGlzTmFOKHMyKSkgczEgPSBzMiA9IDE7XG4gICAgICAgICAgICBpZiAoaXNOYU4oczMpIHx8IGlzTmFOKHM0KSkgczMgPSBzNCA9IDE7XG5cbiAgICAgICAgICAgIHZhciBjb2xsaXNpb25GcmVlU2NhbGUgPSBNYXRoLm1pbihNYXRoLm1heChzMSwgczIpLCBNYXRoLm1heChzMywgczQpKTtcblxuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbkZyZWVTY2FsZSA+IGJsb2NraW5nLm1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gQWZ0ZXIgYSBib3gncyBtYXhTY2FsZSB0aGUgbGFiZWwgaGFzIHNocnVuayBlbm91Z2ggdGhhdCB0aGUgYm94IGlzIG5vIGxvbmdlciBuZWVkZWQgdG8gY292ZXIgaXQsXG4gICAgICAgICAgICAgICAgLy8gc28gdW5ibG9jayB0aGUgbmV3IGJveCBhdCB0aGUgc2NhbGUgdGhhdCB0aGUgb2xkIGJveCBkaXNhcHBlYXJzLlxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA9IGJsb2NraW5nLm1heFNjYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sbGlzaW9uRnJlZVNjYWxlID4gYm94Lm1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJveCBjYW4gb25seSBiZSBzaG93biBhZnRlciBpdCBpcyB2aXNpYmxlLCB0aGVuIHRoZSBib3ggY2FuIG5ldmVyIGJlIHNob3duLlxuICAgICAgICAgICAgICAgIC8vIEJ1dCB0aGUgbGFiZWwgY2FuIGJlIHNob3duIGFmdGVyIHRoaXMgYm94IGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA9IGJveC5tYXhTY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbkZyZWVTY2FsZSA+IG1pblBsYWNlbWVudFNjYWxlICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA+PSBibG9ja2luZy5wbGFjZW1lbnRTY2FsZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgY29sbGlzaW9uIG9jY3VycyBhdCBhIGxvd2VyIHNjYWxlIHRoYW4gcHJldmlvdXNseSBmb3VuZCBjb2xsaXNpb25zXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBjb2xsaXNpb24gb2NjdXJzIHdoaWxlIHRoZSBvdGhlciBsYWJlbCBpcyB2aXNpYmxlXG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHRoaXMgaXMgdGhlIGxvd2VzdCBzY2FsZSBhdCB3aGljaCB0aGUgbGFiZWwgd29uJ3QgY29sbGlkZSB3aXRoIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgbWluUGxhY2VtZW50U2NhbGUgPSBjb2xsaXNpb25GcmVlU2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaW5QbGFjZW1lbnRTY2FsZSA+PSB0aGlzLm1heFNjYWxlKSByZXR1cm4gbWluUGxhY2VtZW50U2NhbGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluUGxhY2VtZW50U2NhbGU7XG59O1xuXG4vKipcbiAqIFJlbWVtYmVyIHRoaXMgY29sbGlzaW9uRmVhdHVyZSBhbmQgd2hhdCBzY2FsZSBpdCB3YXMgcGxhY2VkIGF0IHRvIGJsb2NrXG4gKiBsYXRlciBmZWF0dXJlcyBmcm9tIG92ZXJsYXBwaW5nIHdpdGggaXQuXG4gKlxuICogQHBhcmFtIHtDb2xsaXNpb25GZWF0dXJlfSBjb2xsaXNpb25GZWF0dXJlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUGxhY2VtZW50U2NhbGVcbiAqIEBwcml2YXRlXG4gKi9cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLmluc2VydENvbGxpc2lvbkZlYXR1cmUgPSBmdW5jdGlvbihjb2xsaXNpb25GZWF0dXJlLCBtaW5QbGFjZW1lbnRTY2FsZSkge1xuXG4gICAgdmFyIGJveGVzID0gY29sbGlzaW9uRmVhdHVyZS5ib3hlcztcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGJveGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGJveGVzW2tdLnBsYWNlbWVudFNjYWxlID0gbWluUGxhY2VtZW50U2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKG1pblBsYWNlbWVudFNjYWxlIDwgdGhpcy5tYXhTY2FsZSkge1xuICAgICAgICB0aGlzLnRyZWUubG9hZChib3hlcyk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGludGVycG9sYXRlID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpO1xudmFyIEFuY2hvciA9IHJlcXVpcmUoJy4uL3N5bWJvbC9hbmNob3InKTtcbnZhciBjaGVja01heEFuZ2xlID0gcmVxdWlyZSgnLi9jaGVja19tYXhfYW5nbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbmNob3JzO1xuXG5mdW5jdGlvbiBnZXRBbmNob3JzKGxpbmUsIHNwYWNpbmcsIG1heEFuZ2xlLCBzaGFwZWRUZXh0LCBnbHlwaFNpemUsIGJveFNjYWxlLCBvdmVyc2NhbGluZykge1xuXG4gICAgLy8gUmVzYW1wbGUgYSBsaW5lIHRvIGdldCBhbmNob3IgcG9pbnRzIGZvciBsYWJlbHMgYW5kIGNoZWNrIHRoYXQgZWFjaFxuICAgIC8vIHBvdGVudGlhbCBsYWJlbCBwYXNzZXMgdGV4dC1tYXgtYW5nbGUgY2hlY2sgYW5kIGhhcyBlbm91Z2ggZnJvb20gdG8gZml0XG4gICAgLy8gb24gdGhlIGxpbmUuXG5cbiAgICB2YXIgYW5nbGVXaW5kb3dTaXplID0gc2hhcGVkVGV4dCA/XG4gICAgICAgIDMgLyA1ICogZ2x5cGhTaXplICogYm94U2NhbGUgOlxuICAgICAgICAwO1xuXG4gICAgLy8gT2Zmc2V0IHRoZSBmaXJzdCBhbmNob3IgYnkgaGFsZiB0aGUgbGFiZWwgbGVuZ3RoIChvciBoYWxmIHRoZSBzcGFjaW5nIGRpc3RhbmNlIGZvciBpY29ucykuXG4gICAgLy8gQWRkIGEgYml0IG9mIGV4dHJhIG9mZnNldCB0byBhdm9pZCBjb2xsaXNpb25zIGF0IFQgaW50ZXJzZWN0aW9ucy5cbiAgICB2YXIgbGFiZWxMZW5ndGggPSBzaGFwZWRUZXh0ID8gc2hhcGVkVGV4dC5yaWdodCAtIHNoYXBlZFRleHQubGVmdCA6IHNwYWNpbmc7XG4gICAgdmFyIGV4dHJhT2Zmc2V0ID0gZ2x5cGhTaXplICogMjtcbiAgICB2YXIgb2Zmc2V0ID0gKChsYWJlbExlbmd0aCAvIDIgKyBleHRyYU9mZnNldCkgKiBib3hTY2FsZSAqIG92ZXJzY2FsaW5nKSAlIHNwYWNpbmc7XG5cbiAgICByZXR1cm4gcmVzYW1wbGUobGluZSwgb2Zmc2V0LCBzcGFjaW5nLCBhbmdsZVdpbmRvd1NpemUsIG1heEFuZ2xlLCBsYWJlbExlbmd0aCAqIGJveFNjYWxlLCBmYWxzZSk7XG59XG5cblxuZnVuY3Rpb24gcmVzYW1wbGUobGluZSwgb2Zmc2V0LCBzcGFjaW5nLCBhbmdsZVdpbmRvd1NpemUsIG1heEFuZ2xlLCBsYWJlbExlbmd0aCwgcGxhY2VBdE1pZGRsZSkge1xuXG4gICAgdmFyIGRpc3RhbmNlID0gMCxcbiAgICAgICAgbWFya2VkRGlzdGFuY2UgPSBvZmZzZXQgPyBvZmZzZXQgLSBzcGFjaW5nIDogMDtcblxuICAgIHZhciBhbmNob3JzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGEgPSBsaW5lW2ldLFxuICAgICAgICAgICAgYiA9IGxpbmVbaSArIDFdO1xuXG4gICAgICAgIHZhciBzZWdtZW50RGlzdCA9IGEuZGlzdChiKSxcbiAgICAgICAgICAgIGFuZ2xlID0gYi5hbmdsZVRvKGEpO1xuXG4gICAgICAgIHdoaWxlIChtYXJrZWREaXN0YW5jZSArIHNwYWNpbmcgPCBkaXN0YW5jZSArIHNlZ21lbnREaXN0KSB7XG4gICAgICAgICAgICBtYXJrZWREaXN0YW5jZSArPSBzcGFjaW5nO1xuXG4gICAgICAgICAgICB2YXIgdCA9IChtYXJrZWREaXN0YW5jZSAtIGRpc3RhbmNlKSAvIHNlZ21lbnREaXN0LFxuICAgICAgICAgICAgICAgIHggPSBpbnRlcnBvbGF0ZShhLngsIGIueCwgdCksXG4gICAgICAgICAgICAgICAgeSA9IGludGVycG9sYXRlKGEueSwgYi55LCB0KTtcblxuICAgICAgICAgICAgaWYgKHggPj0gMCAmJiB4IDwgNDA5NiAmJiB5ID49IDAgJiYgeSA8IDQwOTYpIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gbmV3IEFuY2hvcih4LCB5LCBhbmdsZSwgaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFuZ2xlV2luZG93U2l6ZSB8fCBjaGVja01heEFuZ2xlKGxpbmUsIGFuY2hvciwgbGFiZWxMZW5ndGgsIGFuZ2xlV2luZG93U2l6ZSwgbWF4QW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcnMucHVzaChhbmNob3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RhbmNlICs9IHNlZ21lbnREaXN0O1xuICAgIH1cblxuICAgIGlmICghcGxhY2VBdE1pZGRsZSAmJiAhYW5jaG9ycy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGF0dGVtcHQgYXQgZmluZGluZyBhbmNob3JzIGF0IHdoaWNoIGxhYmVscyBjYW4gYmUgcGxhY2VkIGZhaWxlZC5cbiAgICAgICAgLy8gVHJ5IGFnYWluLCBidXQgdGhpcyB0aW1lIGp1c3QgdHJ5IHBsYWNpbmcgb25lIGFuY2hvciBhdCB0aGUgbWlkZGxlIG9mIHRoZSBsaW5lLlxuICAgICAgICAvLyBUaGlzIGhhcyB0aGUgbW9zdCBlZmZlY3QgZm9yIHNob3J0IGxpbmVzIGluIG92ZXJzY2FsZWQgdGlsZXMsIHNpbmNlIHRoZVxuICAgICAgICAvLyBpbml0aWFsIG9mZnNldCB1c2VkIGluIG92ZXJzY2FsZWQgdGlsZXMgaXMgY2FsY3VsYXRlZCB0byBhbGlnbiBsYWJlbHMgd2l0aCBwb3NpdGlvbnMgaW5cbiAgICAgICAgLy8gcGFyZW50IHRpbGVzIGluc3RlYWQgb2YgcGxhY2luZyB0aGUgbGFiZWwgYXMgY2xvc2UgdG8gdGhlIGJlZ2lubmluZyBhcyBwb3NzaWJsZS5cbiAgICAgICAgYW5jaG9ycyA9IHJlc2FtcGxlKGxpbmUsIGRpc3RhbmNlIC8gMiwgc3BhY2luZywgYW5nbGVXaW5kb3dTaXplLCBtYXhBbmdsZSwgbGFiZWxMZW5ndGgsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNob3JzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmluUGFjayA9IHJlcXVpcmUoJy4vYmluX3BhY2snKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaEF0bGFzO1xuZnVuY3Rpb24gR2x5cGhBdGxhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5iaW4gPSBuZXcgQmluUGFjayh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmluZGV4ID0ge307XG4gICAgdGhpcy5pZHMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCk7XG59XG5cbkdseXBoQXRsYXMucHJvdG90eXBlID0ge1xuICAgIGdldCBkZWJ1ZygpIHtcbiAgICAgICAgcmV0dXJuICdjYW52YXMnIGluIHRoaXM7XG4gICAgfSxcbiAgICBzZXQgZGVidWcodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmN0eDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbnZhcztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmdldEdseXBocyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbHlwaHMgPSB7fSxcbiAgICAgICAgc3BsaXQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlkO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XG4gICAgICAgIHNwbGl0ID0ga2V5LnNwbGl0KCcjJyk7XG4gICAgICAgIG5hbWUgPSBzcGxpdFswXTtcbiAgICAgICAgaWQgPSBzcGxpdFsxXTtcblxuICAgICAgICBpZiAoIWdseXBoc1tuYW1lXSkgZ2x5cGhzW25hbWVdID0gW107XG4gICAgICAgIGdseXBoc1tuYW1lXS5wdXNoKGlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhzO1xufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuZ2V0UmVjdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVjdHMgPSB7fSxcbiAgICAgICAgc3BsaXQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlkO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XG4gICAgICAgIHNwbGl0ID0ga2V5LnNwbGl0KCcjJyk7XG4gICAgICAgIG5hbWUgPSBzcGxpdFswXTtcbiAgICAgICAgaWQgPSBzcGxpdFsxXTtcblxuICAgICAgICBpZiAoIXJlY3RzW25hbWVdKSByZWN0c1tuYW1lXSA9IHt9O1xuICAgICAgICByZWN0c1tuYW1lXVtpZF0gPSB0aGlzLmluZGV4W2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3RzO1xufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUucmVtb3ZlR2x5cGhzID0gZnVuY3Rpb24oaWQpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pZHMpIHtcblxuICAgICAgICB2YXIgaWRzID0gdGhpcy5pZHNba2V5XTtcblxuICAgICAgICB2YXIgcG9zID0gaWRzLmluZGV4T2YoaWQpO1xuICAgICAgICBpZiAocG9zID49IDApIGlkcy5zcGxpY2UocG9zLCAxKTtcbiAgICAgICAgdGhpcy5pZHNba2V5XSA9IGlkcztcblxuICAgICAgICBpZiAoIWlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5pbmRleFtrZXldO1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCByZWN0Lmg7IHkrKykge1xuICAgICAgICAgICAgICAgIHZhciB5MSA9IHRoaXMud2lkdGggKiAocmVjdC55ICsgeSkgKyByZWN0Lng7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCByZWN0Lnc7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbeTEgKyB4XSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5iaW4ucmVsZWFzZShyZWN0KTtcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhba2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmlkc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICB0aGlzLnVwZGF0ZVRleHR1cmUodGhpcy5nbCk7XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5hZGRHbHlwaCA9IGZ1bmN0aW9uKGlkLCBuYW1lLCBnbHlwaCwgYnVmZmVyKSB7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ21pc3NpbmcgZ2x5cGgnLCBjb2RlLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBrZXkgPSBuYW1lICsgXCIjXCIgKyBnbHlwaC5pZDtcblxuICAgIC8vIFRoZSBnbHlwaCBpcyBhbHJlYWR5IGluIHRoaXMgdGV4dHVyZS5cbiAgICBpZiAodGhpcy5pbmRleFtrZXldKSB7XG4gICAgICAgIGlmICh0aGlzLmlkc1trZXldLmluZGV4T2YoaWQpIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5pZHNba2V5XS5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFtrZXldO1xuICAgIH1cblxuICAgIC8vIFRoZSBnbHlwaCBiaXRtYXAgaGFzIHplcm8gd2lkdGguXG4gICAgaWYgKCFnbHlwaC5iaXRtYXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlcmVkV2lkdGggPSBnbHlwaC53aWR0aCArIGJ1ZmZlciAqIDI7XG4gICAgdmFyIGJ1ZmZlcmVkSGVpZ2h0ID0gZ2x5cGguaGVpZ2h0ICsgYnVmZmVyICogMjtcblxuICAgIC8vIEFkZCBhIDFweCBib3JkZXIgYXJvdW5kIGV2ZXJ5IGltYWdlLlxuICAgIHZhciBwYWRkaW5nID0gMTtcbiAgICB2YXIgcGFja1dpZHRoID0gYnVmZmVyZWRXaWR0aCArIDIgKiBwYWRkaW5nO1xuICAgIHZhciBwYWNrSGVpZ2h0ID0gYnVmZmVyZWRIZWlnaHQgKyAyICogcGFkZGluZztcblxuICAgIC8vIEluY3JlYXNlIHRvIG5leHQgbnVtYmVyIGRpdmlzaWJsZSBieSA0LCBidXQgYXQgbGVhc3QgMS5cbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiBzY2FsZSBkb3duIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCBwYWNrIHRoZW1cbiAgICAvLyBpbnRvIDIgYnl0ZXMgcmF0aGVyIHRoYW4gNCBieXRlcy5cbiAgICBwYWNrV2lkdGggKz0gKDQgLSBwYWNrV2lkdGggJSA0KTtcbiAgICBwYWNrSGVpZ2h0ICs9ICg0IC0gcGFja0hlaWdodCAlIDQpO1xuXG4gICAgdmFyIHJlY3QgPSB0aGlzLmJpbi5hbGxvY2F0ZShwYWNrV2lkdGgsIHBhY2tIZWlnaHQpO1xuICAgIGlmIChyZWN0LnggPCAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZ2x5cGggYml0bWFwIG92ZXJmbG93Jyk7XG4gICAgICAgIHJldHVybiB7IGdseXBoOiBnbHlwaCwgcmVjdDogbnVsbCB9O1xuICAgIH1cblxuICAgIHRoaXMuaW5kZXhba2V5XSA9IHJlY3Q7XG4gICAgdGhpcy5pZHNba2V5XSA9IFtpZF07XG5cbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5kYXRhO1xuICAgIHZhciBzb3VyY2UgPSBnbHlwaC5iaXRtYXA7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBidWZmZXJlZEhlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciB5MSA9IHRoaXMud2lkdGggKiAocmVjdC55ICsgeSArIHBhZGRpbmcpICsgcmVjdC54ICsgcGFkZGluZztcbiAgICAgICAgdmFyIHkyID0gYnVmZmVyZWRXaWR0aCAqIHk7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgYnVmZmVyZWRXaWR0aDsgeCsrKSB7XG4gICAgICAgICAgICB0YXJnZXRbeTEgKyB4XSA9IHNvdXJjZVt5MiArIHhdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLkFMUEhBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB0aGlzLmJpbmQoZ2wpO1xuICAgIGlmICh0aGlzLmRpcnR5KSB7XG5cbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XG5cbiAgICAgICAgLy8gREVCVUdcbiAgICAgICAgaWYgKHRoaXMuY3R4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyssIGogKz0gNCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtqXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFbaiArIDFdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtqICsgMl0gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhW2ogKyAzXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3R4LnB1dEltYWdlRGF0YShkYXRhLCAwLCAwKTtcblxuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5iaW4uZnJlZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmVlID0gdGhpcy5iaW4uZnJlZVtrXTtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VSZWN0KGZyZWUueCwgZnJlZS55LCBmcmVlLncsIGZyZWUuaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRU5EIERFQlVHXG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBub3JtYWxpemVVUkwgPSByZXF1aXJlKCcuLi91dGlsL21hcGJveCcpLm5vcm1hbGl6ZUdseXBoc1VSTDtcbnZhciBnZXRBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpLmdldEFycmF5QnVmZmVyO1xudmFyIEdseXBocyA9IHJlcXVpcmUoJy4uL3V0aWwvZ2x5cGhzJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaFNvdXJjZTtcblxuLyoqXG4gKiBBIGdseXBoIHNvdXJjZSBoYXMgYSBVUkwgZnJvbSB3aGljaCB0byBsb2FkIG5ldyBnbHlwaHMgYW5kIG93bnMgYSBHbHlwaEF0bGFzXG4gKiB0aGF0IHN0b3JlcyBjdXJyZW50bHktbG9hZGVkIGdseXBocy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIGdseXBoIHRlbXBsYXRlIHVybFxuICogQHBhcmFtIHtPYmplY3R9IGdseXBoQXRsYXMgZ2x5cGggYXRsYXMgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBHbHlwaFNvdXJjZSh1cmwsIGdseXBoQXRsYXMpIHtcbiAgICB0aGlzLnVybCA9IHVybCAmJiBub3JtYWxpemVVUkwodXJsKTtcbiAgICB0aGlzLmdseXBoQXRsYXMgPSBnbHlwaEF0bGFzO1xuICAgIHRoaXMuc3RhY2tzID0gW107XG4gICAgdGhpcy5sb2FkaW5nID0ge307XG59XG5cbkdseXBoU291cmNlLnByb3RvdHlwZS5nZXRTaW1wbGVHbHlwaHMgPSBmdW5jdGlvbihmb250c3RhY2ssIGdseXBoSURzLCB1aWQsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAodGhpcy5zdGFja3NbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB0aGlzLnN0YWNrc1tmb250c3RhY2tdID0ge307XG5cbiAgICB2YXIgZ2x5cGhzID0ge307XG5cbiAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrc1tmb250c3RhY2tdO1xuICAgIHZhciBnbHlwaEF0bGFzID0gdGhpcy5nbHlwaEF0bGFzO1xuXG4gICAgLy8gdGhlIG51bWJlciBvZiBwaXhlbHMgdGhlIHNkZiBiaXRtYXBzIGFyZSBwYWRkZWQgYnlcbiAgICB2YXIgYnVmZmVyID0gMztcblxuICAgIHZhciBtaXNzaW5nID0ge307XG4gICAgdmFyIHJlbWFpbmluZyA9IDA7XG4gICAgdmFyIHJhbmdlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ2x5cGhJRCA9IGdseXBoSURzW2ldO1xuICAgICAgICByYW5nZSA9IE1hdGguZmxvb3IoZ2x5cGhJRCAvIDI1Nik7XG5cbiAgICAgICAgaWYgKHN0YWNrW3JhbmdlXSkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gc3RhY2tbcmFuZ2VdLmdseXBoc1tnbHlwaElEXTtcbiAgICAgICAgICAgIHZhciByZWN0ICA9IGdseXBoQXRsYXMuYWRkR2x5cGgodWlkLCBmb250c3RhY2ssIGdseXBoLCBidWZmZXIpO1xuICAgICAgICAgICAgaWYgKGdseXBoKSBnbHlwaHNbZ2x5cGhJRF0gPSBuZXcgU2ltcGxlR2x5cGgoZ2x5cGgsIHJlY3QsIGJ1ZmZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWlzc2luZ1tyYW5nZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdbcmFuZ2VdID0gW107XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaXNzaW5nW3JhbmdlXS5wdXNoKGdseXBoSUQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZW1haW5pbmcpIGNhbGxiYWNrKHVuZGVmaW5lZCwgZ2x5cGhzKTtcblxuICAgIHZhciBvblJhbmdlTG9hZGVkID0gZnVuY3Rpb24oZXJyLCByYW5nZSwgZGF0YSkge1xuICAgICAgICAvLyBUT0RPIG5vdCBiZSBzaWxlbnQgYWJvdXQgZXJyb3JzXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrc1tmb250c3RhY2tdW3JhbmdlXSA9IGRhdGEuc3RhY2tzWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXNzaW5nW3JhbmdlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaElEID0gbWlzc2luZ1tyYW5nZV1baV07XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoID0gc3RhY2suZ2x5cGhzW2dseXBoSURdO1xuICAgICAgICAgICAgICAgIHZhciByZWN0ICA9IGdseXBoQXRsYXMuYWRkR2x5cGgodWlkLCBmb250c3RhY2ssIGdseXBoLCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaCkgZ2x5cGhzW2dseXBoSURdID0gbmV3IFNpbXBsZUdseXBoKGdseXBoLCByZWN0LCBidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbWFpbmluZy0tO1xuICAgICAgICBpZiAoIXJlbWFpbmluZykgY2FsbGJhY2sodW5kZWZpbmVkLCBnbHlwaHMpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGZvciAodmFyIHIgaW4gbWlzc2luZykge1xuICAgICAgICB0aGlzLmxvYWRSYW5nZShmb250c3RhY2ssIHIsIG9uUmFuZ2VMb2FkZWQpO1xuICAgIH1cbn07XG5cbi8vIEEgc2ltcGxpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2x5cGggY29udGFpbmluZyBvbmx5IHRoZSBwcm9wZXJ0aWVzIG5lZWRlZCBmb3Igc2hhcGluZy5cbmZ1bmN0aW9uIFNpbXBsZUdseXBoKGdseXBoLCByZWN0LCBidWZmZXIpIHtcbiAgICB2YXIgcGFkZGluZyA9IDE7XG4gICAgdGhpcy5hZHZhbmNlID0gZ2x5cGguYWR2YW5jZTtcbiAgICB0aGlzLmxlZnQgPSBnbHlwaC5sZWZ0IC0gYnVmZmVyIC0gcGFkZGluZztcbiAgICB0aGlzLnRvcCA9IGdseXBoLnRvcCArIGJ1ZmZlciArIHBhZGRpbmc7XG4gICAgdGhpcy5yZWN0ID0gcmVjdDtcbn1cblxuR2x5cGhTb3VyY2UucHJvdG90eXBlLmxvYWRSYW5nZSA9IGZ1bmN0aW9uKGZvbnRzdGFjaywgcmFuZ2UsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAocmFuZ2UgKiAyNTYgPiA2NTUzNSkgcmV0dXJuIGNhbGxiYWNrKCdneXBocyA+IDY1NTM1IG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgIGlmICh0aGlzLmxvYWRpbmdbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB0aGlzLmxvYWRpbmdbZm9udHN0YWNrXSA9IHt9O1xuICAgIHZhciBsb2FkaW5nID0gdGhpcy5sb2FkaW5nW2ZvbnRzdGFja107XG5cbiAgICBpZiAobG9hZGluZ1tyYW5nZV0pIHtcbiAgICAgICAgbG9hZGluZ1tyYW5nZV0ucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZGluZ1tyYW5nZV0gPSBbY2FsbGJhY2tdO1xuXG4gICAgICAgIHZhciByYW5nZU5hbWUgPSAocmFuZ2UgKiAyNTYpICsgJy0nICsgKHJhbmdlICogMjU2ICsgMjU1KTtcbiAgICAgICAgdmFyIHVybCA9IGdseXBoVXJsKGZvbnRzdGFjaywgcmFuZ2VOYW1lLCB0aGlzLnVybCk7XG5cbiAgICAgICAgZ2V0QXJyYXlCdWZmZXIodXJsLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSAhZXJyICYmIG5ldyBHbHlwaHMobmV3IFByb3RvYnVmKG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvYWRpbmdbcmFuZ2VdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9hZGluZ1tyYW5nZV1baV0oZXJyLCByYW5nZSwgZ2x5cGhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBsb2FkaW5nW3JhbmdlXTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVc2UgQ05BTUUgc2hhcmRpbmcgdG8gbG9hZCBhIHNwZWNpZmljIGdseXBoIHJhbmdlIG92ZXIgYSByYW5kb21pemVkXG4gKiBidXQgY29uc2lzdGVudCBzdWJkb21haW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udHN0YWNrIGNvbW1hLWpvaW5lZCBmb250c1xuICogQHBhcmFtIHtzdHJpbmd9IHJhbmdlIGNvbW1hLWpvaW5lZCByYW5nZVxuICogQHBhcmFtIHt1cmx9IHVybCB0ZW1wbGF0ZWQgdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1YmRvbWFpbnM9YWJjXSBzdWJkb21haW5zIGFzIGEgc3RyaW5nIHdoZXJlIGVhY2ggbGV0dGVyIGlzIG9uZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IGEgdXJsIHRvIGxvYWQgdGhhdCBzZWN0aW9uIG9mIGdseXBoc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2x5cGhVcmwoZm9udHN0YWNrLCByYW5nZSwgdXJsLCBzdWJkb21haW5zKSB7XG4gICAgc3ViZG9tYWlucyA9IHN1YmRvbWFpbnMgfHwgJ2FiYyc7XG5cbiAgICByZXR1cm4gdXJsXG4gICAgICAgIC5yZXBsYWNlKCd7c30nLCBzdWJkb21haW5zW2ZvbnRzdGFjay5sZW5ndGggJSBzdWJkb21haW5zLmxlbmd0aF0pXG4gICAgICAgIC5yZXBsYWNlKCd7Zm9udHN0YWNrfScsIGZvbnRzdGFjaylcbiAgICAgICAgLnJlcGxhY2UoJ3tyYW5nZX0nLCByYW5nZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVzLCB0ZXh0RmVhdHVyZXMsIGdlb21ldHJpZXMpIHtcblxuICAgIHZhciBsZWZ0SW5kZXggPSB7fSxcbiAgICAgICAgcmlnaHRJbmRleCA9IHt9LFxuICAgICAgICBtZXJnZWRGZWF0dXJlcyA9IFtdLFxuICAgICAgICBtZXJnZWRHZW9tID0gW10sXG4gICAgICAgIG1lcmdlZFRleHRzID0gW10sXG4gICAgICAgIG1lcmdlZEluZGV4ID0gMCxcbiAgICAgICAgaztcblxuICAgIGZ1bmN0aW9uIGFkZChrKSB7XG4gICAgICAgIG1lcmdlZEZlYXR1cmVzLnB1c2goZmVhdHVyZXNba10pO1xuICAgICAgICBtZXJnZWRHZW9tLnB1c2goZ2VvbWV0cmllc1trXSk7XG4gICAgICAgIG1lcmdlZFRleHRzLnB1c2godGV4dEZlYXR1cmVzW2tdKTtcbiAgICAgICAgbWVyZ2VkSW5kZXgrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSkge1xuICAgICAgICB2YXIgaSA9IHJpZ2h0SW5kZXhbbGVmdEtleV07XG4gICAgICAgIGRlbGV0ZSByaWdodEluZGV4W2xlZnRLZXldO1xuICAgICAgICByaWdodEluZGV4W3JpZ2h0S2V5XSA9IGk7XG5cbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXS5wb3AoKTtcbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXSA9IG1lcmdlZEdlb21baV1bMF0uY29uY2F0KGdlb21bMF0pO1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZyb21MZWZ0KGxlZnRLZXksIHJpZ2h0S2V5LCBnZW9tKSB7XG4gICAgICAgIHZhciBpID0gbGVmdEluZGV4W3JpZ2h0S2V5XTtcbiAgICAgICAgZGVsZXRlIGxlZnRJbmRleFtyaWdodEtleV07XG4gICAgICAgIGxlZnRJbmRleFtsZWZ0S2V5XSA9IGk7XG5cbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXS5zaGlmdCgpO1xuICAgICAgICBtZXJnZWRHZW9tW2ldWzBdID0gZ2VvbVswXS5jb25jYXQobWVyZ2VkR2VvbVtpXVswXSk7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEtleSh0ZXh0LCBnZW9tLCBvblJpZ2h0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IG9uUmlnaHQgPyBnZW9tWzBdW2dlb21bMF0ubGVuZ3RoIC0gMV0gOiBnZW9tWzBdWzBdO1xuICAgICAgICByZXR1cm4gdGV4dCArICc6JyArIHBvaW50LnggKyAnOicgKyBwb2ludC55O1xuICAgIH1cblxuICAgIGZvciAoayA9IDA7IGsgPCBmZWF0dXJlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgZ2VvbSA9IGdlb21ldHJpZXNba10sXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dEZlYXR1cmVzW2tdO1xuXG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgYWRkKGspO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVmdEtleSA9IGdldEtleSh0ZXh0LCBnZW9tKSxcbiAgICAgICAgICAgIHJpZ2h0S2V5ID0gZ2V0S2V5KHRleHQsIGdlb20sIHRydWUpO1xuXG4gICAgICAgIGlmICgobGVmdEtleSBpbiByaWdodEluZGV4KSAmJiAocmlnaHRLZXkgaW4gbGVmdEluZGV4KSAmJiAocmlnaHRJbmRleFtsZWZ0S2V5XSAhPT0gbGVmdEluZGV4W3JpZ2h0S2V5XSkpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIGxpbmVzIHdpdGggdGhlIHNhbWUgdGV4dCBhZGphY2VudCB0byBib3RoIGVuZHMgb2YgdGhlIGN1cnJlbnQgbGluZSwgbWVyZ2UgYWxsIHRocmVlXG4gICAgICAgICAgICB2YXIgaiA9IG1lcmdlRnJvbUxlZnQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pO1xuICAgICAgICAgICAgdmFyIGkgPSBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgbWVyZ2VkR2VvbVtqXSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBsZWZ0SW5kZXhbbGVmdEtleV07XG4gICAgICAgICAgICBkZWxldGUgcmlnaHRJbmRleFtyaWdodEtleV07XG5cbiAgICAgICAgICAgIHJpZ2h0SW5kZXhbZ2V0S2V5KHRleHQsIG1lcmdlZEdlb21baV0sIHRydWUpXSA9IGk7XG4gICAgICAgICAgICBtZXJnZWRHZW9tW2pdID0gbnVsbDtcblxuICAgICAgICB9IGVsc2UgaWYgKGxlZnRLZXkgaW4gcmlnaHRJbmRleCkge1xuICAgICAgICAgICAgLy8gZm91bmQgbWVyZ2VhYmxlIGxpbmUgYWRqYWNlbnQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IGxpbmUsIG1lcmdlXG4gICAgICAgICAgICBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyaWdodEtleSBpbiBsZWZ0SW5kZXgpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIG1lcmdlYWJsZSBsaW5lIGFkamFjZW50IHRvIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgbGluZSwgbWVyZ2VcbiAgICAgICAgICAgIG1lcmdlRnJvbUxlZnQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBhZGphY2VudCBsaW5lcywgYWRkIGFzIGEgbmV3IGl0ZW1cbiAgICAgICAgICAgIGFkZChrKTtcbiAgICAgICAgICAgIGxlZnRJbmRleFtsZWZ0S2V5XSA9IG1lcmdlZEluZGV4IC0gMTtcbiAgICAgICAgICAgIHJpZ2h0SW5kZXhbcmlnaHRLZXldID0gbWVyZ2VkSW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmVhdHVyZXM6IG1lcmdlZEZlYXR1cmVzLFxuICAgICAgICB0ZXh0RmVhdHVyZXM6IG1lcmdlZFRleHRzLFxuICAgICAgICBnZW9tZXRyaWVzOiBtZXJnZWRHZW9tXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldEljb25RdWFkczogZ2V0SWNvblF1YWRzLFxuICAgIGdldEdseXBoUXVhZHM6IGdldEdseXBoUXVhZHNcbn07XG5cbnZhciBtaW5TY2FsZSA9IDAuNTsgLy8gdW5kZXJzY2FsZSBieSAxIHpvb20gbGV2ZWxcblxuLyoqXG4gKiBBIHRleHR1cmVkIHF1YWQgZm9yIHJlbmRlcmluZyBhIHNpbmdsZSBpY29uIG9yIGdseXBoLlxuICpcbiAqIFRoZSB6b29tIHJhbmdlIHRoZSBnbHlwaCBjYW4gYmUgc2hvd24gaXMgZGVmaW5lZCBieSBtaW5TY2FsZSBhbmQgbWF4U2NhbGUuXG4gKlxuICogQHBhcmFtIHtQb2ludH0gYW5jaG9yUG9pbnQgdGhlIHBvaW50IHRoZSBzeW1ib2wgaXMgYW5jaG9yZWQgYXJvdW5kXG4gKiBAcGFyYW0ge1BvaW50fSB0bCBUaGUgb2Zmc2V0IG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgZnJvbSB0aGUgYW5jaG9yLlxuICogQHBhcmFtIHtQb2ludH0gdHIgVGhlIG9mZnNldCBvZiB0aGUgdG9wIHJpZ2h0IGNvcm5lciBmcm9tIHRoZSBhbmNob3IuXG4gKiBAcGFyYW0ge1BvaW50fSBibCBUaGUgb2Zmc2V0IG9mIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgZnJvbSB0aGUgYW5jaG9yLlxuICogQHBhcmFtIHtQb2ludH0gYnIgVGhlIG9mZnNldCBvZiB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBmcm9tIHRoZSBhbmNob3IuXG4gKiBAcGFyYW0ge09iamVjdH0gdGV4IFRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSBvZiB0aGUgbGFiZWwgYXQgaXQncyBjZW50ZXIsIG5vdCB0aGUgYW5nbGUgb2YgdGhpcyBxdWFkLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblNjYWxlIFRoZSBtaW5pbXVtIHNjYWxlLCByZWxhdGl2ZSB0byB0aGUgdGlsZSdzIGludGVuZGVkIHNjYWxlLCB0aGF0IHRoZSBnbHlwaCBjYW4gYmUgc2hvd24gYXQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4U2NhbGUgVGhlIG1heGltdW0gc2NhbGUsIHJlbGF0aXZlIHRvIHRoZSB0aWxlJ3MgaW50ZW5kZWQgc2NhbGUsIHRoYXQgdGhlIGdseXBoIGNhbiBiZSBzaG93biBhdC5cbiAqXG4gKiBAY2xhc3MgU3ltYm9sUXVhZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU3ltYm9sUXVhZChhbmNob3JQb2ludCwgdGwsIHRyLCBibCwgYnIsIHRleCwgYW5nbGUsIG1pblNjYWxlLCBtYXhTY2FsZSkge1xuICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBhbmNob3JQb2ludDtcbiAgICB0aGlzLnRsID0gdGw7XG4gICAgdGhpcy50ciA9IHRyO1xuICAgIHRoaXMuYmwgPSBibDtcbiAgICB0aGlzLmJyID0gYnI7XG4gICAgdGhpcy50ZXggPSB0ZXg7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuICAgIHRoaXMubWluU2NhbGUgPSBtaW5TY2FsZTtcbiAgICB0aGlzLm1heFNjYWxlID0gbWF4U2NhbGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBxdWFkcyB1c2VkIGZvciByZW5kZXJpbmcgYW4gaWNvbi5cbiAqXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yXG4gKiBAcGFyYW0ge1Bvc2l0aW9uZWRJY29ufSBzaGFwZWRJY29uXG4gKiBAcGFyYW0ge251bWJlcn0gYm94U2NhbGUgQSBtYWdpYyBudW1iZXIgZm9yIGNvbnZlcnRpbmcgZ2x5cGggbWV0cmljIHVuaXRzIHRvIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxQb2ludD4+fSBsaW5lXG4gKiBAcGFyYW0ge0xheW91dFByb3BlcnRpZXN9IGxheW91dFxuICogQHBhcmFtIHtib29sZWFufSBhbG9uZ0xpbmUgV2hldGhlciB0aGUgaWNvbiBzaG91bGQgYmUgcGxhY2VkIGFsb25nIHRoZSBsaW5lLlxuICogQHJldHVybnMge0FycmF5PFN5bWJvbFF1YWQ+fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0SWNvblF1YWRzKGFuY2hvciwgc2hhcGVkSWNvbiwgYm94U2NhbGUsIGxpbmUsIGxheW91dCwgYWxvbmdMaW5lKSB7XG5cbiAgICB2YXIgcmVjdCA9IHNoYXBlZEljb24uaW1hZ2UucmVjdDtcblxuICAgIHZhciBib3JkZXIgPSAxO1xuICAgIHZhciBsZWZ0ID0gc2hhcGVkSWNvbi5sZWZ0IC0gYm9yZGVyO1xuICAgIHZhciByaWdodCA9IGxlZnQgKyByZWN0Lnc7XG4gICAgdmFyIHRvcCA9IHNoYXBlZEljb24udG9wIC0gYm9yZGVyO1xuICAgIHZhciBib3R0b20gPSB0b3AgKyByZWN0Lmg7XG4gICAgdmFyIHRsID0gbmV3IFBvaW50KGxlZnQsIHRvcCk7XG4gICAgdmFyIHRyID0gbmV3IFBvaW50KHJpZ2h0LCB0b3ApO1xuICAgIHZhciBiciA9IG5ldyBQb2ludChyaWdodCwgYm90dG9tKTtcbiAgICB2YXIgYmwgPSBuZXcgUG9pbnQobGVmdCwgYm90dG9tKTtcblxuICAgIHZhciBhbmdsZSA9IGxheW91dFsnaWNvbi1yb3RhdGUnXSAqIE1hdGguUEkgLyAxODA7XG4gICAgaWYgKGFsb25nTGluZSkge1xuICAgICAgICB2YXIgcHJldiA9IGxpbmVbYW5jaG9yLnNlZ21lbnRdO1xuICAgICAgICBhbmdsZSArPSBNYXRoLmF0YW4yKGFuY2hvci55IC0gcHJldi55LCBhbmNob3IueCAtIHByZXYueCk7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBtYXRyaXggPSBbY29zLCAtc2luLCBzaW4sIGNvc107XG5cbiAgICAgICAgdGwgPSB0bC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgIHRyID0gdHIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICBibCA9IGJsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgYnIgPSBici5tYXRNdWx0KG1hdHJpeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuZXcgU3ltYm9sUXVhZChuZXcgUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KSwgdGwsIHRyLCBibCwgYnIsIHNoYXBlZEljb24uaW1hZ2UucmVjdCwgMCwgbWluU2NhbGUsIEluZmluaXR5KV07XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBxdWFkcyB1c2VkIGZvciByZW5kZXJpbmcgYSB0ZXh0IGxhYmVsLlxuICpcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3JcbiAqIEBwYXJhbSB7U2hhcGluZ30gc2hhcGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGJveFNjYWxlIEEgbWFnaWMgbnVtYmVyIGZvciBjb252ZXJ0aW5nIGZyb20gZ2x5cGggbWV0cmljIHVuaXRzIHRvIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxQb2ludD4+fSBsaW5lXG4gKiBAcGFyYW0ge0xheW91dFByb3BlcnRpZXN9IGxheW91dFxuICogQHBhcmFtIHtib29sZWFufSBhbG9uZ0xpbmUgV2hldGhlciB0aGUgbGFiZWwgc2hvdWxkIGJlIHBsYWNlZCBhbG9uZyB0aGUgbGluZS5cbiAqIEByZXR1cm5zIHtBcnJheTxTeW1ib2xRdWFkPn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEdseXBoUXVhZHMoYW5jaG9yLCBzaGFwaW5nLCBib3hTY2FsZSwgbGluZSwgbGF5b3V0LCBhbG9uZ0xpbmUpIHtcblxuICAgIHZhciB0ZXh0Um90YXRlID0gbGF5b3V0Wyd0ZXh0LXJvdGF0ZSddICogTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIga2VlcFVwcmlnaHQgPSBsYXlvdXRbJ3RleHQta2VlcC11cHJpZ2h0J107XG5cbiAgICB2YXIgcG9zaXRpb25lZEdseXBocyA9IHNoYXBpbmcucG9zaXRpb25lZEdseXBocztcbiAgICB2YXIgcXVhZHMgPSBbXTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zaXRpb25lZEdseXBocy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgcG9zaXRpb25lZEdseXBoID0gcG9zaXRpb25lZEdseXBoc1trXTtcbiAgICAgICAgdmFyIGdseXBoID0gcG9zaXRpb25lZEdseXBoLmdseXBoO1xuICAgICAgICB2YXIgcmVjdCA9IGdseXBoLnJlY3Q7XG5cbiAgICAgICAgaWYgKCFyZWN0KSBjb250aW51ZTtcblxuICAgICAgICB2YXIgY2VudGVyWCA9IChwb3NpdGlvbmVkR2x5cGgueCArIGdseXBoLmFkdmFuY2UgLyAyKSAqIGJveFNjYWxlO1xuXG4gICAgICAgIHZhciBnbHlwaEluc3RhbmNlcztcbiAgICAgICAgdmFyIGxhYmVsTWluU2NhbGUgPSBtaW5TY2FsZTtcbiAgICAgICAgaWYgKGFsb25nTGluZSkge1xuICAgICAgICAgICAgZ2x5cGhJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGxhYmVsTWluU2NhbGUgPSBnZXRTZWdtZW50R2x5cGhzKGdseXBoSW5zdGFuY2VzLCBhbmNob3IsIGNlbnRlclgsIGxpbmUsIGFuY2hvci5zZWdtZW50LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChrZWVwVXByaWdodCkge1xuICAgICAgICAgICAgICAgIGxhYmVsTWluU2NhbGUgPSBNYXRoLm1pbihsYWJlbE1pblNjYWxlLCBnZXRTZWdtZW50R2x5cGhzKGdseXBoSW5zdGFuY2VzLCBhbmNob3IsIGNlbnRlclgsIGxpbmUsIGFuY2hvci5zZWdtZW50LCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaEluc3RhbmNlcyA9IFt7XG4gICAgICAgICAgICAgICAgYW5jaG9yUG9pbnQ6IG5ldyBQb2ludChhbmNob3IueCwgYW5jaG9yLnkpLFxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBhbmdsZTogMCxcbiAgICAgICAgICAgICAgICBtYXhTY2FsZTogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgbWluU2NhbGU6IG1pblNjYWxlXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MSA9IHBvc2l0aW9uZWRHbHlwaC54ICsgZ2x5cGgubGVmdCxcbiAgICAgICAgICAgIHkxID0gcG9zaXRpb25lZEdseXBoLnkgLSBnbHlwaC50b3AsXG4gICAgICAgICAgICB4MiA9IHgxICsgcmVjdC53LFxuICAgICAgICAgICAgeTIgPSB5MSArIHJlY3QuaCxcblxuICAgICAgICAgICAgb3RsID0gbmV3IFBvaW50KHgxLCB5MSksXG4gICAgICAgICAgICBvdHIgPSBuZXcgUG9pbnQoeDIsIHkxKSxcbiAgICAgICAgICAgIG9ibCA9IG5ldyBQb2ludCh4MSwgeTIpLFxuICAgICAgICAgICAgb2JyID0gbmV3IFBvaW50KHgyLCB5Mik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBnbHlwaEluc3RhbmNlc1tpXSxcbiAgICAgICAgICAgICAgICB0bCA9IG90bCxcbiAgICAgICAgICAgICAgICB0ciA9IG90cixcbiAgICAgICAgICAgICAgICBibCA9IG9ibCxcbiAgICAgICAgICAgICAgICBiciA9IG9icixcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGluc3RhbmNlLmFuZ2xlICsgdGV4dFJvdGF0ZTtcblxuICAgICAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICBtYXRyaXggPSBbY29zLCAtc2luLCBzaW4sIGNvc107XG5cbiAgICAgICAgICAgICAgICB0bCA9IHRsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgICAgICB0ciA9IHRyLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgICAgICBibCA9IGJsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgICAgICBiciA9IGJyLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJldmVudCBsYWJlbCBmcm9tIGV4dGVuZGluZyBwYXN0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgIHZhciBnbHlwaE1pblNjYWxlID0gTWF0aC5tYXgoaW5zdGFuY2UubWluU2NhbGUsIGxhYmVsTWluU2NhbGUpO1xuXG4gICAgICAgICAgICB2YXIgZ2x5cGhBbmdsZSA9IChhbmNob3IuYW5nbGUgKyB0ZXh0Um90YXRlICsgaW5zdGFuY2Uub2Zmc2V0ICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIHF1YWRzLnB1c2gobmV3IFN5bWJvbFF1YWQoaW5zdGFuY2UuYW5jaG9yUG9pbnQsIHRsLCB0ciwgYmwsIGJyLCByZWN0LCBnbHlwaEFuZ2xlLCBnbHlwaE1pblNjYWxlLCBpbnN0YW5jZS5tYXhTY2FsZSkpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVhZHM7XG59XG5cbi8qKlxuICogV2UgY2FuIG9ubHkgcmVuZGVyIGdseXBoIHF1YWRzIHRoYXQgc2xpZGUgYWxvbmcgYSBzdHJhaWdodCBsaW5lLiBUbyBkcmF3XG4gKiBjdXJ2ZWQgbGluZXMgd2UgbmVlZCBhbiBpbnN0YW5jZSBvZiBhIGdseXBoIGZvciBlYWNoIHNlZ21lbnQgaXQgYXBwZWFycyBvbi5cbiAqIFRoaXMgY3JlYXRlcyBhbGwgdGhlIGluc3RhbmNlcyBvZiBhIGdseXBoIHRoYXQgYXJlIG5lY2Vzc2FyeSB0byByZW5kZXIgYSBsYWJlbC5cbiAqXG4gKiBXZSBuZWVkIGFcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZ2x5cGhJbnN0YW5jZXMgQW4gZW1wdHkgYXJyYXkgdGhhdCBnbHlwaEluc3RhbmNlcyBhcmUgYWRkZWQgdG8uXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBnbHlwaCdzIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGxhYmVsLlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50IFRoZSBpbmRleCBvZiB0aGUgc2VnbWVudCBvZiB0aGUgbGluZSBvbiB3aGljaCB0aGUgYW5jaG9yIGV4aXN0cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZCBJZiB0cnVlIGdldCB0aGUgZ2x5cGhzIHRoYXQgY29tZSBsYXRlciBvbiB0aGUgbGluZSwgb3RoZXJ3aXNlIGdldCB0aGUgZ2x5cGhzIHRoYXQgY29tZSBlYXJsaWVyLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSBnbHlwaEluc3RhbmNlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2VnbWVudEdseXBocyhnbHlwaHMsIGFuY2hvciwgb2Zmc2V0LCBsaW5lLCBzZWdtZW50LCBmb3J3YXJkKSB7XG4gICAgdmFyIHVwc2lkZURvd24gPSAhZm9yd2FyZDtcblxuICAgIGlmIChvZmZzZXQgPCAwKSBmb3J3YXJkID0gIWZvcndhcmQ7XG5cbiAgICBpZiAoZm9yd2FyZCkgc2VnbWVudCsrO1xuXG4gICAgdmFyIG5ld0FuY2hvclBvaW50ID0gbmV3IFBvaW50KGFuY2hvci54LCBhbmNob3IueSk7XG4gICAgdmFyIGVuZCA9IGxpbmVbc2VnbWVudF07XG4gICAgdmFyIHByZXZTY2FsZSA9IEluZmluaXR5O1xuXG4gICAgb2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcblxuICAgIHZhciBwbGFjZW1lbnRTY2FsZSA9IG1pblNjYWxlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gbmV3QW5jaG9yUG9pbnQuZGlzdChlbmQpO1xuICAgICAgICB2YXIgc2NhbGUgPSBvZmZzZXQgLyBkaXN0YW5jZTtcblxuICAgICAgICAvLyBHZXQgdGhlIGFuZ2xlIG9mIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihlbmQueSAtIG5ld0FuY2hvclBvaW50LnksIGVuZC54IC0gbmV3QW5jaG9yUG9pbnQueCk7XG4gICAgICAgIGlmICghZm9yd2FyZCkgYW5nbGUgKz0gTWF0aC5QSTtcbiAgICAgICAgaWYgKHVwc2lkZURvd24pIGFuZ2xlICs9IE1hdGguUEk7XG5cbiAgICAgICAgZ2x5cGhzLnB1c2goe1xuICAgICAgICAgICAgYW5jaG9yUG9pbnQ6IG5ld0FuY2hvclBvaW50LFxuICAgICAgICAgICAgb2Zmc2V0OiB1cHNpZGVEb3duID8gTWF0aC5QSSA6IDAsXG4gICAgICAgICAgICBtaW5TY2FsZTogc2NhbGUsXG4gICAgICAgICAgICBtYXhTY2FsZTogcHJldlNjYWxlLFxuICAgICAgICAgICAgYW5nbGU6IChhbmdsZSArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNjYWxlIDw9IHBsYWNlbWVudFNjYWxlKSBicmVhaztcblxuICAgICAgICBuZXdBbmNob3JQb2ludCA9IGVuZDtcblxuICAgICAgICAvLyBza2lwIGR1cGxpY2F0ZSBub2Rlc1xuICAgICAgICB3aGlsZSAobmV3QW5jaG9yUG9pbnQuZXF1YWxzKGVuZCkpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGVuZCA9IGxpbmVbc2VnbWVudF07XG4gICAgICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0ID0gZW5kLnN1YihuZXdBbmNob3JQb2ludCkuX3VuaXQoKTtcbiAgICAgICAgbmV3QW5jaG9yUG9pbnQgPSBuZXdBbmNob3JQb2ludC5zdWIodW5pdC5fbXVsdChkaXN0YW5jZSkpO1xuXG4gICAgICAgIHByZXZTY2FsZSA9IHNjYWxlO1xuICAgIH1cblxuICAgIHJldHVybiBwbGFjZW1lbnRTY2FsZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlc29sdmVUb2tlbnMgPSByZXF1aXJlKCcuLi91dGlsL3Rva2VuJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZUljb25zO1xuXG4vLyBGb3IgYW4gYXJyYXkgb2YgZmVhdHVyZXMgZGV0ZXJtaW5lIHdoYXQgaWNvbnMgbmVlZCB0byBiZSBsb2FkZWQuXG5mdW5jdGlvbiByZXNvbHZlSWNvbnMoZmVhdHVyZXMsIGxheW91dFByb3BlcnRpZXMpIHtcbiAgICB2YXIgaWNvbnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBmbCA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGZsOyBpKyspIHtcbiAgICAgICAgdmFyIHRleHQgPSByZXNvbHZlVG9rZW5zKGZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGxheW91dFByb3BlcnRpZXNbJ2ljb24taW1hZ2UnXSk7XG4gICAgICAgIGlmICghdGV4dCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKGljb25zLmluZGV4T2YodGV4dCkgPCAwKSB7XG4gICAgICAgICAgICBpY29ucy5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGljb25zO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVzb2x2ZVRva2VucyA9IHJlcXVpcmUoJy4uL3V0aWwvdG9rZW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlVGV4dDtcblxuLyoqXG4gKiBGb3IgYW4gYXJyYXkgb2YgZmVhdHVyZXMgZGV0ZXJtaW5lIHdoYXQgZ2x5cGggcmFuZ2VzIG5lZWQgdG8gYmUgbG9hZGVkXG4gKiBhbmQgYXBwbHkgYW55IHRleHQgcHJlcHJvY2Vzc2luZy4gVGhlIHJlbWFpbmluZyB1c2VycyBvZiB0ZXh0IHNob3VsZFxuICogdXNlIHRoZSBgdGV4dEZlYXR1cmVzYCBrZXkgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiBhY2Nlc3NpbmdcbiAqIGZlYXR1cmUgdGV4dCBkaXJlY3RseS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUZXh0KGZlYXR1cmVzLCBsYXlvdXRQcm9wZXJ0aWVzLCBnbHlwaHMpIHtcbiAgICB2YXIgdGV4dEZlYXR1cmVzID0gW107XG4gICAgdmFyIGNvZGVwb2ludHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBmbCA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGZsOyBpKyspIHtcbiAgICAgICAgdmFyIHRleHQgPSByZXNvbHZlVG9rZW5zKGZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGxheW91dFByb3BlcnRpZXNbJ3RleHQtZmllbGQnXSk7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgdGV4dEZlYXR1cmVzW2ldID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGxheW91dFByb3BlcnRpZXNbJ3RleHQtdHJhbnNmb3JtJ107XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gPT09ICd1cHBlcmNhc2UnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybSA9PT0gJ2xvd2VyY2FzZScpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSB0ZXh0Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgIGNvZGVwb2ludHMucHVzaCh0ZXh0LmNoYXJDb2RlQXQoaikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2sgaW5kZXhlcyBvZiBmZWF0dXJlcyB3aXRoIHRleHQuXG4gICAgICAgIHRleHRGZWF0dXJlc1tpXSA9IHRleHQ7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGEgbGlzdCBvZiB1bmlxdWUgY29kZXBvaW50cyB3ZSBhcmUgbWlzc2luZ1xuICAgIGNvZGVwb2ludHMgPSB1bmlxKGNvZGVwb2ludHMsIGdseXBocyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0RmVhdHVyZXM6IHRleHRGZWF0dXJlcyxcbiAgICAgICAgY29kZXBvaW50czogY29kZXBvaW50c1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHVuaXEoaWRzLCBhbHJlYWR5SGF2ZSkge1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIGxhc3Q7XG4gICAgaWRzLnNvcnQoc29ydE51bWJlcnMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpZHNbaV0gIT09IGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QgPSBpZHNbaV07XG4gICAgICAgICAgICBpZiAoIWFscmVhZHlIYXZlW2xhc3RdKSB1LnB1c2goaWRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cblxuZnVuY3Rpb24gc29ydE51bWJlcnMoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2hhcGVUZXh0OiBzaGFwZVRleHQsXG4gICAgc2hhcGVJY29uOiBzaGFwZUljb25cbn07XG5cblxuLy8gVGhlIHBvc2l0aW9uIG9mIGEgZ2x5cGggcmVsYXRpdmUgdG8gdGhlIHRleHQncyBhbmNob3IgcG9pbnQuXG5mdW5jdGlvbiBQb3NpdGlvbmVkR2x5cGgoY29kZVBvaW50LCB4LCB5LCBnbHlwaCkge1xuICAgIHRoaXMuY29kZVBvaW50ID0gY29kZVBvaW50O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmdseXBoID0gZ2x5cGg7XG59XG5cbi8vIEEgY29sbGVjdGlvbiBvZiBwb3NpdGlvbmVkIGdseXBocyBhbmQgc29tZSBtZXRhZGF0YVxuZnVuY3Rpb24gU2hhcGluZyhwb3NpdGlvbmVkR2x5cGhzLCB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQpIHtcbiAgICB0aGlzLnBvc2l0aW9uZWRHbHlwaHMgPSBwb3NpdGlvbmVkR2x5cGhzO1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xufVxuXG5mdW5jdGlvbiBzaGFwZVRleHQodGV4dCwgZ2x5cGhzLCBtYXhXaWR0aCwgbGluZUhlaWdodCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCBzcGFjaW5nLCB0cmFuc2xhdGUpIHtcblxuICAgIHZhciBwb3NpdGlvbmVkR2x5cGhzID0gW107XG4gICAgdmFyIHNoYXBpbmcgPSBuZXcgU2hhcGluZyhwb3NpdGlvbmVkR2x5cGhzLCB0cmFuc2xhdGVbMV0sIHRyYW5zbGF0ZVsxXSwgdHJhbnNsYXRlWzBdLCB0cmFuc2xhdGVbMF0pO1xuXG4gICAgLy8gdGhlIHkgb2Zmc2V0ICpzaG91bGQqIGJlIHBhcnQgb2YgdGhlIGZvbnQgbWV0YWRhdGFcbiAgICB2YXIgeU9mZnNldCA9IC0xNztcblxuICAgIHZhciB4ID0gdHJhbnNsYXRlWzBdO1xuICAgIHZhciB5ID0gdHJhbnNsYXRlWzFdICsgeU9mZnNldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZVBvaW50ID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbY29kZVBvaW50XTtcblxuICAgICAgICBpZiAoIWdseXBoKSBjb250aW51ZTtcblxuICAgICAgICBwb3NpdGlvbmVkR2x5cGhzLnB1c2gobmV3IFBvc2l0aW9uZWRHbHlwaChjb2RlUG9pbnQsIHgsIHksIGdseXBoKSk7XG4gICAgICAgIHggKz0gZ2x5cGguYWR2YW5jZSArIHNwYWNpbmc7XG4gICAgfVxuXG4gICAgaWYgKCFwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgbGluZXdyYXAoc2hhcGluZywgZ2x5cGhzLCBsaW5lSGVpZ2h0LCBtYXhXaWR0aCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5KTtcblxuICAgIHJldHVybiBzaGFwaW5nO1xufVxuXG52YXIgYnJlYWthYmxlID0geyAzMjogdHJ1ZSB9OyAvLyBDdXJyZW50bHkgb25seSBicmVha3MgYXQgcmVndWxhciBzcGFjZXNcblxuZnVuY3Rpb24gbGluZXdyYXAoc2hhcGluZywgZ2x5cGhzLCBsaW5lSGVpZ2h0LCBtYXhXaWR0aCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5KSB7XG4gICAgdmFyIGxhc3RTYWZlQnJlYWsgPSBudWxsO1xuXG4gICAgdmFyIGxlbmd0aEJlZm9yZUN1cnJlbnRMaW5lID0gMDtcbiAgICB2YXIgbGluZVN0YXJ0SW5kZXggPSAwO1xuICAgIHZhciBsaW5lID0gMDtcblxuICAgIHZhciBtYXhMaW5lTGVuZ3RoID0gMDtcblxuICAgIHZhciBwb3NpdGlvbmVkR2x5cGhzID0gc2hhcGluZy5wb3NpdGlvbmVkR2x5cGhzO1xuXG4gICAgaWYgKG1heFdpZHRoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zaXRpb25lZEdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uZWRHbHlwaCA9IHBvc2l0aW9uZWRHbHlwaHNbaV07XG5cbiAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaC54IC09IGxlbmd0aEJlZm9yZUN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgcG9zaXRpb25lZEdseXBoLnkgKz0gbGluZUhlaWdodCAqIGxpbmU7XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbmVkR2x5cGgueCA+IG1heFdpZHRoICYmIGxhc3RTYWZlQnJlYWsgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gcG9zaXRpb25lZEdseXBoc1tsYXN0U2FmZUJyZWFrICsgMV0ueDtcbiAgICAgICAgICAgICAgICBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgobGluZUxlbmd0aCwgbWF4TGluZUxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gbGFzdFNhZmVCcmVhayArIDE7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaHNba10ueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2tdLnggLT0gbGluZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoanVzdGlmeSkge1xuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5TGluZShwb3NpdGlvbmVkR2x5cGhzLCBnbHlwaHMsIGxpbmVTdGFydEluZGV4LCBsYXN0U2FmZUJyZWFrIC0gMSwganVzdGlmeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0SW5kZXggPSBsYXN0U2FmZUJyZWFrICsgMTtcbiAgICAgICAgICAgICAgICBsYXN0U2FmZUJyZWFrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZW5ndGhCZWZvcmVDdXJyZW50TGluZSArPSBsaW5lTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJyZWFrYWJsZVtwb3NpdGlvbmVkR2x5cGguY29kZVBvaW50XSkge1xuICAgICAgICAgICAgICAgIGxhc3RTYWZlQnJlYWsgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhc3RQb3NpdGlvbmVkR2x5cGggPSBwb3NpdGlvbmVkR2x5cGhzW3Bvc2l0aW9uZWRHbHlwaHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGxhc3RMaW5lTGVuZ3RoID0gbGFzdFBvc2l0aW9uZWRHbHlwaC54ICsgZ2x5cGhzW2xhc3RQb3NpdGlvbmVkR2x5cGguY29kZVBvaW50XS5hZHZhbmNlO1xuICAgIG1heExpbmVMZW5ndGggPSBNYXRoLm1heChtYXhMaW5lTGVuZ3RoLCBsYXN0TGluZUxlbmd0aCk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gKGxpbmUgKyAxKSAqIGxpbmVIZWlnaHQ7XG5cbiAgICBqdXN0aWZ5TGluZShwb3NpdGlvbmVkR2x5cGhzLCBnbHlwaHMsIGxpbmVTdGFydEluZGV4LCBwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aCAtIDEsIGp1c3RpZnkpO1xuICAgIGFsaWduKHBvc2l0aW9uZWRHbHlwaHMsIGp1c3RpZnksIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwgbWF4TGluZUxlbmd0aCwgbGluZUhlaWdodCwgbGluZSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveFxuICAgIHNoYXBpbmcudG9wICs9IC12ZXJ0aWNhbEFsaWduICogaGVpZ2h0O1xuICAgIHNoYXBpbmcuYm90dG9tID0gc2hhcGluZy50b3AgKyBoZWlnaHQ7XG4gICAgc2hhcGluZy5sZWZ0ICs9IC1ob3Jpem9udGFsQWxpZ24gKiBtYXhMaW5lTGVuZ3RoO1xuICAgIHNoYXBpbmcucmlnaHQgPSBzaGFwaW5nLmxlZnQgKyBtYXhMaW5lTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBqdXN0aWZ5TGluZShwb3NpdGlvbmVkR2x5cGhzLCBnbHlwaHMsIHN0YXJ0LCBlbmQsIGp1c3RpZnkpIHtcbiAgICB2YXIgbGFzdEFkdmFuY2UgPSBnbHlwaHNbcG9zaXRpb25lZEdseXBoc1tlbmRdLmNvZGVQb2ludF0uYWR2YW5jZTtcbiAgICB2YXIgbGluZUluZGVudCA9IChwb3NpdGlvbmVkR2x5cGhzW2VuZF0ueCArIGxhc3RBZHZhbmNlKSAqIGp1c3RpZnk7XG5cbiAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPD0gZW5kOyBqKyspIHtcbiAgICAgICAgcG9zaXRpb25lZEdseXBoc1tqXS54IC09IGxpbmVJbmRlbnQ7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGFsaWduKHBvc2l0aW9uZWRHbHlwaHMsIGp1c3RpZnksIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwgbWF4TGluZUxlbmd0aCwgbGluZUhlaWdodCwgbGluZSkge1xuICAgIHZhciBzaGlmdFggPSAoanVzdGlmeSAtIGhvcml6b250YWxBbGlnbikgKiBtYXhMaW5lTGVuZ3RoO1xuICAgIHZhciBzaGlmdFkgPSAoLXZlcnRpY2FsQWxpZ24gKiAobGluZSArIDEpICsgMC41KSAqIGxpbmVIZWlnaHQ7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcG9zaXRpb25lZEdseXBoc1tqXS54ICs9IHNoaWZ0WDtcbiAgICAgICAgcG9zaXRpb25lZEdseXBoc1tqXS55ICs9IHNoaWZ0WTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gc2hhcGVJY29uKGltYWdlLCBsYXlvdXQpIHtcbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZS5yZWN0KSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBkeCA9IGxheW91dFsnaWNvbi1vZmZzZXQnXVswXTtcbiAgICB2YXIgZHkgPSBsYXlvdXRbJ2ljb24tb2Zmc2V0J11bMV07XG4gICAgdmFyIHgxID0gZHggLSBpbWFnZS53aWR0aCAvIDI7XG4gICAgdmFyIHgyID0geDEgKyBpbWFnZS53aWR0aDtcbiAgICB2YXIgeTEgPSBkeSAtIGltYWdlLmhlaWdodCAvIDI7XG4gICAgdmFyIHkyID0geTEgKyBpbWFnZS5oZWlnaHQ7XG5cbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uZWRJY29uKGltYWdlLCB5MSwgeTIsIHgxLCB4Mik7XG59XG5cbmZ1bmN0aW9uIFBvc2l0aW9uZWRJY29uKGltYWdlLCB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQpIHtcbiAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCaW5QYWNrID0gcmVxdWlyZSgnLi9iaW5fcGFjaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUF0bGFzO1xuZnVuY3Rpb24gU3ByaXRlQXRsYXMod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMuYmluID0gbmV3IEJpblBhY2sod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5pbWFnZXMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLnRleHR1cmUgPSAwOyAvLyBXZWJHTCBJRFxuICAgIHRoaXMuZmlsdGVyID0gMDsgLy8gV2ViR0wgSURcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSAxO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufVxuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUgPSB7XG4gICAgZ2V0IGRlYnVnKCkge1xuICAgICAgICByZXR1cm4gJ2NhbnZhcycgaW4gdGhpcztcbiAgICB9LFxuICAgIHNldCBkZWJ1Zyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiB0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jdHg7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24obmV3UmF0aW8pIHtcbiAgICBpZiAodGhpcy5waXhlbFJhdGlvID09PSBuZXdSYXRpbykgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIG9sZFJhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IG5ld1JhdGlvO1xuXG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuZGF0YTtcblxuICAgICAgICB0aGlzLmRhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbGxvY2F0ZSgpO1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgb2xkV2lkdGggPSB0aGlzLndpZHRoICogb2xkUmF0aW87XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmhlaWdodCAqIG9sZFJhdGlvO1xuICAgICAgICB2YXIgbmV3V2lkdGggPSB0aGlzLndpZHRoICogbmV3UmF0aW87XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSB0aGlzLmhlaWdodCAqIG5ld1JhdGlvO1xuXG4gICAgICAgIC8vIEJhc2ljIGltYWdlIHNjYWxpbmcuIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIGJldHRlciBpbWFnZSBzY2FsaW5nLlxuICAgICAgICB2YXIgbmV3SW1hZ2UgPSB0aGlzLmRhdGE7XG4gICAgICAgIHZhciBvbGRJbWFnZSA9IG9sZERhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBuZXdIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgdmFyIG9sZFlPZmZzZXQgPSBNYXRoLmZsb29yKCh5ICogb2xkSGVpZ2h0KSAvIG5ld0hlaWdodCkgKiBvbGRXaWR0aDtcbiAgICAgICAgICAgIHZhciBuZXdZT2Zmc2V0ID0geSAqIG5ld1dpZHRoO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBuZXdXaWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFggPSBNYXRoLmZsb29yKCh4ICogb2xkV2lkdGgpIC8gbmV3V2lkdGgpO1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlW25ld1lPZmZzZXQgKyB4XSA9IG9sZEltYWdlW29sZFlPZmZzZXQgKyBvbGRYXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9sZERhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kaXJ0eTtcbn07XG5cbmZ1bmN0aW9uIGNvcHlCaXRtYXAoc3JjLCBzcmNTdHJpZGUsIHNyY1gsIHNyY1ksIGRzdCwgZHN0U3RyaWRlLCBkc3RYLCBkc3RZLCB3aWR0aCwgaGVpZ2h0LCB3cmFwKSB7XG4gICAgdmFyIHNyY0kgPSBzcmNZICogc3JjU3RyaWRlICsgc3JjWDtcbiAgICB2YXIgZHN0SSA9IGRzdFkgKiBkc3RTdHJpZGUgKyBkc3RYO1xuICAgIHZhciB4LCB5O1xuXG4gICAgaWYgKHdyYXApIHtcbiAgICAgICAgLy8gYWRkIDEgcGl4ZWwgd3JhcHBlZCBwYWRkaW5nIG9uIGVhY2ggc2lkZSBvZiB0aGUgaW1hZ2VcbiAgICAgICAgZHN0SSAtPSBkc3RTdHJpZGU7XG4gICAgICAgIGZvciAoeSA9IC0xOyB5IDw9IGhlaWdodDsgeSsrLCBzcmNJID0gKCh5ICsgaGVpZ2h0KSAlIGhlaWdodCArIHNyY1kpICogc3JjU3RyaWRlICsgc3JjWCwgZHN0SSArPSBkc3RTdHJpZGUpIHtcbiAgICAgICAgICAgIGZvciAoeCA9IC0xOyB4IDw9IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBkc3RbZHN0SSArIHhdID0gc3JjW3NyY0kgKyAoKHggKyB3aWR0aCkgJSB3aWR0aCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyssIHNyY0kgKz0gc3JjU3RyaWRlLCBkc3RJICs9IGRzdFN0cmlkZSkge1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBkc3RbZHN0SSArIHhdID0gc3JjW3NyY0kgKyB4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmFsbG9jYXRlSW1hZ2UgPSBmdW5jdGlvbihwaXhlbFdpZHRoLCBwaXhlbEhlaWdodCkge1xuXG4gICAgLy8gSW5jcmVhc2UgdG8gbmV4dCBudW1iZXIgZGl2aXNpYmxlIGJ5IDQsIGJ1dCBhdCBsZWFzdCAxLlxuICAgIC8vIFRoaXMgaXMgc28gd2UgY2FuIHNjYWxlIGRvd24gdGhlIHRleHR1cmUgY29vcmRpbmF0ZXMgYW5kIHBhY2sgdGhlbVxuICAgIC8vIGludG8gMiBieXRlcyByYXRoZXIgdGhhbiA0IGJ5dGVzLlxuICAgIC8vIFBhZCBpY29ucyB0byBwcmV2ZW50IHRoZW0gZnJvbSBwb2xsdXRpbmcgbmVpZ2hib3VycyBkdXJpbmcgbGluZWFyIGludGVycG9sYXRpb25cbiAgICB2YXIgcGFkZGluZyA9IDI7XG4gICAgdmFyIHBhY2tXaWR0aCA9IHBpeGVsV2lkdGggKyBwYWRkaW5nICsgKDQgLSAocGl4ZWxXaWR0aCArIHBhZGRpbmcpICUgNCk7XG4gICAgdmFyIHBhY2tIZWlnaHQgPSBwaXhlbEhlaWdodCArIHBhZGRpbmcgKyAoNCAtIChwaXhlbEhlaWdodCArIHBhZGRpbmcpICUgNCk7Ly8gKyA0O1xuXG4gICAgLy8gV2UgaGF2ZSB0byBhbGxvY2F0ZSBhIG5ldyBhcmVhIGluIHRoZSBiaW4sIGFuZCBzdG9yZSBhbiBlbXB0eSBpbWFnZSBpbiBpdC5cbiAgICAvLyBBZGQgYSAxcHggYm9yZGVyIGFyb3VuZCBldmVyeSBpbWFnZS5cbiAgICB2YXIgcmVjdCA9IHRoaXMuYmluLmFsbG9jYXRlKHBhY2tXaWR0aCwgcGFja0hlaWdodCk7XG4gICAgaWYgKHJlY3QudyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICByZWN0Lm9yaWdpbmFsV2lkdGggPSBwaXhlbFdpZHRoO1xuICAgIHJlY3Qub3JpZ2luYWxIZWlnaHQgPSBwaXhlbEhlaWdodDtcblxuICAgIHJldHVybiByZWN0O1xufTtcblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24obmFtZSwgd3JhcCkge1xuICAgIGlmICh0aGlzLmltYWdlc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXNbbmFtZV07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNwcml0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9zID0gdGhpcy5zcHJpdGUuZ2V0U3ByaXRlUG9zaXRpb24obmFtZSk7XG4gICAgaWYgKCFwb3Mud2lkdGggfHwgIXBvcy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gcG9zLndpZHRoIC8gcG9zLnBpeGVsUmF0aW87XG4gICAgdmFyIGhlaWdodCA9IHBvcy5oZWlnaHQgLyBwb3MucGl4ZWxSYXRpbztcbiAgICB2YXIgcmVjdCA9IHRoaXMuYWxsb2NhdGVJbWFnZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAocmVjdC53ID09PSAwKSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IG5ldyBBdGxhc0ltYWdlKHJlY3QsIHdpZHRoLCBoZWlnaHQsIHBvcy5zZGYpO1xuICAgIHRoaXMuaW1hZ2VzW25hbWVdID0gaW1hZ2U7XG5cbiAgICB0aGlzLmNvcHkocmVjdCwgcG9zLCB3cmFwKTtcblxuICAgIHJldHVybiBpbWFnZTtcbn07XG5cblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24obmFtZSwgcmVwZWF0aW5nKSB7XG4gICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZShuYW1lLCByZXBlYXRpbmcpO1xuICAgIHZhciByZWN0ID0gaW1hZ2UgJiYgaW1hZ2UucmVjdDtcblxuICAgIGlmICghcmVjdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHRoZSBpbWFnZSBpcyByZXBlYXRpbmcsIGdldCB0aGUgY29ycmVjdCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2UsIHJhdGhlciB0aGFuIHRoZVxuICAgIC8vIG9uZSByb3VuZGVkIHVwIHRvIDQgcGl4ZWxzLlxuICAgIHZhciB3aWR0aCA9IHJlcGVhdGluZyA/IGltYWdlLndpZHRoIDogcmVjdC53O1xuICAgIHZhciBoZWlnaHQgPSByZXBlYXRpbmcgPyBpbWFnZS5oZWlnaHQgOiByZWN0Lmg7XG4gICAgdmFyIHBhZGRpbmcgPSAxO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZTogW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgICB0bDogWyhyZWN0LnggKyBwYWRkaW5nKSAgICAgICAgIC8gdGhpcy53aWR0aCwgKHJlY3QueSArIHBhZGRpbmcpICAgICAgICAgIC8gdGhpcy5oZWlnaHRdLFxuICAgICAgICBicjogWyhyZWN0LnggKyBwYWRkaW5nICsgd2lkdGgpIC8gdGhpcy53aWR0aCwgKHJlY3QueSArIHBhZGRpbmcgKyBoZWlnaHQpIC8gdGhpcy5oZWlnaHRdXG4gICAgfTtcbn07XG5cblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmFsbG9jYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEpIHtcbiAgICAgICAgdmFyIHcgPSBNYXRoLmZsb29yKHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB2YXIgaCA9IE1hdGguZmxvb3IodGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkodyAqIGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihkc3QsIHNyYywgd3JhcCkge1xuICAgIC8vIGlmICghc3ByaXRlLT5yYXN0ZXIpIHJldHVybjtcbiAgICBpZiAoIXRoaXMuc3ByaXRlLmltZy5kYXRhKSByZXR1cm47XG4gICAgdmFyIHNyY0ltZyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnNwcml0ZS5pbWcuZGF0YS5idWZmZXIpO1xuXG4gICAgdGhpcy5hbGxvY2F0ZSgpO1xuICAgIHZhciBkc3RJbWcgPSB0aGlzLmRhdGE7XG5cbiAgICB2YXIgcGFkZGluZyA9IDE7XG5cbiAgICBjb3B5Qml0bWFwKFxuICAgICAgICAvKiBzb3VyY2UgYnVmZmVyICovICBzcmNJbWcsXG4gICAgICAgIC8qIHNvdXJjZSBzdHJpZGUgKi8gIHRoaXMuc3ByaXRlLmltZy53aWR0aCxcbiAgICAgICAgLyogc291cmNlIHggKi8gICAgICAgc3JjLngsXG4gICAgICAgIC8qIHNvdXJjZSB5ICovICAgICAgIHNyYy55LFxuICAgICAgICAvKiBkZXN0IGJ1ZmZlciAqLyAgICBkc3RJbWcsXG4gICAgICAgIC8qIGRlc3Qgc3RyaWRlICovICAgIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgIC8qIGRlc3QgeCAqLyAgICAgICAgIChkc3QueCArIHBhZGRpbmcpICogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICAvKiBkZXN0IHkgKi8gICAgICAgICAoZHN0LnkgKyBwYWRkaW5nKSAqIHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgLyogaWNvbiBkaW1lbnNpb24gKi8gc3JjLndpZHRoLFxuICAgICAgICAvKiBpY29uIGRpbWVuc2lvbiAqLyBzcmMuaGVpZ2h0LFxuICAgICAgICAvKiB3cmFwICovIHdyYXBcbiAgICApO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuc2V0U3ByaXRlID0gZnVuY3Rpb24oc3ByaXRlKSB7XG4gICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuYWRkSWNvbnMgPSBmdW5jdGlvbihpY29ucywgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGljb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZ2V0SW1hZ2UoaWNvbnNbaV0pO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuaW1hZ2VzKTtcbn07XG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZ2wsIGxpbmVhcikge1xuICAgIHZhciBmaXJzdCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyVmFsID0gbGluZWFyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVDtcbiAgICBpZiAoZmlsdGVyVmFsICE9PSB0aGlzLmZpbHRlcikge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyVmFsKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlclZhbCk7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyVmFsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgIHRoaXMuYWxsb2NhdGUoKTtcblxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgLy8gZW51bSB0YXJnZXRcbiAgICAgICAgICAgICAgICAwLCAvLyBpbmQgbGV2ZWxcbiAgICAgICAgICAgICAgICBnbC5SR0JBLCAvLyBpbmQgaW50ZXJuYWxmb3JtYXRcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLCAvLyBHTHNpemVpIHdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8sIC8vIEdMc2l6ZWkgaGVpZ2h0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW5kIGJvcmRlclxuICAgICAgICAgICAgICAgIGdsLlJHQkEsIC8vIGVudW0gZm9ybWF0XG4gICAgICAgICAgICAgICAgZ2wuVU5TSUdORURfQllURSwgLy8gZW51bSB0eXBlXG4gICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcikgLy8gT2JqZWN0IGRhdGFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIC8vIGVudW0gdGFyZ2V0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW50IGxldmVsXG4gICAgICAgICAgICAgICAgMCwgLy8gaW50IHhvZmZzZXRcbiAgICAgICAgICAgICAgICAwLCAvLyBpbnQgeW9mZnNldFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8sIC8vIGxvbmcgd2lkdGhcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbywgLy8gbG9uZyBoZWlnaHRcbiAgICAgICAgICAgICAgICBnbC5SR0JBLCAvLyBlbnVtIGZvcm1hdFxuICAgICAgICAgICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsIC8vIGVudW0gdHlwZVxuICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpIC8vIE9iamVjdCBwaXhlbHNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gREVCVUdcbiAgICAgICAgaWYgKHRoaXMuY3R4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLCB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBkYXRhLmRhdGEuc2V0KG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLmRhdGEuYnVmZmVyKSk7XG4gICAgICAgICAgICB0aGlzLmN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuYmluLmZyZWUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJlZSA9IHRoaXMuYmluLmZyZWVba107XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlUmVjdChmcmVlLnggKiB0aGlzLnBpeGVsUmF0aW8sIGZyZWUueSAqIHRoaXMucGl4ZWxSYXRpbywgZnJlZS53ICogdGhpcy5waXhlbFJhdGlvLCBmcmVlLmggKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVORCBERUJVR1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEF0bGFzSW1hZ2UocmVjdCwgd2lkdGgsIGhlaWdodCwgc2RmKSB7XG4gICAgdGhpcy5yZWN0ID0gcmVjdDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5zZGYgPSBzZGY7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgaW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuLi91dGlsL2ludGVycG9sYXRlJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIExhdExuZyA9IHJlcXVpcmUoJy4uL2dlby9sYXRfbG5nJyk7XG52YXIgTGF0TG5nQm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvL2xhdF9sbmdfYm91bmRzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG4vKipcbiAqIE9wdGlvbnMgY29tbW9uIHRvIE1hcCNqdW1wVG8sIE1hcCNlYXNlVG8sIGFuZCBNYXAjZmx5VG8sIGNvbnRyb2xsaW5nIHRoZSBkZXN0aW5hdGlvblxuICogbG9jYXRpb24sIHpvb20gbGV2ZWwsIGJlYXJpbmcgYW5kIHBpdGNoLiBBbGwgcHJvcGVydGllcyBhcmUgb3B0aW9uczsgdW5zcGVjaWZpZWRcbiAqIG9wdGlvbnMgd2lsbCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IHZhbHVlIGZvciB0aGF0IHByb3BlcnR5LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbWVyYU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNlbnRlciBMYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChwYXNzZWQgYXMgYFtsYXQsIGxuZ11gKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpvb20gTWFwIHpvb20gbGV2ZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiZWFyaW5nIE1hcCByb3RhdGlvbiBiZWFyaW5nIGluIGRlZ3JlZXMgY291bnRlci1jbG9ja3dpc2UgZnJvbSBub3J0aFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpdGNoIFRoZSBhbmdsZSBhdCB3aGljaCB0aGUgY2FtZXJhIGlzIGxvb2tpbmcgYXQgdGhlIGdyb3VuZFxuICovXG5cbi8qKlxuICogT3B0aW9ucyBjb21tb24gdG8gbWFwIG1vdmVtZW50IG1ldGhvZHMgdGhhdCBpbnZvbHZlIGFuaW1hdGlvbiwgc3VjaCBhcyBNYXAjcGFuQnkgYW5kXG4gKiBNYXAjZWFzZVRvLCBjb250cm9sbGluZyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLiBBbGwgcHJvcGVydGllc1xuICogYXJlIG9wdGlvbmFsLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiBOdW1iZXIgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlYXNpbmdcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9mZnNldCBwb2ludCwgb3JpZ2luIG9mIG1vdmVtZW50IHJlbGF0aXZlIHRvIG1hcCBjZW50ZXJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5pbWF0ZSBXaGVuIHNldCB0byBmYWxzZSwgbm8gYW5pbWF0aW9uIGhhcHBlbnNcbiAqL1xuXG52YXIgQ2FtZXJhID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHt9O1xuXG51dGlsLmV4dGVuZChDYW1lcmEucHJvdG90eXBlLCAvKiogQGxlbmRzIE1hcC5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZpZXcgZ2VvZ3JhcGhpY2FsIHBvaW50LlxuICAgICAqIEByZXR1cm5zIHtMYXRMbmd9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmNlbnRlcjsgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtYXAgbG9jYXRpb24uIEVxdWl2YWxlbnQgdG8gYGp1bXBUbyh7Y2VudGVyOiBjZW50ZXJ9KWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjZW50ZXIgTGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAocGFzc2VkIGFzIGBbbGF0LCBsbmddYClcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5zZXRDZW50ZXIoWy03NCwgMzhdKTtcbiAgICAgKi9cbiAgICBzZXRDZW50ZXI6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgICB0aGlzLmp1bXBUbyh7Y2VudGVyOiBjZW50ZXJ9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbiBieSBhIGNlcnRhaW4gbnVtYmVyIG9mIHBpeGVsc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2Zmc2V0IFt4LCB5XVxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcGFuQnk6IGZ1bmN0aW9uKG9mZnNldCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnBhblRvKHRoaXMudHJhbnNmb3JtLmNlbnRlciwgdXRpbC5leHRlbmQoe29mZnNldDogUG9pbnQuY29udmVydChvZmZzZXQpLm11bHQoLTEpfSwgb3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFuIHRvIGEgY2VydGFpbiBsb2NhdGlvbiB3aXRoIGVhc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxhdGxuZyBhIGBMYXRMbmdgIG9iamVjdFxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcGFuVG86IGZ1bmN0aW9uKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICBsYXRsbmcgPSBMYXRMbmcuY29udmVydChsYXRsbmcpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2UsXG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIG9mZnNldCA9IFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpLnJvdGF0ZSgtdHIuYW5nbGUpLFxuICAgICAgICAgICAgZnJvbSA9IHRyLnBvaW50LFxuICAgICAgICAgICAgdG8gPSB0ci5wcm9qZWN0KGxhdGxuZykuc3ViKG9mZnNldCk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZWFzZShmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICB0ci5jZW50ZXIgPSB0ci51bnByb2plY3QoZnJvbS5hZGQodG8uc3ViKGZyb20pLm11bHQoaykpKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZScpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgem9vbVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Wm9vbTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS56b29tOyB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hcCB6b29tLiBFcXVpdmFsZW50IHRvIGBqdW1wVG8oe3pvb206IHpvb219KWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBNYXAgem9vbSBsZXZlbFxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gem9vbSB0aGUgbWFwIHRvIDVcbiAgICAgKiBtYXAuc2V0Wm9vbSg1KTtcbiAgICAgKi9cbiAgICBzZXRab29tOiBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIHRoaXMuanVtcFRvKHt6b29tOiB6b29tfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tcyB0byBhIGNlcnRhaW4gem9vbSBsZXZlbCB3aXRoIGVhc2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICB6b29tVG86IGZ1bmN0aW9uKHpvb20sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDBcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgb3B0aW9ucy5lYXNpbmcgPSB0aGlzLl91cGRhdGVFYXNpbmcob3B0aW9ucy5kdXJhdGlvbiwgem9vbSwgb3B0aW9ucy5lYXNpbmcpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgYXJvdW5kID0gdHIuY2VudGVyLFxuICAgICAgICAgICAgc3RhcnRab29tID0gdHIuem9vbTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hcm91bmQpIHtcbiAgICAgICAgICAgIGFyb3VuZCA9IExhdExuZy5jb252ZXJ0KG9wdGlvbnMuYXJvdW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgYXJvdW5kID0gdHIucG9pbnRMb2NhdGlvbih0ci5jZW50ZXJQb2ludC5hZGQoUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSBvcHRpb25zLmR1cmF0aW9uID0gMDtcblxuICAgICAgICBpZiAoIXRoaXMuem9vbWluZykge1xuICAgICAgICAgICAgdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIHRyLnNldFpvb21Bcm91bmQoaW50ZXJwb2xhdGUoc3RhcnRab29tLCB6b29tLCBrKSwgYXJvdW5kKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ3pvb20nKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmVhc2UgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gPj0gMjAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmR1cmF0aW9uIDwgMjAwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb25ab29tRW5kKTtcbiAgICAgICAgICAgIHRoaXMuX29uWm9vbUVuZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIDIwMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSBpbiBieSAxIGxldmVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHpvb21JbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLnpvb21Ubyh0aGlzLmdldFpvb20oKSArIDEsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSBvdXQgYnkgMSBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICB6b29tT3V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuem9vbVRvKHRoaXMuZ2V0Wm9vbSgpIC0gMSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBiZWFyaW5nIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldEJlYXJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm0uYmVhcmluZzsgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtYXAgcm90YXRpb24uIEVxdWl2YWxlbnQgdG8gYGp1bXBUbyh7YmVhcmluZzogYmVhcmluZ30pYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIE1hcCByb3RhdGlvbiBiZWFyaW5nIGluIGRlZ3JlZXMgY291bnRlci1jbG9ja3dpc2UgZnJvbSBub3J0aFxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcm90YXRlIHRoZSBtYXAgdG8gOTAgZGVncmVlc1xuICAgICAqIG1hcC5zZXRCZWFyaW5nKDkwKTtcbiAgICAgKi9cbiAgICBzZXRCZWFyaW5nOiBmdW5jdGlvbihiZWFyaW5nKSB7XG4gICAgICAgIHRoaXMuanVtcFRvKHtiZWFyaW5nOiBiZWFyaW5nfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgYmVhcmluZyBieSBhIGNlcnRhaW4gbnVtYmVyIG9mIGRlZ3JlZXMgd2l0aCBlYXNpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByb3RhdGVUbzogZnVuY3Rpb24oYmVhcmluZywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIGFyb3VuZCA9IHRyLmNlbnRlcjtcblxuICAgICAgICBpZiAob3B0aW9ucy5hcm91bmQpIHtcbiAgICAgICAgICAgIGFyb3VuZCA9IExhdExuZy5jb252ZXJ0KG9wdGlvbnMuYXJvdW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgYXJvdW5kID0gdHIucG9pbnRMb2NhdGlvbih0ci5jZW50ZXJQb2ludC5hZGQoUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlYXJpbmcgPSB0aGlzLl9ub3JtYWxpemVCZWFyaW5nKGJlYXJpbmcsIHN0YXJ0KTtcblxuICAgICAgICB0aGlzLnJvdGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIHRyLnNldEJlYXJpbmdBcm91bmQoaW50ZXJwb2xhdGUoc3RhcnQsIGJlYXJpbmcsIGspLCBhcm91bmQpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlJykuZmlyZSgncm90YXRlJyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1hcCBiZWFyaW5nIHRvIDAgKG5vcnRoKSB3aXRoIGVhc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZXNldE5vcnRoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucm90YXRlVG8oMCwgdXRpbC5leHRlbmQoe2R1cmF0aW9uOiAxMDAwfSwgb3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgbWFwIGJlYXJpbmcgdG8gMCAobm9ydGgpIGlmIGl0J3MgYWxyZWFkeSBjbG9zZSB0byBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc25hcFRvTm9ydGg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuZ2V0QmVhcmluZygpKSA8IHRoaXMub3B0aW9ucy5iZWFyaW5nU25hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXROb3J0aChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFBpdGNoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBpdGNoOyB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hcCBhbmdsZS4gRXF1aXZhbGVudCB0byBganVtcFRvKHtwaXRjaDogcGl0Y2h9KWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl0Y2ggVGhlIGFuZ2xlIGF0IHdoaWNoIHRoZSBjYW1lcmEgaXMgbG9va2luZyBhdCB0aGUgZ3JvdW5kXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0UGl0Y2g6IGZ1bmN0aW9uKHBpdGNoKSB7XG4gICAgICAgIHRoaXMuanVtcFRvKHtwaXRjaDogcGl0Y2h9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0byBjb250YWluIGNlcnRhaW4gZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYm91bmRzIFtbbWluTGF0LCBtaW5MbmddLCBbbWF4TGF0LCBtYXhMbmddXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNwZWVkPTEuMl0gSG93IGZhc3QgYW5pbWF0aW9uIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jdXJ2ZT0xLjQyXSBIb3cgbXVjaCB6b29taW5nIG91dCBvY2N1cnMgZHVyaW5nIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuZWFzaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucGFkZGluZyBob3cgbXVjaCBwYWRkaW5nIHRoZXJlIGlzIGFyb3VuZCB0aGUgZ2l2ZW4gYm91bmRzIG9uIGVhY2ggc2lkZSBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXhab29tXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbihib3VuZHMsIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICAgICAgbWF4Wm9vbTogSW5maW5pdHlcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgYm91bmRzID0gTGF0TG5nQm91bmRzLmNvbnZlcnQoYm91bmRzKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgICB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgbncgPSB0ci5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aFdlc3QoKSksXG4gICAgICAgICAgICBzZSA9IHRyLnByb2plY3QoYm91bmRzLmdldFNvdXRoRWFzdCgpKSxcbiAgICAgICAgICAgIHNpemUgPSBzZS5zdWIobncpLFxuICAgICAgICAgICAgc2NhbGVYID0gKHRyLndpZHRoIC0gb3B0aW9ucy5wYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldC54KSAqIDIpIC8gc2l6ZS54LFxuICAgICAgICAgICAgc2NhbGVZID0gKHRyLmhlaWdodCAtIG9wdGlvbnMucGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXQueSkgKiAyKSAvIHNpemUueTtcblxuICAgICAgICBvcHRpb25zLmNlbnRlciA9IHRyLnVucHJvamVjdChudy5hZGQoc2UpLmRpdigyKSk7XG4gICAgICAgIG9wdGlvbnMuem9vbSA9IE1hdGgubWluKHRyLnNjYWxlWm9vbSh0ci5zY2FsZSAqIE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSksIG9wdGlvbnMubWF4Wm9vbSk7XG4gICAgICAgIG9wdGlvbnMuYmVhcmluZyA9IDA7XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubGluZWFyID9cbiAgICAgICAgICAgIHRoaXMuZWFzZVRvKG9wdGlvbnMpIDpcbiAgICAgICAgICAgIHRoaXMuZmx5VG8ob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBhbnkgY29tYmluYXRpb24gb2YgY2VudGVyLCB6b29tLCBiZWFyaW5nLCBhbmQgcGl0Y2gsIHdpdGhvdXRcbiAgICAgKiBhIHRyYW5zaXRpb24uIFRoZSBtYXAgd2lsbCByZXRhaW4gdGhlIGN1cnJlbnQgdmFsdWVzIGZvciBhbnkgb3B0aW9uc1xuICAgICAqIG5vdCBpbmNsdWRlZCBpbiBgb3B0aW9uc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbWVyYU9wdGlvbnN9IG9wdGlvbnMgbWFwIHZpZXcgb3B0aW9uc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGp1bXBUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHpvb21DaGFuZ2VkID0gZmFsc2UsXG4gICAgICAgICAgICBiZWFyaW5nQ2hhbmdlZCA9IGZhbHNlLFxuICAgICAgICAgICAgcGl0Y2hDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCdjZW50ZXInIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRyLmNlbnRlciA9IExhdExuZy5jb252ZXJ0KG9wdGlvbnMuY2VudGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnem9vbScgaW4gb3B0aW9ucyAmJiB0ci56b29tICE9PSArb3B0aW9ucy56b29tKSB7XG4gICAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0ci56b29tID0gK29wdGlvbnMuem9vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnYmVhcmluZycgaW4gb3B0aW9ucyAmJiB0ci5iZWFyaW5nICE9PSArb3B0aW9ucy5iZWFyaW5nKSB7XG4gICAgICAgICAgICBiZWFyaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0ci5iZWFyaW5nID0gK29wdGlvbnMuYmVhcmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgncGl0Y2gnIGluIG9wdGlvbnMgJiYgdHIucGl0Y2ggIT09ICtvcHRpb25zLnBpdGNoKSB7XG4gICAgICAgICAgICBwaXRjaENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdHIucGl0Y2ggPSArb3B0aW9ucy5waXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0JylcbiAgICAgICAgICAgIC5maXJlKCdtb3ZlJyk7XG5cbiAgICAgICAgaWYgKHpvb21DaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3pvb20nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiZWFyaW5nQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdyb3RhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaXRjaENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgncGl0Y2gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRWFzaW5nIGFuaW1hdGlvbiB0byBhIHNwZWNpZmllZCBsb2NhdGlvbi96b29tL2JlYXJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FtZXJhT3B0aW9uc35BbmltYXRpb25PcHRpb25zfSBvcHRpb25zIG1hcCB2aWV3IGFuZCBhbmltYXRpb24gb3B0aW9uc1xuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGVhc2VUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KS5yb3RhdGUoLXRyLmFuZ2xlKSxcbiAgICAgICAgICAgIGZyb20gPSB0ci5wb2ludCxcbiAgICAgICAgICAgIHN0YXJ0Wm9vbSA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgc3RhcnRCZWFyaW5nID0gdGhpcy5nZXRCZWFyaW5nKCksXG4gICAgICAgICAgICBzdGFydFBpdGNoID0gdGhpcy5nZXRQaXRjaCgpLFxuXG4gICAgICAgICAgICB6b29tID0gJ3pvb20nIGluIG9wdGlvbnMgPyArb3B0aW9ucy56b29tIDogc3RhcnRab29tLFxuICAgICAgICAgICAgYmVhcmluZyA9ICdiZWFyaW5nJyBpbiBvcHRpb25zID8gdGhpcy5fbm9ybWFsaXplQmVhcmluZyhvcHRpb25zLmJlYXJpbmcsIHN0YXJ0QmVhcmluZykgOiBzdGFydEJlYXJpbmcsXG4gICAgICAgICAgICBwaXRjaCA9ICdwaXRjaCcgaW4gb3B0aW9ucyA/ICtvcHRpb25zLnBpdGNoIDogc3RhcnRQaXRjaCxcblxuICAgICAgICAgICAgc2NhbGUgPSB0ci56b29tU2NhbGUoem9vbSAtIHN0YXJ0Wm9vbSksXG4gICAgICAgICAgICB0byA9ICdjZW50ZXInIGluIG9wdGlvbnMgPyB0ci5wcm9qZWN0KExhdExuZy5jb252ZXJ0KG9wdGlvbnMuY2VudGVyKSkuc3ViKG9mZnNldC5kaXYoc2NhbGUpKSA6IGZyb20sXG4gICAgICAgICAgICBhcm91bmQgPSBMYXRMbmcuY29udmVydChvcHRpb25zLmFyb3VuZCk7XG5cbiAgICAgICAgaWYgKHpvb20gIT09IHN0YXJ0Wm9vbSkge1xuICAgICAgICAgICAgdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRCZWFyaW5nICE9PSBiZWFyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnpvb21pbmcgJiYgIWFyb3VuZCkge1xuICAgICAgICAgICAgYXJvdW5kID0gdHIucG9pbnRMb2NhdGlvbih0ci5jZW50ZXJQb2ludC5hZGQodG8uc3ViKGZyb20pLmRpdigxIC0gMSAvIHNjYWxlKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy56b29taW5nKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0Wm9vbUFyb3VuZChpbnRlcnBvbGF0ZShzdGFydFpvb20sIHpvb20sIGspLCBhcm91bmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ci5jZW50ZXIgPSB0ci51bnByb2plY3QoZnJvbS5hZGQodG8uc3ViKGZyb20pLm11bHQoaykpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0ci5iZWFyaW5nID0gaW50ZXJwb2xhdGUoc3RhcnRCZWFyaW5nLCBiZWFyaW5nLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBpdGNoICE9PSBzdGFydFBpdGNoKSB7XG4gICAgICAgICAgICAgICAgdHIucGl0Y2ggPSBpbnRlcnBvbGF0ZShzdGFydFBpdGNoLCBwaXRjaCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMuem9vbWluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnem9vbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3JvdGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGbHlpbmcgYW5pbWF0aW9uIHRvIGEgc3BlY2lmaWVkIGxvY2F0aW9uL3pvb20vYmVhcmluZyB3aXRoIGF1dG9tYXRpYyBjdXJ2ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW1lcmFPcHRpb25zfSBvcHRpb25zIG1hcCB2aWV3IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3BlZWQ9MS4yXSBIb3cgZmFzdCBhbmltYXRpb24gb2NjdXJzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmN1cnZlPTEuNDJdIEhvdyBtdWNoIHpvb21pbmcgb3V0IG9jY3VycyBkdXJpbmcgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZWFzaW5nXVxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZmx5IHdpdGggZGVmYXVsdCBvcHRpb25zIHRvIG51bGwgaXNsYW5kXG4gICAgICogbWFwLmZseVRvKHtjZW50ZXI6IFswLCAwXSwgem9vbTogOX0pO1xuICAgICAqIC8vIHVzaW5nIGZseVRvIG9wdGlvbnNcbiAgICAgKiBtYXAuZmx5VG8oe1xuICAgICAqICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICogICB6b29tOiA5LFxuICAgICAqICAgc3BlZWQ6IDAuMixcbiAgICAgKiAgIGN1cnZlOiAxLFxuICAgICAqICAgZWFzaW5nOiBmdW5jdGlvbih0KSB7XG4gICAgICogICAgIHJldHVybiB0O1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGZseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIHNwZWVkOiAxLjIsXG4gICAgICAgICAgICBjdXJ2ZTogMS40MixcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgICBzdGFydFpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICAgIHN0YXJ0QmVhcmluZyA9IHRoaXMuZ2V0QmVhcmluZygpO1xuXG4gICAgICAgIHZhciBjZW50ZXIgPSAnY2VudGVyJyBpbiBvcHRpb25zID8gTGF0TG5nLmNvbnZlcnQob3B0aW9ucy5jZW50ZXIpIDogdGhpcy5nZXRDZW50ZXIoKTtcbiAgICAgICAgdmFyIHpvb20gPSAnem9vbScgaW4gb3B0aW9ucyA/ICArb3B0aW9ucy56b29tIDogc3RhcnRab29tO1xuICAgICAgICB2YXIgYmVhcmluZyA9ICdiZWFyaW5nJyBpbiBvcHRpb25zID8gdGhpcy5fbm9ybWFsaXplQmVhcmluZyhvcHRpb25zLmJlYXJpbmcsIHN0YXJ0QmVhcmluZykgOiBzdGFydEJlYXJpbmc7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdHIuem9vbVNjYWxlKHpvb20gLSBzdGFydFpvb20pLFxuICAgICAgICAgICAgZnJvbSA9IHRyLnBvaW50LFxuICAgICAgICAgICAgdG8gPSB0ci5wcm9qZWN0KGNlbnRlcikuc3ViKG9mZnNldC5kaXYoc2NhbGUpKTtcblxuICAgICAgICB2YXIgc3RhcnRXb3JsZFNpemUgPSB0ci53b3JsZFNpemUsXG4gICAgICAgICAgICByaG8gPSBvcHRpb25zLmN1cnZlLFxuICAgICAgICAgICAgViA9IG9wdGlvbnMuc3BlZWQsXG5cbiAgICAgICAgICAgIHcwID0gTWF0aC5tYXgodHIud2lkdGgsIHRyLmhlaWdodCksXG4gICAgICAgICAgICB3MSA9IHcwIC8gc2NhbGUsXG4gICAgICAgICAgICB1MSA9IHRvLnN1Yihmcm9tKS5tYWcoKSxcbiAgICAgICAgICAgIHJobzIgPSByaG8gKiByaG87XG5cbiAgICAgICAgZnVuY3Rpb24gcihpKSB7XG4gICAgICAgICAgICB2YXIgYiA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIChpID8gLTEgOiAxKSAqIHJobzIgKiByaG8yICogdTEgKiB1MSkgLyAoMiAqIChpID8gdzEgOiB3MCkgKiByaG8yICogdTEpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKE1hdGguc3FydChiICogYiArIDEpIC0gYik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XG4gICAgICAgIGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cbiAgICAgICAgZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxuXG4gICAgICAgIHZhciByMCA9IHIoMCksXG4gICAgICAgICAgICB3ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH0sXG4gICAgICAgICAgICB1ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHcwICogKChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzIpIC8gdTE7IH0sXG4gICAgICAgICAgICBTID0gKHIoMSkgLSByMCkgLyByaG87XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHUxKSA8IDAuMDAwMDAxKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModzAgLSB3MSkgPCAwLjAwMDAwMSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBrID0gdzEgPCB3MCA/IC0xIDogMTtcbiAgICAgICAgICAgIFMgPSBNYXRoLmFicyhNYXRoLmxvZyh3MSAvIHcwKSkgLyByaG87XG5cbiAgICAgICAgICAgIHUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4gICAgICAgICAgICB3ID0gZnVuY3Rpb24ocykgeyByZXR1cm4gTWF0aC5leHAoayAqIHJobyAqIHMpOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IDEwMDAgKiBTIC8gVjtcblxuICAgICAgICB0aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICBpZiAoc3RhcnRCZWFyaW5nICE9PSBiZWFyaW5nKSB0aGlzLnJvdGF0aW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xuXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gayAqIFMsXG4gICAgICAgICAgICAgICAgdXMgPSB1KHMpO1xuXG4gICAgICAgICAgICB0ci56b29tID0gc3RhcnRab29tICsgdHIuc2NhbGVab29tKDEgLyB3KHMpKTtcbiAgICAgICAgICAgIHRyLmNlbnRlciA9IHRyLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWIoZnJvbSkubXVsdCh1cykpLCBzdGFydFdvcmxkU2l6ZSk7XG5cbiAgICAgICAgICAgIGlmIChiZWFyaW5nICE9PSBzdGFydEJlYXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0ci5iZWFyaW5nID0gaW50ZXJwb2xhdGUoc3RhcnRCZWFyaW5nLCBiZWFyaW5nLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnem9vbScpO1xuICAgICAgICAgICAgaWYgKGJlYXJpbmcgIT09IHN0YXJ0QmVhcmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgncm90YXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGlzRWFzaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYWJvcnRGbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBjdXJyZW50IGFuaW1hdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9hYm9ydEZuKSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydEZuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hFYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9lYXNlOiBmdW5jdGlvbihmcmFtZSwgZmluaXNoLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaEZuID0gZmluaXNoO1xuICAgICAgICB0aGlzLl9hYm9ydEZuID0gYnJvd3Nlci50aW1lZChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZnJhbWUuY2FsbCh0aGlzLCBvcHRpb25zLmVhc2luZyh0KSk7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaEVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSA/IDAgOiBvcHRpb25zLmR1cmF0aW9uLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2ZpbmlzaEVhc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fYWJvcnRGbjtcbiAgICAgICAgLy8gVGhlIGZpbmlzaCBmdW5jdGlvbiBtaWdodCBlbWl0IGV2ZW50cyB3aGljaCB0cmlnZ2VyIG5ldyBlYXNlcywgd2hpY2hcbiAgICAgICAgLy8gc2V0IGEgbmV3IF9maW5pc2hGbi4gRW5zdXJlIHdlIGRvbid0IGRlbGV0ZSBpdCB1bmludGVudGlvbmFsbHkuXG4gICAgICAgIHZhciBmaW5pc2ggPSB0aGlzLl9maW5pc2hGbjtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2ZpbmlzaEZuO1xuICAgICAgICBmaW5pc2guY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gY29udmVydCBiZWFyaW5nIHNvIHRoYXQgaXQncyBudW1lcmljYWxseSBjbG9zZSB0byB0aGUgY3VycmVudCBvbmUgc28gdGhhdCBpdCBpbnRlcnBvbGF0ZXMgcHJvcGVybHlcbiAgICBfbm9ybWFsaXplQmVhcmluZzogZnVuY3Rpb24oYmVhcmluZywgY3VycmVudEJlYXJpbmcpIHtcbiAgICAgICAgYmVhcmluZyA9IHV0aWwud3JhcChiZWFyaW5nLCAtMTgwLCAxODApO1xuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGJlYXJpbmcgLSBjdXJyZW50QmVhcmluZyk7XG4gICAgICAgIGlmIChNYXRoLmFicyhiZWFyaW5nIC0gMzYwIC0gY3VycmVudEJlYXJpbmcpIDwgZGlmZikgYmVhcmluZyAtPSAzNjA7XG4gICAgICAgIGlmIChNYXRoLmFicyhiZWFyaW5nICsgMzYwIC0gY3VycmVudEJlYXJpbmcpIDwgZGlmZikgYmVhcmluZyArPSAzNjA7XG4gICAgICAgIHJldHVybiBiZWFyaW5nO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlRWFzaW5nOiBmdW5jdGlvbihkdXJhdGlvbiwgem9vbSwgYmV6aWVyKSB7XG4gICAgICAgIHZhciBlYXNpbmc7XG5cbiAgICAgICAgaWYgKHRoaXMuZWFzZSkge1xuICAgICAgICAgICAgdmFyIGVhc2UgPSB0aGlzLmVhc2UsXG4gICAgICAgICAgICAgICAgdCA9IChEYXRlLm5vdygpIC0gZWFzZS5zdGFydCkgLyBlYXNlLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHNwZWVkID0gZWFzZS5lYXNpbmcodCArIDAuMDEpIC0gZWFzZS5lYXNpbmcodCksXG5cbiAgICAgICAgICAgICAgICAvLyBRdWljayBoYWNrIHRvIG1ha2UgbmV3IGJlemllciB0aGF0IGlzIGNvbnRpbnVvdXMgd2l0aCBsYXN0XG4gICAgICAgICAgICAgICAgeCA9IDAuMjcgLyBNYXRoLnNxcnQoc3BlZWQgKiBzcGVlZCArIDAuMDAwMSkgKiAwLjAxLFxuICAgICAgICAgICAgICAgIHkgPSBNYXRoLnNxcnQoMC4yNyAqIDAuMjcgLSB4ICogeCk7XG5cbiAgICAgICAgICAgIGVhc2luZyA9IHV0aWwuYmV6aWVyKHgsIHksIDAuMjUsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWFzaW5nID0gYmV6aWVyID8gdXRpbC5iZXppZXIuYXBwbHkodXRpbCwgYmV6aWVyKSA6IHV0aWwuZWFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3JlIGluZm9ybWF0aW9uIG9uIGN1cnJlbnQgZWFzaW5nXG4gICAgICAgIHRoaXMuZWFzZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgdG86IE1hdGgucG93KDIsIHpvb20pLFxuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmdcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZWFzaW5nO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbCcpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0aW9uO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbFxuICogQGNsYXNzIEF0dHJpYnV0aW9uXG4gKiBAZXhhbXBsZVxuICogbWFwLmFkZENvbnRyb2wobmV3IG1hcGJveGdsLkF0dHJpYnV0aW9uKCkpO1xuICovXG5mdW5jdGlvbiBBdHRyaWJ1dGlvbigpIHt9XG5cbkF0dHJpYnV0aW9uLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChDb250cm9sLCB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbS1yaWdodCdcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ21hcGJveGdsLWN0cmwtYXR0cmliJyxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgbWFwLmdldENvbnRhaW5lcigpKTtcblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgbWFwLm9uKCdzb3VyY2UubG9hZCcsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbWFwLm9uKCdzb3VyY2UuY2hhbmdlJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICBtYXAub24oJ3NvdXJjZS5yZW1vdmUnLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIG1hcC5vbignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZUVkaXRMaW5rLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXR0cmlidXRpb25zID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcC5zdHlsZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWFwLnN0eWxlLnNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fbWFwLnN0eWxlLnNvdXJjZXNbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuYXR0cmlidXRpb24gJiYgYXR0cmlidXRpb25zLmluZGV4T2Yoc291cmNlLmF0dHJpYnV0aW9uKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb25zLnB1c2goc291cmNlLmF0dHJpYnV0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gYXR0cmlidXRpb25zLmpvaW4oJyB8ICcpO1xuICAgICAgICB0aGlzLl9lZGl0TGluayA9IHRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtYXBib3gtaW1wcm92ZS1tYXAnKVswXTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRWRpdExpbmsoKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUVkaXRMaW5rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VkaXRMaW5rKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgdGhpcy5fZWRpdExpbmsuaHJlZiA9ICdodHRwczovL3d3dy5tYXBib3guY29tL21hcC1mZWVkYmFjay8jLycgK1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXIubG5nICsgJy8nICsgY2VudGVyLmxhdCArICcvJyArIE1hdGgucm91bmQodGhpcy5fbWFwLmdldFpvb20oKSArIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udHJvbDtcblxuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIG1hcC1yZWxhdGVkIGludGVyZmFjZSBlbGVtZW50cy5cbiAqXG4gKiBAY2xhc3MgQ29udHJvbFxuICovXG5mdW5jdGlvbiBDb250cm9sKCkge31cblxuQ29udHJvbC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQWRkIHRoaXMgY29udHJvbCB0byB0aGUgbWFwLCByZXR1cm5pbmcgdGhlIGNvbnRyb2wgaXRzZWxmXG4gICAgICogZm9yIGNoYWluaW5nLiBUaGlzIHdpbGwgaW5zZXJ0IHRoZSBjb250cm9sJ3MgRE9NIGVsZW1lbnQgaW50b1xuICAgICAqIHRoZSBtYXAncyBET00gZWxlbWVudCBpZiB0aGUgY29udHJvbCBoYXMgYSBgcG9zaXRpb25gIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWFwfSBtYXBcbiAgICAgKiBAcmV0dXJucyB7Q29udHJvbH0gYHRoaXNgXG4gICAgICovXG4gICAgYWRkVG86IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgKz0gJyBtYXBib3hnbC1jdHJsJztcbiAgICAgICAgICAgIGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoaXMgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaGFzIGJlZW4gYWRkZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29udHJvbH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHRoaXMub25SZW1vdmUpIHRoaXMub25SZW1vdmUodGhpcy5fbWFwKTtcbiAgICAgICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXZpZ2F0aW9uO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuYXZpZ2F0aW9uIGNvbnRyb2wgd2l0aCB6b29tIGJ1dHRvbnMgYW5kIGEgY29tcGFzc1xuICogQGNsYXNzIE5hdmlnYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbj10b3AtcmlnaHRdIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIGNvbnRyb2wncyBwb3NpdGlvbiBvbiB0aGUgbWFwLiBPcHRpb25zIGFyZSBgdG9wLXJpZ2h0YCwgYHRvcC1sZWZ0YCwgYGJvdHRvbS1yaWdodGAsIGBib3R0b20tbGVmdGBcbiAqIEBleGFtcGxlXG4gKiBtYXAuYWRkQ29udHJvbChuZXcgbWFwYm94Z2wuTmF2aWdhdGlvbih7cG9zaXRpb246ICd0b3AtbGVmdCd9KSk7IC8vIHBvc2l0aW9uIGlzIG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIE5hdmlnYXRpb24ob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbn1cblxuTmF2aWdhdGlvbi5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQ29udHJvbCwge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3AtcmlnaHQnXG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdtYXBib3hnbC1jdHJsJztcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1ncm91cCcsIG1hcC5nZXRDb250YWluZXIoKSk7XG5cbiAgICAgICAgdGhpcy5fem9vbUluQnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSArICctaWNvbiAnICsgY2xhc3NOYW1lICsgJy16b29tLWluJywgbWFwLnpvb21Jbi5iaW5kKG1hcCkpO1xuICAgICAgICB0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSArICctaWNvbiAnICsgY2xhc3NOYW1lICsgJy16b29tLW91dCcsIG1hcC56b29tT3V0LmJpbmQobWFwKSk7XG4gICAgICAgIHRoaXMuX2NvbXBhc3MgPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy1jb21wYXNzJywgbWFwLnJlc2V0Tm9ydGguYmluZChtYXApKTtcblxuICAgICAgICB2YXIgY29tcGFzc0NhbnZhcyA9IHRoaXMuX2NvbXBhc3NDYW52YXMgPSBET00uY3JlYXRlKCdjYW52YXMnLCBjbGFzc05hbWUgKyAnLWNvbXBhc3MtY2FudmFzJywgdGhpcy5fY29tcGFzcyk7XG4gICAgICAgIGNvbXBhc3NDYW52YXMuc3R5bGUuY3NzVGV4dCA9ICd3aWR0aDozMHB4OyBoZWlnaHQ6MzBweDsnO1xuICAgICAgICBjb21wYXNzQ2FudmFzLndpZHRoID0gMjYgKiAyO1xuICAgICAgICBjb21wYXNzQ2FudmFzLmhlaWdodCA9IDI2ICogMjtcblxuICAgICAgICB0aGlzLl9jb21wYXNzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uQ29tcGFzc0Rvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29uQ29tcGFzc01vdmUgPSB0aGlzLl9vbkNvbXBhc3NNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uQ29tcGFzc1VwID0gdGhpcy5fb25Db21wYXNzVXAuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9jb21wYXNzQ3R4ID0gY29tcGFzc0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIG1hcC5vbigncm90YXRlJywgdGhpcy5fZHJhd05vcnRoLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kcmF3Tm9ydGgoKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzRG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICBET00uZGlzYWJsZURyYWcoKTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkNvbXBhc3NNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQ29tcGFzc1VwKTtcbiAgICAgICAgdGhpcy5fcHJldlggPSBlLnNjcmVlblg7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX29uQ29tcGFzc01vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHggPSBlLnNjcmVlblgsXG4gICAgICAgICAgICBkID0geCA8IDIgPyAtNSA6IC8vIGxlZnQgZWRnZSBvZiB0aGUgc2NyZWVuLCBjb250aW51ZSByb3RhdGluZ1xuICAgICAgICAgICAgICAgIHggPiB3aW5kb3cuc2NyZWVuLndpZHRoIC0gMiA/IDUgOiAvLyByaWdodCBlZGdlXG4gICAgICAgICAgICAgICAgKHggLSB0aGlzLl9wcmV2WCkgLyA0O1xuXG4gICAgICAgIHRoaXMuX21hcC5zZXRCZWFyaW5nKHRoaXMuX21hcC5nZXRCZWFyaW5nKCkgLSBkKTtcbiAgICAgICAgdGhpcy5fcHJldlggPSBlLnNjcmVlblg7XG4gICAgICAgIHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIF9vbkNvbXBhc3NVcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uQ29tcGFzc01vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Db21wYXNzVXApO1xuICAgICAgICBET00uZW5hYmxlRHJhZygpO1xuXG4gICAgICAgIGlmICh0aGlzLl9tb3ZlZCkge1xuICAgICAgICAgICAgdGhpcy5fbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIERPTS5zdXBwcmVzc0NsaWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYXAuc25hcFRvTm9ydGgoKTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24oY2xhc3NOYW1lLCBmbikge1xuICAgICAgICB2YXIgYSA9IERPTS5jcmVhdGUoJ2J1dHRvbicsIGNsYXNzTmFtZSwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBmbigpOyB9KTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfSxcblxuICAgIF9kcmF3Tm9ydGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmFkID0gMjAsXG4gICAgICAgICAgICB3aWR0aCA9IDgsXG4gICAgICAgICAgICBjZW50ZXIgPSAyNixcbiAgICAgICAgICAgIGFuZ2xlID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5hbmdsZSArIChNYXRoLlBJIC8gMiksXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9jb21wYXNzQ3R4O1xuXG4gICAgICAgIHRoaXMuX2NvbXBhc3NDYW52YXMud2lkdGggPSB0aGlzLl9jb21wYXNzQ2FudmFzLndpZHRoO1xuXG4gICAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzAwMCc7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgLXdpZHRoKTtcbiAgICAgICAgY3R4LmxpbmVUbygtcmFkLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCB3aWR0aCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNiYmInO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHgubGluZVRvKDAsIHdpZHRoKTtcbiAgICAgICAgY3R4LmxpbmVUbyhyYWQsIDApO1xuICAgICAgICBjdHgubGluZVRvKDAsIC13aWR0aCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2ZmZic7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSA0O1xuICAgICAgICBjdHgubW92ZVRvKDAsIC13aWR0aCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgd2lkdGgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIExhdExuZ0JvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL2dlby9sYXRfbG5nX2JvdW5kcycpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3hab29tO1xuXG5cbmZ1bmN0aW9uIEJveFpvb20obWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IG1hcC5nZXRDb250YWluZXIoKTtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5Cb3hab29tLnByb3RvdHlwZSA9IHtcbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkgfHwgKGUud2hpY2ggPT09IDEgJiYgZS5idXR0b24gPT09IDEpKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuXG4gICAgICAgICAgICB0aGlzLl9zdGFydFBvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcDAgPSB0aGlzLl9zdGFydFBvcyxcbiAgICAgICAgICAgIHAxID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2JveCkge1xuICAgICAgICAgICAgdGhpcy5fYm94ID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLWJveHpvb20nLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLWNyb3NzaGFpcicpO1xuXG4gICAgICAgICAgICBET00uZGlzYWJsZURyYWcoKTtcblxuICAgICAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihwMC54LCBwMS54KSxcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChwMC54LCBwMS54KSxcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihwMC55LCBwMS55KSxcbiAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChwMC55LCBwMS55KTtcblxuICAgICAgICBET00uc2V0VHJhbnNmb3JtKHRoaXMuX2JveCwgJ3RyYW5zbGF0ZSgnICsgbWluWCArICdweCwnICsgbWluWSArICdweCknKTtcblxuICAgICAgICB0aGlzLl9ib3guc3R5bGUud2lkdGggPSAobWF4WCAtIG1pblgpICsgJ3B4JztcbiAgICAgICAgdGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IChtYXhZIC0gbWluWSkgKyAncHgnO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcDAgPSB0aGlzLl9zdGFydFBvcyxcbiAgICAgICAgICAgIHAxID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKSxcbiAgICAgICAgICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHModGhpcy5fbWFwLnVucHJvamVjdChwMCksIHRoaXMuX21hcC51bnByb2plY3QocDEpKTtcblxuICAgICAgICB0aGlzLl9maW5pc2goKTtcblxuICAgICAgICB0aGlzLl9tYXBcbiAgICAgICAgICAgIC5maXRCb3VuZHMoYm91bmRzLCB7bGluZWFyOiB0cnVlfSlcbiAgICAgICAgICAgIC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuICAgIH0sXG5cbiAgICBfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZmlyZSgnYm94em9vbWNhbmNlbCcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ib3gpIHJldHVybjtcblxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdtYXBib3hnbC1jcm9zc2hhaXInKTtcblxuICAgICAgICB0aGlzLl9ib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9ib3gpO1xuICAgICAgICB0aGlzLl9ib3ggPSBudWxsO1xuXG4gICAgICAgIERPTS5lbmFibGVEcmFnKCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBEb3VibGVDbGlja1pvb207XG5cbmZ1bmN0aW9uIERvdWJsZUNsaWNrWm9vbShtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fb25EYmxDbGljayA9IHRoaXMuX29uRGJsQ2xpY2suYmluZCh0aGlzKTtcbn1cblxuRG91YmxlQ2xpY2tab29tLnByb3RvdHlwZSA9IHtcbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRGJsQ2xpY2spO1xuICAgIH0sXG5cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25EYmxDbGljayk7XG4gICAgfSxcblxuICAgIF9vbkRibENsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9tYXAuem9vbVRvKE1hdGgucm91bmQodGhpcy5fbWFwLmdldFpvb20oKSkgKyAxLCB7YXJvdW5kOiBlLmxhdExuZ30pO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnUGFuO1xuXG5cbnZhciBpbmVydGlhTGluZWFyaXR5ID0gMC4yNSxcbiAgICBpbmVydGlhRWFzaW5nID0gdXRpbC5iZXppZXIoMCwgMCwgaW5lcnRpYUxpbmVhcml0eSwgMSksXG4gICAgaW5lcnRpYU1heFNwZWVkID0gMzAwMCwgLy8gcHgvc1xuICAgIGluZXJ0aWFEZWNlbGVyYXRpb24gPSA0MDAwOyAvLyBweC9zXjJcblxuXG5mdW5jdGlvbiBEcmFnUGFuKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5EcmFnUGFuLnByb3RvdHlwZSA9IHtcbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkRvd24pO1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duKTtcbiAgICB9LFxuXG4gICAgX29uRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9wb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuXG4gICAgICAgIHRoaXMuX2luZXJ0aWEgPSBbW0RhdGUubm93KCksIHRoaXMuX3Bvc11dO1xuXG4gICAgICAgIGlmICghZS50b3VjaGVzKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUsIGZhbHNlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgaWYgKG1hcC5ib3hab29tLmFjdGl2ZSB8fCBtYXAuZHJhZ1JvdGF0ZS5hY3RpdmUgfHwgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkpIHJldHVybjtcblxuICAgICAgICB2YXIgcG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKSxcbiAgICAgICAgICAgIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhLFxuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpbmVydGlhLnB1c2goW25vdywgcG9zXSk7XG4gICAgICAgIHdoaWxlIChpbmVydGlhLmxlbmd0aCA+IDIgJiYgbm93IC0gaW5lcnRpYVswXVswXSA+IDUwKSBpbmVydGlhLnNoaWZ0KCk7XG5cbiAgICAgICAgbWFwLnN0b3AoKTtcbiAgICAgICAgbWFwLnRyYW5zZm9ybS5zZXRMb2NhdGlvbkF0UG9pbnQobWFwLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKHRoaXMuX3BvcyksIHBvcyk7XG4gICAgICAgIG1hcC5maXJlKCdtb3ZlJyk7XG5cbiAgICAgICAgdGhpcy5fcG9zID0gcG9zO1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uVXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhO1xuXG4gICAgICAgIGlmIChpbmVydGlhLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdCA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGZpcnN0ID0gaW5lcnRpYVswXSxcbiAgICAgICAgICAgIGZsaW5nT2Zmc2V0ID0gbGFzdFsxXS5zdWIoZmlyc3RbMV0pLFxuICAgICAgICAgICAgZmxpbmdEdXJhdGlvbiA9IChsYXN0WzBdIC0gZmlyc3RbMF0pIC8gMTAwMCxcblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHB4L3MgdmVsb2NpdHkgJiBhZGp1c3QgZm9yIGluY3JlYXNlZCBpbml0aWFsIGFuaW1hdGlvbiBzcGVlZCB3aGVuIGVhc2luZyBvdXRcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gZmxpbmdPZmZzZXQubXVsdChpbmVydGlhTGluZWFyaXR5IC8gZmxpbmdEdXJhdGlvbiksXG4gICAgICAgICAgICBzcGVlZCA9IHZlbG9jaXR5Lm1hZygpOyAvLyBweC9zXG5cbiAgICAgICAgaWYgKHNwZWVkID4gaW5lcnRpYU1heFNwZWVkKSB7XG4gICAgICAgICAgICBzcGVlZCA9IGluZXJ0aWFNYXhTcGVlZDtcbiAgICAgICAgICAgIHZlbG9jaXR5Ll91bml0KCkuX211bHQoc3BlZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gc3BlZWQgLyAoaW5lcnRpYURlY2VsZXJhdGlvbiAqIGluZXJ0aWFMaW5lYXJpdHkpLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdmVsb2NpdHkubXVsdCgtZHVyYXRpb24gLyAyKTtcblxuICAgICAgICB0aGlzLl9tYXAucGFuQnkob2Zmc2V0LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gKiAxMDAwLFxuICAgICAgICAgICAgZWFzaW5nOiBpbmVydGlhRWFzaW5nLFxuICAgICAgICAgICAgbm9Nb3ZlU3RhcnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb25VcCgpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICBfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vblVwKCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnUm90YXRlO1xuXG5cbmZ1bmN0aW9uIERyYWdSb3RhdGUobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgdXRpbC5iaW5kSGFuZGxlcnModGhpcyk7XG59XG5cbkRyYWdSb3RhdGUucHJvdG90eXBlID0ge1xuICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUpO1xuICAgIH0sXG5cbiAgICBfb25Db250ZXh0TWVudTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fbWFwLnN0b3AoKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zdGFydFBvcyA9IHRoaXMuX3BvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAgIHZhciBwMCA9IHRoaXMuX3N0YXJ0UG9zLFxuICAgICAgICAgICAgcDEgPSB0aGlzLl9wb3MsXG4gICAgICAgICAgICBwMiA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSksXG5cbiAgICAgICAgICAgIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgICAgIGNlbnRlciA9IG1hcC50cmFuc2Zvcm0uY2VudGVyUG9pbnQsIC8vIENlbnRlciBvZiByb3RhdGlvblxuICAgICAgICAgICAgc3RhcnRUb0NlbnRlciA9IHAwLnN1YihjZW50ZXIpLFxuICAgICAgICAgICAgc3RhcnRUb0NlbnRlckRpc3QgPSBzdGFydFRvQ2VudGVyLm1hZygpO1xuXG4gICAgICAgIGlmICghbWFwLnJvdGF0aW5nKSB7XG4gICAgICAgICAgICBtYXAuZmlyZSgnbW92ZXN0YXJ0Jyk7XG4gICAgICAgICAgICBtYXAucm90YXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGNsaWNrIHdhcyB0b28gY2xvc2UgdG8gdGhlIGNlbnRlciwgbW92ZSB0aGUgY2VudGVyIG9mIHJvdGF0aW9uIGJ5IDIwMCBwaXhlbHNcbiAgICAgICAgLy8gaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgY2xpY2suXG4gICAgICAgIGlmIChzdGFydFRvQ2VudGVyRGlzdCA8IDIwMCkge1xuICAgICAgICAgICAgY2VudGVyID0gcDAuYWRkKG5ldyBQb2ludCgtMjAwLCAwKS5fcm90YXRlKHN0YXJ0VG9DZW50ZXIuYW5nbGUoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJlYXJpbmdEaWZmID0gcDEuc3ViKGNlbnRlcikuYW5nbGVXaXRoKHAyLnN1YihjZW50ZXIpKSAvIE1hdGguUEkgKiAxODA7XG4gICAgICAgIG1hcC50cmFuc2Zvcm0uYmVhcmluZyA9IG1hcC5nZXRCZWFyaW5nKCkgLSBiZWFyaW5nRGlmZjtcblxuICAgICAgICBtYXAuZmlyZSgnbW92ZScpLmZpcmUoJ3JvdGF0ZScpO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fb25UaW1lb3V0LCAyMDApO1xuXG4gICAgICAgIHRoaXMuX3BvcyA9IHAyO1xuICAgIH0sXG5cbiAgICBfb25UaW1lb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgbWFwLnJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgIG1hcC5zbmFwVG9Ob3J0aCgpO1xuXG4gICAgICAgIGlmICghbWFwLnJvdGF0aW5nKSB7XG4gICAgICAgICAgICBtYXAuX3JlcmVuZGVyKCk7XG4gICAgICAgICAgICBtYXAuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlib2FyZDtcblxuXG52YXIgcGFuRGVsdGEgPSA4MCxcbiAgICByb3RhdGVEZWx0YSA9IDI7XG5cbi8qKlxuICogVGhlIGBLZXlib2FyZGAgaGFuZGxlciByZXNwb25kcyB0byBrZXlib2FyZCBpbnB1dCBieSB6b29taW5nLCByb3RhdGluZywgb3IgcGFubmluZyB0aGVcbiAqIG1hcC4gVGhlIGZvbGxvd2luZyBrZXlib2FyZCBzaG9ydGN1dHMgYXJlIHN1cHBvcnRlZDpcbiAqICAqIGA9YCAvIGArYDogaW5jcmVhc2Ugem9vbSBsZXZlbCBieSAxXG4gKiAgKiBgU2hpZnQtPWAgLyBgU2hpZnQtK2A6IGluY3JlYXNlIHpvb20gbGV2ZWwgYnkgMlxuICogICogYC1gOiBkZWNyZWFzZSB6b29tIGxldmVsIGJ5IDFcbiAqICAqIGBTaGlmdC0tYDogZGVjcmVhc2Ugem9vbSBsZXZlbCBieSAyXG4gKiAgKiBBcnJvdyBrZXlzOiBwYW4gYnkgODAgcGl4ZWxzXG4gKiAgKiBgU2hpZnQr4oeiYDogaW5jcmVhc2Ugcm90YXRpb24gYnkgMiBkZWdyZWVzXG4gKiAgKiBgU2hpZnQr4oegYDogZGVjcmVhc2Ugcm90YXRpb24gYnkgMiBkZWdyZWVzXG4gKiBAY2xhc3MgS2V5Ym9hcmRcbiAqIEBleGFtcGxlXG4gKiAgIC8vIERpc2FibGUgdGhlIGtleWJvYXJkIGhhbmRsZXJcbiAqICAgbWFwLmtleWJvYXJkLmRpc2FibGUoKTtcbiAqIEBleGFtcGxlXG4gKiAgIC8vIEVuYWJsZSB0aGUga2V5Ym9hcmQgaGFuZGxlclxuICogICBtYXAua2V5Ym9hcmQuZW5hYmxlKCk7XG4gKi9cbmZ1bmN0aW9uIEtleWJvYXJkKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgIHRoaXMuX29uS2V5RG93biA9IHRoaXMuX29uS2V5RG93bi5iaW5kKHRoaXMpO1xufVxuXG5LZXlib2FyZC5wcm90b3R5cGUgPSB7XG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duKTtcbiAgICB9LFxuXG4gICAgX29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHJldHVybjtcblxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgNjE6XG4gICAgICAgIGNhc2UgMTA3OlxuICAgICAgICBjYXNlIDE3MTpcbiAgICAgICAgY2FzZSAxODc6XG4gICAgICAgICAgICBtYXAuem9vbVRvKE1hdGgucm91bmQobWFwLmdldFpvb20oKSkgKyAoZS5zaGlmdEtleSA/IDIgOiAxKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE4OTpcbiAgICAgICAgY2FzZSAxMDk6XG4gICAgICAgIGNhc2UgMTczOlxuICAgICAgICAgICAgbWFwLnpvb21UbyhNYXRoLnJvdW5kKG1hcC5nZXRab29tKCkpIC0gKGUuc2hpZnRLZXkgPyAyIDogMSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLnNldEJlYXJpbmcobWFwLmdldEJlYXJpbmcoKSAtIHJvdGF0ZURlbHRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwLnBhbkJ5KFstcGFuRGVsdGEsIDBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIG1hcC5zZXRCZWFyaW5nKG1hcC5nZXRCZWFyaW5nKCkgKyByb3RhdGVEZWx0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcC5wYW5CeShbcGFuRGVsdGEsIDBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICBtYXAucGFuQnkoWzAsIC1wYW5EZWx0YV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgIG1hcC5wYW5CeShbMCwgcGFuRGVsdGFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBpbmNoO1xuXG5cbmZ1bmN0aW9uIFBpbmNoKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5QaW5jaC5wcm90b3R5cGUgPSB7XG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblN0YXJ0LCBmYWxzZSk7XG4gICAgfSxcblxuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uU3RhcnQpO1xuICAgIH0sXG5cbiAgICBfb25TdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDIpIHJldHVybjtcblxuICAgICAgICB2YXIgcDAgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUudG91Y2hlc1swXSksXG4gICAgICAgICAgICBwMSA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZS50b3VjaGVzWzFdKTtcblxuICAgICAgICB0aGlzLl9zdGFydFZlYyA9IHAwLnN1YihwMSk7XG4gICAgICAgIHRoaXMuX3N0YXJ0U2NhbGUgPSB0aGlzLl9tYXAudHJhbnNmb3JtLnNjYWxlO1xuICAgICAgICB0aGlzLl9zdGFydEJlYXJpbmcgPSB0aGlzLl9tYXAudHJhbnNmb3JtLmJlYXJpbmc7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25FbmQsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgX29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDIpIHJldHVybjtcblxuICAgICAgICB2YXIgcDAgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUudG91Y2hlc1swXSksXG4gICAgICAgICAgICBwMSA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZS50b3VjaGVzWzFdKSxcbiAgICAgICAgICAgIHAgPSBwMC5hZGQocDEpLmRpdigyKSxcbiAgICAgICAgICAgIHZlYyA9IHAwLnN1YihwMSksXG4gICAgICAgICAgICBzY2FsZSA9IHZlYy5tYWcoKSAvIHRoaXMuX3N0YXJ0VmVjLm1hZygpLFxuICAgICAgICAgICAgYmVhcmluZyA9IHZlYy5hbmdsZVdpdGgodGhpcy5fc3RhcnRWZWMpICogMTgwIC8gTWF0aC5QSSxcbiAgICAgICAgICAgIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICBtYXAuZWFzZVRvKHtcbiAgICAgICAgICAgIHpvb206IG1hcC50cmFuc2Zvcm0uc2NhbGVab29tKHRoaXMuX3N0YXJ0U2NhbGUgKiBzY2FsZSksXG4gICAgICAgICAgICBiZWFyaW5nOiB0aGlzLl9zdGFydEJlYXJpbmcgKyBiZWFyaW5nLFxuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICBhcm91bmQ6IG1hcC51bnByb2plY3QocClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwLnNuYXBUb05vcnRoKCk7XG5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkVuZCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYnJvd3NlcicpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxab29tO1xuXG5cbnZhciB1YSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpIDogJycsXG4gICAgZmlyZWZveCA9IHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEsXG4gICAgc2FmYXJpID0gdWEuaW5kZXhPZignc2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ2Nocm9tJykgPT09IC0xO1xuXG5cbmZ1bmN0aW9uIFNjcm9sbFpvb20obWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgdXRpbC5iaW5kSGFuZGxlcnModGhpcyk7XG59XG5cblNjcm9sbFpvb20ucHJvdG90eXBlID0ge1xuICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX29uV2hlZWwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWwsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX29uV2hlZWwpO1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbCk7XG4gICAgfSxcblxuICAgIF9vbldoZWVsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgdmFsdWUgPSBlLmRlbHRhWTtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG91YmxlcyB0aGUgdmFsdWVzIG9uIHJldGluYSBzY3JlZW5zLi4uXG4gICAgICAgICAgICBpZiAoZmlyZWZveCAmJiBlLmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB2YWx1ZSAvPSBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB2YWx1ZSAqPSA0MDtcblxuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IC1lLndoZWVsRGVsdGFZO1xuICAgICAgICAgICAgaWYgKHNhZmFyaSkgdmFsdWUgPSB2YWx1ZSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm93ID0gKHdpbmRvdy5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKSxcbiAgICAgICAgICAgIHRpbWVEZWx0YSA9IG5vdyAtICh0aGlzLl90aW1lIHx8IDApO1xuXG4gICAgICAgIHRoaXMuX3BvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgICAgIHRoaXMuX3RpbWUgPSBub3c7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSAwICYmICh2YWx1ZSAlIDQuMDAwMjQ0MTQwNjI1KSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIG1vdXNlIHdoZWVsIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICd3aGVlbCc7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhpcyB2YWx1ZSB0byBtYXRjaCB0cmFja3BhZC5cbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IDAgJiYgTWF0aC5hYnModmFsdWUpIDwgNCkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIHRyYWNrcGFkIGV2ZW50IGJlY2F1c2UgaXQgaXMgc28gc21hbGwuXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ3RyYWNrcGFkJztcblxuICAgICAgICB9IGVsc2UgaWYgKHRpbWVEZWx0YSA+IDQwMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYSBuZXcgc2Nyb2xsIGFjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgdGltZW91dCBpbiBjYXNlIHRoaXMgd2FzIGEgc2luZ3VsYXIgZXZlbnQsIGFuZCBkZWx5IGl0IGJ5IHVwIHRvIDQwbXMuXG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9vblRpbWVvdXQsIDQwKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVwZWF0aW5nIGV2ZW50LCBidXQgd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBvZiBldmVudCBqdXN0IHlldC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWx0YSBwZXIgdGltZSBpcyBzbWFsbCwgd2UgYXNzdW1lIGl0J3MgYSBmYXN0IHRyYWNrcGFkOyBvdGhlcndpc2Ugd2Ugc3dpdGNoIGludG8gd2hlZWwgbW9kZS5cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSAoTWF0aC5hYnModGltZURlbHRhICogdmFsdWUpIDwgMjAwKSA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgb3VyIGRlbGF5ZWQgZXZlbnQgaXNuJ3QgZmlyZWQgYWdhaW4sIGJlY2F1c2Ugd2UgYWNjdW11bGF0ZVxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGV2ZW50ICh3aGljaCB3YXMgbGVzcyB0aGFuIDQwbXMgYWdvKSBpbnRvIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9sYXN0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbG93IGRvd24gem9vbSBpZiBzaGlmdCBrZXkgaXMgaGVsZCBmb3IgbW9yZSBwcmVjaXNlIHpvb21pbmdcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgdmFsdWUpIHZhbHVlID0gdmFsdWUgLyA0O1xuXG4gICAgICAgIC8vIE9ubHkgZmlyZSB0aGUgY2FsbGJhY2sgaWYgd2UgYWN0dWFsbHkga25vdyB3aGF0IHR5cGUgb2Ygc2Nyb2xsaW5nIGRldmljZSB0aGUgdXNlciB1c2VzLlxuICAgICAgICBpZiAodGhpcy5fdHlwZSkgdGhpcy5fem9vbSgtdmFsdWUpO1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uVGltZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90eXBlID0gJ3doZWVsJztcbiAgICAgICAgdGhpcy5fem9vbSgtdGhpcy5fbGFzdFZhbHVlKTtcbiAgICB9LFxuXG4gICAgX3pvb206IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIFNjYWxlIGJ5IHNpZ21vaWQgb2Ygc2Nyb2xsIHdoZWVsIGRlbHRhLlxuICAgICAgICB2YXIgc2NhbGUgPSAyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZGVsdGEgLyAxMDApKSk7XG4gICAgICAgIGlmIChkZWx0YSA8IDAgJiYgc2NhbGUgIT09IDApIHNjYWxlID0gMSAvIHNjYWxlO1xuXG4gICAgICAgIHZhciBmcm9tU2NhbGUgPSBtYXAuZWFzZSA/IG1hcC5lYXNlLnRvIDogbWFwLnRyYW5zZm9ybS5zY2FsZSxcbiAgICAgICAgICAgIHRhcmdldFpvb20gPSBtYXAudHJhbnNmb3JtLnNjYWxlWm9vbShmcm9tU2NhbGUgKiBzY2FsZSk7XG5cbiAgICAgICAgbWFwLnpvb21Ubyh0YXJnZXRab29tLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIGFyb3VuZDogbWFwLnVucHJvamVjdCh0aGlzLl9wb3MpXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG4gKiBBZGRzIHBvc2l0aW9uYWwgY29vcmRpbmF0ZXMgdG8gVVJMIGhhc2hlcy4gUGFzc2VkIGFzIGFuIG9wdGlvbiB0byB0aGUgbWFwIG9iamVjdFxuICpcbiAqIEBjbGFzcyBtYXBib3hnbC5IYXNoXG4gKiBAcmV0dXJucyB7SGFzaH0gYHRoaXNgXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcblxuZnVuY3Rpb24gSGFzaCgpIHtcbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX29uSGFzaENoYW5nZScsXG4gICAgICAgICdfdXBkYXRlSGFzaCdcbiAgICBdLCB0aGlzKTtcbn1cblxuSGFzaC5wcm90b3R5cGUgPSB7XG4gICAgLyogTWFwIGVsZW1lbnQgdG8gbGlzdGVuIGZvciBjb29yZGluYXRlIGNoYW5nZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBcbiAgICAgKiBAcmV0dXJucyB7SGFzaH0gYHRoaXNgXG4gICAgICovXG4gICAgYWRkVG86IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5fb25IYXNoQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZUhhc2gpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyogUmVtb3ZlcyBoYXNoXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5fb25IYXNoQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ21vdmVlbmQnLCB0aGlzLl91cGRhdGVIYXNoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21hcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9vbkhhc2hDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9jID0gbG9jYXRpb24uaGFzaC5yZXBsYWNlKCcjJywgJycpLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChsb2MubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5qdW1wVG8oe1xuICAgICAgICAgICAgICAgIGNlbnRlcjogWytsb2NbMV0sICtsb2NbMl1dLFxuICAgICAgICAgICAgICAgIHpvb206ICtsb2NbMF0sXG4gICAgICAgICAgICAgICAgYmVhcmluZzogKyhsb2NbM10gfHwgMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlSGFzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCksXG4gICAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgIGJlYXJpbmcgPSB0aGlzLl9tYXAuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKE1hdGgubG9nKHpvb20pIC8gTWF0aC5MTjIpKSxcblxuICAgICAgICAgICAgaGFzaCA9ICcjJyArIChNYXRoLnJvdW5kKHpvb20gKiAxMDApIC8gMTAwKSArXG4gICAgICAgICAgICAgICAgJy8nICsgY2VudGVyLmxhdC50b0ZpeGVkKHByZWNpc2lvbikgK1xuICAgICAgICAgICAgICAgICcvJyArIGNlbnRlci5sbmcudG9GaXhlZChwcmVjaXNpb24pICtcbiAgICAgICAgICAgICAgICAoYmVhcmluZyA/ICcvJyArIChNYXRoLnJvdW5kKGJlYXJpbmcgKiAxMCkgLyAxMCkgOiAnJyk7XG5cbiAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKCcnLCAnJywgaGFzaCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhbmRsZXJzID0ge1xuICAgIHNjcm9sbFpvb206IHJlcXVpcmUoJy4vaGFuZGxlci9zY3JvbGxfem9vbScpLFxuICAgIGJveFpvb206IHJlcXVpcmUoJy4vaGFuZGxlci9ib3hfem9vbScpLFxuICAgIGRyYWdSb3RhdGU6IHJlcXVpcmUoJy4vaGFuZGxlci9kcmFnX3JvdGF0ZScpLFxuICAgIGRyYWdQYW46IHJlcXVpcmUoJy4vaGFuZGxlci9kcmFnX3BhbicpLFxuICAgIGtleWJvYXJkOiByZXF1aXJlKCcuL2hhbmRsZXIva2V5Ym9hcmQnKSxcbiAgICBkb3VibGVDbGlja1pvb206IHJlcXVpcmUoJy4vaGFuZGxlci9kYmxjbGlja196b29tJyksXG4gICAgcGluY2g6IHJlcXVpcmUoJy4vaGFuZGxlci9waW5jaCcpXG59O1xuXG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJhY3Rpb247XG5cbi8qKlxuICogTW91c2UgbW92ZSBldmVudC5cbiAqXG4gKiBAZXZlbnQgbW91c2Vtb3ZlXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtQb2ludH0gcG9pbnQgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBldmVudFxuICogQHByb3BlcnR5IHtMYXRMbmd9IHBvaW50IHRoZSBnZW9ncmFwaGljIGxvY2F0aW9uIG9mIHRoZSBldmVudFxuICogQHByb3BlcnR5IHtFdmVudH0gb3JpZ2luYWxFdmVudCB0aGUgb3JpZ2luYWwgRE9NIGV2ZW50XG4gKi9cblxuLyoqXG4gKiBDbGljayBldmVudC5cbiAqXG4gKiBAZXZlbnQgY2xpY2tcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1BvaW50fSBwb2ludCB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge0xhdExuZ30gcG9pbnQgdGhlIGdlb2dyYXBoaWMgbG9jYXRpb24gb2YgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IHRoZSBvcmlnaW5hbCBET00gZXZlbnRcbiAqL1xuXG4vKipcbiAqIERvdWJsZSBjbGljayBldmVudC5cbiAqXG4gKiBAZXZlbnQgZGJsY2xpY2tcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1BvaW50fSBwb2ludCB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge0xhdExuZ30gcG9pbnQgdGhlIGdlb2dyYXBoaWMgbG9jYXRpb24gb2YgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge0V2ZW50fSBvcmlnaW5hbEV2ZW50IHRoZSBvcmlnaW5hbCBET00gZXZlbnRcbiAqL1xuXG5mdW5jdGlvbiBJbnRlcmFjdGlvbihtYXApIHtcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGhhbmRsZXJzKSB7XG4gICAgICAgIG1hcFtuYW1lXSA9IG5ldyBoYW5kbGVyc1tuYW1lXShtYXApO1xuICAgIH1cblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5JbnRlcmFjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fbWFwLm9wdGlvbnMsXG4gICAgICAgICAgICBlbCA9IHRoaXMuX2VsO1xuXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW25hbWVdKSB0aGlzLl9tYXBbbmFtZV0uZW5hYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgZmFsc2UpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljaywgZmFsc2UpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuX29uRGJsQ2xpY2ssIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX21hcC5vcHRpb25zLFxuICAgICAgICAgICAgZWwgPSB0aGlzLl9lbDtcblxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uc1tuYW1lXSkgdGhpcy5fbWFwW25hbWVdLmRpc2FibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLl9vbkRibENsaWNrKTtcbiAgICB9LFxuXG4gICAgX29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9zdGFydFBvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgfSxcblxuICAgIF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggPiAxKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLl90YXBwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcHBlZCA9IHNldFRpbWVvdXQodGhpcy5fb25UaW1lb3V0LCAzMDApO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGFwcGVkKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcHBlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2RibGNsaWNrJywgZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uVGltZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXBwZWQgPSBudWxsO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gICAgICAgICAgICBlbCA9IHRoaXMuX2VsO1xuXG4gICAgICAgIGlmIChtYXAuZHJhZ1Bhbi5hY3RpdmUgfHwgbWFwLmRyYWdSb3RhdGUuYWN0aXZlKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IGUudG9FbGVtZW50IHx8IGUudGFyZ2V0O1xuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gZWwpIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSBlbCkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnbW91c2Vtb3ZlJywgZSk7XG4gICAgfSxcblxuICAgIF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcblxuICAgICAgICBpZiAocG9zLmVxdWFscyh0aGlzLl9zdGFydFBvcykpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnY2xpY2snLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25EYmxDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdkYmxjbGljaycsIGUpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIF9maXJlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgIHZhciBwb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuXG4gICAgICAgIHRoaXMuX21hcC5maXJlKHR5cGUsIHtcbiAgICAgICAgICAgIGxhdExuZzogdGhpcy5fbWFwLnVucHJvamVjdChwb3MpLFxuICAgICAgICAgICAgcG9pbnQ6IHBvcyxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbnZhcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2FudmFzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKTtcblxudmFyIFN0eWxlID0gcmVxdWlyZSgnLi4vc3R5bGUvc3R5bGUnKTtcbnZhciBBbmltYXRpb25Mb29wID0gcmVxdWlyZSgnLi4vc3R5bGUvYW5pbWF0aW9uX2xvb3AnKTtcbnZhciBQYWludGVyID0gcmVxdWlyZSgnLi4vcmVuZGVyL3BhaW50ZXInKTtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL2dlby90cmFuc2Zvcm0nKTtcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG5cbnZhciBJbnRlcmFjdGlvbiA9IHJlcXVpcmUoJy4vaW50ZXJhY3Rpb24nKTtcblxudmFyIENhbWVyYSA9IHJlcXVpcmUoJy4vY2FtZXJhJyk7XG52YXIgTGF0TG5nID0gcmVxdWlyZSgnLi4vZ2VvL2xhdF9sbmcnKTtcbnZhciBMYXRMbmdCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW8vbGF0X2xuZ19ib3VuZHMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgQXR0cmlidXRpb24gPSByZXF1aXJlKCcuL2NvbnRyb2wvYXR0cmlidXRpb24nKTtcblxuLyoqXG4gKiBPcHRpb25zIGNvbW1vbiB0byBNYXAjYWRkQ2xhc3MsIE1hcCNyZW1vdmVDbGFzcywgYW5kIE1hcCNzZXRDbGFzc2VzLCBjb250cm9sbGluZ1xuICogd2hldGhlciBvciBub3QgdG8gc21vb3RobHkgdHJhbnNpdGlvbiBwcm9wZXJ0eSBjaGFuZ2VzIHRyaWdnZXJlZCBieSB0aGUgY2xhc3MgY2hhbmdlLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0eWxlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSB0cmFuc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlLlxuICogQGNsYXNzIE1hcFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNvbnRhaW5lciBIVE1MIGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSB0aGUgbWFwIGluIChvciBlbGVtZW50IGlkIGFzIHN0cmluZylcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5ab29tPTBdIE1pbmltdW0gem9vbSBvZiB0aGUgbWFwXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4Wm9vbT0yMF0gTWF4aW11bSB6b29tIG9mIHRoZSBtYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnN0eWxlIE1hcCBzdHlsZSBhbmQgZGF0YSBzb3VyY2UgZGVmaW5pdGlvbiAoZWl0aGVyIGEgSlNPTiBvYmplY3Qgb3IgYSBKU09OIFVSTCksIGRlc2NyaWJlZCBpbiB0aGUgW3N0eWxlIHJlZmVyZW5jZV0oaHR0cHM6Ly9tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGFzaD1mYWxzZV0gSWYgYHRydWVgLCB0aGUgbWFwIHdpbGwgdHJhY2sgYW5kIHVwZGF0ZSB0aGUgcGFnZSBVUkwgYWNjb3JkaW5nIHRvIG1hcCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbnRlcmFjdGl2ZT10cnVlXSBJZiBgZmFsc2VgLCBubyBtb3VzZSwgdG91Y2gsIG9yIGtleWJvYXJkIGxpc3RlbmVycyBhcmUgYXR0YWNoZWQgdG8gdGhlIG1hcCwgc28gaXQgd2lsbCBub3QgcmVzcG9uZCB0byBpbnB1dFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJlYXJpbmdTbmFwPTddIFNuYXAgdG8gbm9ydGggdGhyZXNob2xkIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmNsYXNzZXMgU3R5bGUgY2xhc3MgbmFtZXMgd2l0aCB3aGljaCB0byBpbml0aWFsaXplIHRoZSBtYXBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdD1mYWxzZV0gSWYgYHRydWVgLCBtYXAgY3JlYXRpb24gd2lsbCBmYWlsIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBkZXRlcm1pbmVzIHRoYXQgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBjcmVhdGVkIFdlYkdMIGNvbnRleHQgd291bGQgYmUgZHJhbWF0aWNhbGx5IGxvd2VyIHRoYW4gZXhwZWN0ZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV0gSWYgYHRydWVgLCBUaGUgbWFwcyBjYW52YXMgY2FuIGJlIGV4cG9ydGVkIHRvIGEgUE5HIHVzaW5nIGBtYXAuZ2V0Q2FudmFzKCkudG9EYXRhVVJMKCk7YC4gVGhpcyBpcyBmYWxzZSBieSBkZWZhdWx0IGFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBtYXAgPSBuZXcgbWFwYm94Z2wuTWFwKHtcbiAqICAgY29udGFpbmVyOiAnbWFwJyxcbiAqICAgY2VudGVyOiBbMzcuNzcyNTM3LCAtMTIyLjQyMDY3OV0sXG4gKiAgIHpvb206IDEzLFxuICogICBzdHlsZTogc3R5bGVfb2JqZWN0LFxuICogICBoYXNoOiB0cnVlXG4gKiB9KTtcbiAqL1xudmFyIE1hcCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IHV0aWwuaW5oZXJpdCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gbmV3IEFuaW1hdGlvbkxvb3AoKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20pO1xuXG4gICAgaWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XG4gICAgICAgIHZhciBiID0gTGF0TG5nQm91bmRzLmNvbnZlcnQob3B0aW9ucy5tYXhCb3VuZHMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5sYXRSYW5nZSA9IFtiLmdldFNvdXRoKCksIGIuZ2V0Tm9ydGgoKV07XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmxuZ1JhbmdlID0gW2IuZ2V0V2VzdCgpLCBiLmdldEVhc3QoKV07XG4gICAgfVxuXG4gICAgdXRpbC5iaW5kQWxsKFtcbiAgICAgICAgJ19mb3J3YXJkU3R5bGVFdmVudCcsXG4gICAgICAgICdfZm9yd2FyZFNvdXJjZUV2ZW50JyxcbiAgICAgICAgJ19mb3J3YXJkTGF5ZXJFdmVudCcsXG4gICAgICAgICdfZm9yd2FyZFRpbGVFdmVudCcsXG4gICAgICAgICdfb25TdHlsZUxvYWQnLFxuICAgICAgICAnX29uU3R5bGVDaGFuZ2UnLFxuICAgICAgICAnX29uU291cmNlQWRkJyxcbiAgICAgICAgJ19vblNvdXJjZVJlbW92ZScsXG4gICAgICAgICdfb25Tb3VyY2VVcGRhdGUnLFxuICAgICAgICAndXBkYXRlJyxcbiAgICAgICAgJ3JlbmRlcidcbiAgICBdLCB0aGlzKTtcblxuICAgIHRoaXMuX3NldHVwQ29udGFpbmVyKCk7XG4gICAgdGhpcy5fc2V0dXBQYWludGVyKCk7XG5cbiAgICB0aGlzLm9uKCdtb3ZlJywgdGhpcy51cGRhdGUpO1xuICAgIHRoaXMub24oJ3pvb20nLCB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMsIHRydWUpKTtcbiAgICB0aGlzLm9uKCdtb3ZlZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zZXQoMzAwKTsgLy8gdGV4dCBmYWRpbmdcbiAgICAgICAgdGhpcy5fcmVyZW5kZXIoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKS5yZXNpemUoKS51cGRhdGUoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IG5ldyBJbnRlcmFjdGlvbih0aGlzKTtcblxuICAgIGlmIChvcHRpb25zLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24uZW5hYmxlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5faGFzaCA9IG9wdGlvbnMuaGFzaCAmJiAobmV3IEhhc2goKSkuYWRkVG8odGhpcyk7XG4gICAgLy8gZG9uJ3Qgc2V0IHBvc2l0aW9uIGZyb20gb3B0aW9ucyBpZiBzZXQgdGhyb3VnaCBoYXNoXG4gICAgaWYgKCF0aGlzLl9oYXNoIHx8ICF0aGlzLl9oYXNoLl9vbkhhc2hDaGFuZ2UoKSkge1xuICAgICAgICB0aGlzLmp1bXBUbyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZXMgPSB7fTtcbiAgICB0aGlzLnN0YWNrcyA9IHt9O1xuICAgIHRoaXMuX2NsYXNzZXMgPSB7fTtcblxuICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICBpZiAob3B0aW9ucy5jbGFzc2VzKSB0aGlzLnNldENsYXNzZXMob3B0aW9ucy5jbGFzc2VzKTtcbiAgICBpZiAob3B0aW9ucy5zdHlsZSkgdGhpcy5zZXRTdHlsZShvcHRpb25zLnN0eWxlKTtcbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHRoaXMuYWRkQ29udHJvbChuZXcgQXR0cmlidXRpb24oKSk7XG59O1xuXG51dGlsLmV4dGVuZChNYXAucHJvdG90eXBlLCBFdmVudGVkKTtcbnV0aWwuZXh0ZW5kKE1hcC5wcm90b3R5cGUsIENhbWVyYS5wcm90b3R5cGUpO1xudXRpbC5leHRlbmQoTWFwLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBNYXAucHJvdG90eXBlICove1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAgICAgICAgem9vbTogMCxcbiAgICAgICAgYmVhcmluZzogMCxcbiAgICAgICAgcGl0Y2g6IDAsXG5cbiAgICAgICAgbWluWm9vbTogMCxcbiAgICAgICAgbWF4Wm9vbTogMjAsXG5cbiAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG5cbiAgICAgICAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgICAgICAgYm94Wm9vbTogdHJ1ZSxcbiAgICAgICAgZHJhZ1JvdGF0ZTogdHJ1ZSxcbiAgICAgICAgZHJhZ1BhbjogdHJ1ZSxcbiAgICAgICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgICAgIGRvdWJsZUNsaWNrWm9vbTogdHJ1ZSxcbiAgICAgICAgcGluY2g6IHRydWUsXG5cbiAgICAgICAgYmVhcmluZ1NuYXA6IDcsXG5cbiAgICAgICAgaGFzaDogZmFsc2UsXG5cbiAgICAgICAgYXR0cmlidXRpb25Db250cm9sOiB0cnVlLFxuXG4gICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IGZhbHNlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXG4gICAgfSxcblxuICAgIGFkZENvbnRyb2w6IGZ1bmN0aW9uKGNvbnRyb2wpIHtcbiAgICAgICAgY29udHJvbC5hZGRUbyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdHlsZSBjbGFzcyB0byBhIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtsYXNzIG5hbWUgb2Ygc3R5bGUgY2xhc3NcbiAgICAgKiBAcGFyYW0ge1N0eWxlT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIGNoYW5nZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbihrbGFzcywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5fY2xhc3Nlc1trbGFzc10pIHJldHVybjtcbiAgICAgICAgdGhpcy5fY2xhc3Nlc1trbGFzc10gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdHlsZSkgdGhpcy5zdHlsZS5fY2FzY2FkZSh0aGlzLl9jbGFzc2VzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHN0eWxlIGNsYXNzIGZyb20gYSBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrbGFzcyBuYW1lIG9mIHN0eWxlIGNsYXNzXG4gICAgICogQHBhcmFtIHtTdHlsZU9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBmaXJlcyBjaGFuZ2VcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oa2xhc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jbGFzc2VzW2tsYXNzXSkgcmV0dXJuO1xuICAgICAgICBkZWxldGUgdGhpcy5fY2xhc3Nlc1trbGFzc107XG4gICAgICAgIGlmICh0aGlzLnN0eWxlKSB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCBtb3JlIHRoYW4gb25lIGNsYXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGtsYXNzZXMgQW4gYXJyYXkgb2YgY2xhc3MgbmFtZXNcbiAgICAgKiBAcGFyYW0ge1N0eWxlT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIGNoYW5nZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldENsYXNzZXM6IGZ1bmN0aW9uKGtsYXNzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY2xhc3NlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2NsYXNzZXNba2xhc3Nlc1tpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0eWxlKSB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIGEgc3R5bGUgY2xhc3MgaXMgYWN0aXZlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2xhc3MgTmFtZSBvZiBzdHlsZSBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihrbGFzcykge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jbGFzc2VzW2tsYXNzXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IGFjdGl2ZSBzdHlsZSBjbGFzc2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXRDbGFzc2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2NsYXNzZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgdGhlIG1hcCdzIG5ldyB3aWR0aCBhbmQgaGVpZ2h0IGFuZCByZXNpemUgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2lkdGggPSAwLCBoZWlnaHQgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoIHx8IDQwMDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgfHwgMzAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FudmFzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLnRyYW5zZm9ybS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLl9jb25zdHJhaW4oKTtcblxuICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAuZmlyZSgnbW92ZXN0YXJ0JylcbiAgICAgICAgICAgIC5maXJlKCdtb3ZlJylcbiAgICAgICAgICAgIC5maXJlKCdyZXNpemUnKVxuICAgICAgICAgICAgLmZpcmUoJ21vdmVlbmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtYXAncyBnZW9ncmFwaGljYWwgYm91bmRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TGF0TG5nQm91bmRzfVxuICAgICAqL1xuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihuZXcgUG9pbnQoMCwgMCkpLFxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbih0aGlzLnRyYW5zZm9ybS5zaXplKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBwaXhlbCBjb29yZGluYXRlcyAocmVsYXRpdmUgdG8gbWFwIGNvbnRhaW5lcikgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGF0TG5nfSBsYXRsbmdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBgeGAgYW5kIGB5YCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIHByb2plY3Q6IGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubG9jYXRpb25Qb2ludChMYXRMbmcuY29udmVydChsYXRsbmcpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBnaXZlbiBwaXhlbCBjb29yZGluYXRlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwb2ludCBbeCwgeV0gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyB7TGF0TG5nfVxuICAgICAqL1xuICAgIHVucHJvamVjdDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24oUG9pbnQuY29udmVydChwb2ludCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGZlYXR1cmVzIGF0IGEgcG9pbnQgKFt4LCB5XSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcG9pbnQgW3gsIHldIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnJhZGl1cz0wXSBPcHRpb25hbC4gUmFkaXVzIGluIHBpeGVscyB0byBzZWFyY2ggaW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmxheWVyIE9wdGlvbmFsLiBPbmx5IHJldHVybiBmZWF0dXJlcyBmcm9tIGEgZ2l2ZW4gbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnR5cGUgT3B0aW9uYWwuIEVpdGhlciBgcmFzdGVyYCBvciBgdmVjdG9yYFxuICAgICAqIEBwYXJhbSB7ZmVhdHVyZXNBdENhbGxiYWNrfSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3BvbnNlXG4gICAgICpcbiAgICAgKiBAY2FsbGJhY2sgZmVhdHVyZXNBdENhbGxiYWNrXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gZXJyIEVycm9yIF9JZiBhbnlfXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmVhdHVyZXMgRGlzcGxheXMgYSBKU09OIGFycmF5IG9mIGZlYXR1cmVzIGdpdmVuIHRoZSBwYXNzZWQgcGFyYW1ldGVycyBvZiBgZmVhdHVyZXNBdGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtYXAuZmVhdHVyZXNBdChbMTAsIDIwXSwgeyByYWRpdXM6IDEwIH0sIGZ1bmN0aW9uKGVyciwgZmVhdHVyZXMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGZlYXR1cmVzKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmZWF0dXJlc0F0OiBmdW5jdGlvbihwb2ludCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybS5wb2ludENvb3JkaW5hdGUoUG9pbnQuY29udmVydChwb2ludCkpO1xuICAgICAgICB0aGlzLnN0eWxlLmZlYXR1cmVzQXQoY29vcmQsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgbXVsdGlwbGUgc3R5bGUgbXV0YXRpb25zIGluIGEgYmF0Y2hcbiAgICAgKlxuICAgICAqIG1hcC5iYXRjaChmdW5jdGlvbiAoYmF0Y2gpIHtcbiAgICAgKiAgICAgYmF0Y2guYWRkTGF5ZXIobGF5ZXIxKTtcbiAgICAgKiAgICAgYmF0Y2guYWRkTGF5ZXIobGF5ZXIyKTtcbiAgICAgKiAgICAgLi4uXG4gICAgICogICAgIGJhdGNoLmFkZExheWVyKGxheWVyTik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB3b3JrIEZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgdGhlIFN0eWxlQmF0Y2ggaW50ZXJmYWNlXG4gICAgICovXG4gICAgYmF0Y2g6IGZ1bmN0aW9uKHdvcmspIHtcbiAgICAgICAgdGhpcy5zdHlsZS5iYXRjaCh3b3JrKTtcblxuICAgICAgICB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgdGhlIG1hcCdzIHN0eWxlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEEgc3R5bGUgb2JqZWN0IGZvcm1hdHRlZCBhcyBKU09OXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlXG4gICAgICAgICAgICAgICAgLm9mZignbG9hZCcsIHRoaXMuX29uU3R5bGVMb2FkKVxuICAgICAgICAgICAgICAgIC5vZmYoJ2Vycm9yJywgdGhpcy5fZm9yd2FyZFN0eWxlRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZignY2hhbmdlJywgdGhpcy5fb25TdHlsZUNoYW5nZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdzb3VyY2UuYWRkJywgdGhpcy5fb25Tb3VyY2VBZGQpXG4gICAgICAgICAgICAgICAgLm9mZignc291cmNlLnJlbW92ZScsIHRoaXMuX29uU291cmNlUmVtb3ZlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5sb2FkJywgdGhpcy5fb25Tb3VyY2VVcGRhdGUpXG4gICAgICAgICAgICAgICAgLm9mZignc291cmNlLmVycm9yJywgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5jaGFuZ2UnLCB0aGlzLl9vblNvdXJjZVVwZGF0ZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdsYXllci5hZGQnLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCdsYXllci5yZW1vdmUnLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCd0aWxlLmFkZCcsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZigndGlsZS5yZW1vdmUnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUubG9hZCcsIHRoaXMudXBkYXRlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUuZXJyb3InLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5fcmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHRoaXMub2ZmKCdyb3RhdGUnLCB0aGlzLnN0eWxlLl9yZWRvUGxhY2VtZW50KTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdwaXRjaCcsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSBpbnN0YW5jZW9mIFN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKHN0eWxlLCB0aGlzLmFuaW1hdGlvbkxvb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdHlsZVxuICAgICAgICAgICAgLm9uKCdsb2FkJywgdGhpcy5fb25TdHlsZUxvYWQpXG4gICAgICAgICAgICAub24oJ2Vycm9yJywgdGhpcy5fZm9yd2FyZFN0eWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ2NoYW5nZScsIHRoaXMuX29uU3R5bGVDaGFuZ2UpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5hZGQnLCB0aGlzLl9vblNvdXJjZUFkZClcbiAgICAgICAgICAgIC5vbignc291cmNlLnJlbW92ZScsIHRoaXMuX29uU291cmNlUmVtb3ZlKVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UubG9hZCcsIHRoaXMuX29uU291cmNlVXBkYXRlKVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UuZXJyb3InLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5jaGFuZ2UnLCB0aGlzLl9vblNvdXJjZVVwZGF0ZSlcbiAgICAgICAgICAgIC5vbignbGF5ZXIuYWRkJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpXG4gICAgICAgICAgICAub24oJ2xheWVyLnJlbW92ZScsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmFkZCcsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUucmVtb3ZlJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5sb2FkJywgdGhpcy51cGRhdGUpXG4gICAgICAgICAgICAub24oJ3RpbGUuZXJyb3InLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KTtcblxuICAgICAgICB0aGlzLm9uKCdyb3RhdGUnLCB0aGlzLnN0eWxlLl9yZWRvUGxhY2VtZW50KTtcbiAgICAgICAgdGhpcy5vbigncGl0Y2gnLCB0aGlzLnN0eWxlLl9yZWRvUGxhY2VtZW50KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgc291cmNlIHRvIHRoZSBtYXAgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIHNvdXJjZS4gTXVzdCBub3QgYmUgdXNlZCBieSBhbnkgZXhpc3Rpbmcgc291cmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2Ugc291cmNlIHNwZWNpZmljYXRpb24sIGZvbGxvd2luZyB0aGVcbiAgICAgKiBbTWFwYm94IEdMIFN0eWxlIFJlZmVyZW5jZV0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jc291cmNlcylcbiAgICAgKiBAZmlyZXMgc291cmNlLmFkZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZFNvdXJjZTogZnVuY3Rpb24oaWQsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnN0eWxlLmFkZFNvdXJjZShpZCwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBleGlzdGluZyBzb3VyY2UgZnJvbSB0aGUgbWFwIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBzb3VyY2UgdG8gcmVtb3ZlXG4gICAgICogQGZpcmVzIHNvdXJjZS5yZW1vdmVcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmVTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHRoaXMuc3R5bGUucmVtb3ZlU291cmNlKGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3R5bGUgc291cmNlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgaWRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHNvdXJjZSBJRFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRTb3VyY2UoaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsYXllciB0byB0aGUgbWFwIHN0eWxlLiBUaGUgbGF5ZXIgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGxheWVyIHdpdGhcbiAgICAgKiBJRCBgYmVmb3JlYCwgb3IgYXBwZW5kZWQgaWYgYGJlZm9yZWAgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1N0eWxlTGF5ZXJ8T2JqZWN0fSBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYmVmb3JlICBJRCBvZiBhbiBleGlzdGluZyBsYXllciB0byBpbnNlcnQgYmVmb3JlXG4gICAgICogQGZpcmVzIGxheWVyLmFkZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZExheWVyOiBmdW5jdGlvbihsYXllciwgYmVmb3JlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuYWRkTGF5ZXIobGF5ZXIsIGJlZm9yZSk7XG4gICAgICAgIHRoaXMuc3R5bGUuX2Nhc2NhZGUodGhpcy5fY2xhc3Nlcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGBpZGAgZnJvbSB0aGUgbWFwLiBBbnkgbGF5ZXJzIHdoaWNoIHJlZmVyIHRvIHRoZVxuICAgICAqIHNwZWNpZmllZCBsYXllciB2aWEgYSBgcmVmYCBwcm9wZXJ0eSBhcmUgYWxzbyByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGxheWVyIGlkXG4gICAgICogQGZpcmVzIGxheWVyLnJlbW92ZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IHRoaXNcbiAgICAgKi9cbiAgICByZW1vdmVMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5yZW1vdmVMYXllcihpZCk7XG4gICAgICAgIHRoaXMuc3R5bGUuX2Nhc2NhZGUodGhpcy5fY2xhc3Nlcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZpbHRlciBmb3IgYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBJRCBvZiBhIGxheWVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVyIGZpbHRlciBzcGVjaWZpY2F0aW9uLCBhcyBkZWZpbmVkIGluIHRoZSBbU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jZmlsdGVyKVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldEZpbHRlcjogZnVuY3Rpb24obGF5ZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLnN0eWxlLnNldEZpbHRlcihsYXllciwgZmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlsdGVyIGZvciBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGZpbHRlciBzcGVjaWZpY2F0aW9uLCBhcyBkZWZpbmVkIGluIHRoZSBbU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jZmlsdGVyKVxuICAgICAqL1xuICAgIGdldEZpbHRlcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0RmlsdGVyKGxheWVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhIHBhaW50IHByb3BlcnR5IGluIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgYSBwYWludCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgZm9yIHRoZSBwYWludCBwcm9wZXJ5OyBtdXN0IGhhdmUgdGhlIHR5cGUgYXBwcm9wcmlhdGUgZm9yIHRoZSBwcm9wZXJ0eSBhcyBkZWZpbmVkIGluIHRoZSBbU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8pXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBrbGFzcyBvcHRpb25hbCBjbGFzcyBzcGVjaWZpZXIgZm9yIHRoZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lLCB2YWx1ZSwga2xhc3MpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5zZXRQYWludFByb3BlcnR5KGxheWVyLCBuYW1lLCB2YWx1ZSwga2xhc3MpO1xuICAgICAgICB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgYSBwYWludCBwcm9wZXJ0eSBpbiBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGEgcGFpbnQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGtsYXNzIG9wdGlvbmFsIGNsYXNzIHNwZWNpZmllciBmb3IgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybnMgeyp9IHZhbHVlIGZvciB0aGUgcGFpbnQgcHJvcGVyeVxuICAgICAqL1xuICAgIGdldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lLCBrbGFzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRQYWludFByb3BlcnR5KGxheWVyLCBuYW1lLCBrbGFzcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYSBsYXlvdXQgcHJvcGVydHkgaW4gYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBJRCBvZiBhIGxheWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBhIGxheW91dCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgdmFsdWUgZm9yIHRoZSBsYXlvdXQgcHJvcGVyeTsgbXVzdCBoYXZlIHRoZSB0eXBlIGFwcHJvcHJpYXRlIGZvciB0aGUgcHJvcGVydHkgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvKVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5zZXRMYXlvdXRQcm9wZXJ0eShsYXllciwgbmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiBhIGxheW91dCBwcm9wZXJ0eSBpbiBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGEgbGF5b3V0IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBrbGFzcyBvcHRpb25hbCBjbGFzcyBzcGVjaWZpZXIgZm9yIHRoZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHsqfSB2YWx1ZSBmb3IgdGhlIGxheW91dCBwcm9wZXJ5XG4gICAgICovXG4gICAgZ2V0TGF5b3V0UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldExheW91dFByb3BlcnR5KGxheWVyLCBuYW1lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBNYXAncyBjb250YWluZXIgYXMgYW4gSFRNTCBlbGVtZW50XG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAgICAgKi9cbiAgICBnZXRDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbnRhaW5lciBmb3IgdGhlIG1hcCBgY2FudmFzYCBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgdG8gYWRkIG5vbi1HTCBvdmVybGF5cyB0byB0aGUgbWFwLCB5b3Ugc2hvdWxkIGFwcGVuZCB0aGVtIHRvIHRoaXMgZWxlbWVudC4gVGhpc1xuICAgICAqIGlzIHRoZSBlbGVtZW50IHRvIHdoaWNoIGV2ZW50IGJpbmRpbmdzIGZvciBtYXAgaW50ZXJhY3Rpdml0eSBzdWNoIGFzIHBhbm5pbmcgYW5kIHpvb21pbmcgYXJlXG4gICAgICogYXR0YWNoZWQuIEl0IHdpbGwgcmVjZWl2ZSBidWJibGVkIGV2ZW50cyBmb3IgY2hpbGQgZWxlbWVudHMgc3VjaCBhcyB0aGUgYGNhbnZhc2AsIGJ1dCBub3QgZm9yXG4gICAgICogbWFwIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAgICAgKi9cbiAgICBnZXRDYW52YXNDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzQ29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIE1hcCdzIGNhbnZhcyBhcyBhbiBIVE1MIGNhbnZhc1xuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gY2FudmFzXG4gICAgICovXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcy5nZXRFbGVtZW50KCk7XG4gICAgfSxcblxuICAgIF9zZXR1cENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLW1hcCcpO1xuXG4gICAgICAgIHZhciBjYW52YXNDb250YWluZXIgPSB0aGlzLl9jYW52YXNDb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtY2FudmFzLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1pbnRlcmFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IG5ldyBDYW52YXModGhpcywgY2FudmFzQ29udGFpbmVyKTtcblxuICAgICAgICB2YXIgY29udHJvbENvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1jb250cm9sLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fTtcbiAgICAgICAgWyd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICBjb3JuZXJzW3Bvc10gPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtY3RybC0nICsgcG9zLCBjb250cm9sQ29udGFpbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9zZXR1cFBhaW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLl9jYW52YXMuZ2V0V2ViR0xDb250ZXh0KHtcbiAgICAgICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRoaXMub3B0aW9ucy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0LFxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0aGlzLm9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFdlYkdMJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBuZXcgUGFpbnRlcihnbCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIH0sXG5cbiAgICBfY29udGV4dExvc3Q6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLl9mcmFtZUlkKSB7XG4gICAgICAgICAgICBicm93c2VyLmNhbmNlbEZyYW1lKHRoaXMuX2ZyYW1lSWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jb250ZXh0UmVzdG9yZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zZXR1cFBhaW50ZXIoKTtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBtYXAgZnVsbHkgbG9hZGVkPyBJZiB0aGUgc3R5bGUgaXNuJ3QgbG9hZGVkXG4gICAgICogb3IgaXQgaGFzIGEgY2hhbmdlIHRvIHRoZSBzb3VyY2VzIG9yIHN0eWxlIHRoYXQgaXNuJ3RcbiAgICAgKiBwcm9wYWdhdGVkIHRvIGl0cyBzdHlsZSwgcmV0dXJuIGZhbHNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIG1hcCBpcyBsb2FkZWRcbiAgICAgKi9cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fc3R5bGVEaXJ0eSB8fCB0aGlzLl9zb3VyY2VzRGlydHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlICYmICF0aGlzLnN0eWxlLmxvYWRlZCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoaXMgbWFwJ3Mgc3R5bGUgYW5kIHJlLXJlbmRlciB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZVN0eWxlIG5ldyBzdHlsZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IHRoaXNcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHVwZGF0ZVN0eWxlKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHlsZSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IHRoaXMuX3N0eWxlRGlydHkgfHwgdXBkYXRlU3R5bGU7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNEaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fcmVyZW5kZXIoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB3aGVuIGEgKHJlLSlyZW5kZXIgb2YgdGhlIG1hcCBpcyByZXF1aXJlZCwgZS5nLiB3aGVuIHRoZVxuICAgICAqIHVzZXIgcGFubmVkIG9yIHpvb21lZCxmIG9yIG5ldyBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7TWFwfSB0aGlzXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUgJiYgdGhpcy5fc3R5bGVEaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5fcmVjYWxjdWxhdGUodGhpcy50cmFuc2Zvcm0uem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiB0aGlzLl9zb3VyY2VzRGlydHkgJiYgIXRoaXMuX3NvdXJjZXNEaXJ0eVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc291cmNlc0RpcnR5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlc0RpcnR5VGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIDUwKTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuX3VwZGF0ZVNvdXJjZXModGhpcy50cmFuc2Zvcm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYWludGVyLnJlbmRlcih0aGlzLnN0eWxlLCB7XG4gICAgICAgICAgICBkZWJ1ZzogdGhpcy5kZWJ1ZyxcbiAgICAgICAgICAgIHZlcnRpY2VzOiB0aGlzLnZlcnRpY2VzLFxuICAgICAgICAgICAgcm90YXRpbmc6IHRoaXMucm90YXRpbmcsXG4gICAgICAgICAgICB6b29taW5nOiB0aGlzLnpvb21pbmdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdyZW5kZXInKTtcblxuICAgICAgICBpZiAodGhpcy5sb2FkZWQoKSAmJiAhdGhpcy5fbG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFtZUlkID0gbnVsbDtcblxuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uTG9vcC5zdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZXNEaXJ0eSB8fCB0aGlzLl9yZXBhaW50IHx8ICF0aGlzLmFuaW1hdGlvbkxvb3Auc3RvcHBlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBtYXAncyB1bmRlcmx5aW5nIHJlc291cmNlcywgaW5jbHVkaW5nIHdlYiB3b3JrZXJzLlxuICAgICAqIEByZXR1cm5zIHtNYXB9IHRoaXNcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzaCkgdGhpcy5faGFzaC5yZW1vdmUoKTtcbiAgICAgICAgYnJvd3Nlci5jYW5jZWxGcmFtZSh0aGlzLl9mcmFtZUlkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3NvdXJjZXNEaXJ0eVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JlcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUgJiYgIXRoaXMuX2ZyYW1lSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lSWQgPSBicm93c2VyLmZyYW1lKHRoaXMucmVuZGVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZm9yd2FyZFN0eWxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCdzdHlsZS4nICsgZS50eXBlLCB1dGlsLmV4dGVuZCh7c3R5bGU6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICBfZm9yd2FyZFNvdXJjZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZShlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzdHlsZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIF9mb3J3YXJkTGF5ZXJFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoZS50eXBlLCB1dGlsLmV4dGVuZCh7c3R5bGU6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICBfZm9yd2FyZFRpbGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoZS50eXBlLCB1dGlsLmV4dGVuZCh7c3R5bGU6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICBfb25TdHlsZUxvYWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5fY2FzY2FkZSh0aGlzLl9jbGFzc2VzLCB7dHJhbnNpdGlvbjogZmFsc2V9KTtcbiAgICAgICAgdGhpcy5fZm9yd2FyZFN0eWxlRXZlbnQoZSk7XG4gICAgfSxcblxuICAgIF9vblN0eWxlQ2hhbmdlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU3R5bGVFdmVudChlKTtcbiAgICB9LFxuXG4gICAgX29uU291cmNlQWRkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBlLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZS5vbkFkZClcbiAgICAgICAgICAgIHNvdXJjZS5vbkFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBfb25Tb3VyY2VSZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGUuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLm9uUmVtb3ZlKVxuICAgICAgICAgICAgc291cmNlLm9uUmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQoZSk7XG4gICAgfSxcblxuICAgIF9vblNvdXJjZVVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQoZSk7XG4gICAgfVxufSk7XG5cbnV0aWwuZXh0ZW5kQWxsKE1hcC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgTWFwLnByb3RvdHlwZSAqL3tcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBkZWJ1Z2dpbmcgbW9kZVxuICAgICAqXG4gICAgICogQG5hbWUgZGVidWdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfZGVidWc6IGZhbHNlLFxuICAgIGdldCBkZWJ1ZygpIHsgcmV0dXJuIHRoaXMuX2RlYnVnOyB9LFxuICAgIHNldCBkZWJ1Zyh2YWx1ZSkgeyB0aGlzLl9kZWJ1ZyA9IHZhbHVlOyB0aGlzLnVwZGF0ZSgpOyB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBjb2xsaXNpb24gYm94ZXM6IHVzZWZ1bCBmb3IgZGVidWdnaW5nIGxhYmVsIHBsYWNlbWVudFxuICAgICAqIGluIHN0eWxlcy5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbGxpc2lvbkRlYnVnXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgX2NvbGxpc2lvbkRlYnVnOiBmYWxzZSxcbiAgICBnZXQgY29sbGlzaW9uRGVidWcoKSB7IHJldHVybiB0aGlzLl9jb2xsaXNpb25EZWJ1ZzsgfSxcbiAgICBzZXQgY29sbGlzaW9uRGVidWcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29sbGlzaW9uRGVidWcgPSB2YWx1ZTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnN0eWxlLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuc291cmNlc1tpXS5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgY29udGludW91cyByZXBhaW50IHRvIGFuYWx5emUgcGVyZm9ybWFuY2VcbiAgICAgKlxuICAgICAqIEBuYW1lIHJlcGFpbnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfcmVwYWludDogZmFsc2UsXG4gICAgZ2V0IHJlcGFpbnQoKSB7IHJldHVybiB0aGlzLl9yZXBhaW50OyB9LFxuICAgIHNldCByZXBhaW50KHZhbHVlKSB7IHRoaXMuX3JlcGFpbnQgPSB2YWx1ZTsgdGhpcy51cGRhdGUoKTsgfSxcblxuICAgIC8vIHNob3cgdmVydGljZXNcbiAgICBfdmVydGljZXM6IGZhbHNlLFxuICAgIGdldCB2ZXJ0aWNlcygpIHsgcmV0dXJuIHRoaXMuX3ZlcnRpY2VzOyB9LFxuICAgIHNldCB2ZXJ0aWNlcyh2YWx1ZSkgeyB0aGlzLl92ZXJ0aWNlcyA9IHZhbHVlOyB0aGlzLnVwZGF0ZSgpOyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQb3B1cDtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKTtcbnZhciBMYXRMbmcgPSByZXF1aXJlKCcuLi9nZW8vbGF0X2xuZycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwb3B1cCBjb21wb25lbnRcbiAqIEBjbGFzcyBQb3B1cFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jbG9zZUJ1dHRvblxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNsb3NlT25DbGlja1xuICogQGV4YW1wbGVcbiAqIHZhciB0b29sdGlwID0gbmV3IG1hcGJveGdsLlBvcHVwKClcbiAqICAgLnNldExhdExuZyhtYXAudW5wcm9qZWN0KGUucG9pbnQpKVxuICogICAuc2V0SFRNTChcIjxoMT5IZWxsbyBXb3JsZCE8L2gxPlwiKVxuICogICAuYWRkVG8obWFwKTtcbiAqL1xuZnVuY3Rpb24gUG9wdXAob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX3VwZGF0ZVBvc2l0aW9uJyxcbiAgICAgICAgJ19vbkNsaWNrQ2xvc2UnXSxcbiAgICAgICAgdGhpcyk7XG59XG5cblBvcHVwLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCAvKiogQGxlbmRzIFBvcHVwLnByb3RvdHlwZSAqL3tcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGNsb3NlQnV0dG9uOiB0cnVlLFxuICAgICAgICBjbG9zZU9uQ2xpY2s6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdGhlIHBvcHVwIHRvIGEgbWFwXG4gICAgICogQHBhcmFtIHtNYXB9IG1hcFxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgYWRkVG86IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuX21hcC5vbignbW92ZScsIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLl9vbkNsaWNrQ2xvc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcG9wdXAgZnJvbSB0aGUgbWFwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9wdXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKS5hZGRUbyhtYXApO1xuICAgICAqIHBvcHVwLnJlbW92ZSgpO1xuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vZmYoJ21vdmUnLCB0aGlzLl91cGRhdGVQb3NpdGlvbik7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKCdjbGljaycsIHRoaXMuX29uQ2xpY2tDbG9zZSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb29yZGluYXRlcyBvZiBwb3B1cCBlbGVtZW50IHJlbGF0aXZlIHRvIG1hcFxuICAgICAqIEByZXR1cm5zIHtMYXRMbmd9XG4gICAgICovXG4gICAgZ2V0TGF0TG5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdExuZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiBhIHBvcHVwIGVsZW1lbnQgdG8gYSBtYXBcbiAgICAgKiBAcGFyYW0ge0xhdExuZ30gbGF0bG5nXG4gICAgICogQHJldHVybnMge1BvcHVwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRMYXRMbmc6IGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICB0aGlzLl9sYXRMbmcgPSBMYXRMbmcuY29udmVydChsYXRsbmcpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbGwgYSBwb3B1cCBlbGVtZW50IHdpdGggdGV4dCBvbmx5IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbGwgYSBwb3B1cCBlbGVtZW50IHdpdGggSFRNTCBjb250ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldEhUTUw6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgICB2YXIgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JvZHknKSwgY2hpbGQ7XG4gICAgICAgIHRlbXAuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNoaWxkID0gdGVtcC5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKCFjaGlsZCkgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLXBvcHVwJywgdGhpcy5fbWFwLmdldENvbnRhaW5lcigpKTtcblxuICAgICAgICAgICAgdGhpcy5fdGlwICAgICA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1wb3B1cC10aXAnLCAgICAgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZXIgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtcG9wdXAtY29udGVudCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZUJ1dHRvbiA9IERPTS5jcmVhdGUoJ2J1dHRvbicsICdtYXBib3hnbC1wb3B1cC1jbG9zZS1idXR0b24nLCB0aGlzLl93cmFwcGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJiMyMTU7JztcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tDbG9zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVDb250ZW50KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIF91cGRhdGVDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb250ZW50IHx8ICF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl93cmFwcGVyO1xuXG4gICAgICAgIHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9jbG9zZUJ1dHRvbik7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRlbnQpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xhdExuZyB8fCAhdGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9sYXRMbmcpLnJvdW5kKCksXG4gICAgICAgICAgICBhbmNob3IgPSB0aGlzLm9wdGlvbnMuYW5jaG9yO1xuXG4gICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgaWYgKHBvcy55IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gWyd0b3AnXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zLnkgPiB0aGlzLl9tYXAudHJhbnNmb3JtLmhlaWdodCAtIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IFsnYm90dG9tJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zLnggPCB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IucHVzaCgnbGVmdCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MueCA+IHRoaXMuX21hcC50cmFuc2Zvcm0ud2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IucHVzaCgncmlnaHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuY2hvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSAnYm90dG9tJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gYW5jaG9yLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmNob3JUcmFuc2xhdGUgPSB7XG4gICAgICAgICAgICAndG9wJzogJ3RyYW5zbGF0ZSgtNTAlLDApJyxcbiAgICAgICAgICAgICd0b3AtbGVmdCc6ICd0cmFuc2xhdGUoMCwwKScsXG4gICAgICAgICAgICAndG9wLXJpZ2h0JzogJ3RyYW5zbGF0ZSgtMTAwJSwwKScsXG4gICAgICAgICAgICAnYm90dG9tJzogJ3RyYW5zbGF0ZSgtNTAlLC0xMDAlKScsXG4gICAgICAgICAgICAnYm90dG9tLWxlZnQnOiAndHJhbnNsYXRlKDAsLTEwMCUpJyxcbiAgICAgICAgICAgICdib3R0b20tcmlnaHQnOiAndHJhbnNsYXRlKC0xMDAlLC0xMDAlKScsXG4gICAgICAgICAgICAnbGVmdCc6ICd0cmFuc2xhdGUoMCwtNTAlKScsXG4gICAgICAgICAgICAncmlnaHQnOiAndHJhbnNsYXRlKC0xMDAlLC01MCUpJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYW5jaG9yVHJhbnNsYXRlKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdtYXBib3hnbC1wb3B1cC1hbmNob3ItJyArIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtcG9wdXAtYW5jaG9yLScgKyBhbmNob3IpO1xuXG4gICAgICAgIERPTS5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCBhbmNob3JUcmFuc2xhdGVbYW5jaG9yXSArICcgdHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyk7XG4gICAgfSxcblxuICAgIF9vbkNsaWNrQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjdG9yO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBbQWN0b3IgZGVzaWduIHBhdHRlcm5dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWN0b3JfbW9kZWwpXG4gKiB0aGF0IG1haW50YWlucyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gYXN5bmNocm9ub3VzIHRhc2tzIGFuZCB0aGUgb2JqZWN0c1xuICogdGhhdCBzcGluIHRoZW0gb2ZmIC0gaW4gdGhpcyBjYXNlLCB0YXNrcyBsaWtlIHBhcnNpbmcgcGFydHMgb2Ygc3R5bGVzLFxuICogb3duZWQgYnkgdGhlIHN0eWxlc1xuICpcbiAqIEBwYXJhbSB7V2ViV29ya2VyfSB0YXJnZXRcbiAqIEBwYXJhbSB7V2ViV29ya2VyfSBwYXJlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEFjdG9yKHRhcmdldCwgcGFyZW50KSB7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLmNhbGxiYWNrSUQgPSAwO1xuICAgIHRoaXMucmVjZWl2ZSA9IHRoaXMucmVjZWl2ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLnJlY2VpdmUsIGZhbHNlKTtcbn1cblxuQWN0b3IucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdmFyIGRhdGEgPSBtZXNzYWdlLmRhdGEsXG4gICAgICAgIGNhbGxiYWNrO1xuXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJzxyZXNwb25zZT4nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbZGF0YS5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tkYXRhLmlkXTtcbiAgICAgICAgY2FsbGJhY2soZGF0YS5lcnJvciB8fCBudWxsLCBkYXRhLmRhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEuaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBpZCA9IGRhdGEuaWQ7XG4gICAgICAgIHRoaXMucGFyZW50W2RhdGEudHlwZV0oZGF0YS5kYXRhLCBmdW5jdGlvbihlcnIsIGRhdGEsIGJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICc8cmVzcG9uc2U+JyxcbiAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyID8gU3RyaW5nKGVycikgOiBudWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgIH0sIGJ1ZmZlcnMpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50W2RhdGEudHlwZV0oZGF0YS5kYXRhKTtcbiAgICB9XG59O1xuXG5BY3Rvci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCBidWZmZXJzKSB7XG4gICAgdmFyIGlkID0gbnVsbDtcbiAgICBpZiAoY2FsbGJhY2spIHRoaXMuY2FsbGJhY2tzW2lkID0gdGhpcy5jYWxsYmFja0lEKytdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wb3N0TWVzc2FnZSh7IHR5cGU6IHR5cGUsIGlkOiBTdHJpbmcoaWQpLCBkYXRhOiBkYXRhIH0sIGJ1ZmZlcnMpO1xufTtcblxuLyoqXG4gKiBXcmFwcGVkIHBvc3RNZXNzYWdlIEFQSSB0aGF0IGFic3RyYWN0cyBhcm91bmQgSUUncyBsYWNrIG9mXG4gKiBgdHJhbnNmZXJMaXN0YCBzdXBwb3J0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmZXJMaXN0XG4gKiBAcHJpdmF0ZVxuICovXG5BY3Rvci5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCB0cmFuc2Zlckxpc3QpIHtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLnRhcmdldC5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlckxpc3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy50YXJnZXQucG9zdE1lc3NhZ2UobWVzc2FnZSk7IC8vIE5vIHN1cHBvcnQgZm9yIHRyYW5zZmVyTGlzdCBvbiBJRVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZ2V0SlNPTiA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgIH07XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCAmJiB4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZCgpO1xuICAgIHJldHVybiB4aHI7XG59O1xuXG5leHBvcnRzLmdldEFycmF5QnVmZmVyID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgfTtcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwICYmIHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZCgpO1xuICAgIHJldHVybiB4aHI7XG59O1xuXG5mdW5jdGlvbiBzYW1lT3JpZ2luKHVybCkge1xuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGEuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gYS5wcm90b2NvbCA9PT0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgJiYgYS5ob3N0ID09PSBkb2N1bWVudC5sb2NhdGlvbi5ob3N0O1xufVxuXG5leHBvcnRzLmdldEltYWdlID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpZiAoIXNhbWVPcmlnaW4odXJsKSkge1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICB9XG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBpbWcpO1xuICAgIH07XG4gICAgaW1nLnNyYyA9IHVybDtcbiAgICBpbWcuZ2V0RGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpLmRhdGE7XG4gICAgfTtcbiAgICByZXR1cm4gaW1nO1xufTtcblxuZXhwb3J0cy5nZXRWaWRlbyA9IGZ1bmN0aW9uKHVybHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB2aWRlby5vbmxvYWRzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB2aWRlbyk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcbiAgICAgICAgaWYgKCFzYW1lT3JpZ2luKHVybHNbaV0pKSB7XG4gICAgICAgICAgICB2aWRlby5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgICAgIHMuc3JjID0gdXJsc1tpXTtcbiAgICAgICAgdmlkZW8uYXBwZW5kQ2hpbGQocyk7XG4gICAgfVxuICAgIHZpZGVvLmdldERhdGEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHZpZGVvOyB9O1xuICAgIHJldHVybiB2aWRlbztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW52YXMgPSByZXF1aXJlKCcuL2NhbnZhcycpO1xuXG52YXIgZnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbmV4cG9ydHMuZnJhbWUgPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiBmcmFtZShmbik7XG59O1xuXG52YXIgY2FuY2VsID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbmV4cG9ydHMuY2FuY2VsRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgIGNhbmNlbChpZCk7XG59O1xuXG5leHBvcnRzLnRpbWVkID0gZnVuY3Rpb24gKGZuLCBkdXIsIGN0eCkge1xuICAgIGlmICghZHVyKSB7XG4gICAgICAgIGZuLmNhbGwoY3R4LCAxKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFib3J0ID0gZmFsc2UsXG4gICAgICAgIHN0YXJ0ID0gd2luZG93LnBlcmZvcm1hbmNlID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3coKTtcblxuICAgIGZ1bmN0aW9uIHRpY2sobm93KSB7XG4gICAgICAgIGlmIChhYm9ydCkgcmV0dXJuO1xuICAgICAgICBpZiAoIXdpbmRvdy5wZXJmb3JtYW5jZSkgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAobm93ID49IHN0YXJ0ICsgZHVyKSB7XG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgKG5vdyAtIHN0YXJ0KSAvIGR1cik7XG4gICAgICAgICAgICBleHBvcnRzLmZyYW1lKHRpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0cy5mcmFtZSh0aWNrKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHsgYWJvcnQgPSB0cnVlOyB9O1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGJhc2ljIEphdmFTY3JpcHQgYW5kIERPTSBmZWF0dXJlcyByZXF1aXJlZCBmb3IgTWFwYm94IEdMIGFyZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdD1mYWxzZV0gSWYgYHRydWVgLCBtYXAgY3JlYXRpb24gd2lsbCBmYWlsIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBkZXRlcm1pbmVzIHRoYXQgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBjcmVhdGVkIFdlYkdMIGNvbnRleHQgd291bGQgYmUgZHJhbWF0aWNhbGx5IGxvd2VyIHRoYW4gZXhwZWN0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgTWFwYm94IEdMIHNob3VsZCBiZSBleHBlY3RlZCB0byB3b3JrLCBhbmQgZmFsc2UgaWYgbm90LlxuICogQG1lbWJlcm9mIG1hcGJveGdsXG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMuc3VwcG9ydGVkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgdmFyIHN1cHBvcnRzID0gW1xuXG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7IH0sXG5cbiAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnOyB9LFxuXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIShBcnJheS5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZXZlcnkgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZmlsdGVyICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZiAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc29tZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhIShGdW5jdGlvbi5wcm90b3R5cGUgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpICYmXG4gICAgICAgICAgICAgICAgISEoT2JqZWN0LmtleXMgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzU2VhbGVkICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5pc0Zyb3plbiAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5zZWFsICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAnSlNPTicgaW4gd2luZG93ICYmICdwYXJzZScgaW4gSlNPTiAmJiAnc3RyaW5naWZ5JyBpbiBKU09OO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW52YXMoKS5zdXBwb3J0c1dlYkdMQ29udGV4dCgob3B0aW9ucyAmJiBvcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpIHx8IGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdXb3JrZXInIGluIHdpbmRvdzsgfVxuICAgIF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1cHBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghc3VwcG9ydHNbaV0oKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydHMuaGFyZHdhcmVDb25jdXJyZW5jeSA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGV2aWNlUGl4ZWxSYXRpbycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7XG5cbmZ1bmN0aW9uIENhbnZhcyhwYXJlbnQsIGNvbnRhaW5lcikge1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBpZiAocGFyZW50ICYmIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMuY2FudmFzLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLWNhbnZhcycpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgcGFyZW50Ll9jb250ZXh0TG9zdC5iaW5kKHBhcmVudCksIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBwYXJlbnQuX2NvbnRleHRSZXN0b3JlZC5iaW5kKHBhcmVudCksIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgIH1cbn1cblxuQ2FudmFzLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgLy8gUmVxdWVzdCB0aGUgcmVxdWlyZWQgY2FudmFzIHNpemUgdGFraW5nIHRoZSBwaXhlbHJhdGlvIGludG8gYWNjb3VudC5cbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHBpeGVsUmF0aW8gKiB3aWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwaXhlbFJhdGlvICogaGVpZ2h0O1xuXG4gICAgLy8gTWFpbnRhaW4gdGhlIHNhbWUgY2FudmFzIHNpemUsIHBvdGVudGlhbGx5IGRvd25zY2FsaW5nIGl0IGZvciBIaURQSSBkaXNwbGF5c1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG59O1xuXG52YXIgcmVxdWlyZWRDb250ZXh0QXR0cmlidXRlcyA9IHtcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIGFscGhhOiB0cnVlLFxuICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgZGVwdGg6IGZhbHNlXG59O1xuXG5DYW52YXMucHJvdG90eXBlLmdldFdlYkdMQ29udGV4dCA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICBhdHRyaWJ1dGVzID0gdXRpbC5leHRlbmQoe30sIGF0dHJpYnV0ZXMsIHJlcXVpcmVkQ29udGV4dEF0dHJpYnV0ZXMpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcyk7XG59O1xuXG5DYW52YXMucHJvdG90eXBlLnN1cHBvcnRzV2ViR0xDb250ZXh0ID0gZnVuY3Rpb24oZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCkge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0XG4gICAgfSwgcmVxdWlyZWRDb250ZXh0QXR0cmlidXRlcyk7XG5cbiAgICBpZiAoJ3Byb2JhYmx5U3VwcG9ydHNDb250ZXh0JyBpbiB0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMucHJvYmFibHlTdXBwb3J0c0NvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnByb2JhYmx5U3VwcG9ydHNDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKTtcbiAgICB9IGVsc2UgaWYgKCdzdXBwb3J0c0NvbnRleHQnIGluIHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5zdXBwb3J0c0NvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN1cHBvcnRzQ29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dCAmJiAhIXRoaXMuZ2V0V2ViR0xDb250ZXh0KGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpO1xufTtcblxuQ2FudmFzLnByb3RvdHlwZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFjdG9yID0gcmVxdWlyZSgnLi4vYWN0b3InKTtcbnZhciBXZWJXb3JraWZ5ID0gcmVxdWlyZSgnd2Vid29ya2lmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXI7XG5cbmZ1bmN0aW9uIERpc3BhdGNoZXIobGVuZ3RoLCBwYXJlbnQpIHtcbiAgICB0aGlzLmFjdG9ycyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEFjdG9yID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV2ViV29ya2lmeShyZXF1aXJlKCcuLi8uLi9zb3VyY2Uvd29ya2VyJykpO1xuICAgICAgICB2YXIgYWN0b3IgPSBuZXcgQWN0b3Iod29ya2VyLCBwYXJlbnQpO1xuICAgICAgICBhY3Rvci5uYW1lID0gXCJXb3JrZXIgXCIgKyBpO1xuICAgICAgICB0aGlzLmFjdG9ycy5wdXNoKGFjdG9yKTtcbiAgICB9XG59XG5cbkRpc3BhdGNoZXIucHJvdG90eXBlID0ge1xuICAgIGJyb2FkY2FzdDogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFjdG9yc1tpXS5zZW5kKHR5cGUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlbmQ6IGZ1bmN0aW9uKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCB0YXJnZXRJRCwgYnVmZmVycykge1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElEICE9PSAnbnVtYmVyJyB8fCBpc05hTih0YXJnZXRJRCkpIHtcbiAgICAgICAgICAgIC8vIFVzZSByb3VuZCByb2JpbiB0byBzZW5kIHJlcXVlc3RzIHRvIHdlYiB3b3JrZXJzLlxuICAgICAgICAgICAgdGFyZ2V0SUQgPSB0aGlzLmN1cnJlbnRBY3RvciA9ICh0aGlzLmN1cnJlbnRBY3RvciArIDEpICUgdGhpcy5hY3RvcnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RvcnNbdGFyZ2V0SURdLnNlbmQodHlwZSwgZGF0YSwgY2FsbGJhY2ssIGJ1ZmZlcnMpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0SUQ7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzW2ldLnRhcmdldC50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdG9ycyA9IFtdO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBpZiAoY2xhc3NOYW1lKSBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgaWYgKGNvbnRhaW5lcikgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZWw7XG59O1xuXG52YXIgZG9jU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cbmZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocHJvcHNbaV0gaW4gZG9jU3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHNlbGVjdFByb3AgPSB0ZXN0UHJvcChbJ3VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKSxcbiAgICB1c2VyU2VsZWN0O1xuZXhwb3J0cy5kaXNhYmxlRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICB1c2VyU2VsZWN0ID0gZG9jU3R5bGVbc2VsZWN0UHJvcF07XG4gICAgICAgIGRvY1N0eWxlW3NlbGVjdFByb3BdID0gJ25vbmUnO1xuICAgIH1cbn07XG5leHBvcnRzLmVuYWJsZURyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZG9jU3R5bGVbc2VsZWN0UHJvcF0gPSB1c2VyU2VsZWN0O1xuICAgIH1cbn07XG5cbnZhciB0cmFuc2Zvcm1Qcm9wID0gdGVzdFByb3AoWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJ10pO1xuZXhwb3J0cy5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbihlbCwgdmFsdWUpIHtcbiAgICBlbC5zdHlsZVt0cmFuc2Zvcm1Qcm9wXSA9IHZhbHVlO1xufTtcblxuLy8gU3VwcHJlc3MgdGhlIG5leHQgY2xpY2ssIGJ1dCBvbmx5IGlmIGl0J3MgaW1tZWRpYXRlLlxuZnVuY3Rpb24gc3VwcHJlc3NDbGljayhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3VwcHJlc3NDbGljaywgdHJ1ZSk7XG59XG5leHBvcnRzLnN1cHByZXNzQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdXBwcmVzc0NsaWNrLCB0cnVlKTtcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3VwcHJlc3NDbGljaywgdHJ1ZSk7XG4gICAgfSwgMCk7XG59O1xuXG5leHBvcnRzLm1vdXNlUG9zID0gZnVuY3Rpb24gKGVsLCBlKSB7XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBlID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcbiAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICBlLmNsaWVudFggLSByZWN0LmxlZnQgLSBlbC5jbGllbnRMZWZ0LFxuICAgICAgICBlLmNsaWVudFkgLSByZWN0LnRvcCAtIGVsLmNsaWVudFRvcCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBIVFRQX1VSTDogJ2h0dHA6Ly9hLnRpbGVzLm1hcGJveC5jb20nLFxuICAgIEhUVFBTX1VSTDogJ2h0dHBzOi8vYS50aWxlcy5tYXBib3guY29tJyxcbiAgICBGT1JDRV9IVFRQUzogdHJ1ZSxcbiAgICBSRVFVSVJFX0FDQ0VTU19UT0tFTjogdHJ1ZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBNZXRob2RzIG1peGVkIGluIHRvIG90aGVyIGNsYXNzZXMgZm9yIGV2ZW50IGNhcGFiaWxpdGllcy5cbiAqIEBtaXhpbiBFdmVudGVkXG4gKi9cbnZhciBFdmVudGVkID0ge1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGEgc3BlY2lmaWVkIGV2ZW50IHdpdGggYSBsaXN0ZW5lciBmdW5jdGlvbiB0aGUgbGF0dGVyIGdldHMgdGhlIGRhdGEgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCB0byBgZmlyZWAgYW5kIGFkZGl0aW9uYWxseSBgdGFyZ2V0YCBhbmQgYHR5cGVgIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWRcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGZuKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZXZlbnQgbGlzdGVuZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gRXZlbnQgdHlwZS4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2xpc3RlbmVyXSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuIElmIG5vbmUgaXMgc3BlY2lmaWVkIGFsbCBsaXN0ZW5lcnMgYXJlIHJlbW92ZWRcbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubGlzdGVucyh0eXBlKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fZXZlbnRzW3R5cGVdLmluZGV4T2YoZm4pO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBhIGZ1bmN0aW9uIG9uY2Ugd2hlbiBhbiBldmVudCBoYXMgZmlyZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2Ugd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWRcbiAgICAgKi9cbiAgICBvbmNlOiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHR5cGUsIHdyYXBwZXIpO1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uKHR5cGUsIHdyYXBwZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZSBldmVudCBvZiBhIGdpdmVuIHN0cmluZyB0eXBlIHdpdGggdGhlIGdpdmVuIGRhdGEgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBPcHRpb25hbCBkYXRhIHBhc3NlZCBkb3duIHRvIHRoZSBldmVudCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBgdGhpc2BcbiAgICAgKi9cbiAgICBmaXJlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5zKHR5cGUpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBkYXRhID0gdXRpbC5leHRlbmQoe30sIGRhdGEpO1xuICAgICAgICB1dGlsLmV4dGVuZChkYXRhLCB7dHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzfSk7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIGFkZGluZy9yZW1vdmluZyBsaXN0ZW5lcnMgaW5zaWRlIG90aGVyIGxpc3RlbmVycyB3b24ndCBjYXVzZSBpbmZpbml0ZSBsb29wXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gZXZlbnQgaXMgcmVnaXN0ZXJlZCB0byBhIHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgcmVnaXN0ZXJlZCBsaXN0ZW5lciBmb3IgZXZlbnRzIG9mIHR5cGUgYHR5cGVgXG4gICAgICovXG4gICAgbGlzdGVuczogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBocztcblxuZnVuY3Rpb24gR2x5cGhzKHBiZiwgZW5kKSB7XG4gICAgdGhpcy5zdGFja3MgPSBwYmYucmVhZEZpZWxkcyhyZWFkRm9udHN0YWNrcywgW10sIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGb250c3RhY2tzKHRhZywgc3RhY2tzLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxKSB7XG4gICAgICAgIHZhciBmb250c3RhY2sgPSBwYmYucmVhZE1lc3NhZ2UocmVhZEZvbnRzdGFjaywge2dseXBoczoge319KTtcbiAgICAgICAgc3RhY2tzLnB1c2goZm9udHN0YWNrKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRGb250c3RhY2sodGFnLCBmb250c3RhY2ssIHBiZikge1xuICAgIGlmICh0YWcgPT09IDEpIGZvbnRzdGFjay5uYW1lID0gcGJmLnJlYWRTdHJpbmcoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDIpIGZvbnRzdGFjay5yYW5nZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAzKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IHBiZi5yZWFkTWVzc2FnZShyZWFkR2x5cGgsIHt9KTtcbiAgICAgICAgZm9udHN0YWNrLmdseXBoc1tnbHlwaC5pZF0gPSBnbHlwaDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRHbHlwaCh0YWcsIGdseXBoLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxKSBnbHlwaC5pZCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBnbHlwaC5iaXRtYXAgPSBwYmYucmVhZEJ5dGVzKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAzKSBnbHlwaC53aWR0aCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSA0KSBnbHlwaC5oZWlnaHQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNSkgZ2x5cGgubGVmdCA9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNikgZ2x5cGgudG9wID0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSA3KSBnbHlwaC5hZHZhbmNlID0gcGJmLnJlYWRWYXJpbnQoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnBvbGF0ZTtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoYSwgYiwgdCkge1xuICAgIHJldHVybiAoYSAqICgxIC0gdCkpICsgKGIgKiB0KTtcbn1cblxuaW50ZXJwb2xhdGUubnVtYmVyID0gaW50ZXJwb2xhdGU7XG5cbmludGVycG9sYXRlLnZlYzIgPSBmdW5jdGlvbihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMF0sIHRvWzBdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVsxXSwgdG9bMV0sIHQpXG4gICAgXTtcbn07XG5cbi8qXG4gKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHR3byBjb2xvcnMgZ2l2ZW4gYXMgNC1lbGVtZW50IGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge0NvbG9yfSBmcm9tXG4gKiBAcGFyYW0ge0NvbG9yfSB0b1xuICogQHBhcmFtIHtudW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBmYWN0b3IgYmV0d2VlbiAwIGFuZCAxXG4gKiBAcmV0dXJucyB7Q29sb3J9IGludGVycG9sYXRlZCBjb2xvclxuICovXG5pbnRlcnBvbGF0ZS5jb2xvciA9IGZ1bmN0aW9uKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVswXSwgdG9bMF0sIHQpLFxuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzFdLCB0b1sxXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMl0sIHRvWzJdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVszXSwgdG9bM10sIHQpXG4gICAgXTtcbn07XG5cbmludGVycG9sYXRlLmFycmF5ID0gZnVuY3Rpb24oZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gZnJvbS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGUoZCwgdG9baV0sIHQpO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVVUkwodXJsLCBwYXRoUHJlZml4LCBhY2Nlc3NUb2tlbikge1xuICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgY29uZmlnLkFDQ0VTU19UT0tFTjtcblxuICAgIGlmICghYWNjZXNzVG9rZW4gJiYgY29uZmlnLlJFUVVJUkVfQUNDRVNTX1RPS0VOKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gQVBJIGFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZCB0byB1c2UgTWFwYm94IEdMLiAnICtcbiAgICAgICAgICAgICdTZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9kZXZlbG9wZXJzL2FwaS8jYWNjZXNzLXRva2VucycpO1xuICAgIH1cblxuICAgIHZhciBodHRwcyA9IGNvbmZpZy5GT1JDRV9IVFRQUyB8fFxuICAgICAgICAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicpO1xuXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL15tYXBib3g6XFwvXFwvLywgKGh0dHBzID8gY29uZmlnLkhUVFBTX1VSTCA6IGNvbmZpZy5IVFRQX1VSTCkgKyBwYXRoUHJlZml4KTtcbiAgICB1cmwgKz0gdXJsLmluZGV4T2YoJz8nKSAhPT0gLTEgPyAnJmFjY2Vzc190b2tlbj0nIDogJz9hY2Nlc3NfdG9rZW49JztcblxuICAgIGlmIChjb25maWcuUkVRVUlSRV9BQ0NFU1NfVE9LRU4pIHtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuWzBdID09PSAncycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlIGEgcHVibGljIGFjY2VzcyB0b2tlbiAocGsuKikgd2l0aCBNYXBib3ggR0wgSlMsIG5vdCBhIHNlY3JldCBhY2Nlc3MgdG9rZW4gKHNrLiopLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vZGV2ZWxvcGVycy9hcGkvI2FjY2Vzcy10b2tlbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybCArPSBhY2Nlc3NUb2tlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTdHlsZVVSTCA9IGZ1bmN0aW9uKHVybCwgYWNjZXNzVG9rZW4pIHtcbiAgICB2YXIgdXNlciA9IHVybC5tYXRjaCgvXm1hcGJveDpcXC9cXC8oW14uXSspLyk7XG4gICAgaWYgKCF1c2VyKVxuICAgICAgICByZXR1cm4gdXJsO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVVSTCh1cmwsICcvc3R5bGVzL3YxLycgKyB1c2VyWzFdICsgJy8nLCBhY2Nlc3NUb2tlbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTb3VyY2VVUkwgPSBmdW5jdGlvbih1cmwsIGFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKCF1cmwubWF0Y2goL15tYXBib3g6XFwvXFwvLykpXG4gICAgICAgIHJldHVybiB1cmw7XG5cbiAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsICsgJy5qc29uJywgJy92NC8nLCBhY2Nlc3NUb2tlbik7XG5cbiAgICAvLyBUaWxlSlNPTiByZXF1ZXN0cyBuZWVkIGEgc2VjdXJlIGZsYWcgYXBwZW5kZWQgdG8gdGhlaXIgVVJMcyBzb1xuICAgIC8vIHRoYXQgdGhlIHNlcnZlciBrbm93cyB0byBzZW5kIFNTTC1pZmllZCByZXNvdXJjZSByZWZlcmVuY2VzLlxuICAgIGlmICh1cmwuaW5kZXhPZignaHR0cHMnKSA9PT0gMClcbiAgICAgICAgdXJsICs9ICcmc2VjdXJlJztcblxuICAgIHJldHVybiB1cmw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVHbHlwaHNVUkwgPSBmdW5jdGlvbih1cmwsIGFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKCF1cmwubWF0Y2goL15tYXBib3g6XFwvXFwvLykpXG4gICAgICAgIHJldHVybiB1cmw7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplVVJMKHVybCwgJy92NC8nLCBhY2Nlc3NUb2tlbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVUaWxlVVJMID0gZnVuY3Rpb24odXJsLCBzb3VyY2VVcmwpIHtcbiAgICBpZiAoIXNvdXJjZVVybCB8fCAhc291cmNlVXJsLm1hdGNoKC9ebWFwYm94OlxcL1xcLy8pKVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXFwuKCg/OnBuZ3xqcGcpXFxkKikoPz0kfFxcPykvLCBicm93c2VyLmRldmljZVBpeGVsUmF0aW8gPj0gMiA/ICdAMnguJDEnIDogJy4kMScpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIFttb3N0LXJlY2VudGx5LXVzZWQgY2FjaGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfYWxnb3JpdGhtcylcbiAqIHdpdGggaGFzaCBsb29rdXAgbWFkZSBwb3NzaWJsZSBieSBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIGluIHBhcmFsbGVsIHRvXG4gKiBhbiBhcnJheSBvZiBkaWN0aW9uYXJ5IG9mIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbnVtYmVyIG9mIHBlcm1pdHRlZCB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVtb3ZlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIGl0ZW1zIHdoZW4gdGhleSBleHBpcmVcbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTVJVQ2FjaGU7XG5mdW5jdGlvbiBNUlVDYWNoZShtYXgsIG9uUmVtb3ZlKSB7XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gICAgdGhpcy5vblJlbW92ZSA9IG9uUmVtb3ZlO1xuICAgIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgY2FjaGVcbiAqXG4gKiBAcmV0dXJucyB7TVJVQ2FjaGV9IHRoaXMgY2FjaGVcbiAqIEBwcml2YXRlXG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3QpIHtcbiAgICAgICAgdGhpcy5vblJlbW92ZSh0aGlzLmxpc3Rba2V5XSk7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ID0ge307XG4gICAgdGhpcy5vcmRlciA9IFtdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGtleSwgdmFsdWUgY29tYmluYXRpb24gdG8gdGhlIGNhY2hlLCB0cmltbWluZyBpdHMgc2l6ZSBpZiB0aGlzIHB1c2hlc1xuICogaXQgb3ZlciBtYXggbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgbG9va3VwIGtleSBmb3IgdGhlIGl0ZW1cbiAqIEBwYXJhbSB7Kn0gZGF0YSBhbnkgdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7TVJVQ2FjaGV9IHRoaXMgY2FjaGVcbiAqIEBwcml2YXRlXG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihrZXksIGRhdGEpIHtcbiAgICB0aGlzLmxpc3Rba2V5XSA9IGRhdGE7XG4gICAgdGhpcy5vcmRlci5wdXNoKGtleSk7XG5cbiAgICBpZiAodGhpcy5vcmRlci5sZW5ndGggPiB0aGlzLm1heCkge1xuICAgICAgICB2YXIgcmVtb3ZlZERhdGEgPSB0aGlzLmdldCh0aGlzLm9yZGVyWzBdKTtcbiAgICAgICAgaWYgKHJlbW92ZWREYXRhKSB0aGlzLm9uUmVtb3ZlKHJlbW92ZWREYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHZhbHVlIGF0dGFjaGVkIHRvIGBrZXlgIGlzIHByZXNlbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSBrZXkgdG8gYmUgbG9va2VkLXVwXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgY2FjaGUgaGFzIHRoaXMgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMubGlzdDtcbn07XG5cbi8qKlxuICogTGlzdCBhbGwga2V5cyBpbiB0aGUgY2FjaGVcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gYW4gYXJyYXkgb2Yga2V5cyBpbiB0aGlzIGNhY2hlLlxuICogQHByaXZhdGVcbiAqL1xuTVJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcmRlcjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBhdHRhY2hlZCB0byBhIHNwZWNpZmljIGtleS4gSWYgdGhlIGtleSBpcyBub3QgZm91bmQsXG4gKiByZXR1cm5zIGBudWxsYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIGtleSB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7Kn0gdGhlIGRhdGEsIG9yIG51bGwgaWYgaXQgaXNuJ3QgZm91bmRcbiAqIEBwcml2YXRlXG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIHZhciBkYXRhID0gdGhpcy5saXN0W2tleV07XG5cbiAgICBkZWxldGUgdGhpcy5saXN0W2tleV07XG4gICAgdGhpcy5vcmRlci5zcGxpY2UodGhpcy5vcmRlci5pbmRleE9mKGtleSksIDEpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVUb2tlbnM7XG5cbi8qKlxuICogUmVwbGFjZSB0b2tlbnMgaW4gYSBzdHJpbmcgdGVtcGxhdGUgd2l0aCB2YWx1ZXMgaW4gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgYSBrZXkvdmFsdWUgcmVsYXRpb25zaGlwIGJldHdlZW4gdG9rZW5zIGFuZCByZXBsYWNlbWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IHRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0ZW1wbGF0ZSB3aXRoIHRva2VucyByZXBsYWNlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRva2Vucyhwcm9wZXJ0aWVzLCB0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgveyhbXnt9KClcXFtcXF08PiQ9OjsuLF5dKyl9L2csIGZ1bmN0aW9uKG1hdGNoLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiBwcm9wZXJ0aWVzID8gcHJvcGVydGllc1trZXldIDogJyc7XG4gICAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBVbml0QmV6aWVyID0gcmVxdWlyZSgndW5pdGJlemllcicpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmFsdWUgYHRgIHRoYXQgdmFyaWVzIGJldHdlZW4gMCBhbmQgMSwgcmV0dXJuXG4gKiBhbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIHRoYXQgZWFzZXMgYmV0d2VlbiAwIGFuZCAxIGluIGEgcGxlYXNpbmdcbiAqIGN1YmljIGluLW91dCBmYXNoaW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBpbnB1dFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5lYXNlQ3ViaWNJbk91dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKHQgPD0gMCkgcmV0dXJuIDA7XG4gICAgaWYgKHQgPj0gMSkgcmV0dXJuIDE7XG4gICAgdmFyIHQyID0gdCAqIHQsXG4gICAgICAgIHQzID0gdDIgKiB0O1xuICAgIHJldHVybiA0ICogKHQgPCAwLjUgPyB0MyA6IDMgKiAodCAtIHQyKSArIHQzIC0gMC43NSk7XG59O1xuXG4vKipcbiAqIEdpdmVuIGdpdmVuICh4LCB5KSwgKHgxLCB5MSkgY29udHJvbCBwb2ludHMgZm9yIGEgYmV6aWVyIGN1cnZlLFxuICogcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBpbnRlcnBvbGF0ZXMgYWxvbmcgdGhhdCBjdXJ2ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcDF4IGNvbnRyb2wgcG9pbnQgMSB4IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMXkgY29udHJvbCBwb2ludCAxIHkgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHAyeCBjb250cm9sIHBvaW50IDIgeCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcDJ5IGNvbnRyb2wgcG9pbnQgMiB5IGNvb3JkaW5hdGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gaW50ZXJwb2xhdG9yOiByZWNlaXZlcyBudW1iZXIgdmFsdWUsIHJldHVybnNcbiAqIG51bWJlciB2YWx1ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmV6aWVyID0gZnVuY3Rpb24ocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgdmFyIGJlemllciA9IG5ldyBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIGJlemllci5zb2x2ZSh0KTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIGRlZmF1bHQgYmV6aWVyLWN1cnZlIHBvd2VyZWQgZWFzaW5nIGZ1bmN0aW9uIHdpdGhcbiAqIGNvbnRyb2wgcG9pbnRzICgwLjI1LCAwLjEpIGFuZCAoMC4yNSwgMSlcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn0gb3V0cHV0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmVhc2UgPSBleHBvcnRzLmJlemllcigwLjI1LCAwLjEsIDAuMjUsIDEpO1xuXG4vKipcbiAqIEdpdmVuIGEgZm91ci1lbGVtZW50IGFycmF5IG9mIG51bWJlcnMgdGhhdCByZXByZXNlbnRzIGEgY29sb3IgaW5cbiAqIFJHQkEsIHJldHVybiBhIHZlcnNpb24gZm9yIHdoaWNoIHRoZSBSR0IgY29tcG9uZW50cyBhcmUgbXVsdGlwbGllZFxuICogYnkgdGhlIEEgKGFscGhhKSBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGMgY29sb3IgYXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBwcmVtdWx0aXBsaWVkIGNvbG9yIGFycmF5XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnByZW11bHRpcGx5ID0gZnVuY3Rpb24gKGMpIHtcbiAgICBjWzBdICo9IGNbM107XG4gICAgY1sxXSAqPSBjWzNdO1xuICAgIGNbMl0gKj0gY1szXTtcbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogY29uc3RyYWluIG4gdG8gdGhlIGdpdmVuIHJhbmdlIHZpYSBtaW4gKyBtYXhcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiB0aGUgbWluaW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCB0aGUgbWF4aW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNsYW1wZWQgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY2xhbXAgPSBmdW5jdGlvbiAobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIG4pKTtcbn07XG5cbi8qXG4gKiBjb25zdHJhaW4gbiB0byB0aGUgZ2l2ZW4gcmFuZ2UgdmlhIG1vZHVsYXIgYXJpdGhtZXRpY1xuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGNvbnN0cmFpbmVkIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy53cmFwID0gZnVuY3Rpb24gKG4sIG1pbiwgbWF4KSB7XG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgcmV0dXJuIG4gPT09IG1heCA/IG4gOiAoKG4gLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcbn07XG5cbi8qXG4gKiByZXR1cm4gdGhlIGZpcnN0IG5vbi1udWxsIGFuZCBub24tdW5kZWZpbmVkIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Kn0gYXJndW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY29hbGVzY2UgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoYXJnICE9PSBudWxsICYmIGFyZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59O1xuXG4vKlxuICogQ2FsbCBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gb24gYW4gYXJyYXkgb2YgYXJndW1lbnRzLFxuICogY2FsbGluZyBgY2FsbGJhY2tgIG9uY2UgYWxsIGNhbGxzIGNvbXBsZXRlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFycmF5IGlucHV0IHRvIGVhY2ggY2FsbCBvZiB0aGUgYXN5bmMgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBhbiBhc3luYyBmdW5jdGlvbiB3aXRoIHNpZ25hdHVyZSAoZGF0YSwgY2FsbGJhY2spXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIGNhbGxiYWNrIHJ1biBhZnRlciBhbGwgYXN5bmMgd29yayBpcyBkb25lLlxuICogY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5hc3luY0VhY2ggPSBmdW5jdGlvbiAoYXJyYXksIGZuLCBjYWxsYmFjaykge1xuICAgIHZhciByZW1haW5pbmcgPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgZnVuY3Rpb24gY2hlY2soKSB7IGlmICgtLXJlbWFpbmluZyA9PT0gMCkgY2FsbGJhY2soKTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIGZuKGFycmF5W2ldLCBjaGVjayk7XG59O1xuXG4vKlxuICogQ29tcHV0ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBrZXlzIGluIG9uZSBvYmplY3QgYW5kIHRoZSBrZXlzXG4gKiBpbiBhbm90aGVyIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXJcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBrZXlzIGRpZmZlcmVuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMua2V5c0RpZmZlcmVuY2UgPSBmdW5jdGlvbiAob2JqLCBvdGhlcikge1xuICAgIHZhciBkaWZmZXJlbmNlID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCEoaSBpbiBvdGhlcikpIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZmVyZW5jZTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBkZXN0aW5hdGlvbiBvYmplY3QgYW5kIG9wdGlvbmFsbHkgbWFueSBzb3VyY2Ugb2JqZWN0cyxcbiAqIGNvcHkgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc291cmNlIG9iamVjdHMgaW50byB0aGUgZGVzdGluYXRpb24uXG4gKiBUaGUgbGFzdCBzb3VyY2Ugb2JqZWN0IGdpdmVuIG92ZXJyaWRlcyBwcm9wZXJ0aWVzIGZyb20gcHJldmlvdXNcbiAqIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3QgZGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBzb3VyY2VzIGZyb20gd2hpY2ggcHJvcGVydGllcyBhcmUgcHVsbGVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBzcmMpIHtcbiAgICAgICAgICAgIGRlc3Rba10gPSBzcmNba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59O1xuXG4vKipcbiAqIEV4dGVuZCBhIGRlc3RpbmF0aW9uIG9iamVjdCB3aXRoIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBzcmMgb2JqZWN0LFxuICogdXNpbmcgZGVmaW5lUHJvcGVydHkgaW5zdGVhZCBvZiBzaW1wbGUgYXNzaWdubWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmV4dGVuZEFsbCA9IGZ1bmN0aW9uIChkZXN0LCBzcmMpIHtcbiAgICBmb3IgKHZhciBpIGluIHNyYykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwgaSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59O1xuXG4vKipcbiAqIEV4dGVuZCBhIHBhcmVudCdzIHByb3RvdHlwZSB3aXRoIGFsbCBwcm9wZXJ0aWVzIGluIGEgcHJvcGVydGllc1xuICogb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHJldHVybnMge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuaW5oZXJpdCA9IGZ1bmN0aW9uIChwYXJlbnQsIHByb3BzKSB7XG4gICAgdmFyIHBhcmVudFByb3RvID0gdHlwZW9mIHBhcmVudCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudC5wcm90b3R5cGUgOiBwYXJlbnQsXG4gICAgICAgIHByb3RvID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm90byk7XG4gICAgZXhwb3J0cy5leHRlbmRBbGwocHJvdG8sIHByb3BzKTtcbiAgICByZXR1cm4gcHJvdG87XG59O1xuXG4vKipcbiAqIEdpdmVuIGFuIG9iamVjdCBhbmQgYSBudW1iZXIgb2YgcHJvcGVydGllcyBhcyBzdHJpbmdzLCByZXR1cm4gdmVyc2lvblxuICogb2YgdGhhdCBvYmplY3Qgd2l0aCBvbmx5IHRob3NlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNyYyB0aGUgb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByb3BlcnRpZXMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgY2hvc2VuXG4gKiB0byBhcHBlYXIgb24gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBsaW1pdGVkIHByb3BlcnRpZXMuXG4gKiBAZXhhbXBsZVxuICogdmFyIGZvbyA9IHsgbmFtZTogJ0NoYXJsaWUnLCBhZ2U6IDEwIH07XG4gKiB2YXIganVzdE5hbWUgPSBwaWNrKGZvbywgWyduYW1lJ10pO1xuICogLy8ganVzdE5hbWUgPSB7IG5hbWU6ICdDaGFybGllJyB9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnBpY2sgPSBmdW5jdGlvbiAoc3JjLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgayA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIGlmIChrIGluIHNyYykge1xuICAgICAgICAgICAgcmVzdWx0W2tdID0gc3JjW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgaWQgPSAxO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXF1ZSBudW1lcmljIGlkLCBzdGFydGluZyBhdCAxIGFuZCBpbmNyZW1lbnRpbmcgd2l0aFxuICogZWFjaCBjYWxsLlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZSBudW1lcmljIGlkLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy51bmlxdWVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaWQrKztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgdmVyc2lvbiBvZiBgZm5gIHRoYXQgb25seSBmaXJlcyBvbmNlIGV2ZXJ5IGB0aW1lYCBtaWxsc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgZnVuY3Rpb24gdG8gYmUgdGhyb3R0bGVkXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBtaWxsc2Vjb25kcyByZXF1aXJlZCBiZXR3ZWVuIGZ1bmN0aW9uIGNhbGxzXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgdGhlIHZhbHVlIG9mIGB0aGlzYCB3aXRoIHdoaWNoIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnRocm90dGxlID0gZnVuY3Rpb24gKGZuLCB0aW1lLCBjb250ZXh0KSB7XG4gICAgdmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XG5cbiAgICBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcbiAgICAgICAgbG9jayA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgd3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgYXJncyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgICAgIC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxuICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxuICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xuICAgICAgICAgICAgbG9jayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHdyYXBwZXJGbjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgdmVyc2lvbiBvZiBgZm5gIHRoYXQgaXMgb25seSBjYWxsZWQgYHRpbWVgIG1pbGxpc2Vjb25kc1xuICogYWZ0ZXIgaXRzIGxhc3QgaW52b2NhdGlvblxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRoZSBmdW5jdGlvbiB0byBiZSBkZWJvdW5jZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIG1pbGxzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmRlYm91bmNlID0gZnVuY3Rpb24oZm4sIHRpbWUpIHtcbiAgICB2YXIgdGltZXIsIGFyZ3M7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH0sIHRpbWUpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIG1lbWJlciBmdW5jdGlvbiBuYW1lcyBhcyBzdHJpbmdzLCByZXBsYWNlIGFsbCBvZiB0aGVtXG4gKiB3aXRoIGJvdW5kIHZlcnNpb25zIHRoYXQgd2lsbCBhbHdheXMgcmVmZXIgdG8gYGNvbnRleHRgIGFzIGB0aGlzYC4gVGhpc1xuICogaXMgdXNlZnVsIGZvciBjbGFzc2VzIHdoZXJlIG90aGVyd2lzZSBldmVudCBiaW5kaW5ncyB3b3VsZCByZWFzc2lnblxuICogYHRoaXNgIHRvIHRoZSBldmVudGVkIG9iamVjdCBvciBzb21lIG90aGVyIHZhbHVlOiB0aGlzIGxldHMgeW91IGVuc3VyZVxuICogdGhlIGB0aGlzYCB2YWx1ZSBhbHdheXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBmbnMgbGlzdCBvZiBtZW1iZXIgZnVuY3Rpb24gbmFtZXNcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCB0aGUgY29udGV4dCB2YWx1ZVxuICogQHJldHVybnMge3VuZGVmaW5lZH0gY2hhbmdlcyBmdW5jdGlvbnMgaW4tcGxhY2VcbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiBNeUNsYXNzKCkge1xuICogICBiaW5kQWxsKFsnb250aW1lciddLCB0aGlzKTtcbiAqICAgdGhpcy5uYW1lID0gJ1RvbSc7XG4gKiB9XG4gKiBNeUNsYXNzLnByb3RvdHlwZS5vbnRpbWVyID0gZnVuY3Rpb24oKSB7XG4gKiAgIGFsZXJ0KHRoaXMubmFtZSk7XG4gKiB9O1xuICogdmFyIG15Q2xhc3MgPSBuZXcgTXlDbGFzcygpO1xuICogc2V0VGltZW91dChteUNsYXNzLm9udGltZXIsIDEwMCk7XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmRBbGwgPSBmdW5jdGlvbihmbnMsIGNvbnRleHQpIHtcbiAgICBmbnMuZm9yRWFjaChmdW5jdGlvbihmbikge1xuICAgICAgICBjb250ZXh0W2ZuXSA9IGNvbnRleHRbZm5dLmJpbmQoY29udGV4dCk7XG4gICAgfSk7XG59O1xuXG5leHBvcnRzLmJpbmRIYW5kbGVycyA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpIGluIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0W2ldID09PSAnZnVuY3Rpb24nICYmIGkuaW5kZXhPZignX29uJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRleHRbaV0gPSBjb250ZXh0W2ldLmJpbmQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgJ29wdGlvbnMnIHByb3BlcnR5IG9uIGBvYmpgIHdpdGggcHJvcGVydGllc1xuICogZnJvbSB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50LiBQcm9wZXJ0aWVzIGluIHRoZSBgb3B0aW9uc2BcbiAqIG9iamVjdCB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9iamVjdCBvZiBvdmVycmlkZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXJpdmVkIG9wdGlvbnMgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5zZXRPcHRpb25zID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xuICAgICAgICBvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gT2JqZWN0LmNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgIG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5vcHRpb25zO1xufTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLy8gKGMpIERlYW4gTWNOYW1lZSA8ZGVhbkBnbWFpbC5jb20+LCAyMDEyLlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncbi8vIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci9cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgXCJ0cmFuc3BhcmVudFwiOiBbMCwwLDAsMF0sIFwiYWxpY2VibHVlXCI6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwyMzUsMjE1LDFdLCBcImFxdWFcIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsMjU1LDIxMiwxXSwgXCJhenVyZVwiOiBbMjQwLDI1NSwyNTUsMV0sXG4gIFwiYmVpZ2VcIjogWzI0NSwyNDUsMjIwLDFdLCBcImJpc3F1ZVwiOiBbMjU1LDIyOCwxOTYsMV0sXG4gIFwiYmxhY2tcIjogWzAsMCwwLDFdLCBcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNSwxXSxcbiAgXCJibHVlXCI6IFswLDAsMjU1LDFdLCBcImJsdWV2aW9sZXRcIjogWzEzOCw0MywyMjYsMV0sXG4gIFwiYnJvd25cIjogWzE2NSw0Miw0MiwxXSwgXCJidXJseXdvb2RcIjogWzIyMiwxODQsMTM1LDFdLFxuICBcImNhZGV0Ymx1ZVwiOiBbOTUsMTU4LDE2MCwxXSwgXCJjaGFydHJldXNlXCI6IFsxMjcsMjU1LDAsMV0sXG4gIFwiY2hvY29sYXRlXCI6IFsyMTAsMTA1LDMwLDFdLCBcImNvcmFsXCI6IFsyNTUsMTI3LDgwLDFdLFxuICBcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsMTQ5LDIzNywxXSwgXCJjb3Juc2lsa1wiOiBbMjU1LDI0OCwyMjAsMV0sXG4gIFwiY3JpbXNvblwiOiBbMjIwLDIwLDYwLDFdLCBcImN5YW5cIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJkYXJrYmx1ZVwiOiBbMCwwLDEzOSwxXSwgXCJkYXJrY3lhblwiOiBbMCwxMzksMTM5LDFdLFxuICBcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwxMzQsMTEsMV0sIFwiZGFya2dyYXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtncmVlblwiOiBbMCwxMDAsMCwxXSwgXCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2toYWtpXCI6IFsxODksMTgzLDEwNywxXSwgXCJkYXJrbWFnZW50YVwiOiBbMTM5LDAsMTM5LDFdLFxuICBcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwxMDcsNDcsMV0sIFwiZGFya29yYW5nZVwiOiBbMjU1LDE0MCwwLDFdLFxuICBcImRhcmtvcmNoaWRcIjogWzE1Myw1MCwyMDQsMV0sIFwiZGFya3JlZFwiOiBbMTM5LDAsMCwxXSxcbiAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsMTUwLDEyMiwxXSwgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywxODgsMTQzLDFdLFxuICBcImRhcmtzbGF0ZWJsdWVcIjogWzcyLDYxLDEzOSwxXSwgXCJkYXJrc2xhdGVncmF5XCI6IFs0Nyw3OSw3OSwxXSxcbiAgXCJkYXJrc2xhdGVncmV5XCI6IFs0Nyw3OSw3OSwxXSwgXCJkYXJrdHVycXVvaXNlXCI6IFswLDIwNiwyMDksMV0sXG4gIFwiZGFya3Zpb2xldFwiOiBbMTQ4LDAsMjExLDFdLCBcImRlZXBwaW5rXCI6IFsyNTUsMjAsMTQ3LDFdLFxuICBcImRlZXBza3libHVlXCI6IFswLDE5MSwyNTUsMV0sIFwiZGltZ3JheVwiOiBbMTA1LDEwNSwxMDUsMV0sXG4gIFwiZGltZ3JleVwiOiBbMTA1LDEwNSwxMDUsMV0sIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NSwxXSxcbiAgXCJmaXJlYnJpY2tcIjogWzE3OCwzNCwzNCwxXSwgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LDI1MCwyNDAsMV0sXG4gIFwiZm9yZXN0Z3JlZW5cIjogWzM0LDEzOSwzNCwxXSwgXCJmdWNoc2lhXCI6IFsyNTUsMCwyNTUsMV0sXG4gIFwiZ2FpbnNib3JvXCI6IFsyMjAsMjIwLDIyMCwxXSwgXCJnaG9zdHdoaXRlXCI6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgXCJnb2xkXCI6IFsyNTUsMjE1LDAsMV0sIFwiZ29sZGVucm9kXCI6IFsyMTgsMTY1LDMyLDFdLFxuICBcImdyYXlcIjogWzEyOCwxMjgsMTI4LDFdLCBcImdyZWVuXCI6IFswLDEyOCwwLDFdLFxuICBcImdyZWVueWVsbG93XCI6IFsxNzMsMjU1LDQ3LDFdLCBcImdyZXlcIjogWzEyOCwxMjgsMTI4LDFdLFxuICBcImhvbmV5ZGV3XCI6IFsyNDAsMjU1LDI0MCwxXSwgXCJob3RwaW5rXCI6IFsyNTUsMTA1LDE4MCwxXSxcbiAgXCJpbmRpYW5yZWRcIjogWzIwNSw5Miw5MiwxXSwgXCJpbmRpZ29cIjogWzc1LDAsMTMwLDFdLFxuICBcIml2b3J5XCI6IFsyNTUsMjU1LDI0MCwxXSwgXCJraGFraVwiOiBbMjQwLDIzMCwxNDAsMV0sXG4gIFwibGF2ZW5kZXJcIjogWzIzMCwyMzAsMjUwLDFdLCBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwyNDAsMjQ1LDFdLFxuICBcImxhd25ncmVlblwiOiBbMTI0LDI1MiwwLDFdLCBcImxlbW9uY2hpZmZvblwiOiBbMjU1LDI1MCwyMDUsMV0sXG4gIFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMCwxXSwgXCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOCwxXSxcbiAgXCJsaWdodGN5YW5cIjogWzIyNCwyNTUsMjU1LDFdLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsMjUwLDIxMCwxXSxcbiAgXCJsaWdodGdyYXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0Z3JlZW5cIjogWzE0NCwyMzgsMTQ0LDFdLFxuICBcImxpZ2h0Z3JleVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRwaW5rXCI6IFsyNTUsMTgyLDE5MywxXSxcbiAgXCJsaWdodHNhbG1vblwiOiBbMjU1LDE2MCwxMjIsMV0sIFwibGlnaHRzZWFncmVlblwiOiBbMzIsMTc4LDE3MCwxXSxcbiAgXCJsaWdodHNreWJsdWVcIjogWzEzNSwyMDYsMjUwLDFdLCBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksMTM2LDE1MywxXSxcbiAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LDEzNiwxNTMsMV0sIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwxOTYsMjIyLDFdLFxuICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsMjU1LDIyNCwxXSwgXCJsaW1lXCI6IFswLDI1NSwwLDFdLFxuICBcImxpbWVncmVlblwiOiBbNTAsMjA1LDUwLDFdLCBcImxpbmVuXCI6IFsyNTAsMjQwLDIzMCwxXSxcbiAgXCJtYWdlbnRhXCI6IFsyNTUsMCwyNTUsMV0sIFwibWFyb29uXCI6IFsxMjgsMCwwLDFdLFxuICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwyMDUsMTcwLDFdLCBcIm1lZGl1bWJsdWVcIjogWzAsMCwyMDUsMV0sXG4gIFwibWVkaXVtb3JjaGlkXCI6IFsxODYsODUsMjExLDFdLCBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LDExMiwyMTksMV0sXG4gIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTMsMV0sIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsMTA0LDIzOCwxXSxcbiAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwyNTAsMTU0LDFdLCBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsMjA5LDIwNCwxXSxcbiAgXCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwyMSwxMzMsMV0sIFwibWlkbmlnaHRibHVlXCI6IFsyNSwyNSwxMTIsMV0sXG4gIFwibWludGNyZWFtXCI6IFsyNDUsMjU1LDI1MCwxXSwgXCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1LDFdLFxuICBcIm1vY2Nhc2luXCI6IFsyNTUsMjI4LDE4MSwxXSwgXCJuYXZham93aGl0ZVwiOiBbMjU1LDIyMiwxNzMsMV0sXG4gIFwibmF2eVwiOiBbMCwwLDEyOCwxXSwgXCJvbGRsYWNlXCI6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgXCJvbGl2ZVwiOiBbMTI4LDEyOCwwLDFdLCBcIm9saXZlZHJhYlwiOiBbMTA3LDE0MiwzNSwxXSxcbiAgXCJvcmFuZ2VcIjogWzI1NSwxNjUsMCwxXSwgXCJvcmFuZ2VyZWRcIjogWzI1NSw2OSwwLDFdLFxuICBcIm9yY2hpZFwiOiBbMjE4LDExMiwyMTQsMV0sIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LDIzMiwxNzAsMV0sXG4gIFwicGFsZWdyZWVuXCI6IFsxNTIsMjUxLDE1MiwxXSwgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOCwxXSxcbiAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksMTEyLDE0NywxXSwgXCJwYXBheWF3aGlwXCI6IFsyNTUsMjM5LDIxMywxXSxcbiAgXCJwZWFjaHB1ZmZcIjogWzI1NSwyMTgsMTg1LDFdLCBcInBlcnVcIjogWzIwNSwxMzMsNjMsMV0sXG4gIFwicGlua1wiOiBbMjU1LDE5MiwyMDMsMV0sIFwicGx1bVwiOiBbMjIxLDE2MCwyMjEsMV0sXG4gIFwicG93ZGVyYmx1ZVwiOiBbMTc2LDIyNCwyMzAsMV0sIFwicHVycGxlXCI6IFsxMjgsMCwxMjgsMV0sXG4gIFwicmVkXCI6IFsyNTUsMCwwLDFdLCBcInJvc3licm93blwiOiBbMTg4LDE0MywxNDMsMV0sXG4gIFwicm95YWxibHVlXCI6IFs2NSwxMDUsMjI1LDFdLCBcInNhZGRsZWJyb3duXCI6IFsxMzksNjksMTksMV0sXG4gIFwic2FsbW9uXCI6IFsyNTAsMTI4LDExNCwxXSwgXCJzYW5keWJyb3duXCI6IFsyNDQsMTY0LDk2LDFdLFxuICBcInNlYWdyZWVuXCI6IFs0NiwxMzksODcsMV0sIFwic2Vhc2hlbGxcIjogWzI1NSwyNDUsMjM4LDFdLFxuICBcInNpZW5uYVwiOiBbMTYwLDgyLDQ1LDFdLCBcInNpbHZlclwiOiBbMTkyLDE5MiwxOTIsMV0sXG4gIFwic2t5Ymx1ZVwiOiBbMTM1LDIwNiwyMzUsMV0sIFwic2xhdGVibHVlXCI6IFsxMDYsOTAsMjA1LDFdLFxuICBcInNsYXRlZ3JheVwiOiBbMTEyLDEyOCwxNDQsMV0sIFwic2xhdGVncmV5XCI6IFsxMTIsMTI4LDE0NCwxXSxcbiAgXCJzbm93XCI6IFsyNTUsMjUwLDI1MCwxXSwgXCJzcHJpbmdncmVlblwiOiBbMCwyNTUsMTI3LDFdLFxuICBcInN0ZWVsYmx1ZVwiOiBbNzAsMTMwLDE4MCwxXSwgXCJ0YW5cIjogWzIxMCwxODAsMTQwLDFdLFxuICBcInRlYWxcIjogWzAsMTI4LDEyOCwxXSwgXCJ0aGlzdGxlXCI6IFsyMTYsMTkxLDIxNiwxXSxcbiAgXCJ0b21hdG9cIjogWzI1NSw5OSw3MSwxXSwgXCJ0dXJxdW9pc2VcIjogWzY0LDIyNCwyMDgsMV0sXG4gIFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOCwxXSwgXCJ3aGVhdFwiOiBbMjQ1LDIyMiwxNzksMV0sXG4gIFwid2hpdGVcIjogWzI1NSwyNTUsMjU1LDFdLCBcIndoaXRlc21va2VcIjogWzI0NSwyNDUsMjQ1LDFdLFxuICBcInllbGxvd1wiOiBbMjU1LDI1NSwwLDFdLCBcInllbGxvd2dyZWVuXCI6IFsxNTQsMjA1LDUwLDFdfVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfYnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19mbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIGggKz0gMTtcbiAgZWxzZSBpZiAoaCA+IDEpIGggLT0gMTtcblxuICBpZiAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yO1xuICBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1NTQ29sb3IoY3NzX3N0cikge1xuICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHJldHVybiBrQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7ICAvLyBkdXAuXG5cbiAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWygoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtwYXJzZV9jc3NfaW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChwYXJhbXNbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1sxXSk7XG4gICAgICAgIHZhciBsID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1syXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICAgICAgICByZXR1cm4gW2NsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCsxLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgtMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnRyeSB7IGV4cG9ydHMucGFyc2VDU1NDb2xvciA9IHBhcnNlQ1NTQ29sb3IgfSBjYXRjaChlKSB7IH1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVGZWF0dXJlVHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cbmZ1bmN0aW9uIGluZml4KG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8sIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJyR0eXBlJykge1xuICAgICAgICAgICAgcmV0dXJuICd0JyArIG9wZXJhdG9yICsgVmVjdG9yVGlsZUZlYXR1cmVUeXBlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncFsnICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddJyArIG9wZXJhdG9yICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaWN0SW5maXgob3BlcmF0b3IpIHtcbiAgICB2YXIgbm9uc3RyaWN0SW5maXggPSBpbmZpeChvcGVyYXRvcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8sIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJyR0eXBlJykge1xuICAgICAgICAgICAgcmV0dXJuIG5vbnN0cmljdEluZml4KF8sIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd0eXBlb2YocFsnICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddKSA9PT0gdHlwZW9mKCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnKSAmJiAnICtcbiAgICAgICAgICAgICAgICBub25zdHJpY3RJbmZpeChfLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbnZhciBvcGVyYXRvcnMgPSB7XG4gICAgJz09JzogaW5maXgoJz09PScpLFxuICAgICchPSc6IGluZml4KCchPT0nKSxcbiAgICAnPic6IHN0cmljdEluZml4KCc+JyksXG4gICAgJzwnOiBzdHJpY3RJbmZpeCgnPCcpLFxuICAgICc8PSc6IHN0cmljdEluZml4KCc8PScpLFxuICAgICc+PSc6IHN0cmljdEluZml4KCc+PScpLFxuICAgICdpbic6IGZ1bmN0aW9uKF8sIGtleSkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnKCcgKyBvcGVyYXRvcnNbJz09J10oXywga2V5LCB2YWx1ZSkgKyAnKSc7XG4gICAgICAgIH0pLmpvaW4oJ3x8JykgfHwgJ2ZhbHNlJztcbiAgICB9LFxuICAgICchaW4nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICchKCcgKyBvcGVyYXRvcnMuaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKSArICcpJztcbiAgICB9LFxuICAgICdhbnknOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkubWFwKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuICcoJyArIGNvbXBpbGUoZmlsdGVyKSArICcpJztcbiAgICAgICAgfSkuam9pbignfHwnKSB8fCAnZmFsc2UnO1xuICAgIH0sXG4gICAgJ2FsbCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5tYXAoZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gJygnICsgY29tcGlsZShmaWx0ZXIpICsgJyknO1xuICAgICAgICB9KS5qb2luKCcmJicpIHx8ICd0cnVlJztcbiAgICB9LFxuICAgICdub25lJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnISgnICsgb3BlcmF0b3JzLmFueS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgJyknO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNvbXBpbGUoZmlsdGVyKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yc1tmaWx0ZXJbMF1dLmFwcGx5KGZpbHRlciwgZmlsdGVyKTtcbn1cblxuZnVuY3Rpb24gdHJ1dGgoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmaWx0ZXIgZXhwcmVzc2VkIGFzIG5lc3RlZCBhcnJheXMsIHJldHVybiBhIG5ldyBmdW5jdGlvblxuICogdGhhdCBldmFsdWF0ZXMgd2hldGhlciBhIGdpdmVuIGZlYXR1cmUgKHdpdGggYSAucHJvcGVydGllcyBvciAudGFncyBwcm9wZXJ0eSlcbiAqIHBhc3NlcyBpdHMgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXIgbWFwYm94IGdsIGZpbHRlclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBmaWx0ZXItZXZhbHVhdGluZyBmdW5jdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICBpZiAoIWZpbHRlcikgcmV0dXJuIHRydXRoO1xuICAgIHZhciBmaWx0ZXJTdHIgPSAndmFyIHAgPSBmLnByb3BlcnRpZXMgfHwgZi50YWdzIHx8IHt9LCB0ID0gZi50eXBlOyByZXR1cm4gJyArIGNvbXBpbGUoZmlsdGVyKSArICc7JztcbiAgICAvLyBqc2hpbnQgZXZpbDogdHJ1ZVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ2YnLCBmaWx0ZXJTdHIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjbGlwO1xuXG4vKiBjbGlwIGZlYXR1cmVzIGJldHdlZW4gdHdvIGF4aXMtcGFyYWxsZWwgbGluZXM6XG4gKiAgICAgfCAgICAgICAgfFxuICogIF9fX3xfX18gICAgIHwgICAgIC9cbiAqIC8gICB8ICAgXFxfX19ffF9fX18vXG4gKiAgICAgfCAgICAgICAgfFxuICovXG5cbmZ1bmN0aW9uIGNsaXAoZmVhdHVyZXMsIHNjYWxlLCBrMSwgazIsIGF4aXMsIGludGVyc2VjdCwgbWluQWxsLCBtYXhBbGwpIHtcblxuICAgIGsxIC89IHNjYWxlO1xuICAgIGsyIC89IHNjYWxlO1xuXG4gICAgaWYgKG1pbkFsbCA+PSBrMSAmJiBtYXhBbGwgPD0gazIpIHJldHVybiBmZWF0dXJlczsgLy8gdHJpdmlhbCBhY2NlcHRcbiAgICBlbHNlIGlmIChtaW5BbGwgPiBrMiB8fCBtYXhBbGwgPCBrMSkgcmV0dXJuIG51bGw7IC8vIHRyaXZpYWwgcmVqZWN0XG5cbiAgICB2YXIgY2xpcHBlZCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlLFxuICAgICAgICAgICAgbWluLCBtYXg7XG5cbiAgICAgICAgbWluID0gZmVhdHVyZS5taW5bYXhpc107XG4gICAgICAgIG1heCA9IGZlYXR1cmUubWF4W2F4aXNdO1xuXG4gICAgICAgIGlmIChtaW4gPj0gazEgJiYgbWF4IDw9IGsyKSB7IC8vIHRyaXZpYWwgYWNjZXB0XG4gICAgICAgICAgICBjbGlwcGVkLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtaW4gPiBrMiB8fCBtYXggPCBrMSkgY29udGludWU7IC8vIHRyaXZpYWwgcmVqZWN0XG5cbiAgICAgICAgdmFyIHNsaWNlcyA9IHR5cGUgPT09IDEgP1xuICAgICAgICAgICAgICAgIGNsaXBQb2ludHMoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcykgOlxuICAgICAgICAgICAgICAgIGNsaXBHZW9tZXRyeShnZW9tZXRyeSwgazEsIGsyLCBheGlzLCBpbnRlcnNlY3QsIHR5cGUgPT09IDMpO1xuXG4gICAgICAgIGlmIChzbGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZiBhIGZlYXR1cmUgZ290IGNsaXBwZWQsIGl0IHdpbGwgbGlrZWx5IGdldCBjbGlwcGVkIG9uIHRoZSBuZXh0IHpvb20gbGV2ZWwgYXMgd2VsbCxcbiAgICAgICAgICAgIC8vIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byByZWNhbGN1bGF0ZSBiYm94ZXNcbiAgICAgICAgICAgIGNsaXBwZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHNsaWNlcyxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmVzW2ldLnRhZ3MgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBtaW46IGZlYXR1cmUubWluLFxuICAgICAgICAgICAgICAgIG1heDogZmVhdHVyZS5tYXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBwZWQubGVuZ3RoID8gY2xpcHBlZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNsaXBQb2ludHMoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcykge1xuICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYSA9IGdlb21ldHJ5W2ldLFxuICAgICAgICAgICAgYWsgPSBhW2F4aXNdO1xuXG4gICAgICAgIGlmIChhayA+PSBrMSAmJiBhayA8PSBrMikgc2xpY2UucHVzaChhKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuXG5mdW5jdGlvbiBjbGlwR2VvbWV0cnkoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcywgaW50ZXJzZWN0LCBjbG9zZWQpIHtcblxuICAgIHZhciBzbGljZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgYWsgPSAwLFxuICAgICAgICAgICAgYmsgPSAwLFxuICAgICAgICAgICAgYiA9IG51bGwsXG4gICAgICAgICAgICBwb2ludHMgPSBnZW9tZXRyeVtpXSxcbiAgICAgICAgICAgIGFyZWEgPSBwb2ludHMuYXJlYSxcbiAgICAgICAgICAgIGRpc3QgPSBwb2ludHMuZGlzdCxcbiAgICAgICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhLCBqLCBsYXN0O1xuXG4gICAgICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW4gLSAxOyBqKyspIHtcbiAgICAgICAgICAgIGEgPSBiIHx8IHBvaW50c1tqXTtcbiAgICAgICAgICAgIGIgPSBwb2ludHNbaiArIDFdO1xuICAgICAgICAgICAgYWsgPSBiayB8fCBhW2F4aXNdO1xuICAgICAgICAgICAgYmsgPSBiW2F4aXNdO1xuXG4gICAgICAgICAgICBpZiAoYWsgPCBrMSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKChiayA+IGsyKSkgeyAvLyAtLS18LS0tLS18LS0+XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsxKSwgaW50ZXJzZWN0KGEsIGIsIGsyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA+PSBrMSkgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpKTsgLy8gLS0tfC0tPiAgfFxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFrID4gazIpIHtcblxuICAgICAgICAgICAgICAgIGlmICgoYmsgPCBrMSkpIHsgLy8gPC0tfC0tLS0tfC0tLVxuICAgICAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMiksIGludGVyc2VjdChhLCBiLCBrMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkgc2xpY2UgPSBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmsgPD0gazIpIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsyKSk7IC8vIHwgIDwtLXwtLS1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goYSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmsgPCBrMSkgeyAvLyA8LS18LS0tICB8XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA+IGsyKSB7IC8vIHwgIC0tLXwtLT5cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHwgLS0+IHxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGUgbGFzdCBwb2ludFxuICAgICAgICBhID0gcG9pbnRzW2xlbiAtIDFdO1xuICAgICAgICBhayA9IGFbYXhpc107XG4gICAgICAgIGlmIChhayA+PSBrMSAmJiBhayA8PSBrMikgc2xpY2UucHVzaChhKTtcblxuICAgICAgICAvLyBjbG9zZSB0aGUgcG9seWdvbiBpZiBpdHMgZW5kcG9pbnRzIGFyZSBub3QgdGhlIHNhbWUgYWZ0ZXIgY2xpcHBpbmdcblxuICAgICAgICBsYXN0ID0gc2xpY2Vbc2xpY2UubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjbG9zZWQgJiYgbGFzdCAmJiAoc2xpY2VbMF1bMF0gIT09IGxhc3RbMF0gfHwgc2xpY2VbMF1bMV0gIT09IGxhc3RbMV0pKSBzbGljZS5wdXNoKHNsaWNlWzBdKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGZpbmFsIHNsaWNlXG4gICAgICAgIG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBzbGljZXM7XG59XG5cbmZ1bmN0aW9uIG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpIHtcbiAgICBpZiAoc2xpY2UubGVuZ3RoKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IHJlY2FsY3VsYXRlIHRoZSBhcmVhL2xlbmd0aCBvZiB0aGUgdW5jbGlwcGVkIGdlb21ldHJ5IGJlY2F1c2UgdGhlIGNhc2Ugd2hlcmUgaXQgZ29lc1xuICAgICAgICAvLyBiZWxvdyB0aGUgdmlzaWJpbGl0eSB0aHJlc2hvbGQgYXMgYSByZXN1bHQgb2YgY2xpcHBpbmcgaXMgcmFyZSwgc28gd2UgYXZvaWQgZG9pbmcgdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICBzbGljZS5hcmVhID0gYXJlYTtcbiAgICAgICAgc2xpY2UuZGlzdCA9IGRpc3Q7XG5cbiAgICAgICAgc2xpY2VzLnB1c2goc2xpY2UpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDtcblxudmFyIHNpbXBsaWZ5ID0gcmVxdWlyZSgnLi9zaW1wbGlmeScpO1xuXG4vLyBjb252ZXJ0cyBHZW9KU09OIGZlYXR1cmUgaW50byBhbiBpbnRlcm1lZGlhdGUgcHJvamVjdGVkIEpTT04gdmVjdG9yIGZvcm1hdCB3aXRoIHNpbXBsaWZpY2F0aW9uIGRhdGFcblxuZnVuY3Rpb24gY29udmVydChkYXRhLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcblxuICAgIGlmIChkYXRhLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywgZGF0YS5mZWF0dXJlc1tpXSwgdG9sZXJhbmNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIGRhdGEsIHRvbGVyYW5jZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaW5nbGUgZ2VvbWV0cnkgb3IgYSBnZW9tZXRyeSBjb2xsZWN0aW9uXG4gICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCB7Z2VvbWV0cnk6IGRhdGF9LCB0b2xlcmFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCBmZWF0dXJlLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIHR5cGUgPSBnZW9tLnR5cGUsXG4gICAgICAgIGNvb3JkcyA9IGdlb20uY29vcmRpbmF0ZXMsXG4gICAgICAgIHRhZ3MgPSBmZWF0dXJlLnByb3BlcnRpZXMsXG4gICAgICAgIGksIGosIHJpbmdzO1xuXG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMSwgW3Byb2plY3RQb2ludChjb29yZHMpXSkpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMSwgcHJvamVjdChjb29yZHMpKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAyLCBbcHJvamVjdChjb29yZHMsIHRvbGVyYW5jZSldKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnIHx8IHR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICByaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByaW5ncy5wdXNoKHByb2plY3QoY29vcmRzW2ldLCB0b2xlcmFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCB0eXBlID09PSAnUG9seWdvbicgPyAzIDogMiwgcmluZ3MpKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgcmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJpbmdzLnB1c2gocHJvamVjdChjb29yZHNbaV1bal0sIHRvbGVyYW5jZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDMsIHJpbmdzKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb20uZ2VvbWV0cmllc1tpXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB0YWdzXG4gICAgICAgICAgICB9LCB0b2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGUodGFncywgdHlwZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgZmVhdHVyZSA9IHtcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0YWdzOiB0YWdzIHx8IG51bGwsXG4gICAgICAgIG1pbjogWzIsIDFdLCAvLyBpbml0aWFsIGJib3ggdmFsdWVzO1xuICAgICAgICBtYXg6IFstMSwgMF0gIC8vIG5vdGUgdGhhdCBjb29yZHMgYXJlIHVzdWFsbHkgaW4gWzAuLjFdIHJhbmdlXG4gICAgfTtcbiAgICBjYWxjQkJveChmZWF0dXJlKTtcbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdChsb25sYXRzLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgcHJvamVjdGVkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25sYXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb2plY3RlZC5wdXNoKHByb2plY3RQb2ludChsb25sYXRzW2ldKSk7XG4gICAgfVxuICAgIGlmICh0b2xlcmFuY2UpIHtcbiAgICAgICAgc2ltcGxpZnkocHJvamVjdGVkLCB0b2xlcmFuY2UpO1xuICAgICAgICBjYWxjU2l6ZShwcm9qZWN0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvamVjdGVkO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0UG9pbnQocCkge1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbihwWzFdICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgIHggPSAocFswXSAvIDM2MCArIDAuNSksXG4gICAgICAgIHkgPSAoMC41IC0gMC4yNSAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyBNYXRoLlBJKTtcblxuICAgIHkgPSB5IDwgLTEgPyAtMSA6XG4gICAgICAgIHkgPiAxID8gMSA6IHk7XG5cbiAgICByZXR1cm4gW3gsIHksIDBdO1xufVxuXG4vLyBjYWxjdWxhdGUgYXJlYSBhbmQgbGVuZ3RoIG9mIHRoZSBwb2x5XG5mdW5jdGlvbiBjYWxjU2l6ZShwb2ludHMpIHtcbiAgICB2YXIgYXJlYSA9IDAsXG4gICAgICAgIGRpc3QgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGEsIGI7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGEgPSBiIHx8IHBvaW50c1tpXTtcbiAgICAgICAgYiA9IHBvaW50c1tpICsgMV07XG5cbiAgICAgICAgYXJlYSArPSBhWzBdICogYlsxXSAtIGJbMF0gKiBhWzFdO1xuXG4gICAgICAgIC8vIHVzZSBNYW5oYXR0YW4gZGlzdGFuY2UgaW5zdGVhZCBvZiBFdWNsaWRpYW4gb25lIHRvIGF2b2lkIGV4cGVuc2l2ZSBzcXVhcmUgcm9vdCBjb21wdXRhdGlvblxuICAgICAgICBkaXN0ICs9IE1hdGguYWJzKGJbMF0gLSBhWzBdKSArIE1hdGguYWJzKGJbMV0gLSBhWzFdKTtcbiAgICB9XG4gICAgcG9pbnRzLmFyZWEgPSBNYXRoLmFicyhhcmVhIC8gMik7XG4gICAgcG9pbnRzLmRpc3QgPSBkaXN0O1xufVxuXG4vLyBjYWxjdWxhdGUgdGhlIGZlYXR1cmUgYm91bmRpbmcgYm94IGZvciBmYXN0ZXIgY2xpcHBpbmcgbGF0ZXJcbmZ1bmN0aW9uIGNhbGNCQm94KGZlYXR1cmUpIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICBtaW4gPSBmZWF0dXJlLm1pbixcbiAgICAgICAgbWF4ID0gZmVhdHVyZS5tYXg7XG5cbiAgICBpZiAoZmVhdHVyZS50eXBlID09PSAxKSBjYWxjUmluZ0JCb3gobWluLCBtYXgsIGdlb21ldHJ5KTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkubGVuZ3RoOyBpKyspIGNhbGNSaW5nQkJveChtaW4sIG1heCwgZ2VvbWV0cnlbaV0pO1xuXG4gICAgcmV0dXJuIGZlYXR1cmU7XG59XG5cbmZ1bmN0aW9uIGNhbGNSaW5nQkJveChtaW4sIG1heCwgcG9pbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgbWluWzBdID0gTWF0aC5taW4ocFswXSwgbWluWzBdKTtcbiAgICAgICAgbWF4WzBdID0gTWF0aC5tYXgocFswXSwgbWF4WzBdKTtcbiAgICAgICAgbWluWzFdID0gTWF0aC5taW4ocFsxXSwgbWluWzFdKTtcbiAgICAgICAgbWF4WzFdID0gTWF0aC5tYXgocFsxXSwgbWF4WzFdKTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VvanNvbnZ0O1xuXG52YXIgY29udmVydCA9IHJlcXVpcmUoJy4vY29udmVydCcpLCAvLyBHZW9KU09OIGNvbnZlcnNpb24gYW5kIHByZXByb2Nlc3NpbmdcbiAgICBjbGlwID0gcmVxdWlyZSgnLi9jbGlwJyksICAgICAgIC8vIHN0cmlwZSBjbGlwcGluZyBhbGdvcml0aG1cbiAgICB3cmFwID0gcmVxdWlyZSgnLi93cmFwJyksICAgICAgIC8vIGRhdGUgbGluZSBwcm9jZXNzaW5nXG4gICAgY3JlYXRlVGlsZSA9IHJlcXVpcmUoJy4vdGlsZScpOyAvLyBmaW5hbCBzaW1wbGlmaWVkIHRpbGUgZ2VuZXJhdGlvblxuXG5cbmZ1bmN0aW9uIGdlb2pzb252dChkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBHZW9KU09OVlQoZGF0YSwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIEdlb0pTT05WVChkYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IGV4dGVuZChPYmplY3QuY3JlYXRlKHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuXG4gICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICAgIGlmIChkZWJ1ZykgY29uc29sZS50aW1lKCdwcmVwcm9jZXNzIGRhdGEnKTtcblxuICAgIHZhciB6MiA9IDEgPDwgb3B0aW9ucy5tYXhab29tLCAvLyAyXnpcbiAgICAgICAgZmVhdHVyZXMgPSBjb252ZXJ0KGRhdGEsIG9wdGlvbnMudG9sZXJhbmNlIC8gKHoyICogb3B0aW9ucy5leHRlbnQpKTtcblxuICAgIHRoaXMudGlsZXMgPSB7fTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ3ByZXByb2Nlc3MgZGF0YScpO1xuICAgICAgICBjb25zb2xlLmxvZygnaW5kZXg6IG1heFpvb206ICVkLCBtYXhQb2ludHM6ICVkJywgb3B0aW9ucy5pbmRleE1heFpvb20sIG9wdGlvbnMuaW5kZXhNYXhQb2ludHMpO1xuICAgICAgICBjb25zb2xlLnRpbWUoJ2dlbmVyYXRlIHRpbGVzJyk7XG4gICAgICAgIHRoaXMuc3RhdHMgPSB7fTtcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgfVxuXG4gICAgZmVhdHVyZXMgPSB3cmFwKGZlYXR1cmVzLCBvcHRpb25zLmJ1ZmZlciAvIG9wdGlvbnMuZXh0ZW50LCBpbnRlcnNlY3RYKTtcblxuICAgIC8vIHN0YXJ0IHNsaWNpbmcgZnJvbSB0aGUgdG9wIHRpbGUgZG93blxuICAgIHRoaXMuc3BsaXRUaWxlKGZlYXR1cmVzLCAwLCAwLCAwKTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnZmVhdHVyZXM6ICVkLCBwb2ludHM6ICVkJywgdGhpcy50aWxlc1swXS5udW1GZWF0dXJlcywgdGhpcy50aWxlc1swXS5udW1Qb2ludHMpO1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ2dlbmVyYXRlIHRpbGVzJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0aWxlcyBnZW5lcmF0ZWQ6JywgdGhpcy50b3RhbCwgSlNPTi5zdHJpbmdpZnkodGhpcy5zdGF0cykpO1xuICAgIH1cbn1cblxuR2VvSlNPTlZULnByb3RvdHlwZS5vcHRpb25zID0ge1xuICAgIG1heFpvb206IDE0LCAgICAgICAgICAgIC8vIG1heCB6b29tIHRvIHByZXNlcnZlIGRldGFpbCBvblxuICAgIGluZGV4TWF4Wm9vbTogNSwgICAgICAgIC8vIG1heCB6b29tIGluIHRoZSB0aWxlIGluZGV4XG4gICAgaW5kZXhNYXhQb2ludHM6IDEwMDAwMCwgLy8gbWF4IG51bWJlciBvZiBwb2ludHMgcGVyIHRpbGUgaW4gdGhlIHRpbGUgaW5kZXhcbiAgICB0b2xlcmFuY2U6IDMsICAgICAgICAgICAvLyBzaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2UgKGhpZ2hlciBtZWFucyBzaW1wbGVyKVxuICAgIGV4dGVudDogNDA5NiwgICAgICAgICAgIC8vIHRpbGUgZXh0ZW50XG4gICAgYnVmZmVyOiA2NCwgICAgICAgICAgICAgLy8gdGlsZSBidWZmZXIgb24gZWFjaCBzaWRlXG4gICAgZGVidWc6IDAgICAgICAgICAgICAgICAgLy8gbG9nZ2luZyBsZXZlbCAoMCwgMSBvciAyKVxufTtcblxuR2VvSlNPTlZULnByb3RvdHlwZS5zcGxpdFRpbGUgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHosIHgsIHksIGN6LCBjeCwgY3kpIHtcblxuICAgIHZhciBzdGFjayA9IFtmZWF0dXJlcywgeiwgeCwgeV0sXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZyxcbiAgICAgICAgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQsXG4gICAgICAgIGJ1ZmZlciA9IG9wdGlvbnMuYnVmZmVyO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uIGJ5IHVzaW5nIGEgcHJvY2Vzc2luZyBxdWV1ZVxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgZmVhdHVyZXMgPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICB6ID0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgeCA9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgIHkgPSBzdGFjay5zaGlmdCgpO1xuXG4gICAgICAgIHZhciB6MiA9IDEgPDwgeixcbiAgICAgICAgICAgIGlkID0gdG9JRCh6LCB4LCB5KSxcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLnRpbGVzW2lkXSxcbiAgICAgICAgICAgIHRpbGVUb2xlcmFuY2UgPSB6ID09PSBvcHRpb25zLm1heFpvb20gPyAwIDogb3B0aW9ucy50b2xlcmFuY2UgLyAoejIgKiBleHRlbnQpO1xuXG4gICAgICAgIGlmICghdGlsZSkge1xuICAgICAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lKCdjcmVhdGlvbicpO1xuXG4gICAgICAgICAgICB0aWxlID0gdGhpcy50aWxlc1tpZF0gPSBjcmVhdGVUaWxlKGZlYXR1cmVzLCB6MiwgeCwgeSwgdGlsZVRvbGVyYW5jZSwgeiA9PT0gb3B0aW9ucy5tYXhab29tKTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGlsZSB6JWQtJWQtJWQgKGZlYXR1cmVzOiAlZCwgcG9pbnRzOiAlZCwgc2ltcGxpZmllZDogJWQpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHosIHgsIHksIHRpbGUubnVtRmVhdHVyZXMsIHRpbGUubnVtUG9pbnRzLCB0aWxlLm51bVNpbXBsaWZpZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ2NyZWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSAneicgKyB6O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHNba2V5XSA9ICh0aGlzLnN0YXRzW2tleV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMudG90YWwrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIGdlb21ldHJ5IGluIHRpbGUgc28gdGhhdCB3ZSBjYW4gZHJpbGwgZG93biBsYXRlciBpZiB3ZSBzdG9wIG5vd1xuICAgICAgICB0aWxlLnNvdXJjZSA9IGZlYXR1cmVzO1xuXG4gICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIHRoZSB0aWxlIGlzIGRlZ2VuZXJhdGVcbiAgICAgICAgaWYgKGlzQ2xpcHBlZFNxdWFyZSh0aWxlLmZlYXR1cmVzLCBleHRlbnQsIGJ1ZmZlcikpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0LXBhc3MgdGlsaW5nXG4gICAgICAgIGlmICghY3opIHtcbiAgICAgICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIHdlIHJlYWNoZWQgbWF4IHpvb20sIG9yIGlmIHRoZSB0aWxlIGlzIHRvbyBzaW1wbGVcbiAgICAgICAgICAgIGlmICh6ID09PSBvcHRpb25zLmluZGV4TWF4Wm9vbSB8fCB0aWxlLm51bVBvaW50cyA8PSBvcHRpb25zLmluZGV4TWF4UG9pbnRzKSBjb250aW51ZTtcblxuICAgICAgICAvLyBpZiBhIGRyaWxsZG93biB0byBhIHNwZWNpZmljIHRpbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIHdlIHJlYWNoZWQgYmFzZSB6b29tIG9yIG91ciB0YXJnZXQgdGlsZSB6b29tXG4gICAgICAgICAgICBpZiAoeiA9PT0gb3B0aW9ucy5tYXhab29tIHx8IHogPT09IGN6KSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgaXQncyBub3QgYW4gYW5jZXN0b3Igb2YgdGhlIHRhcmdldCB0aWxlXG4gICAgICAgICAgICB2YXIgbSA9IDEgPDwgKGN6IC0geik7XG4gICAgICAgICAgICBpZiAoeCAhPT0gTWF0aC5mbG9vcihjeCAvIG0pICYmIHkgIT09IE1hdGguZmxvb3IoY3kgLyBtKSkgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBzbGljZSBmdXJ0aGVyIGRvd24sIG5vIG5lZWQgdG8ga2VlcCBzb3VyY2UgZ2VvbWV0cnlcbiAgICAgICAgdGlsZS5zb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZSgnY2xpcHBpbmcnKTtcblxuICAgICAgICAvLyB2YWx1ZXMgd2UnbGwgdXNlIGZvciBjbGlwcGluZ1xuICAgICAgICB2YXIgazEgPSAwLjUgKiBidWZmZXIgLyBleHRlbnQsXG4gICAgICAgICAgICBrMiA9IDAuNSAtIGsxLFxuICAgICAgICAgICAgazMgPSAwLjUgKyBrMSxcbiAgICAgICAgICAgIGs0ID0gMSArIGsxLFxuICAgICAgICAgICAgdGwsIGJsLCB0ciwgYnIsIGxlZnQsIHJpZ2h0O1xuXG4gICAgICAgIHRsID0gYmwgPSB0ciA9IGJyID0gbnVsbDtcblxuICAgICAgICBsZWZ0ICA9IGNsaXAoZmVhdHVyZXMsIHoyLCB4IC0gazEsIHggKyBrMywgMCwgaW50ZXJzZWN0WCwgdGlsZS5taW5bMF0sIHRpbGUubWF4WzBdKTtcbiAgICAgICAgcmlnaHQgPSBjbGlwKGZlYXR1cmVzLCB6MiwgeCArIGsyLCB4ICsgazQsIDAsIGludGVyc2VjdFgsIHRpbGUubWluWzBdLCB0aWxlLm1heFswXSk7XG5cbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIHRsID0gY2xpcChsZWZ0LCB6MiwgeSAtIGsxLCB5ICsgazMsIDEsIGludGVyc2VjdFksIHRpbGUubWluWzFdLCB0aWxlLm1heFsxXSk7XG4gICAgICAgICAgICBibCA9IGNsaXAobGVmdCwgejIsIHkgKyBrMiwgeSArIGs0LCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICB0ciA9IGNsaXAocmlnaHQsIHoyLCB5IC0gazEsIHkgKyBrMywgMSwgaW50ZXJzZWN0WSwgdGlsZS5taW5bMV0sIHRpbGUubWF4WzFdKTtcbiAgICAgICAgICAgIGJyID0gY2xpcChyaWdodCwgejIsIHkgKyBrMiwgeSArIGs0LCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lRW5kKCdjbGlwcGluZycpO1xuXG4gICAgICAgIGlmICh0bCkgc3RhY2sucHVzaCh0bCwgeiArIDEsIHggKiAyLCAgICAgeSAqIDIpO1xuICAgICAgICBpZiAoYmwpIHN0YWNrLnB1c2goYmwsIHogKyAxLCB4ICogMiwgICAgIHkgKiAyICsgMSk7XG4gICAgICAgIGlmICh0cikgc3RhY2sucHVzaCh0ciwgeiArIDEsIHggKiAyICsgMSwgeSAqIDIpO1xuICAgICAgICBpZiAoYnIpIHN0YWNrLnB1c2goYnIsIHogKyAxLCB4ICogMiArIDEsIHkgKiAyICsgMSk7XG4gICAgfVxufTtcblxuR2VvSlNPTlZULnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gKHosIHgsIHkpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQsXG4gICAgICAgIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICAgIHZhciB6MiA9IDEgPDwgejtcbiAgICB4ID0gKCh4ICUgejIpICsgejIpICUgejI7IC8vIHdyYXAgdGlsZSB4IGNvb3JkaW5hdGVcblxuICAgIHZhciBpZCA9IHRvSUQoeiwgeCwgeSk7XG4gICAgaWYgKHRoaXMudGlsZXNbaWRdKSByZXR1cm4gdHJhbnNmb3JtVGlsZSh0aGlzLnRpbGVzW2lkXSwgZXh0ZW50KTtcblxuICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUubG9nKCdkcmlsbGluZyBkb3duIHRvIHolZC0lZC0lZCcsIHosIHgsIHkpO1xuXG4gICAgdmFyIHowID0geixcbiAgICAgICAgeDAgPSB4LFxuICAgICAgICB5MCA9IHksXG4gICAgICAgIHBhcmVudDtcblxuICAgIHdoaWxlICghcGFyZW50ICYmIHowID4gMCkge1xuICAgICAgICB6MC0tO1xuICAgICAgICB4MCA9IE1hdGguZmxvb3IoeDAgLyAyKTtcbiAgICAgICAgeTAgPSBNYXRoLmZsb29yKHkwIC8gMik7XG4gICAgICAgIHBhcmVudCA9IHRoaXMudGlsZXNbdG9JRCh6MCwgeDAsIHkwKV07XG4gICAgfVxuXG4gICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS5sb2coJ2ZvdW5kIHBhcmVudCB0aWxlIHolZC0lZC0lZCcsIHowLCB4MCwgeTApO1xuXG4gICAgLy8gaWYgd2UgZm91bmQgYSBwYXJlbnQgdGlsZSBjb250YWluaW5nIHRoZSBvcmlnaW5hbCBnZW9tZXRyeSwgd2UgY2FuIGRyaWxsIGRvd24gZnJvbSBpdFxuICAgIGlmIChwYXJlbnQuc291cmNlKSB7XG4gICAgICAgIGlmIChpc0NsaXBwZWRTcXVhcmUocGFyZW50LmZlYXR1cmVzLCBvcHRpb25zLmV4dGVudCwgb3B0aW9ucy5idWZmZXIpKSByZXR1cm4gdHJhbnNmb3JtVGlsZShwYXJlbnQsIGV4dGVudCk7XG5cbiAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lKCdkcmlsbGluZyBkb3duJyk7XG4gICAgICAgIHRoaXMuc3BsaXRUaWxlKHBhcmVudC5zb3VyY2UsIHowLCB4MCwgeTAsIHosIHgsIHkpO1xuICAgICAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWVFbmQoJ2RyaWxsaW5nIGRvd24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtVGlsZSh0aGlzLnRpbGVzW2lkXSwgZXh0ZW50KTtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVRpbGUodGlsZSwgZXh0ZW50KSB7XG4gICAgaWYgKCF0aWxlIHx8IHRpbGUudHJhbnNmb3JtZWQpIHJldHVybiB0aWxlO1xuXG4gICAgdmFyIHoyID0gdGlsZS56MixcbiAgICAgICAgdHggPSB0aWxlLngsXG4gICAgICAgIHR5ID0gdGlsZS55LFxuICAgICAgICBpLCBqLCBrO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRpbGUuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSB0aWxlLmZlYXR1cmVzW2ldLFxuICAgICAgICAgICAgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbS5sZW5ndGg7IGorKykgZ2VvbVtqXSA9IHRyYW5zZm9ybVBvaW50KGdlb21bal0sIGV4dGVudCwgejIsIHR4LCB0eSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJpbmcgPSBnZW9tW2pdO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCByaW5nLmxlbmd0aDsgaysrKSByaW5nW2tdID0gdHJhbnNmb3JtUG9pbnQocmluZ1trXSwgZXh0ZW50LCB6MiwgdHgsIHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRpbGUudHJhbnNmb3JtZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRpbGU7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KHAsIGV4dGVudCwgejIsIHR4LCB0eSkge1xuICAgIHZhciB4ID0gTWF0aC5yb3VuZChleHRlbnQgKiAocFswXSAqIHoyIC0gdHgpKSxcbiAgICAgICAgeSA9IE1hdGgucm91bmQoZXh0ZW50ICogKHBbMV0gKiB6MiAtIHR5KSk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLy8gY2hlY2tzIHdoZXRoZXIgYSB0aWxlIGlzIGEgd2hvbGUtYXJlYSBmaWxsIGFmdGVyIGNsaXBwaW5nOyBpZiBpdCBpcywgdGhlcmUncyBubyBzZW5zZSBzbGljaW5nIGl0IGZ1cnRoZXJcbmZ1bmN0aW9uIGlzQ2xpcHBlZFNxdWFyZShmZWF0dXJlcywgZXh0ZW50LCBidWZmZXIpIHtcbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzWzBdO1xuICAgIGlmIChmZWF0dXJlLnR5cGUgIT09IDMgfHwgZmVhdHVyZS5nZW9tZXRyeS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmUuZ2VvbWV0cnlbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBmZWF0dXJlLmdlb21ldHJ5WzBdW2ldO1xuICAgICAgICBpZiAoKHBbMF0gIT09IC1idWZmZXIgJiYgcFswXSAhPT0gZXh0ZW50ICsgYnVmZmVyKSB8fFxuICAgICAgICAgICAgKHBbMV0gIT09IC1idWZmZXIgJiYgcFsxXSAhPT0gZXh0ZW50ICsgYnVmZmVyKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdG9JRCh6LCB4LCB5KSB7XG4gICAgcmV0dXJuICgoKDEgPDwgeikgKiB5ICsgeCkgKiAzMikgKyB6O1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RYKGEsIGIsIHgpIHtcbiAgICByZXR1cm4gW3gsICh4IC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pIC8gKGJbMF0gLSBhWzBdKSArIGFbMV0sIDFdO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0WShhLCBiLCB5KSB7XG4gICAgcmV0dXJuIFsoeSAtIGFbMV0pICogKGJbMF0gLSBhWzBdKSAvIChiWzFdIC0gYVsxXSkgKyBhWzBdLCB5LCAxXTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSBkZXN0W2ldID0gc3JjW2ldO1xuICAgIHJldHVybiBkZXN0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuXG4vLyBjYWxjdWxhdGUgc2ltcGxpZmljYXRpb24gZGF0YSB1c2luZyBvcHRpbWl6ZWQgRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobVxuXG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlLFxuICAgICAgICBsZW4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IDAsXG4gICAgICAgIGxhc3QgPSBsZW4gLSAxLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBpLCBtYXhTcURpc3QsIHNxRGlzdCwgaW5kZXg7XG5cbiAgICAvLyBhbHdheXMgcmV0YWluIHRoZSBlbmRwb2ludHMgKDEgaXMgdGhlIG1heCB2YWx1ZSlcbiAgICBwb2ludHNbZmlyc3RdWzJdID0gMTtcbiAgICBwb2ludHNbbGFzdF1bMl0gPSAxO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uIGJ5IHVzaW5nIGEgc3RhY2tcbiAgICB3aGlsZSAobGFzdCkge1xuXG4gICAgICAgIG1heFNxRGlzdCA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgICAgICBpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcG9pbnRzW2luZGV4XVsyXSA9IG1heFNxRGlzdDsgLy8gc2F2ZSB0aGUgcG9pbnQgaW1wb3J0YW5jZSBpbiBzcXVhcmVkIHBpeGVscyBhcyBhIHogY29vcmRpbmF0ZVxuICAgICAgICAgICAgc3RhY2sucHVzaChmaXJzdCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIGZpcnN0ID0gaW5kZXg7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGZpcnN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgYSwgYikge1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sXG4gICAgICAgIHB4ID0gcFswXSwgcHkgPSBwWzFdLFxuICAgICAgICBkeCA9IGJ4IC0geCxcbiAgICAgICAgZHkgPSBieSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICB2YXIgdCA9ICgocHggLSB4KSAqIGR4ICsgKHB5IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IGJ4O1xuICAgICAgICAgICAgeSA9IGJ5O1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHB4IC0geDtcbiAgICBkeSA9IHB5IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUaWxlO1xuXG5mdW5jdGlvbiBjcmVhdGVUaWxlKGZlYXR1cmVzLCB6MiwgdHgsIHR5LCB0b2xlcmFuY2UsIG5vU2ltcGxpZnkpIHtcbiAgICB2YXIgdGlsZSA9IHtcbiAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgICBudW1Qb2ludHM6IDAsXG4gICAgICAgIG51bVNpbXBsaWZpZWQ6IDAsXG4gICAgICAgIG51bUZlYXR1cmVzOiAwLFxuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIHg6IHR4LFxuICAgICAgICB5OiB0eSxcbiAgICAgICAgejI6IHoyLFxuICAgICAgICB0cmFuc2Zvcm1lZDogZmFsc2UsXG4gICAgICAgIG1pbjogWzIsIDFdLFxuICAgICAgICBtYXg6IFstMSwgMF1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGlsZS5udW1GZWF0dXJlcysrO1xuICAgICAgICBhZGRGZWF0dXJlKHRpbGUsIGZlYXR1cmVzW2ldLCB0b2xlcmFuY2UsIG5vU2ltcGxpZnkpO1xuXG4gICAgICAgIHZhciBtaW4gPSBmZWF0dXJlc1tpXS5taW4sXG4gICAgICAgICAgICBtYXggPSBmZWF0dXJlc1tpXS5tYXg7XG5cbiAgICAgICAgaWYgKG1pblswXSA8IHRpbGUubWluWzBdKSB0aWxlLm1pblswXSA9IG1pblswXTtcbiAgICAgICAgaWYgKG1pblsxXSA8IHRpbGUubWluWzFdKSB0aWxlLm1pblsxXSA9IG1pblsxXTtcbiAgICAgICAgaWYgKG1heFswXSA+IHRpbGUubWF4WzBdKSB0aWxlLm1heFswXSA9IG1heFswXTtcbiAgICAgICAgaWYgKG1heFsxXSA+IHRpbGUubWF4WzFdKSB0aWxlLm1heFsxXSA9IG1heFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbGU7XG59XG5cbmZ1bmN0aW9uIGFkZEZlYXR1cmUodGlsZSwgZmVhdHVyZSwgdG9sZXJhbmNlLCBub1NpbXBsaWZ5KSB7XG5cbiAgICB2YXIgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGUsXG4gICAgICAgIHNpbXBsaWZpZWQgPSBbXSxcbiAgICAgICAgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2UsXG4gICAgICAgIGksIGosIHJpbmcsIHA7XG5cbiAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2ltcGxpZmllZC5wdXNoKGdlb21baV0pO1xuICAgICAgICAgICAgdGlsZS5udW1Qb2ludHMrKztcbiAgICAgICAgICAgIHRpbGUubnVtU2ltcGxpZmllZCsrO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHNpbXBsaWZ5IGFuZCB0cmFuc2Zvcm0gcHJvamVjdGVkIGNvb3JkaW5hdGVzIGZvciB0aWxlIGdlb21ldHJ5XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByaW5nID0gZ2VvbVtpXTtcblxuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aW55IHBvbHlsaW5lcyAmIHBvbHlnb25zXG4gICAgICAgICAgICBpZiAoIW5vU2ltcGxpZnkgJiYgKCh0eXBlID09PSAyICYmIHJpbmcuZGlzdCA8IHRvbGVyYW5jZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT09IDMgJiYgcmluZy5hcmVhIDwgc3FUb2xlcmFuY2UpKSkge1xuICAgICAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzICs9IHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2ltcGxpZmllZFJpbmcgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwID0gcmluZ1tqXTtcbiAgICAgICAgICAgICAgICAvLyBrZWVwIHBvaW50cyB3aXRoIGltcG9ydGFuY2UgPiB0b2xlcmFuY2VcbiAgICAgICAgICAgICAgICBpZiAobm9TaW1wbGlmeSB8fCBwWzJdID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxpZmllZFJpbmcucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5udW1TaW1wbGlmaWVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNpbXBsaWZpZWQucHVzaChzaW1wbGlmaWVkUmluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2ltcGxpZmllZC5sZW5ndGgpIHtcbiAgICAgICAgdGlsZS5mZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgIGdlb21ldHJ5OiBzaW1wbGlmaWVkLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmUudGFncyB8fCBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsaXAgPSByZXF1aXJlKCcuL2NsaXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwO1xuXG5mdW5jdGlvbiB3cmFwKGZlYXR1cmVzLCBidWZmZXIsIGludGVyc2VjdFgpIHtcbiAgICB2YXIgbWVyZ2VkID0gZmVhdHVyZXMsXG4gICAgICAgIGxlZnQgID0gY2xpcChmZWF0dXJlcywgMSwgLTEgLSBidWZmZXIsIGJ1ZmZlciwgICAgIDAsIGludGVyc2VjdFgsIC0xLCAyKSwgLy8gbGVmdCB3b3JsZCBjb3B5XG4gICAgICAgIHJpZ2h0ID0gY2xpcChmZWF0dXJlcywgMSwgIDEgLSBidWZmZXIsIDIgKyBidWZmZXIsIDAsIGludGVyc2VjdFgsIC0xLCAyKTsgLy8gcmlnaHQgd29ybGQgY29weVxuXG4gICAgaWYgKGxlZnQgfHwgcmlnaHQpIHtcbiAgICAgICAgbWVyZ2VkID0gY2xpcChmZWF0dXJlcywgMSwgLWJ1ZmZlciwgMSArIGJ1ZmZlciwgMCwgaW50ZXJzZWN0WCwgLTEsIDIpOyAvLyBjZW50ZXIgd29ybGQgY29weVxuXG4gICAgICAgIGlmIChsZWZ0KSBtZXJnZWQgPSBzaGlmdEZlYXR1cmVDb29yZHMobGVmdCwgMSkuY29uY2F0KG1lcmdlZCk7IC8vIG1lcmdlIGxlZnQgaW50byBjZW50ZXJcbiAgICAgICAgaWYgKHJpZ2h0KSBtZXJnZWQgPSBtZXJnZWQuY29uY2F0KHNoaWZ0RmVhdHVyZUNvb3JkcyhyaWdodCwgLTEpKTsgLy8gbWVyZ2UgcmlnaHQgaW50byBjZW50ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBzaGlmdEZlYXR1cmVDb29yZHMoZmVhdHVyZXMsIG9mZnNldCkge1xuICAgIHZhciBuZXdGZWF0dXJlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldLFxuICAgICAgICAgICAgdHlwZSA9IGZlYXR1cmUudHlwZTtcblxuICAgICAgICB2YXIgbmV3R2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIG5ld0dlb21ldHJ5ID0gc2hpZnRDb29yZHMoZmVhdHVyZS5nZW9tZXRyeSwgb2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0dlb21ldHJ5ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZlYXR1cmUuZ2VvbWV0cnkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdHZW9tZXRyeS5wdXNoKHNoaWZ0Q29vcmRzKGZlYXR1cmUuZ2VvbWV0cnlbal0sIG9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV3RmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICBnZW9tZXRyeTogbmV3R2VvbWV0cnksXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdGFnczogZmVhdHVyZS50YWdzLFxuICAgICAgICAgICAgbWluOiBbZmVhdHVyZS5taW5bMF0gKyBvZmZzZXQsIGZlYXR1cmUubWluWzFdXSxcbiAgICAgICAgICAgIG1heDogW2ZlYXR1cmUubWF4WzBdICsgb2Zmc2V0LCBmZWF0dXJlLm1heFsxXV1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0ZlYXR1cmVzO1xufVxuXG5mdW5jdGlvbiBzaGlmdENvb3Jkcyhwb2ludHMsIG9mZnNldCkge1xuICAgIHZhciBuZXdQb2ludHMgPSBbXTtcbiAgICBuZXdQb2ludHMuYXJlYSA9IHBvaW50cy5hcmVhO1xuICAgIG5ld1BvaW50cy5kaXN0ID0gcG9pbnRzLmRpc3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdQb2ludHMucHVzaChbcG9pbnRzW2ldWzBdICsgb2Zmc2V0LCBwb2ludHNbaV1bMV0sIHBvaW50c1tpXVsyXV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGdsLW1hdHJpeCAtIEhpZ2ggcGVyZm9ybWFuY2UgbWF0cml4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuICogQGF1dGhvciBCcmFuZG9uIEpvbmVzXG4gKiBAYXV0aG9yIENvbGluIE1hY0tlbnppZSBJVlxuICogQHZlcnNpb24gMi4zLjBcbiAqL1xuXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuLy8gRU5EIEhFQURFUlxuXG5leHBvcnRzLmdsTWF0cml4ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L2NvbW1vbi5qc1wiKTtcbmV4cG9ydHMubWF0MiA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQyLmpzXCIpO1xuZXhwb3J0cy5tYXQyZCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQyZC5qc1wiKTtcbmV4cG9ydHMubWF0MyA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQzLmpzXCIpO1xuZXhwb3J0cy5tYXQ0ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDQuanNcIik7XG5leHBvcnRzLnF1YXQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvcXVhdC5qc1wiKTtcbmV4cG9ydHMudmVjMiA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWMyLmpzXCIpO1xuZXhwb3J0cy52ZWMzID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzMuanNcIik7XG5leHBvcnRzLnZlYzQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjNC5qc1wiKTsiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyBDb21tb24gdXRpbGl0aWVzXG4gKiBAbmFtZSBnbE1hdHJpeFxuICovXG52YXIgZ2xNYXRyaXggPSB7fTtcblxuLy8gQ29uc3RhbnRzXG5nbE1hdHJpeC5FUFNJTE9OID0gMC4wMDAwMDE7XG5nbE1hdHJpeC5BUlJBWV9UWVBFID0gKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKSA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xuZ2xNYXRyaXguUkFORE9NID0gTWF0aC5yYW5kb207XG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2VzXG4gKlxuICogQHBhcmFtIHtUeXBlfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cbmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBHTE1BVF9BUlJBWV9UWVBFID0gdHlwZTtcbn1cblxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IEFuZ2xlIGluIERlZ3JlZXNcbiovXG5nbE1hdHJpeC50b1JhZGlhbiA9IGZ1bmN0aW9uKGEpe1xuICAgICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnbE1hdHJpeDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMngyIE1hdHJpeFxuICogQG5hbWUgbWF0MlxuICovXG52YXIgbWF0MiA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTEgPSBhWzFdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhWzFdO1xuICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuICAgIFxuICAgIG91dFswXSA9ICBhMyAqIGRldDtcbiAgICBvdXRbMV0gPSAtYTEgKiBkZXQ7XG4gICAgb3V0WzJdID0gLWEyICogZGV0O1xuICAgIG91dFszXSA9ICBhMCAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxuICAgIHZhciBhMCA9IGFbMF07XG4gICAgb3V0WzBdID0gIGFbM107XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gIGEwO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDIuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyLm11bCA9IG1hdDIubXVsdGlwbHk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xubWF0Mi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYztcbiAgICBvdXRbMV0gPSBzO1xuICAgIG91dFsyXSA9IC1zO1xuICAgIG91dFszXSA9IGM7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gdlsxXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0Mi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MignICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDIuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSkpXG59O1xuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuXG5tYXQyLkxEVSA9IGZ1bmN0aW9uIChMLCBELCBVLCBhKSB7IFxuICAgIExbMl0gPSBhWzJdL2FbMF07IFxuICAgIFVbMF0gPSBhWzBdOyBcbiAgICBVWzFdID0gYVsxXTsgXG4gICAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTsgXG4gICAgcmV0dXJuIFtMLCBELCBVXTsgICAgICAgXG59OyBcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDI7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDJ4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDJkXG4gKiBcbiAqIEBkZXNjcmlwdGlvbiBcbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5XVxuICogPC9wcmU+XG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5LFxuICogIDAsIDAsIDFdXG4gKiA8L3ByZT5cbiAqIFRoZSBsYXN0IHJvdyBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXG4gKi9cbnZhciBtYXQyZCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcbiAqXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbm1hdDJkLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYWEgPSBhWzBdLCBhYiA9IGFbMV0sIGFjID0gYVsyXSwgYWQgPSBhWzNdLFxuICAgICAgICBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgIGlmKCFkZXQpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDJkLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDJkLm11bCA9IG1hdDJkLm11bHRpcGx5O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyZCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAtcztcbiAgICBvdXRbM10gPSBjO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSB2WzBdO1xuICAgIG91dFs1XSA9IHZbMV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDJkLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyZCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyZC5mcm9iID0gZnVuY3Rpb24gKGEpIHsgXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcbn07IFxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDJkO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAzeDMgTWF0cml4XG4gKiBAbmFtZSBtYXQzXG4gKi9cbnZhciBtYXQzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQzXG4gKlxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVs0XTtcbiAgICBvdXRbNF0gPSBhWzVdO1xuICAgIG91dFs1XSA9IGFbNl07XG4gICAgb3V0WzZdID0gYVs4XTtcbiAgICBvdXRbN10gPSBhWzldO1xuICAgIG91dFs4XSA9IGFbMTBdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGExMiA9IGFbNV07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGEwMTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYTAyO1xuICAgICAgICBvdXRbN10gPSBhMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYVsxXTtcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYVsyXTtcbiAgICAgICAgb3V0WzddID0gYVs1XTtcbiAgICAgICAgb3V0WzhdID0gYVs4XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxLFxuICAgICAgICBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwLFxuICAgICAgICBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjAsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gICAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICAgIG91dFszXSA9IGIxMSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gICAgb3V0WzZdID0gYjIxICogZGV0O1xuICAgIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGEyMiAtIGExMiAqIGEyMSk7XG4gICAgb3V0WzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XG4gICAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gICAgb3V0WzNdID0gKGExMiAqIGEyMCAtIGExMCAqIGEyMik7XG4gICAgb3V0WzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XG4gICAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XG4gICAgb3V0WzZdID0gKGExMCAqIGEyMSAtIGExMSAqIGEyMCk7XG4gICAgb3V0WzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XG4gICAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDMuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdLFxuICAgICAgICBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdLFxuICAgICAgICBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuXG4gICAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG5cbiAgICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gICAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICAgIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcblxuICAgIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gICAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQzLm11bCA9IG1hdDMubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcbiAgICAgICAgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG5cbiAgICBvdXRbM10gPSBhMTA7XG4gICAgb3V0WzRdID0gYTExO1xuICAgIG91dFs1XSA9IGExMjtcblxuICAgIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICAgIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICAgIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gICAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gICAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICAgIG91dFs2XSA9IGEyMDtcbiAgICBvdXRbN10gPSBhMjE7XG4gICAgb3V0WzhdID0gYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IHggKiBhWzBdO1xuICAgIG91dFsxXSA9IHggKiBhWzFdO1xuICAgIG91dFsyXSA9IHggKiBhWzJdO1xuXG4gICAgb3V0WzNdID0geSAqIGFbM107XG4gICAgb3V0WzRdID0geSAqIGFbNF07XG4gICAgb3V0WzVdID0geSAqIGFbNV07XG5cbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IHZbMF07XG4gICAgb3V0WzddID0gdlsxXTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IC1zO1xuICAgIG91dFs0XSA9IGM7XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB2WzFdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5mcm9tTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IGFbMl07XG4gICAgb3V0WzRdID0gYVszXTtcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gYVs0XTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzNdID0geXggLSB3ejtcbiAgICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbNV0gPSB6eSArIHd4O1xuICAgIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMubm9ybWFsRnJvbU1hdDQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0My5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDMuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpKVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDM7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDR4NCBNYXRyaXhcbiAqIEBuYW1lIG1hdDRcbiAqL1xudmFyIG1hdDQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgICAgIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gICAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0NC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTsgIFxuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0NC5tdWwgPSBtYXQ0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNsYXRlID0gZnVuY3Rpb24gKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5tYXQ0LnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgICBvdXRbMF0gPSBhWzBdICogeDtcbiAgICBvdXRbMV0gPSBhWzFdICogeDtcbiAgICBvdXRbMl0gPSBhWzJdICogeDtcbiAgICBvdXRbM10gPSBhWzNdICogeDtcbiAgICBvdXRbNF0gPSBhWzRdICogeTtcbiAgICBvdXRbNV0gPSBhWzVdICogeTtcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcbiAgICBvdXRbN10gPSBhWzddICogeTtcbiAgICBvdXRbOF0gPSBhWzhdICogejtcbiAgICBvdXRbOV0gPSBhWzldICogejtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICAgIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IGdsTWF0cml4LkVQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cbiAgICBcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIGIwMCA9IHggKiB4ICogdCArIGM7IGIwMSA9IHkgKiB4ICogdCArIHogKiBzOyBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gICAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gICAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFs4XSAgPSBhWzhdO1xuICAgICAgICBvdXRbOV0gID0gYVs5XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gICAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tVHJhbnNsYXRpb24gPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSB2WzFdO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IHZbMl07XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0O1xuICAgIFxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG4gICAgXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgICBvdXRbMV0gPSB5ICogeCAqIHQgKyB6ICogcztcbiAgICBvdXRbMl0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHggKiB5ICogdCAtIHogKiBzO1xuICAgIG91dFs1XSA9IHkgKiB5ICogdCArIGM7XG4gICAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4ICogeiAqIHQgKyB5ICogcztcbiAgICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgICBvdXRbMTBdID0geiAqIHogKiB0ICsgYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVhSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IDE7XG4gICAgb3V0WzFdICA9IDA7XG4gICAgb3V0WzJdICA9IDA7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBjO1xuICAgIG91dFs2XSA9IHM7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IC1zO1xuICAgIG91dFsxMF0gPSBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gYztcbiAgICBvdXRbMV0gID0gMDtcbiAgICBvdXRbMl0gID0gLXM7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSBzO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21aUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSBjO1xuICAgIG91dFsxXSAgPSBzO1xuICAgIG91dFsyXSAgPSAwO1xuICAgIG91dFszXSAgPSAwO1xuICAgIG91dFs0XSA9IC1zO1xuICAgIG91dFs1XSA9IGM7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAob3V0LCBxLCB2KSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIG91dFsxXSA9IHh5ICsgd3o7XG4gICAgb3V0WzJdID0geHogLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHh5IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICBvdXRbNl0gPSB5eiArIHd4O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geHogKyB3eTtcbiAgICBvdXRbOV0gPSB5eiAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZSA9IGZ1bmN0aW9uIChvdXQsIHEsIHYsIHMpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MixcbiAgICAgICAgc3ggPSBzWzBdLFxuICAgICAgICBzeSA9IHNbMV0sXG4gICAgICAgIHN6ID0gc1syXTtcblxuICAgIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICAgIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICAgIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gICAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gICAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luID0gZnVuY3Rpb24gKG91dCwgcSwgdiwgcywgbykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgeDIgPSB4ICsgeCxcbiAgICAgIHkyID0geSArIHksXG4gICAgICB6MiA9IHogKyB6LFxuXG4gICAgICB4eCA9IHggKiB4MixcbiAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgeHogPSB4ICogejIsXG4gICAgICB5eSA9IHkgKiB5MixcbiAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgenogPSB6ICogejIsXG4gICAgICB3eCA9IHcgKiB4MixcbiAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgd3ogPSB3ICogejIsXG4gICAgICBcbiAgICAgIHN4ID0gc1swXSxcbiAgICAgIHN5ID0gc1sxXSxcbiAgICAgIHN6ID0gc1syXSxcblxuICAgICAgb3ggPSBvWzBdLFxuICAgICAgb3kgPSBvWzFdLFxuICAgICAgb3ogPSBvWzJdO1xuICAgICAgXG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF0gKyBveCAtIChvdXRbMF0gKiBveCArIG91dFs0XSAqIG95ICsgb3V0WzhdICogb3opO1xuICBvdXRbMTNdID0gdlsxXSArIG95IC0gKG91dFsxXSAqIG94ICsgb3V0WzVdICogb3kgKyBvdXRbOV0gKiBveik7XG4gIG91dFsxNF0gPSB2WzJdICsgb3ogLSAob3V0WzJdICogb3ggKyBvdXRbNl0gKiBveSArIG91dFsxMF0gKiBveik7XG4gIG91dFsxNV0gPSAxO1xuICAgICAgICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbm1hdDQuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJ1c3R1bSA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpLFxuICAgICAgICB0YiA9IDEgLyAodG9wIC0gYm90dG9tKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3ID0gZnVuY3Rpb24gKG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbiksXG4gICAgICAgIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gICAgb3V0WzBdID0geFNjYWxlO1xuICAgIG91dFsxXSA9IDAuMDtcbiAgICBvdXRbMl0gPSAwLjA7XG4gICAgb3V0WzNdID0gMC4wO1xuICAgIG91dFs0XSA9IDAuMDtcbiAgICBvdXRbNV0gPSB5U2NhbGU7XG4gICAgb3V0WzZdID0gMC4wO1xuICAgIG91dFs3XSA9IDAuMDtcbiAgICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgICBvdXRbOV0gPSAoKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICAgIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzExXSA9IC0xLjA7XG4gICAgb3V0WzEyXSA9IDAuMDtcbiAgICBvdXRbMTNdID0gMC4wO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzE1XSA9IDAuMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQub3J0aG8gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KSxcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5sb29rQXQgPSBmdW5jdGlvbiAob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiBtYXQ0LmlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0NC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0NCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQ0LmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYXQ0O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xudmFyIG1hdDMgPSByZXF1aXJlKFwiLi9tYXQzLmpzXCIpO1xudmFyIHZlYzMgPSByZXF1aXJlKFwiLi92ZWMzLmpzXCIpO1xudmFyIHZlYzQgPSByZXF1aXJlKFwiLi92ZWM0LmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAbmFtZSBxdWF0XG4gKi9cbnZhciBxdWF0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XG4gKlxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqL1xucXVhdC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cbiAqXG4gKiBCb3RoIHZlY3RvcnMgYXJlIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGlvblRvID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsMCwwKTtcbiAgICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsMSwwKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICAgICAgdmFyIGRvdCA9IHZlYzMuZG90KGEsIGIpO1xuICAgICAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICAgICAgICBpZiAodmVjMy5sZW5ndGgodG1wdmVjMykgPCAwLjAwMDAwMSlcbiAgICAgICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgICAgICAgIHF1YXQuc2V0QXhpc0FuZ2xlKG91dCwgdG1wdmVjMywgTWF0aC5QSSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICAgICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICAgICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHJpZ2h0IHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInJpZ2h0XCIgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2V0QXhlcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICAgICAgbWF0clswXSA9IHJpZ2h0WzBdO1xuICAgICAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgICAgIG1hdHJbNl0gPSByaWdodFsyXTtcblxuICAgICAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgICAgIG1hdHJbNF0gPSB1cFsxXTtcbiAgICAgICAgbWF0cls3XSA9IHVwWzJdO1xuXG4gICAgICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICAgICAgbWF0cls1XSA9IC12aWV3WzFdO1xuICAgICAgICBtYXRyWzhdID0gLXZpZXdbMl07XG5cbiAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgcXVhdC5mcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jbG9uZSA9IHZlYzQuY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbVZhbHVlcyA9IHZlYzQuZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHNvdXJjZSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jb3B5ID0gdmVjNC5jb3B5O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNldCA9IHZlYzQuc2V0O1xuXG4vKipcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXG4gKiB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xucXVhdC5zZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihvdXQsIGF4aXMsIHJhZCkge1xuICAgIHJhZCA9IHJhZCAqIDAuNTtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gICAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gICAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuYWRkID0gdmVjNC5hZGQ7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubXVsID0gcXVhdC5tdWx0aXBseTtcblxuLyoqXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNjYWxlID0gdmVjNC5zY2FsZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnkgPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXkgKiBieTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnogPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXkgKiBiejtcbiAgICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY2FsY3VsYXRlVyA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcblxuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IE1hdGguc3FydChNYXRoLmFicygxLjAgLSB4ICogeCAtIHkgKiB5IC0geiAqIHopKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5kb3QgPSB2ZWM0LmRvdDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZXJwID0gdmVjNC5sZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNsZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIC8vIGJlbmNobWFya3M6XG4gICAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIHZhciAgICAgICAgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7XG5cbiAgICAvLyBjYWxjIGNvc2luZVxuICAgIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcbiAgICAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcbiAgICBpZiAoIGNvc29tIDwgMC4wICkge1xuICAgICAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICAgICAgYnggPSAtIGJ4O1xuICAgICAgICBieSA9IC0gYnk7XG4gICAgICAgIGJ6ID0gLSBiejtcbiAgICAgICAgYncgPSAtIGJ3O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG4gICAgaWYgKCAoMS4wIC0gY29zb20pID4gMC4wMDAwMDEgKSB7XG4gICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgICAgICBvbWVnYSAgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgICAgICBzaW5vbSAgPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHsgICAgICAgIFxuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlIFxuICAgICAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICAgIHNjYWxlMSA9IHQ7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcbiAgICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICAgIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gICAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zcWxlcnAgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVtcDEgPSBxdWF0LmNyZWF0ZSgpO1xuICB2YXIgdGVtcDIgPSBxdWF0LmNyZWF0ZSgpO1xuICBcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgICBxdWF0LnNsZXJwKHRlbXAxLCBhLCBkLCB0KTtcbiAgICBxdWF0LnNsZXJwKHRlbXAyLCBiLCBjLCB0KTtcbiAgICBxdWF0LnNsZXJwKG91dCwgdGVtcDEsIHRlbXAyLCAyICogdCAqICgxIC0gdCkpO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KCkpO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIGRvdCA9IGEwKmEwICsgYTEqYTEgKyBhMiphMiArIGEzKmEzLFxuICAgICAgICBpbnZEb3QgPSBkb3QgPyAxLjAvZG90IDogMDtcbiAgICBcbiAgICAvLyBUT0RPOiBXb3VsZCBiZSBmYXN0ZXIgdG8gcmV0dXJuIFswLDAsMCwwXSBpbW1lZGlhdGVseSBpZiBkb3QgPT0gMFxuXG4gICAgb3V0WzBdID0gLWEwKmludkRvdDtcbiAgICBvdXRbMV0gPSAtYTEqaW52RG90O1xuICAgIG91dFsyXSA9IC1hMippbnZEb3Q7XG4gICAgb3V0WzNdID0gYTMqaW52RG90O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY29uanVnYXRlID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lmxlbmd0aCA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW4gPSBxdWF0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxckxlbiA9IHF1YXQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIDN4MyByb3RhdGlvbiBtYXRyaXguXG4gKlxuICogTk9URTogVGhlIHJlc3VsdGFudCBxdWF0ZXJuaW9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyB5b3Ugc2hvdWxkIGJlIHN1cmVcbiAqIHRvIHJlbm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uIHlvdXJzZWxmIHdoZXJlIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7bWF0M30gbSByb3RhdGlvbiBtYXRyaXhcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21NYXQzID0gZnVuY3Rpb24ob3V0LCBtKSB7XG4gICAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cbiAgICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICAgIHZhciBmUm9vdDtcblxuICAgIGlmICggZlRyYWNlID4gMC4wICkge1xuICAgICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7ICAvLyAyd1xuICAgICAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUvZlJvb3Q7ICAvLyAxLyg0dylcbiAgICAgICAgb3V0WzBdID0gKG1bNV0tbVs3XSkqZlJvb3Q7XG4gICAgICAgIG91dFsxXSA9IChtWzZdLW1bMl0pKmZSb290O1xuICAgICAgICBvdXRbMl0gPSAobVsxXS1tWzNdKSpmUm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB8d3wgPD0gMS8yXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKCBtWzRdID4gbVswXSApXG4gICAgICAgICAgaSA9IDE7XG4gICAgICAgIGlmICggbVs4XSA+IG1baSozK2ldIClcbiAgICAgICAgICBpID0gMjtcbiAgICAgICAgdmFyIGogPSAoaSsxKSUzO1xuICAgICAgICB2YXIgayA9IChpKzIpJTM7XG4gICAgICAgIFxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChtW2kqMytpXS1tW2oqMytqXS1tW2sqMytrXSArIDEuMCk7XG4gICAgICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290O1xuICAgICAgICBvdXRbM10gPSAobVtqKjMra10gLSBtW2sqMytqXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2pdID0gKG1baiozK2ldICsgbVtpKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtrXSA9IChtW2sqMytpXSArIG1baSozK2tdKSAqIGZSb290O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xucXVhdC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAncXVhdCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcXVhdDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzJcbiAqL1xudmFyIHZlYzIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zdWIgPSB2ZWMyLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXN0ID0gdmVjMi5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyRGlzdCA9IHZlYzIuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmxlbiA9IHZlYzIubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckxlbiA9IHZlYzIuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMyLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMi5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICAgIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDIgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCBcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjMjtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzNcbiAqL1xudmFyIHZlYzMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zdWIgPSB2ZWMzLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLm11bCA9IHZlYzMubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5kaXYgPSB2ZWMzLmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzMuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5kaXN0ID0gdmVjMy5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzMuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zcXJEaXN0ID0gdmVjMy5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmxlbiA9IHZlYzMubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zcXJMZW4gPSB2ZWMzLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmludmVyc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6Kno7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzMuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl07XG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgaGVybWl0ZSBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuaGVybWl0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0LFxuICAgICAgZmFjdG9yMSA9IGZhY3RvclRpbWVzMiAqICgyICogdCAtIDMpICsgMSxcbiAgICAgIGZhY3RvcjIgPSBmYWN0b3JUaW1lczIgKiAodCAtIDIpICsgdCxcbiAgICAgIGZhY3RvcjMgPSBmYWN0b3JUaW1lczIgKiAodCAtIDEpLFxuICAgICAgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqICgzIC0gMiAqIHQpO1xuICBcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5iZXppZXIgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQsXG4gICAgICBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcixcbiAgICAgIGZhY3RvclRpbWVzMiA9IHQgKiB0LFxuICAgICAgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3IsXG4gICAgICBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd28sXG4gICAgICBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3IsXG4gICAgICBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIFxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICB2YXIgeiA9IChnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCkgLSAxLjA7XG4gICAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlO1xuXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gICAgb3V0WzJdID0geiAqIHNjYWxlO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gICAgdyA9IHcgfHwgMS4wO1xuICAgIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICAgIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICAgIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gICAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVggPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICAgdmFyIHAgPSBbXSwgcj1bXTtcblx0ICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cdCAgcFswXSA9IGFbMF0gLSBiWzBdO1xuXHQgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG5cblx0ICAvL3BlcmZvcm0gcm90YXRpb25cblx0ICByWzBdID0gcFswXTtcblx0ICByWzFdID0gcFsxXSpNYXRoLmNvcyhjKSAtIHBbMl0qTWF0aC5zaW4oYyk7XG5cdCAgclsyXSA9IHBbMV0qTWF0aC5zaW4oYykgKyBwWzJdKk1hdGguY29zKGMpO1xuXG5cdCAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXHQgIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuXHQgIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuXHQgIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm90YXRlWSA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gIFx0dmFyIHAgPSBbXSwgcj1bXTtcbiAgXHQvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIFx0cFswXSA9IGFbMF0gLSBiWzBdO1xuICBcdHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG4gIFxuICBcdC8vcGVyZm9ybSByb3RhdGlvblxuICBcdHJbMF0gPSBwWzJdKk1hdGguc2luKGMpICsgcFswXSpNYXRoLmNvcyhjKTtcbiAgXHRyWzFdID0gcFsxXTtcbiAgXHRyWzJdID0gcFsyXSpNYXRoLmNvcyhjKSAtIHBbMF0qTWF0aC5zaW4oYyk7XG4gIFxuICBcdC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgXHRvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgXHRvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgXHRvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm90YXRlWiA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gIFx0dmFyIHAgPSBbXSwgcj1bXTtcbiAgXHQvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIFx0cFswXSA9IGFbMF0gLSBiWzBdO1xuICBcdHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG4gIFxuICBcdC8vcGVyZm9ybSByb3RhdGlvblxuICBcdHJbMF0gPSBwWzBdKk1hdGguY29zKGMpIC0gcFsxXSpNYXRoLnNpbihjKTtcbiAgXHRyWzFdID0gcFswXSpNYXRoLnNpbihjKSArIHBbMV0qTWF0aC5jb3MoYyk7XG4gIFx0clsyXSA9IHBbMl07XG4gIFxuICBcdC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgXHRvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgXHRvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgXHRvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xudmVjMy5hbmdsZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgIFxuICAgIHZhciB0ZW1wQSA9IHZlYzMuZnJvbVZhbHVlcyhhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICB2YXIgdGVtcEIgPSB2ZWMzLmZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSk7XG4gXG4gICAgdmVjMy5ub3JtYWxpemUodGVtcEEsIHRlbXBBKTtcbiAgICB2ZWMzLm5vcm1hbGl6ZSh0ZW1wQiwgdGVtcEIpO1xuIFxuICAgIHZhciBjb3NpbmUgPSB2ZWMzLmRvdCh0ZW1wQSwgdGVtcEIpO1xuXG4gICAgaWYoY29zaW5lID4gMS4wKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICAgIH0gICAgIFxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMy5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnKSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzM7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDQgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWM0XG4gKi9cbnZhciB2ZWM0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxuICpcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHosIHcpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjNCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeiwgdykge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3ViID0gdmVjNC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5tdWwgPSB2ZWM0Lm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGl2ID0gdmVjNC5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGlzdCA9IHZlYzQuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJEaXN0ID0gdmVjNC5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5sZW4gPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWM0LnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckxlbiA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IC1hWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICBvdXRbM10gPSAxLjAgLyBhWzNdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSB4ICogbGVuO1xuICAgICAgICBvdXRbMV0gPSB5ICogbGVuO1xuICAgICAgICBvdXRbMl0gPSB6ICogbGVuO1xuICAgICAgICBvdXRbM10gPSB3ICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl0sXG4gICAgICAgIGF3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgICBvdXRbMF0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMV0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMl0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbM10gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICB2ZWM0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgdmVjNC5zY2FsZShvdXQsIG91dCwgc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICAgIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihhLCBiLCB0KSB7XG4gICAgcmV0dXJuIChhICogKDEgLSB0KSkgKyAoYiAqIHQpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KGEsIGIsIHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IGludGVycG9sYXRlTnVtYmVyKGFbaV0sIGJbaV0sIHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzWydpbnRlcnBvbGF0ZWQnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoIWYuc3RvcHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50KGYpO1xuICAgIH1cblxuICAgIHZhciBzdG9wcyA9IGYuc3RvcHMsXG4gICAgICAgIGJhc2UgPSBmLmJhc2UgfHwgMSxcbiAgICAgICAgaW50ZXJwb2xhdGUgPSBBcnJheS5pc0FycmF5KHN0b3BzWzBdWzFdKSA/IGludGVycG9sYXRlQXJyYXkgOiBpbnRlcnBvbGF0ZU51bWJlcjtcblxuICAgIHJldHVybiBmdW5jdGlvbih6KSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIHR3byBzdG9wcyB3aGljaCB0aGUgY3VycmVudCB6IGlzIGJldHdlZW5cbiAgICAgICAgdmFyIGxvdywgaGlnaDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW2ldO1xuXG4gICAgICAgICAgICBpZiAoc3RvcFswXSA8PSB6KSB7XG4gICAgICAgICAgICAgICAgbG93ID0gc3RvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0b3BbMF0gPiB6KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IHN0b3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG93ICYmIGhpZ2gpIHtcbiAgICAgICAgICAgIHZhciB6b29tRGlmZiA9IGhpZ2hbMF0gLSBsb3dbMF0sXG4gICAgICAgICAgICAgICAgem9vbVByb2dyZXNzID0geiAtIGxvd1swXSxcblxuICAgICAgICAgICAgICAgIHQgPSBiYXNlID09PSAxID9cbiAgICAgICAgICAgICAgICB6b29tUHJvZ3Jlc3MgLyB6b29tRGlmZiA6XG4gICAgICAgICAgICAgICAgKE1hdGgucG93KGJhc2UsIHpvb21Qcm9ncmVzcykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCB6b29tRGlmZikgLSAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKGxvd1sxXSwgaGlnaFsxXSwgdCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBsb3dbMV07XG5cbiAgICAgICAgfSBlbHNlIGlmIChoaWdoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGlnaFsxXTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5leHBvcnRzWydwaWVjZXdpc2UtY29uc3RhbnQnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoIWYuc3RvcHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50KGYpO1xuICAgIH1cblxuICAgIHZhciBzdG9wcyA9IGYuc3RvcHM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oeikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RvcHNbaV1bMF0gPiB6KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3BzW2kgPT09IDAgPyAwIDogaSAtIDFdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdWzFdO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWZlcmVuY2UgPSByZXF1aXJlKCcuLi8uLi9yZWZlcmVuY2UvbGF0ZXN0LmpzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3BhcnNlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKHN0eWxlLCByZWZlcmVuY2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlQ1NTQ29sb3IgPSByZXF1aXJlKCdjc3Njb2xvcnBhcnNlcicpLnBhcnNlQ1NTQ29sb3I7XG52YXIgZm9ybWF0ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHlsZSwgcmVmZXJlbmNlKSB7XG5cbiAgICB2YXIgY29uc3RhbnRzID0gc3R5bGUuY29uc3RhbnRzIHx8IHt9LFxuICAgICAgICBsYXllcnMgPSB7fSxcbiAgICAgICAgZXJyb3JzID0gW107XG5cbiAgICBmdW5jdGlvbiBlcnJvcihrZXksIHZhbCAvKiwgbWVzc2FnZSwgLi4uKi8pIHtcbiAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IChrZXkgPyBrZXkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgIGZvcm1hdC5hcHBseShmb3JtYXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwuX19saW5lX18pIHtcbiAgICAgICAgICAgIGVyci5saW5lID0gdmFsLl9fbGluZV9fO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICB9XG5cbiAgICAvLyBNYWluIHJlY3Vyc2l2ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBUcmFja3M6XG4gICAgLy9cbiAgICAvLyAtIGtleTogc3RyaW5nIHJlcHJlc2VudGluZyBsb2NhdGlvbiBvZiB2YWxpZGF0aW9uIGluIHN0eWxlIHRyZWUuIFVzZWQgb25seVxuICAgIC8vICAgZm9yIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgcmVwb3J0aW5nLlxuICAgIC8vIC0gdmFsOiBjdXJyZW50IHZhbHVlIGZyb20gc3R5bGUgYmVpbmcgZXZhbHVhdGVkLiBNYXkgYmUgYW55dGhpbmcgZnJvbSBhXG4gICAgLy8gICBoaWdoIGxldmVsIG9iamVjdCB0aGF0IG5lZWRzIHRvIGJlIGRlc2NlbmRlZCBpbnRvIGRlZXBlciBvciBhIHNpbXBsZVxuICAgIC8vICAgc2NhbGFyIHZhbHVlLlxuICAgIC8vIC0gc3BlYzogY3VycmVudCBzcGVjIGJlaW5nIGV2YWx1YXRlZC4gVHJhY2tzIHZhbC5cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKGtleSwgdmFsLCBzcGVjKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mXyh2YWwpO1xuXG4gICAgICAgIC8vIENvbnN0YW50c1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnQCcpIHtcbiAgICAgICAgICAgIGlmICghKHZhbCBpbiBjb25zdGFudHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnY29uc3RhbnQgXCIlc1wiIG5vdCBmb3VuZCcsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWwgPSBjb25zdGFudHNbdmFsXTtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlb2ZfKHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGdW5jdGlvbnNcbiAgICAgICAgaWYgKHNwZWMuZnVuY3Rpb24gJiYgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZS5mdW5jdGlvbihrZXksIHZhbCwgc3BlYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BlYy50eXBlKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gdmFsaWRhdGVbc3BlYy50eXBlXTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdG9yKGtleSwgdmFsLCBzcGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwZWMgPSByZWZlcmVuY2Vbc3BlYy50eXBlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbGlkYXRlLm9iamVjdChrZXksIHZhbCwgc3BlYyk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGUuY29uc3RhbnRzID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2ZfKHZhbCk7XG4gICAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnb2JqZWN0IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiB2YWwpIHtcbiAgICAgICAgICAgIGlmIChrWzBdICE9PSAnQCcpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnLicgKyBrLCB2YWxba10sICdjb25zdGFudHMgbXVzdCBzdGFydCB3aXRoIFwiQFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFsaWRhdGUuc291cmNlID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwudHlwZSkge1xuICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICdcInR5cGVcIiBpcyByZXF1aXJlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGUgPSB1bmJ1bmRsZSh2YWwudHlwZSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndmVjdG9yJzpcbiAgICAgICAgICAgIGNhc2UgJ3Jhc3Rlcic6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUub2JqZWN0KGtleSwgdmFsLCByZWZlcmVuY2Uuc291cmNlX3RpbGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCd1cmwnIGluIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFsndHlwZScsICd1cmwnLCAndGlsZVNpemUnXS5pbmRleE9mKHByb3ApIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKGtleSArICcuJyArIHByb3AsIHZhbFtwcm9wXSwgJ2Egc291cmNlIHdpdGggYSBcInVybFwiIHByb3BlcnR5IG1heSBub3QgaW5jbHVkZSBhIFwiJXNcIiBwcm9wZXJ0eScsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnZW9qc29uJzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZS5vYmplY3Qoa2V5LCB2YWwsIHJlZmVyZW5jZS5zb3VyY2VfZ2VvanNvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUub2JqZWN0KGtleSwgdmFsLCByZWZlcmVuY2Uuc291cmNlX3ZpZGVvKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuZW51bShrZXkgKyAnLnR5cGUnLCB2YWwudHlwZSwge3ZhbHVlczogWyd2ZWN0b3InLCAncmFzdGVyJywgJ2dlb2pzb24nLCAndmlkZW8nXX0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhbGlkYXRlLmxheWVyID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwudHlwZSAmJiAhdmFsLnJlZikge1xuICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICdlaXRoZXIgXCJ0eXBlXCIgb3IgXCJyZWZcIiBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGUgPSB1bmJ1bmRsZSh2YWwudHlwZSksXG4gICAgICAgICAgICByZWYgPSB1bmJ1bmRsZSh2YWwucmVmKTtcblxuICAgICAgICBpZiAodmFsLmlkKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXJzW3ZhbC5pZF0pIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbC5pZCwgJ2R1cGxpY2F0ZSBsYXllciBpZCBcIiVzXCIsIHByZXZpb3VzbHkgdXNlZCBhdCBsaW5lICVkJywgdmFsLmlkLCBsYXllcnNbdmFsLmlkXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxheWVyc1t2YWwuaWRdID0gdmFsLmlkLl9fbGluZV9fO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdyZWYnIGluIHZhbCkge1xuICAgICAgICAgICAgWyd0eXBlJywgJ3NvdXJjZScsICdzb3VyY2UtbGF5ZXInLCAnZmlsdGVyJywgJ2xheW91dCddLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocCBpbiB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWxbcF0sICdcIiVzXCIgaXMgcHJvaGliaXRlZCBmb3IgcmVmIGxheWVycycsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGFyZW50O1xuXG4gICAgICAgICAgICBzdHlsZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5pZCA9PSByZWYpIHBhcmVudCA9IGxheWVyO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwucmVmLCAncmVmIGxheWVyIFwiJXNcIiBub3QgZm91bmQnLCByZWYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQucmVmKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwucmVmLCAncmVmIGNhbm5vdCByZWZlcmVuY2UgYW5vdGhlciByZWYgbGF5ZXInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKCF2YWwuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwic291cmNlXCInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHN0eWxlLnNvdXJjZXNbdmFsLnNvdXJjZV07XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwuc291cmNlLCAnc291cmNlIFwiJXNcIiBub3QgZm91bmQnLCB2YWwuc291cmNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS50eXBlID09ICd2ZWN0b3InICYmIHR5cGUgPT0gJ3Jhc3RlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwuc291cmNlLCAnbGF5ZXIgXCIlc1wiIHJlcXVpcmVzIGEgcmFzdGVyIHNvdXJjZScsIHZhbC5pZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UudHlwZSA9PSAncmFzdGVyJyAmJiB0eXBlICE9ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLnNvdXJjZSwgJ2xheWVyIFwiJXNcIiByZXF1aXJlcyBhIHZlY3RvciBzb3VyY2UnLCB2YWwuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbGlkYXRlLm9iamVjdChrZXksIHZhbCwgcmVmZXJlbmNlLmxheWVyLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IHZhbGlkYXRlLmZpbHRlcixcbiAgICAgICAgICAgIGxheW91dDogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BlYyA9IHJlZmVyZW5jZVsnbGF5b3V0XycgKyB0eXBlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZSAmJiBzcGVjICYmIHZhbGlkYXRlKGtleSwgdmFsLCBzcGVjKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYWludDogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BlYyA9IHJlZmVyZW5jZVsncGFpbnRfJyArIHR5cGVdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlICYmIHNwZWMgJiYgdmFsaWRhdGUoa2V5LCB2YWwsIHNwZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdGUub2JqZWN0ID0gZnVuY3Rpb24gKGtleSwgdmFsLCBzcGVjLCB2YWxpZGF0b3JzKSB7XG4gICAgICAgIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IHt9O1xuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mXyh2YWwpO1xuICAgICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihrZXksIHZhbCwgJ29iamVjdCBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsKSB7XG4gICAgICAgICAgICB2YXIgc3BlY2tleSA9IGsuc3BsaXQoJy4nKVswXTsgLy8gdHJlYXQgJ3BhaW50LionIGFzICdwYWludCdcbiAgICAgICAgICAgIHZhciBkZWYgPSBzcGVjW3NwZWNrZXldIHx8IHNwZWNbJyonXTtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gc3BlY2tleS5tYXRjaCgvXiguKiktdHJhbnNpdGlvbiQvKTtcblxuICAgICAgICAgICAgaWYgKGRlZikge1xuICAgICAgICAgICAgICAgICh2YWxpZGF0b3JzW3NwZWNrZXldIHx8IHZhbGlkYXRlKSgoa2V5ID8ga2V5ICsgJy4nIDoga2V5KSArIGssIHZhbFtrXSwgZGVmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbiAmJiBzcGVjW3RyYW5zaXRpb25bMV1dICYmIHNwZWNbdHJhbnNpdGlvblsxXV0udHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlKChrZXkgPyBrZXkgKyAnLicgOiBrZXkpICsgaywgdmFsW2tdLCByZWZlcmVuY2UudHJhbnNpdGlvbik7XG4gICAgICAgICAgICAvLyB0b2xlcmF0ZSByb290LWxldmVsIGV4dHJhIGtleXMgJiBhcmJpdHJhcnkgbGF5ZXIgcHJvcGVydGllc1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09ICcnICYmIGtleS5zcGxpdCgnLicpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGVycm9yKGtleSwgdmFsW2tdLCAndW5rbm93biBwcm9wZXJ0eSBcIiVzXCInLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGwgaW4gc3BlYykge1xuICAgICAgICAgICAgaWYgKHNwZWNbbF0ucmVxdWlyZWQgJiYgc3BlY1tsXVsnZGVmYXVsdCddID09PSB1bmRlZmluZWQgJiYgdmFsW2xdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCIlc1wiJywgbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFsaWRhdGUuYXJyYXkgPSBmdW5jdGlvbiAoa2V5LCB2YWwsIHNwZWMsIHZhbGlkYXRvcikge1xuICAgICAgICBpZiAodHlwZW9mXyh2YWwpICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdhcnJheSBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlb2ZfKHZhbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWMubGVuZ3RoICYmIHZhbC5sZW5ndGggIT09IHNwZWMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdhcnJheSBsZW5ndGggJWQgZXhwZWN0ZWQsIGxlbmd0aCAlZCBmb3VuZCcsIHNwZWMubGVuZ3RoLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBzcGVjLnZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0eWxlLnZlcnNpb24gPCA3KSB7XG4gICAgICAgICAgICB2YWx1ZS5mdW5jdGlvbiA9IHNwZWMuZnVuY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mXyhzcGVjLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc3BlYy52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAodmFsaWRhdG9yIHx8IHZhbGlkYXRlKShrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YWxpZGF0ZS5maWx0ZXIgPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICB2YXIgdHlwZTtcblxuICAgICAgICBpZiAodHlwZW9mXyh2YWwpICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdhcnJheSBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlb2ZfKHZhbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsaWRhdGUuZW51bShrZXkgKyAnWzBdJywgdmFsWzBdLCByZWZlcmVuY2UuZmlsdGVyX29wZXJhdG9yKTtcblxuICAgICAgICBzd2l0Y2ggKHVuYnVuZGxlKHZhbFswXSkpIHtcbiAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPj0gMiAmJiB2YWxbMV0gPT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJ1wiJHR5cGVcIiBjYW5ub3QgYmUgdXNlIHdpdGggb3BlcmF0b3IgXCIlc1wiJywgdmFsWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggIT0gMykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJ2ZpbHRlciBhcnJheSBmb3Igb3BlcmF0b3IgXCIlc1wiIG11c3QgaGF2ZSAzIGVsZW1lbnRzJywgdmFsWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICBjYXNlICchaW4nOlxuICAgICAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVvZl8odmFsWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWzFdJywgdmFsWzFdLCAnc3RyaW5nIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbFsxXVswXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWzFdJywgdmFsWzFdLCAnZmlsdGVyIGtleSBjYW5ub3QgYmUgYSBjb25zdGFudCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlb2ZfKHZhbFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxbMV0gPT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUuZW51bShrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0sIHJlZmVyZW5jZS5nZW9tZXRyeV90eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWxbaV1bMF0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5ICsgJ1snICsgaSArICddJywgdmFsW2ldLCAnZmlsdGVyIHZhbHVlIGNhbm5vdCBiZSBhIGNvbnN0YW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gJ251bWJlcicgJiYgdHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0sICdzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbiBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYW55JzpcbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlLmZpbHRlcihrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YWxpZGF0ZS5mdW5jdGlvbiA9IGZ1bmN0aW9uKGtleSwgdmFsLCBzcGVjKSB7XG4gICAgICAgIHZhbGlkYXRlLm9iamVjdChrZXksIHZhbCwgcmVmZXJlbmNlLmZ1bmN0aW9uLCB7XG4gICAgICAgICAgICBzdG9wczogZnVuY3Rpb24gKGtleSwgdmFsLCBhcnJheVNwZWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFN0b3AgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuYXJyYXkoa2V5LCB2YWwsIGFycmF5U3BlYywgZnVuY3Rpb24gdmFsaWRhdGVTdG9wKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2ZfKHZhbCkgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihrZXksIHZhbCwgJ2FycmF5IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGVvZl8odmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnYXJyYXkgbGVuZ3RoICVkIGV4cGVjdGVkLCBsZW5ndGggJWQgZm91bmQnLCAyLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKGtleSArICdbMF0nLCB2YWxbMF0sIHt0eXBlOiAnbnVtYmVyJ30pO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShrZXkgKyAnWzFdJywgdmFsWzFdLCBzcGVjKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mXyh2YWxbMF0pID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWMuZnVuY3Rpb24gPT09ICdwaWVjZXdpc2UtY29uc3RhbnQnICYmIHZhbFswXSAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWzBdJywgdmFsWzBdLCAnem9vbSBsZXZlbCBmb3IgcGllY2V3aXNlLWNvbnN0YW50IGZ1bmN0aW9ucyBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbFswXSA8IGxhc3RTdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5ICsgJ1swXScsIHZhbFswXSwgJ2FycmF5IHN0b3BzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U3RvcCA9IHZhbFswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZl8odmFsKSA9PT0gJ2FycmF5JyAmJiB2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdG9wJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdGUuZW51bSA9IGZ1bmN0aW9uIChrZXksIHZhbCwgc3BlYykge1xuICAgICAgICBpZiAoc3BlYy52YWx1ZXMuaW5kZXhPZih1bmJ1bmRsZSh2YWwpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnZXhwZWN0ZWQgb25lIG9mIFslc10sICVzIGZvdW5kJywgc3BlYy52YWx1ZXMuam9pbignLCAnKSwgdmFsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YWxpZGF0ZS5jb2xvciA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mXyh2YWwpO1xuICAgICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnY29sb3IgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyc2VDU1NDb2xvcih2YWwpID09PSBudWxsKSB7XG4gICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJ2NvbG9yIGV4cGVjdGVkLCBcIiVzXCIgZm91bmQnLCB2YWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHR5cGVWYWxpZGF0b3IoZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsLCBzcGVjKSB7XG4gICAgICAgICAgICB2YXIgYWN0dWFsID0gdHlwZW9mXyh2YWwpO1xuICAgICAgICAgICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJyVzIGV4cGVjdGVkLCAlcyBmb3VuZCcsIGV4cGVjdGVkLCBhY3R1YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJ21pbmltdW0nIGluIHNwZWMgJiYgdmFsIDwgc3BlYy5taW5pbXVtKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICclcyBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gdmFsdWUgJXMnLCB2YWwsIHNwZWMubWluaW11bSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgnbWF4aW11bScgaW4gc3BlYyAmJiB2YWwgPiBzcGVjLm1heGltdW0pIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJyVzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSAlcycsIHZhbCwgc3BlYy5tYXhpbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZS5udW1iZXIgPSB0eXBlVmFsaWRhdG9yKCdudW1iZXInKTtcbiAgICB2YWxpZGF0ZS5zdHJpbmcgPSB0eXBlVmFsaWRhdG9yKCdzdHJpbmcnKTtcbiAgICB2YWxpZGF0ZS5ib29sZWFuID0gdHlwZVZhbGlkYXRvcignYm9vbGVhbicpO1xuXG4gICAgdmFsaWRhdGVbJyonXSA9IGZ1bmN0aW9uKCkge307XG5cbiAgICB2YWxpZGF0ZSgnJywgc3R5bGUsIHJlZmVyZW5jZS4kcm9vdCk7XG5cbiAgICByZXR1cm4gZXJyb3JzO1xufTtcblxuZnVuY3Rpb24gdHlwZW9mXyh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTnVtYmVyKVxuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFN0cmluZylcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBCb29sZWFuKVxuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIGlmICh2YWwgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG59XG5cbmZ1bmN0aW9uIHVuYnVuZGxlKF8pIHtcbiAgICBpZiAoXyBpbnN0YW5jZW9mIE51bWJlciB8fFxuICAgICAgICBfIGluc3RhbmNlb2YgU3RyaW5nIHx8XG4gICAgICAgIF8gaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiBfLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXztcbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdjcuanNvbicpO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiR2ZXJzaW9uXCI6IDcsXG4gIFwiJHJvb3RcIjoge1xuICAgIFwidmVyc2lvblwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIDdcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIlN0eWxlc2hlZXQgdmVyc2lvbiBudW1iZXIuIE11c3QgYmUgNy5cIlxuICAgIH0sXG4gICAgXCJuYW1lXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIGh1bWFuLXJlYWRhYmxlIG5hbWUgZm9yIHRoZSBzdHlsZS5cIlxuICAgIH0sXG4gICAgXCJjb25zdGFudHNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29uc3RhbnRzXCIsXG4gICAgICBcImRvY1wiOiBcIkFuIG9iamVjdCBvZiBjb25zdGFudHMgdG8gYmUgcmVmZXJlbmNlZCBpbiBsYXllcnMuXCJcbiAgICB9LFxuICAgIFwic291cmNlc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJzb3VyY2VzXCIsXG4gICAgICBcImRvY1wiOiBcIkRhdGEgc291cmNlIHNwZWNpZmljYXRpb25zLlwiXG4gICAgfSxcbiAgICBcInNwcml0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBiYXNlIFVSTCBmb3IgcmV0cmlldmluZyB0aGUgc3ByaXRlIGltYWdlIGFuZCBtZXRhZGF0YS4gVGhlIGV4dGVuc2lvbnMgYC5wbmdgLCBgLmpzb25gIGFuZCBzY2FsZSBmYWN0b3IgYEAyeC5wbmdgIHdpbGwgYmUgYXV0b21hdGljYWxseSBhcHBlbmRlZC5cIlxuICAgIH0sXG4gICAgXCJnbHlwaHNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkEgVVJMIHRlbXBsYXRlIGZvciBsb2FkaW5nIHNpZ25lZC1kaXN0YW5jZS1maWVsZCBnbHlwaCBzZXRzIGluIFBCRiBmb3JtYXQuIFZhbGlkIHRva2VucyBhcmUge2ZvbnRzdGFja30gYW5kIHtyYW5nZX0uXCJcbiAgICB9LFxuICAgIFwidHJhbnNpdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJ0cmFuc2l0aW9uXCIsXG4gICAgICBcImRvY1wiOiBcIkEgZ2xvYmFsIHRyYW5zaXRpb24gZGVmaW5pdGlvbiB0byB1c2UgYXMgYSBkZWZhdWx0IGFjcm9zcyBwcm9wZXJ0aWVzLlwiXG4gICAgfSxcbiAgICBcImxheWVyc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcImxheWVyXCIsXG4gICAgICBcImRvY1wiOiBcIkxheWVycyB3aWxsIGJlIGRyYXduIGluIHRoZSBvcmRlciBvZiB0aGlzIGFycmF5LlwiXG4gICAgfVxuICB9LFxuICBcImNvbnN0YW50c1wiOiB7XG4gICAgXCIqXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBjb25zdGFudCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgdmVyYmF0aW0gaW4gdGhlIHJlZmVyZW5jaW5nIHBsYWNlLiBUaGlzIGNhbiBiZSBhbnl0aGluZywgaW5jbHVkaW5nIG9iamVjdHMgYW5kIGFycmF5cy4gQWxsIHZhcmlhYmxlIG5hbWVzIG11c3QgYmUgcHJlZml4ZWQgd2l0aCBhbiBgQGAgc3ltYm9sLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZXNcIjoge1xuICAgIFwiKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzb3VyY2VcIixcbiAgICAgIFwiZG9jXCI6IFwiU3BlY2lmaWNhdGlvbiBvZiBhIGRhdGEgc291cmNlLiBGb3IgdmVjdG9yIGFuZCByYXN0ZXIgc291cmNlcywgZWl0aGVyIFRpbGVKU09OIG9yIGEgVVJMIHRvIGEgVGlsZUpTT04gbXVzdCBiZSBwcm92aWRlZC4gRm9yIEdlb0pTT04gYW5kIHZpZGVvIHNvdXJjZXMsIGEgVVJMIG11c3QgYmUgcHJvdmlkZWQuXCJcbiAgICB9XG4gIH0sXG4gIFwic291cmNlXCI6IFtcbiAgICBcInNvdXJjZV90aWxlXCIsXG4gICAgXCJzb3VyY2VfZ2VvanNvblwiLFxuICAgIFwic291cmNlX3ZpZGVvXCJcbiAgXSxcbiAgXCJzb3VyY2VfdGlsZVwiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2ZWN0b3JcIixcbiAgICAgICAgXCJyYXN0ZXJcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgc291cmNlLlwiXG4gICAgfSxcbiAgICBcInVybFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBVUkwgdG8gYSBUaWxlSlNPTiByZXNvdXJjZS4gU3VwcG9ydGVkIHByb3RvY29scyBhcmUgYGh0dHA6YCwgYGh0dHBzOmAsIGFuZCBgbWFwYm94Oi8vPG1hcGlkPmAuXCJcbiAgICB9LFxuICAgIFwidGlsZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgdGlsZSBzb3VyY2UgVVJMcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcbiAgICB9LFxuICAgIFwibWluem9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJNaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gICAgfSxcbiAgICBcIm1heHpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMjIsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcbiAgICB9LFxuICAgIFwidGlsZVNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogNTEyLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy5cIlxuICAgIH0sXG4gICAgXCIqXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZV9nZW9qc29uXCI6IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImdlb2pzb25cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIlxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VfdmlkZW9cIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlkZW9cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ1cmxcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiVVJMcyB0byB2aWRlbyBjb250ZW50IGluIG9yZGVyIG9mIHByZWZlcnJlZCBmb3JtYXQuXCJcbiAgICB9LFxuICAgIFwiY29vcmRpbmF0ZXNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwibGVuZ3RoXCI6IDQsXG4gICAgICBcInZhbHVlXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcImxheWVyXCI6IHtcbiAgICBcImlkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJVbmlxdWUgbGF5ZXIgbmFtZS5cIlxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJmaWxsXCIsXG4gICAgICAgIFwibGluZVwiLFxuICAgICAgICBcInN5bWJvbFwiLFxuICAgICAgICBcInJhc3RlclwiLFxuICAgICAgICBcImJhY2tncm91bmRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIlxuICAgIH0sXG4gICAgXCJyZWZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlJlZmVyZW5jZXMgYW5vdGhlciBsYXllciB0byBjb3B5IGB0eXBlYCwgYHNvdXJjZWAsIGBzb3VyY2UtbGF5ZXJgLCBgbWluem9vbWAsIGBtYXh6b29tYCwgYGZpbHRlcmAsIGFuZCBgbGF5b3V0YCBwcm9wZXJ0aWVzIGZyb20uIFRoaXMgYWxsb3dzIHRoZSBsYXllcnMgdG8gc2hhcmUgcHJvY2Vzc2luZyBhbmQgYmUgbW9yZSBlZmZpY2llbnQuXCJcbiAgICB9LFxuICAgIFwic291cmNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGEgc291cmNlIGRlc2NyaXB0aW9uIHRvIGJlIHVzZWQgZm9yIHRoaXMgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwic291cmNlLWxheWVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJMYXllciB0byB1c2UgZnJvbSBhIHZlY3RvciB0aWxlIHNvdXJjZS4gUmVxdWlyZWQgaWYgdGhlIHNvdXJjZSBzdXBwb3J0cyBtdWx0aXBsZSBsYXllcnMuXCJcbiAgICB9LFxuICAgIFwibWluem9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDIyLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBsYXllciBnZXRzIHBhcnNlZCBhbmQgYXBwZWFycyBvbi5cIlxuICAgIH0sXG4gICAgXCJtYXh6b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMjIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGxheWVyIGdldHMgcGFyc2VkIGFuZCBhcHBlYXJzIG9uLlwiXG4gICAgfSxcbiAgICBcImludGVyYWN0aXZlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZG9jXCI6IFwiRW5hYmxlIHF1ZXJ5aW5nIG9mIGZlYXR1cmUgZGF0YSBmcm9tIHRoaXMgbGF5ZXIgZm9yIGludGVyYWN0aXZpdHkuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiZmlsdGVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlclwiLFxuICAgICAgXCJkb2NcIjogXCJBIGV4cHJlc3Npb24gc3BlY2lmeWluZyBjb25kaXRpb25zIG9uIHNvdXJjZSBmZWF0dXJlcy4gT25seSBmZWF0dXJlcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgYXJlIGRpc3BsYXllZC5cIlxuICAgIH0sXG4gICAgXCJsYXlvdXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGF5b3V0XCIsXG4gICAgICBcImRvY1wiOiBcIkxheW91dCBwcm9wZXJ0aWVzIGZvciB0aGUgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwicGFpbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFpbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiRGVmYXVsdCBwYWludCBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLlwiXG4gICAgfSxcbiAgICBcInBhaW50LipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFpbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiQ2xhc3Mtc3BlY2lmaWMgcGFpbnQgcHJvcGVydGllcyBmb3IgdGhpcyBsYXllci4gVGhlIGNsYXNzIG5hbWUgaXMgdGhlIHBhcnQgYWZ0ZXIgdGhlIGZpcnN0IGRvdC5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRcIjogW1xuICAgIFwibGF5b3V0X2ZpbGxcIixcbiAgICBcImxheW91dF9saW5lXCIsXG4gICAgXCJsYXlvdXRfc3ltYm9sXCIsXG4gICAgXCJsYXlvdXRfcmFzdGVyXCIsXG4gICAgXCJsYXlvdXRfYmFja2dyb3VuZFwiXG4gIF0sXG4gIFwibGF5b3V0X2JhY2tncm91bmRcIjoge1xuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X2ZpbGxcIjoge1xuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X2xpbmVcIjoge1xuICAgIFwibGluZS1jYXBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImJ1dHRcIixcbiAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICBcInNxdWFyZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiYnV0dFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiBsaW5lIGVuZGluZ3MuXCJcbiAgICB9LFxuICAgIFwibGluZS1qb2luXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJiZXZlbFwiLFxuICAgICAgICBcInJvdW5kXCIsXG4gICAgICAgIFwibWl0ZXJcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1pdGVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmVzIHdoZW4gam9pbmluZy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLW1pdGVyLWxpbWl0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IG1pdGVyIGpvaW5zIHRvIGJldmVsIGpvaW5zIGZvciBzaGFycCBhbmdsZXMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwibGluZS1qb2luXCI6IFwibWl0ZXJcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtcm91bmQtbGltaXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgcm91bmQgam9pbnMgdG8gbWl0ZXIgam9pbnMgZm9yIHNoYWxsb3cgYW5nbGVzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImxpbmUtam9pblwiOiBcInJvdW5kXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfc3ltYm9sXCI6IHtcbiAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICAgIFwicG9pbnRcIixcbiAgICAgICAgICBcImxpbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInBvaW50XCIsXG4gICAgICBcImRvY1wiOiBcIkxhYmVsIHBsYWNlbWVudCByZWxhdGl2ZSB0byBpdHMgZ2VvbWV0cnkuIGBsaW5lYCBjYW4gb25seSBiZSB1c2VkIG9uIExpbmVTdHJpbmdzIGFuZCBQb2x5Z29ucy5cIlxuICAgIH0sXG4gICAgXCJzeW1ib2wtbWluLWRpc3RhbmNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDI1MCxcbiAgICAgIFwibWluaW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJNaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdHdvIHN5bWJvbCBhbmNob3JzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJzeW1ib2wtYXZvaWQtZWRnZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgc3ltYm9scyB3aWxsIG5vdCBjcm9zcyB0aWxlIGVkZ2VzIHRvIGF2b2lkIG11dHVhbCBjb2xsaXNpb25zLiBSZWNvbW1lbmRlZCBpbiBsYXllcnMgdGhhdCBkb24ndCBoYXZlIGVub3VnaCBwYWRkaW5nIGluIHRoZSB2ZWN0b3IgdGlsZSB0byBwcmV2ZW50IGNvbGxpc2lvbnMsIG9yIGlmIGl0IGlzIGEgcG9pbnQgc3ltYm9sIGxheWVyIHBsYWNlZCBhZnRlciBhIGxpbmUgc3ltYm9sIGxheWVyLlwiXG4gICAgfSxcbiAgICBcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBpY29uIHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgaWNvbnMgYW5kIHRleHQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gd29uJ3QgYWZmZWN0IHBsYWNlbWVudCBvZiBvdGhlciBpY29ucyBhbmQgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLW9wdGlvbmFsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHN5bWJvbCB3aWxsIGFwcGVhciB3aXRob3V0IGl0cyBpY29uLCBpbiBzcGFjZXMgd2hlcmUgdGhlIGljb24gd291bGQgbWFrZSBpdCB0b28gbGFyZ2UgdG8gZml0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpZXdwb3J0XCIsXG4gICAgICBcImRvY1wiOiBcIk9yaWVudGF0aW9uIG9mIGljb24gd2hlbiBtYXAgaXMgcm90YXRlZC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLW1heC1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gZmFjdG9yIHRvIHNjYWxlIHRoZSBpY29uLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRvY1wiOiBcIkEgc3RyaW5nIHdpdGgge3Rva2Vuc30gcmVwbGFjZWQsIHJlZmVyZW5jaW5nIHRoZSBkYXRhIHByb3BlcnR5IHRvIHB1bGwgZnJvbS5cIixcbiAgICAgIFwidG9rZW5zXCI6IHRydWVcbiAgICB9LFxuICAgIFwiaWNvbi1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgdGhlIGljb24gY2xvY2t3aXNlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tcGFkZGluZ1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlBhZGRpbmcgdmFsdWUgYXJvdW5kIGljb24gYm91bmRpbmcgYm94IHRvIGF2b2lkIGljb24gY29sbGlzaW9ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWtlZXAtdXByaWdodFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBpY29uIG1heSBiZSBmbGlwcGVkIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93blwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1vZmZzZXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJJY29uJ3Mgb2Zmc2V0IGRpc3RhbmNlLiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpZXdwb3J0XCIsXG4gICAgICBcImRvY1wiOiBcIk9yaWVudGF0aW9uIG9mIGljb24gb3IgdGV4dCB3aGVuIG1hcCBpcyByb3RhdGVkLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtZmllbGRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJcIixcbiAgICAgIFwidG9rZW5zXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIlZhbHVlIHRvIHVzZSBmb3IgYSB0ZXh0IGxhYmVsLiBGZWF0dXJlIHByb3BlcnRpZXMgYXJlIHNwZWNpZmllZCB1c2luZyB0b2tlbnMgbGlrZSB7ZmllbGRfbmFtZX0uXCJcbiAgICB9LFxuICAgIFwidGV4dC1mb250XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiT3BlbiBTYW5zIFJlZ3VsYXIsIEFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiLFxuICAgICAgXCJkb2NcIjogXCJGb250IHN0YWNrIHRvIHVzZSBmb3IgZGlzcGxheWluZyB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbWF4LXNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTYsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gc2l6ZSB0ZXh0IHdpbGwgYmUgbGFpZCBvdXQsIHRvIGNhbGN1bGF0ZSBjb2xsaXNpb25zIHdpdGguXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1tYXgtd2lkdGhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTUsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJlbVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciB0ZXh0IHdyYXBwaW5nLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbGluZS1oZWlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMS4yLFxuICAgICAgXCJ1bml0c1wiOiBcImVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlRleHQgbGVhZGluZyB2YWx1ZSBmb3IgbXVsdGktbGluZSB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJlbVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGtlcm5pbmcgdmFsdWUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1qdXN0aWZ5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwicmlnaHRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGp1c3RpZmljYXRpb24gb3B0aW9ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwibGVmdFwiLFxuICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgIFwidG9wXCIsXG4gICAgICAgIFwiYm90dG9tXCIsXG4gICAgICAgIFwidG9wLWxlZnRcIixcbiAgICAgICAgXCJ0b3AtcmlnaHRcIixcbiAgICAgICAgXCJib3R0b20tbGVmdFwiLFxuICAgICAgICBcImJvdHRvbS1yaWdodFwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgICBcImRvY1wiOiBcIldoaWNoIHBhcnQgb2YgdGhlIHRleHQgdG8gcGxhY2UgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbWF4LWFuZ2xlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDQ1LFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiTWF4aW11bSBhbmdsZSBjaGFuZ2UgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgdGhlIHRleHQgY2xvY2t3aXNlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtcGFkZGluZ1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlBhZGRpbmcgdmFsdWUgYXJvdW5kIHRleHQgYm91bmRpbmcgYm94IHRvIGF2b2lkIGxhYmVsIGNvbGxpc2lvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IG1heSBiZSBmbGlwcGVkIHZlcnRpY2FsbHkgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2Zvcm1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgXCJ1cHBlcmNhc2VcIixcbiAgICAgICAgXCJsb3dlcmNhc2VcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm5vbmVcIixcbiAgICAgIFwiZG9jXCI6IFwiU3BlY2lmaWVzIGhvdyB0byBjYXBpdGFsaXplIHRleHQsIHNpbWlsYXIgdG8gdGhlIENTUyBgdGV4dC10cmFuc2Zvcm1gIHByb3BlcnR5LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtb2Zmc2V0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyB0aGUgZGlzdGFuY2UgdGhhdCB0ZXh0IGlzIG9mZnNldCBmcm9tIGl0cyBhbmNob3IgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LlwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJ1bml0c1wiOiBcImVtc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBpY29ucyBhbmQgbGFiZWxzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdvbid0IGFmZmVjdCBwbGFjZW1lbnQgb2Ygb3RoZXIgaWNvbnMgYW5kIGxhYmVscy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW9wdGlvbmFsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHN5bWJvbCB3aWxsIGFwcGVhciB3aXRob3V0IGl0cyB0ZXh0LCBpbiBzcGFjZXMgd2hlcmUgdGhlIHRleHQgd291bGQgbWFrZSBpdCB0b28gbGFyZ2UgdG8gZml0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfcmFzdGVyXCI6IHtcbiAgICBcInZpc2liaWxpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpc2libGVcIixcbiAgICAgICAgXCJub25lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiXG4gICAgfVxuICB9LFxuICBcImZpbHRlclwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICBcInZhbHVlXCI6IFwiKlwiXG4gIH0sXG4gIFwiZmlsdGVyX29wZXJhdG9yXCI6IHtcbiAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgXCI9PVwiLFxuICAgICAgXCIhPVwiLFxuICAgICAgXCI+XCIsXG4gICAgICBcIj49XCIsXG4gICAgICBcIjxcIixcbiAgICAgIFwiPD1cIixcbiAgICAgIFwiaW5cIixcbiAgICAgIFwiIWluXCIsXG4gICAgICBcImFsbFwiLFxuICAgICAgXCJhbnlcIixcbiAgICAgIFwibm9uZVwiXG4gICAgXVxuICB9LFxuICBcImdlb21ldHJ5X3R5cGVcIjoge1xuICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICBcInZhbHVlc1wiOiBbXG4gICAgICBcIlBvaW50XCIsXG4gICAgICBcIkxpbmVTdHJpbmdcIixcbiAgICAgIFwiUG9seWdvblwiXG4gICAgXVxuICB9LFxuICBcImZ1bmN0aW9uXCI6IHtcbiAgICBcInN0b3BzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkFuIGFycmF5IG9mIHN0b3BzLlwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcImZ1bmN0aW9uX3N0b3BcIlxuICAgIH0sXG4gICAgXCJiYXNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGV4cG9uZW50aWFsIGJhc2Ugb2YgdGhlIGludGVycG9sYXRpb24gY3VydmUuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSByZXN1bHQgaW5jcmVhc2VzLiBIaWdoZXIgdmFsdWVzIG1ha2UgdGhlIHJlc3VsdCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCBgMWAgdGhlIHN0b3BzIGFyZSBpbnRlcnBvbGF0ZWQgbGluZWFybHkuXCJcbiAgICB9XG4gIH0sXG4gIFwiZnVuY3Rpb25fc3RvcFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICBcIm1pbmltdW1cIjogMCxcbiAgICBcIm1heGltdW1cIjogMjIsXG4gICAgXCJ2YWx1ZVwiOiBbXG4gICAgICBcIm51bWJlclwiLFxuICAgICAgXCJjb2xvclwiXG4gICAgXSxcbiAgICBcImxlbmd0aFwiOiAyLFxuICAgIFwiZG9jXCI6IFwiWm9vbSBsZXZlbCBhbmQgdmFsdWUgcGFpci5cIlxuICB9LFxuICBcInBhaW50XCI6IFtcbiAgICBcInBhaW50X2ZpbGxcIixcbiAgICBcInBhaW50X2xpbmVcIixcbiAgICBcInBhaW50X3N5bWJvbFwiLFxuICAgIFwicGFpbnRfcmFzdGVyXCIsXG4gICAgXCJwYWludF9iYWNrZ3JvdW5kXCJcbiAgXSxcbiAgXCJwYWludF9maWxsXCI6IHtcbiAgICBcImZpbGwtYW50aWFsaWFzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJXaGV0aGVyIG9yIG5vdCB0aGUgZmlsbCBzaG91bGQgYmUgYW50aWFsaWFzZWQuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBnaXZlbiB0byB0aGUgZmlsbCBjb2xvci5cIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImZpbGwtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBmaWxsLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImZpbGwtaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImZpbGwtb3V0bGluZS1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3V0bGluZSBjb2xvciBvZiB0aGUgZmlsbC4gTWF0Y2hlcyB0aGUgdmFsdWUgb2YgYGZpbGwtY29sb3JgIGlmIHVuc3BlY2lmaWVkLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImZpbGwtaW1hZ2VcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJmaWxsLWFudGlhbGlhc1wiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZmlsbC10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCJcbiAgICB9LFxuICAgIFwiZmlsbC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJmaWxsLXRyYW5zbGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImZpbGwtaW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGZpbGxzLlwiXG4gICAgfVxuICB9LFxuICBcInBhaW50X2xpbmVcIjoge1xuICAgIFwibGluZS1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgbGluZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwibGluZS1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgbGluZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImxpbmUtaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwibGluZS10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJTdHJva2UgdGhpY2tuZXNzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtZ2FwLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiRHJhd3MgYSBsaW5lIGNhc2luZyBvdXRzaWRlIG9mIGEgbGluZSdzIGFjdHVhbCBwYXRoLiBWYWx1ZSBpbmRpY2F0ZXMgdGhlIHdpZHRoIG9mIHRoZSBpbm5lciBnYXAuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIlxuICAgIH0sXG4gICAgXCJsaW5lLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkJsdXIgYXBwbGllZCB0byB0aGUgbGluZSwgaW4gcGl4ZWxzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtZGFzaGFycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyB0aGUgbGVuZ3RocyBvZiB0aGUgYWx0ZXJuYXRpbmcgZGFzaGVzIGFuZCBnYXBzIHRoYXQgZm9ybSB0aGUgZGFzaCBwYXR0ZXJuLiBUaGUgbGVuZ3RocyBhcmUgbGF0ZXIgc2NhbGVkIGJ5IHRoZSBsaW5lIHdpZHRoLiBUbyBjb252ZXJ0IGEgZGFzaCBsZW5ndGggdG8gcGl4ZWxzLCBtdWx0aXBseSB0aGUgbGVuZ3RoIGJ5IHRoZSBjdXJyZW50IGxpbmUgd2lkdGguXCIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcImxpbmUgd2lkdGhzXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImxpbmUtaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtaW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGxpbmVzLlwiXG4gICAgfVxuICB9LFxuICBcInBhaW50X3N5bWJvbFwiOiB7XG4gICAgXCJpY29uLW9wYWNpdHlcIjoge1xuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaWNvbiB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJTY2FsZSBmYWN0b3IgZm9yIGljb24uIDEgaXMgb3JpZ2luYWwgc2l6ZSwgMyB0cmlwbGVzIHRoZSBzaXplLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24uIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNkZiBpY29ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWhhbG8tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24ncyBoYWxvLiBJY29uIGhhbG9zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBpY29uIG91dGxpbmUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkZhZGUgb3V0IHRoZSBoYWxvIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkFuIGljb24ncyBvZmZzZXQgZGlzdGFuY2UuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICBcImljb24tdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDE2LFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiRm9udCBzaXplLiBJZiB1bnNwZWNpZmllZCwgdGhlIHRleHQgd2lsbCBiZSBhcyBiaWcgYXMgYWxsb3dlZCBieSB0aGUgbGF5ZXIgZGVmaW5pdGlvbi5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIHRleHQncyBoYWxvLCB3aGljaCBoZWxwcyBpdCBzdGFuZCBvdXQgZnJvbSBiYWNrZ3JvdW5kcy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8td2lkdGhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGZvbnQgb3V0bGluZS4gTWF4IHRleHQgaGFsbyB3aWR0aCBpcyAxLzQgb2YgdGhlIGZvbnQtc2l6ZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8tYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGhhbG8ncyBmYWRlb3V0IGRpc3RhbmNlIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkxhYmVsIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICAgIFwidGV4dC10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9yYXN0ZXJcIjoge1xuICAgIFwicmFzdGVyLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpbWFnZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLWh1ZS1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyBodWVzIGFyb3VuZCB0aGUgY29sb3Igd2hlZWwuXCJcbiAgICB9LFxuICAgIFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1pbmltdW0gYnJpZ2h0bmVzcy5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIGJyaWdodG5lc3MuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItc2F0dXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBpbWFnZS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IC0xLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItY29udHJhc3RcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgY29udHJhc3Qgb2YgdGhlIGltYWdlLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogLTEsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMwMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBcImRvY1wiOiBcIkZhZGUgZHVyYXRpb24gd2hlbiBhIG5ldyB0aWxlIGlzIGFkZGVkLlwiXG4gICAgfVxuICB9LFxuICBcInBhaW50X2JhY2tncm91bmRcIjoge1xuICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImJhY2tncm91bmQtaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImJhY2tncm91bmQtaW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiT3B0aW9uYWxseSBhbiBpbWFnZSB3aGljaCBpcyBkcmF3biBhcyB0aGUgYmFja2dyb3VuZC5cIlxuICAgIH0sXG4gICAgXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgXCJ0cmFuc2l0aW9uXCI6IHtcbiAgICBcImR1cmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMwMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaW1lIGFsbG90dGVkIGZvciB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZS5cIlxuICAgIH0sXG4gICAgXCJkZWxheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBcImRvY1wiOiBcIkxlbmd0aCBvZiB0aW1lIGJlZm9yZSBhIHRyYW5zaXRpb24gYmVnaW5zLlwiXG4gICAgfVxuICB9XG59XG4iLCIvLyBUb3AgbGV2ZWwgZmlsZSBpcyBqdXN0IGEgbWl4aW4gb2Ygc3VibW9kdWxlcyAmIGNvbnN0YW50c1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMvY29tbW9uJykuYXNzaWduO1xuXG52YXIgZGVmbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvZGVmbGF0ZScpO1xudmFyIGluZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2luZmxhdGUnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2xpYi96bGliL2NvbnN0YW50cycpO1xuXG52YXIgcGFrbyA9IHt9O1xuXG5hc3NpZ24ocGFrbywgZGVmbGF0ZSwgaW5mbGF0ZSwgY29uc3RhbnRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYWtvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZS5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgenN0cmVhbSA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xuXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG5cbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbnZhciBEZWZsYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cbn07XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zaCBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tEZWZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogYXJyYXkgZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3VwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbHJvcnl0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgZGF0YSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZzsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xuZXhwb3J0cy5nemlwID0gZ3ppcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUuanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIGMgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgenN0cmVhbSA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgZ3poZWFkZXIgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG52YXIgSW5mbGF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgZ3poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcbn07XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGFcbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFuc2ggWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tJbmZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgZGVjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBPbmx5IGJpbmFyeSBzdHJpbmdzIGNhbiBiZSBkZWNvbXByZXNzZWQgb24gcHJhY3RpY2VcbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbFxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgeyB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOyB9XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3VwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxsaWduZWQgc3RyaW5ncyB0byBvbkRhdGFcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBpbnB1dCA9IHBha28uZGVmbGF0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnOyB9XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xuZXhwb3J0cy51bmd6aXAgID0gaW5mbGF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMrbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24oY2h1bmtzKSB7XG4gICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0O1xuXG4gICAgLy8gY2FsY3VsYXRlIGRhdGEgbGVuZ3RoXG4gICAgbGVuID0gMDtcbiAgICBmb3IgKGk9MCwgbD1jaHVua3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gam9pbiBjaHVua3NcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIHBvcyA9IDA7XG4gICAgZm9yIChpPTAsIGw9Y2h1bmtzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xuICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTtcbiAgICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGZuVW50eXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGZvciAodmFyIGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcnlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbMF0pOyB9IGNhdGNoKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7XG5mb3IgKHZhciBxPTA7IHE8MjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdPV91dGY4bGVuWzI1NF09MTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcysxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MrMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpPTAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlciAodXNlZCBpbiAyIHBsYWNlcylcbmZ1bmN0aW9uIGJ1ZjJiaW5zdHJpbmcoYnVmLCBsZW4pIHtcbiAgLy8gdXNlIGZhbGxiYWNrIGZvciBiaWcgYXJyYXlzIHRvIGF2b2lkIHN0YWNrIG92ZXJmbG93XG4gIGlmIChsZW4gPCA2NTUzNykge1xuICAgIGlmICgoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHx8ICghYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9PSykpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaT0wOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmdcbmV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uKGJ1Zikge1xuICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpO1xufTtcblxuXG4vLyBDb252ZXJ0IGJpbmFyeSBzdHJpbmcgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaT0wLCBsZW49YnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbmV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4qMik7XG5cbiAgZm9yIChvdXQ9MCwgaT0wOyBpPGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbi0xOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbmV4cG9ydHMudXRmOGJvcmRlciA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4LTE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIEZ1Y2t1cCAtIHZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgdnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGRvZXNuJ3Qgd29ydGggdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbmEgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0wOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0wOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjJjEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjID0gY3JjIF4gKC0xKTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIqTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkgKHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0gtMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSC0xKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0gtMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplLU1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSC0xO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMS0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGgtMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0gtMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSC0xID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSC0xO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG52YXIgQ29uZmlnID0gZnVuY3Rpb24gKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn07XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIqRF9DT0RFUysxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIqQkxfQ09ERVMrMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMrMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMipMX0NPREVTKzEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIqTF9DT0RFUysxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIHMuZF9idWYgPSBzLmxpdF9idWZzaXplID4+IDE7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB0aGUgc291cmNlIHN0YXRlIHRvIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZVxuICovXG4vL2Z1bmN0aW9uIGRlZmxhdGVDb3B5KGRlc3QsIHNvdXJjZSkge1xuLy9cbi8vfVxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHZhciB3aW5kb3c7ICAgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHdpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSB3aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiBaU1dBUDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywge2JpdHM6IDl9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7Yml0czogNX0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn1cblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7XG4gIHZhciBkaXN0O1xuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcbiAgdmFyIGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIHZhciBvcHRzO1xuXG4gIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFNcblxuICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgY2FzZSBIRUFEOlxuICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNDtcbiAgICAgIGJpdHMgLT0gNDtcbiAgICAgIC8vLS0tLy9cbiAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRkxBR1M6XG4gICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRJTUU6XG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgLy89PT1cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgT1M6XG4gICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRVhMRU46XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEVYVFJBOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW5kIHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTkFNRTpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBIQ1JDOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwIC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBESUNUSUQ6XG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSBaU1dBUDMyKGhvbGQpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJQ1Q6XG4gICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRTpcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRZUEVETzpcbiAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gMTtcbiAgICAgIGJpdHMgLT0gMTtcbiAgICAgIC8vLS0tLy9cblxuICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgYml0cyAtPSAyO1xuICAgICAgLy8tLS0vL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTVE9SRUQ6XG4gICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAvLy0tLS8vXG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZXzpcbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09QWTpcbiAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBpZiAoY29weSkge1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFRBQkxFOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNDtcbiAgICAgIGJpdHMgLT0gNDtcbiAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuLy8jZW5kaWZcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkxFTlM6XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICBvcHRzID0ge2JpdHM6IHN0YXRlLmxlbmJpdHN9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgb3B0cyA9IHtiaXRzOiBzdGF0ZS5sZW5iaXRzfTtcbiAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgIG9wdHMgPSB7Yml0czogc3RhdGUuZGlzdGJpdHN9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5fOlxuICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTjpcbiAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgIC8vLS0tXG5cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0xKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5FWFQ6XG4gICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLTEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElTVDpcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0xKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLTEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBESVNURVhUOlxuICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0xKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE1BVENIOlxuICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgfVxuICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICBkbyB7XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMSVQ6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBsZWZ0LS07XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDSEVDSzpcbiAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAvLyBVc2UgJ3wnIGluc2RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgfVxuICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgWlNXQVAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiBaU1dBUDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOR1RIOlxuICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRE9ORTpcbiAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIEJBRDpcbiAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIE1FTTpcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICBjYXNlIFNZTkM6XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUysxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMrMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBpPTA7XG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIGkrKztcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAnMic6ICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgJzEnOiAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gICcwJzogICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMipMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc2RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMrMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0gtTUlOX01BVENIKzEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxudmFyIFN0YXRpY1RyZWVEZXNjID0gZnVuY3Rpb24gKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn07XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG52YXIgVHJlZURlc2MgPSBmdW5jdGlvbihkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59O1xuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydCAocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjKjJdLyouQ29kZSovLCB0cmVlW2MqMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSoyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4KzE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuKjIgKzFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbioyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbi1iYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbioyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGgtMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzKzFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttKjIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSoyICsgMV0vKi5MZW4qLykqdHJlZVttKjJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20qMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTKzEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzLTFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24qMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuKjJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTKzEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUy0xOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDE8PGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGgtMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMCA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDE8PGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxPDwoZXh0cmFfZGJpdHNbY29kZV0tNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuKjIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbioyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24qMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuKjIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUysxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbioyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24qMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTKzEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID1uZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbioyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbioyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24qMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLKjJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbioyO1xuICB2YXIgX20yID0gbSoyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqKzFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4KjJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4KjIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUrTElURVJBTFMrMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbioyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlKjIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuKjIgKyAxXS8qLkRhZCovID0gdHJlZVttKjIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCoyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUrMSkqMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobisxKSoyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNioyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCoyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCoyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCoyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobisxKSoyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50LTMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudC0zLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQtMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMtMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdKjIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMqKG1heF9ibGluZGV4KzEpICsgNSs1KzQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzLTI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzLTEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzLTQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdKjIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzLTEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMtMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbioyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0s8PDEpKyhsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUzw8MSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiszKzcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiszKzcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbis0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUzw8MSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVM8PDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlKzEsIHMuZF9kZXNjLm1heF9jb2RlKzEsIG1heF9ibGluZGV4KzEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMqMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXStMSVRFUkFMUysxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmFpbHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZS0xKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbGlnaHR3ZWlnaHQgQnVmZmVyIHNoaW0gZm9yIHBiZiBicm93c2VyIGJ1aWxkXG4vLyBiYXNlZCBvbiBjb2RlIGZyb20gZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyIChNSVQtbGljZW5zZWQpXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKTtcblxudmFyIEJ1ZmZlck1ldGhvZHM7XG5cbmZ1bmN0aW9uIEJ1ZmZlcihsZW5ndGgpIHtcbiAgICB2YXIgYXJyO1xuICAgIGlmIChsZW5ndGggJiYgbGVuZ3RoLmxlbmd0aCkge1xuICAgICAgICBhcnIgPSBsZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGggfHwgMCk7XG4gICAgaWYgKGFycikgYnVmLnNldChhcnIpO1xuXG4gICAgYnVmLnJlYWRVSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZFVJbnQzMkxFO1xuICAgIGJ1Zi53cml0ZVVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZVVJbnQzMkxFO1xuICAgIGJ1Zi5yZWFkSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZEludDMyTEU7XG4gICAgYnVmLndyaXRlSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVJbnQzMkxFO1xuICAgIGJ1Zi5yZWFkRmxvYXRMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZEZsb2F0TEU7XG4gICAgYnVmLndyaXRlRmxvYXRMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVGbG9hdExFO1xuICAgIGJ1Zi5yZWFkRG91YmxlTEUgPSBCdWZmZXJNZXRob2RzLnJlYWREb3VibGVMRTtcbiAgICBidWYud3JpdGVEb3VibGVMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVEb3VibGVMRTtcbiAgICBidWYudG9TdHJpbmcgPSBCdWZmZXJNZXRob2RzLnRvU3RyaW5nO1xuICAgIGJ1Zi53cml0ZSA9IEJ1ZmZlck1ldGhvZHMud3JpdGU7XG4gICAgYnVmLnNsaWNlID0gQnVmZmVyTWV0aG9kcy5zbGljZTtcbiAgICBidWYuY29weSA9IEJ1ZmZlck1ldGhvZHMuY29weTtcblxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlO1xuICAgIHJldHVybiBidWY7XG59XG5cbnZhciBsYXN0U3RyLCBsYXN0U3RyRW5jb2RlZDtcblxuQnVmZmVyTWV0aG9kcyA9IHtcbiAgICByZWFkVUludDMyTEU6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gKCh0aGlzW3Bvc10pIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDJdIDw8IDE2KSkgK1xuICAgICAgICAgICAgKHRoaXNbcG9zICsgM10gKiAweDEwMDAwMDApO1xuICAgIH0sXG5cbiAgICB3cml0ZVVJbnQzMkxFOiBmdW5jdGlvbih2YWwsIHBvcykge1xuICAgICAgICB0aGlzW3Bvc10gPSB2YWw7XG4gICAgICAgIHRoaXNbcG9zICsgMV0gPSAodmFsID4+PiA4KTtcbiAgICAgICAgdGhpc1twb3MgKyAyXSA9ICh2YWwgPj4+IDE2KTtcbiAgICAgICAgdGhpc1twb3MgKyAzXSA9ICh2YWwgPj4+IDI0KTtcbiAgICB9LFxuXG4gICAgcmVhZEludDMyTEU6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gKCh0aGlzW3Bvc10pIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDJdIDw8IDE2KSkgK1xuICAgICAgICAgICAgKHRoaXNbcG9zICsgM10gPDwgMjQpO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXRMRTogIGZ1bmN0aW9uKHBvcykgeyByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIHBvcywgdHJ1ZSwgMjMsIDQpOyB9LFxuICAgIHJlYWREb3VibGVMRTogZnVuY3Rpb24ocG9zKSB7IHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgcG9zLCB0cnVlLCA1MiwgOCk7IH0sXG5cbiAgICB3cml0ZUZsb2F0TEU6ICBmdW5jdGlvbih2YWwsIHBvcykgeyByZXR1cm4gaWVlZTc1NC53cml0ZSh0aGlzLCB2YWwsIHBvcywgdHJ1ZSwgMjMsIDQpOyB9LFxuICAgIHdyaXRlRG91YmxlTEU6IGZ1bmN0aW9uKHZhbCwgcG9zKSB7IHJldHVybiBpZWVlNzU0LndyaXRlKHRoaXMsIHZhbCwgcG9zLCB0cnVlLCA1MiwgOCk7IH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnLFxuICAgICAgICAgICAgdG1wID0gJyc7XG5cbiAgICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCwgZW5kIHx8IHRoaXMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChjaCA8PSAweDdGKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGRlY29kZVVSSUNvbXBvbmVudCh0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICAgICAgdG1wID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRtcCArPSAnJScgKyBjaC50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gZGVjb2RlVVJJQ29tcG9uZW50KHRtcCk7XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgd3JpdGU6IGZ1bmN0aW9uKHN0ciwgcG9zKSB7XG4gICAgICAgIHZhciBieXRlcyA9IHN0ciA9PT0gbGFzdFN0ciA/IGxhc3RTdHJFbmNvZGVkIDogZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbcG9zICsgaV0gPSBieXRlc1tpXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzbGljZTogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oYnVmLCBwb3MpIHtcbiAgICAgICAgcG9zID0gcG9zIHx8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdGhpc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJ1ZmZlck1ldGhvZHMud3JpdGVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZVVJbnQzMkxFO1xuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGxhc3RTdHIgPSBzdHI7XG4gICAgbGFzdFN0ckVuY29kZWQgPSBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gbGFzdFN0ckVuY29kZWQubGVuZ3RoO1xufTtcblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgcmV0dXJuICEhKGJ1ZiAmJiBidWYuX2lzQnVmZmVyKTtcbn07XG5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aCxcbiAgICAgICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBjLCBsZWFkOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBjb2RlIHBvaW50XG5cbiAgICAgICAgaWYgKGMgPiAweEQ3RkYgJiYgYyA8IDB4RTAwMCkge1xuXG4gICAgICAgICAgICBpZiAobGVhZCkge1xuICAgICAgICAgICAgICAgIGlmIChjIDwgMHhEQzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBsZWFkIC0gMHhEODAwIDw8IDEwIHwgYyAtIDB4REMwMCB8IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA+IDB4REJGRiB8fCAoaSArIDEgPT09IGxlbmd0aCkpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICAgICAgZWxzZSBsZWFkID0gYztcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobGVhZCkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgIGxlYWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSBieXRlcy5wdXNoKGMpO1xuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIGJ5dGVzLnB1c2goYyA+PiAweDYgfCAweEMwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgICAgICBlbHNlIGlmIChjIDwgMHgxMDAwMCkgYnl0ZXMucHVzaChjID4+IDB4QyB8IDB4RTAsIGMgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgIGVsc2UgYnl0ZXMucHVzaChjID4+IDB4MTIgfCAweEYwLCBjID4+IDB4QyAmIDB4M0YgfCAweDgwLCBjID4+IDB4NiAmIDB4M0YgfCAweDgwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGJmO1xuXG52YXIgQnVmZmVyID0gZ2xvYmFsLkJ1ZmZlciB8fCByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5mdW5jdGlvbiBQYmYoYnVmKSB7XG4gICAgdGhpcy5idWYgPSAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikgPyBuZXcgQnVmZmVyKGJ1ZiB8fCAwKSA6IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7XG59XG5cblBiZi5WYXJpbnQgID0gMDsgLy8gdmFyaW50OiBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuUGJmLkZpeGVkNjQgPSAxOyAvLyA2NC1iaXQ6IGRvdWJsZSwgZml4ZWQ2NCwgc2ZpeGVkNjRcblBiZi5CeXRlcyAgID0gMjsgLy8gbGVuZ3RoLWRlbGltaXRlZDogc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcblBiZi5GaXhlZDMyID0gNTsgLy8gMzItYml0OiBmbG9hdCwgZml4ZWQzMiwgc2ZpeGVkMzJcblxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksXG4gICAgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMixcbiAgICBQT1dfMl82MyA9IE1hdGgucG93KDIsIDYzKTtcblxuUGJmLnByb3RvdHlwZSA9IHtcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7XG4gICAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWwgPj4gMyxcbiAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgICByZWFkRmllbGQodGFnLCByZXN1bHQsIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0UG9zKSB0aGlzLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICByZWFkTWVzc2FnZTogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpZWxkcyhyZWFkRmllbGQsIHJlc3VsdCwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7XG4gICAgfSxcblxuICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIDY0LWJpdCBpbnQgaGFuZGxpbmcgaXMgYmFzZWQgb24gZ2l0aHViLmNvbS9kcHcvbm9kZS1idWZmZXItbW9yZS1pbnRzIChNSVQtbGljZW5zZWQpXG5cbiAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEZsb2F0TEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWREb3VibGVMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmID0gdGhpcy5idWYsXG4gICAgICAgICAgICB2YWwsIGIsIGIwLCBiMSwgYjIsIGIzO1xuXG4gICAgICAgIGIwID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjAgPCAweDgwKSByZXR1cm4gYjA7ICAgICAgICAgICAgICAgICBiMCA9IGIwICYgMHg3ZjtcbiAgICAgICAgYjEgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMSA8IDB4ODApIHJldHVybiBiMCB8IGIxIDw8IDc7ICAgICAgIGIxID0gKGIxICYgMHg3ZikgPDwgNztcbiAgICAgICAgYjIgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMiA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgPDwgMTQ7IGIyID0gKGIyICYgMHg3ZikgPDwgMTQ7XG4gICAgICAgIGIzID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjMgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIHwgYjMgPDwgMjE7XG5cbiAgICAgICAgdmFsID0gYjAgfCBiMSB8IGIyIHwgKGIzICYgMHg3ZikgPDwgMjE7XG5cbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDsgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDQwMDAwMDAwMDAwOyAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwMDAwMDAwMDsgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDAwMDAwMDA7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzJyk7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IFBPV18yXzYzKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zltwb3NdID09PSAweGZmKSBwb3MtLTtcbiAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UG9zKSBwb3MgPSBzdGFydFBvcztcblxuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcyAtIHN0YXJ0UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IH50aGlzLmJ1ZltzdGFydFBvcyArIGldICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCArPSBpIDwgNCA/IGIgPDwgaSAqIDcgOiBiICogTWF0aC5wb3coMiwgaSAqIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC12YWwgLSAxO1xuICAgIH0sXG5cbiAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW0gPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH0sXG5cbiAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICB9LFxuXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgc3RyID0gdGhpcy5idWYudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHJlYWRCeXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0sXG5cbiAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblxuICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgICAgIGlmICh0eXBlID09PSBQYmYuVmFyaW50KSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKSB7fVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdmFsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4M2ZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDIpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMyk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHhmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMjEpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHdoaWxlICh2YWwgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICh2YWwgJiAweGZmKSB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFsIC89IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbCB8IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgLSBwb3MgPiAxMCkgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YXJpbnQgZG9lc25cXCd0IGZpdCBpbnRvIDEwIGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd3JpdGVTVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwgPCAwID8gLXZhbCAqIDIgLSAxIDogdmFsICogMik7XG4gICAgfSxcblxuICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbiAgICB9LFxuXG4gICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChieXRlcyk7XG4gICAgICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICB9LFxuXG4gICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVGbG9hdExFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVEb3VibGVMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVCeXRlczogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucmVhbGxvYyhsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IGJ1ZmZlcltpXTtcbiAgICB9LFxuXG4gICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbih0YWcsIGZuLCBvYmopIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG5cbiAgICAgICAgdGhpcy5wb3MrKzsgLy8gcmVzZXJ2ZSAxIGJ5dGUgZm9yIHNob3J0IG1lc3NhZ2UgbGVuZ3RoXG5cbiAgICAgICAgLy8gd3JpdGUgdGhlIG1lc3NhZ2UgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zO1xuICAgICAgICBmbihvYmosIHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5wb3MgLSBzdGFydFBvcztcblxuICAgICAgICB2YXIgdmFyaW50TGVuID1cbiAgICAgICAgICAgIGxlbiA8PSAweDdmID8gMSA6XG4gICAgICAgICAgICBsZW4gPD0gMHgzZmZmID8gMiA6XG4gICAgICAgICAgICBsZW4gPD0gMHgxZmZmZmYgPyAzIDpcbiAgICAgICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyA0IDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAgICAgLy8gaWYgMSBieXRlIGlzbid0IGVub3VnaCBmb3IgZW5jb2RpbmcgbWVzc2FnZSBsZW5ndGgsIHNoaWZ0IHRoZSBkYXRhIHRvIHRoZSByaWdodFxuICAgICAgICBpZiAodmFyaW50TGVuID4gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKHZhcmludExlbiAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSB0aGlzLmJ1ZltpICsgdmFyaW50TGVuIC0gMV0gPSB0aGlzLmJ1ZltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgLSAxO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB9LFxuXG4gICAgd3JpdGVQYWNrZWRWYXJpbnQ6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFZhcmludCwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkU1ZhcmludDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTVmFyaW50LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEJvb2xlYW46ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkQm9vbGVhbiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRGbG9hdDogICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZsb2F0LCBhcnIpOyAgICB9LFxuICAgIHdyaXRlUGFja2VkRG91YmxlOiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWREb3VibGUsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkMzI6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQzMiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDMyLCBhcnIpOyB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDY0LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkNjQsIGFycik7IH0sXG5cbiAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXMoYnVmZmVyKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVNWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uKHRhZywgc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG4gICAgfSxcbiAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZURvdWJsZSh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0YWcsIEJvb2xlYW4odmFsKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVQYWNrZWRWYXJpbnQoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlVmFyaW50KGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU1ZhcmludChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGbG9hdChhcnIsIHBiZikgICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRmxvYXQoYXJyW2ldKTsgICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWREb3VibGUoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRG91YmxlKGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlQm9vbGVhbihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQzMihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQzMihhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkMzIoYXJyW2ldKTsgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQ2NChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NChhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkNjQoYXJyW2ldKTsgfVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbmZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG59XG5cblBvaW50LnByb3RvdHlwZSA9IHtcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpOyB9LFxuXG4gICAgYWRkOiAgICAgZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQocCk7ICAgICB9LFxuICAgIHN1YjogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKHApOyAgICAgfSxcbiAgICBtdWx0OiAgICBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX211bHQoayk7ICAgIH0sXG4gICAgZGl2OiAgICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXYoayk7ICAgICB9LFxuICAgIHJvdGF0ZTogIGZ1bmN0aW9uKGEpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlKGEpOyAgfSxcbiAgICBtYXRNdWx0OiBmdW5jdGlvbihtKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX21hdE11bHQobSk7IH0sXG4gICAgdW5pdDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3VuaXQoKTsgfSxcbiAgICBwZXJwOiAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcGVycCgpOyB9LFxuICAgIHJvdW5kOiAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpOyB9LFxuXG4gICAgbWFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcC54ICYmXG4gICAgICAgICAgICAgICB0aGlzLnkgPT09IHAueTtcbiAgICB9LFxuXG4gICAgZGlzdDogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdFNxcihwKSk7XG4gICAgfSxcblxuICAgIGRpc3RTcXI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIGR4ID0gcC54IC0gdGhpcy54LFxuICAgICAgICAgICAgZHkgPSBwLnkgLSB0aGlzLnk7XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9LFxuXG4gICAgYW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgfSxcblxuICAgIGFuZ2xlVG86IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55IC0gYi55LCB0aGlzLnggLSBiLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVdpdGg6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGVXaXRoU2VwKGIueCwgYi55KTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgYW5nbGUgb2YgdGhlIHR3byB2ZWN0b3JzLCBzb2x2aW5nIHRoZSBmb3JtdWxhIGZvciB0aGUgY3Jvc3MgcHJvZHVjdCBhIHggYiA9IHxhfHxifHNpbijOuCkgZm9yIM64LlxuICAgIGFuZ2xlV2l0aFNlcDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIHRoaXMueCAqIHkgLSB0aGlzLnkgKiB4LFxuICAgICAgICAgICAgdGhpcy54ICogeCArIHRoaXMueSAqIHkpO1xuICAgIH0sXG5cbiAgICBfbWF0TXVsdDogZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeCA9IG1bMF0gKiB0aGlzLnggKyBtWzFdICogdGhpcy55LFxuICAgICAgICAgICAgeSA9IG1bMl0gKiB0aGlzLnggKyBtWzNdICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FkZDogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggKz0gcC54O1xuICAgICAgICB0aGlzLnkgKz0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3N1YjogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggLT0gcC54O1xuICAgICAgICB0aGlzLnkgLT0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX211bHQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54ICo9IGs7XG4gICAgICAgIHRoaXMueSAqPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2RpdjogZnVuY3Rpb24oaykge1xuICAgICAgICB0aGlzLnggLz0gaztcbiAgICAgICAgdGhpcy55IC89IGs7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rpdih0aGlzLm1hZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9wZXJwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueDtcbiAgICAgICAgdGhpcy54ID0gLXk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgeCA9IGNvcyAqIHRoaXMueCAtIHNpbiAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBzaW4gKiB0aGlzLnggKyBjb3MgKiB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gY29uc3RydWN0cyBQb2ludCBmcm9tIGFuIGFycmF5IGlmIG5lY2Vzc2FyeVxuUG9pbnQuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChhWzBdLCBhWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuIiwiLypcbiAoYykgMjAxMywgVmxhZGltaXIgQWdhZm9ua2luXG4gUkJ1c2gsIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBoaWdoLXBlcmZvcm1hbmNlIDJEIHNwYXRpYWwgaW5kZXhpbmcgb2YgcG9pbnRzIGFuZCByZWN0YW5nbGVzLlxuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoXG4qL1xuXG4oZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCkge1xuXG4gICAgLy8ganNoaW50IG5ld2NhcDogZmFsc2UsIHZhbGlkdGhpczogdHJ1ZVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbnJidXNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH0sXG5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlLmJib3gpKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGNvbGxpZGVzOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUuYmJveCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3g7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGxvYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS5sZW5ndGgpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLl9taW5FbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc3RyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fYnVpbGQoZGF0YS5zbGljZSgpLCAwLCBkYXRhLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gdG1wTm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBzbWFsbCB0cmVlIGludG8gdGhlIGxhcmdlIHRyZWUgYXQgYXBwcm9wcmlhdGUgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlLCB0aGlzLmRhdGEuaGVpZ2h0IC0gbm9kZS5oZWlnaHQgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgYmJveDogZW1wdHkoKSxcbiAgICAgICAgICAgIGxlYWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5vZGUuY2hpbGRyZW4uaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUuYmJveCwgYmJveCkpIHsgLy8gZ28gZG93blxuICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHsgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSBub2RlID0gbnVsbDsgLy8gbm90aGluZyBmb3VuZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvQkJveDogZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH0sXG5cbiAgICBjb21wYXJlTWluWDogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9LFxuICAgIGNvbXBhcmVNaW5ZOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVsxXSAtIGJbMV07IH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGF0YTsgfSxcblxuICAgIGZyb21KU09OOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FsbDogZnVuY3Rpb24gKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoLmFwcGx5KG5vZGVzVG9TZWFyY2gsIG5vZGUuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfYnVpbGQ6IGZ1bmN0aW9uIChpdGVtcywgbGVmdCwgcmlnaHQsIGhlaWdodCkge1xuXG4gICAgICAgIHZhciBOID0gcmlnaHQgLSBsZWZ0ICsgMSxcbiAgICAgICAgICAgIE0gPSB0aGlzLl9tYXhFbnRyaWVzLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAoTiA8PSBNKSB7XG4gICAgICAgICAgICAvLyByZWFjaGVkIGxlYWYgbGV2ZWw7IHJldHVybiBsZWFmXG4gICAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBpdGVtcy5zbGljZShsZWZ0LCByaWdodCArIDEpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICBiYm94OiBudWxsLFxuICAgICAgICAgICAgICAgIGxlYWY6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gZWxpbWluYXRlIHJlY3Vyc2lvbj9cblxuICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBiYm94OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3BsaXQgdGhlIGl0ZW1zIGludG8gTSBtb3N0bHkgc3F1YXJlIHRpbGVzXG5cbiAgICAgICAgdmFyIE4yID0gTWF0aC5jZWlsKE4gLyBNKSxcbiAgICAgICAgICAgIE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKSxcbiAgICAgICAgICAgIGksIGosIHJpZ2h0MiwgcmlnaHQzO1xuXG4gICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBsZWZ0LCByaWdodCwgTjEsIHRoaXMuY29tcGFyZU1pblgpO1xuXG4gICAgICAgIGZvciAoaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkgKz0gTjEpIHtcblxuICAgICAgICAgICAgcmlnaHQyID0gTWF0aC5taW4oaSArIE4xIC0gMSwgcmlnaHQpO1xuXG4gICAgICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPD0gcmlnaHQyOyBqICs9IE4yKSB7XG5cbiAgICAgICAgICAgICAgICByaWdodDMgPSBNYXRoLm1pbihqICsgTjIgLSAxLCByaWdodDIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKGl0ZW1zLCBqLCByaWdodDMsIGhlaWdodCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVN1YnRyZWU6IGZ1bmN0aW9uIChiYm94LCBub2RlLCBsZXZlbCwgcGF0aCkge1xuXG4gICAgICAgIHZhciBpLCBsZW4sIGNoaWxkLCB0YXJnZXROb2RlLCBhcmVhLCBlbmxhcmdlbWVudCwgbWluQXJlYSwgbWluRW5sYXJnZW1lbnQ7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBwYXRoLmxlbmd0aCAtIDEgPT09IGxldmVsKSBicmVhaztcblxuICAgICAgICAgICAgbWluQXJlYSA9IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGNoaWxkLmJib3gpO1xuICAgICAgICAgICAgICAgIGVubGFyZ2VtZW50ID0gZW5sYXJnZWRBcmVhKGJib3gsIGNoaWxkLmJib3gpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2luc2VydDogZnVuY3Rpb24gKGl0ZW0sIGxldmVsLCBpc05vZGUpIHtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBiYm94ID0gaXNOb2RlID8gaXRlbS5iYm94IDogdG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgaW5zZXJ0UGF0aCA9IFtdO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3Qgbm9kZSBmb3IgYWNjb21tb2RhdGluZyB0aGUgaXRlbSwgc2F2aW5nIGFsbCBub2RlcyBhbG9uZyB0aGUgcGF0aCB0b29cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgaXRlbSBpbnRvIHRoZSBub2RlXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgICAgZXh0ZW5kKG5vZGUuYmJveCwgYmJveCk7XG5cbiAgICAgICAgLy8gc3BsaXQgb24gbm9kZSBvdmVyZmxvdzsgcHJvcGFnYXRlIHVwd2FyZHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHdoaWxlIChsZXZlbCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0UGF0aFtsZXZlbF0uY2hpbGRyZW4ubGVuZ3RoID4gdGhpcy5fbWF4RW50cmllcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwbGl0KGluc2VydFBhdGgsIGxldmVsKTtcbiAgICAgICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgaW5zZXJ0aW9uIHBhdGhcbiAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIGluc2VydFBhdGgsIGxldmVsKTtcbiAgICB9LFxuXG4gICAgLy8gc3BsaXQgb3ZlcmZsb3dlZCBub2RlIGludG8gdHdvXG4gICAgX3NwbGl0OiBmdW5jdGlvbiAoaW5zZXJ0UGF0aCwgbGV2ZWwpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IGluc2VydFBhdGhbbGV2ZWxdLFxuICAgICAgICAgICAgTSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgICAgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBuZXdOb2RlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uc3BsaWNlKHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSkpLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChub2RlLmxlYWYpIG5ld05vZGUubGVhZiA9IHRydWU7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfSxcblxuICAgIF9zcGxpdFJvb3Q6IGZ1bmN0aW9uIChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW25vZGUsIG5ld05vZGVdLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCArIDFcbiAgICAgICAgfTtcbiAgICAgICAgY2FsY0JCb3godGhpcy5kYXRhLCB0aGlzLnRvQkJveCk7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTcGxpdEluZGV4OiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBpLCBiYm94MSwgYmJveDIsIG92ZXJsYXAsIGFyZWEsIG1pbk92ZXJsYXAsIG1pbkFyZWEsIGluZGV4O1xuXG4gICAgICAgIG1pbk92ZXJsYXAgPSBtaW5BcmVhID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8PSBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBiYm94MSA9IGRpc3RCQm94KG5vZGUsIDAsIGksIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIGJib3gyID0gZGlzdEJCb3gobm9kZSwgaSwgTSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgICAgICBvdmVybGFwID0gaW50ZXJzZWN0aW9uQXJlYShiYm94MSwgYmJveDIpO1xuICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGJib3gxKSArIGJib3hBcmVhKGJib3gyKTtcblxuICAgICAgICAgICAgLy8gY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gb3ZlcmxhcFxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcmxhcCA9PT0gbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBhcmVhXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvLyBzb3J0cyBub2RlIGNoaWxkcmVuIGJ5IHRoZSBiZXN0IGF4aXMgZm9yIHNwbGl0XG4gICAgX2Nob29zZVNwbGl0QXhpczogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgY29tcGFyZU1pblggPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5YIDogY29tcGFyZU5vZGVNaW5YLFxuICAgICAgICAgICAgY29tcGFyZU1pblkgPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5ZIDogY29tcGFyZU5vZGVNaW5ZLFxuICAgICAgICAgICAgeE1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblgpLFxuICAgICAgICAgICAgeU1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblkpO1xuXG4gICAgICAgIC8vIGlmIHRvdGFsIGRpc3RyaWJ1dGlvbnMgbWFyZ2luIHZhbHVlIGlzIG1pbmltYWwgZm9yIHgsIHNvcnQgYnkgbWluWCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J3MgYWxyZWFkeSBzb3J0ZWQgYnkgbWluWVxuICAgICAgICBpZiAoeE1hcmdpbiA8IHlNYXJnaW4pIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlTWluWCk7XG4gICAgfSxcblxuICAgIC8vIHRvdGFsIG1hcmdpbiBvZiBhbGwgcG9zc2libGUgc3BsaXQgZGlzdHJpYnV0aW9ucyB3aGVyZSBlYWNoIG5vZGUgaXMgYXQgbGVhc3QgbSBmdWxsXG4gICAgX2FsbERpc3RNYXJnaW46IGZ1bmN0aW9uIChub2RlLCBtLCBNLCBjb21wYXJlKSB7XG5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGxlZnRCQm94ID0gZGlzdEJCb3gobm9kZSwgMCwgbSwgdG9CQm94KSxcbiAgICAgICAgICAgIHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpLFxuICAgICAgICAgICAgbWFyZ2luID0gYmJveE1hcmdpbihsZWZ0QkJveCkgKyBiYm94TWFyZ2luKHJpZ2h0QkJveCksXG4gICAgICAgICAgICBpLCBjaGlsZDtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgTSAtIG07IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSBNIC0gbSAtIDE7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQocmlnaHRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9LFxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlczogZnVuY3Rpb24gKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGdpdmVuIHRyZWUgcGF0aFxuICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBleHRlbmQocGF0aFtpXS5iYm94LCBiYm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY29uZGVuc2U6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMSwgc2libGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3MgPSBwYXRoW2kgLSAxXS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAgICAgfSBlbHNlIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5pdEZvcm1hdDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAvLyBkYXRhIGZvcm1hdCAobWluWCwgbWluWSwgbWF4WCwgbWF4WSBhY2Nlc3NvcnMpXG5cbiAgICAgICAgLy8gdXNlcyBldmFsLXR5cGUgZnVuY3Rpb24gY29tcGlsYXRpb24gaW5zdGVhZCBvZiBqdXN0IGFjY2VwdGluZyBhIHRvQkJveCBmdW5jdGlvblxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBhbGdvcml0aG1zIGFyZSB2ZXJ5IHNlbnNpdGl2ZSB0byBzb3J0aW5nIGZ1bmN0aW9ucyBwZXJmb3JtYW5jZSxcbiAgICAgICAgLy8gc28gdGhleSBzaG91bGQgYmUgZGVhZCBzaW1wbGUgYW5kIHdpdGhvdXQgaW5uZXIgY2FsbHNcblxuICAgICAgICAvLyBqc2hpbnQgZXZpbDogdHJ1ZVxuXG4gICAgICAgIHZhciBjb21wYXJlQXJyID0gWydyZXR1cm4gYScsICcgLSBiJywgJzsnXTtcblxuICAgICAgICB0aGlzLmNvbXBhcmVNaW5YID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzBdKSk7XG4gICAgICAgIHRoaXMuY29tcGFyZU1pblkgPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMV0pKTtcblxuICAgICAgICB0aGlzLnRvQkJveCA9IG5ldyBGdW5jdGlvbignYScsICdyZXR1cm4gW2EnICsgZm9ybWF0LmpvaW4oJywgYScpICsgJ107Jyk7XG4gICAgfVxufTtcblxuXG4vLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXG5mdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcbiAgICBub2RlLmJib3ggPSBkaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCwgdG9CQm94KTtcbn1cblxuLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbmZ1bmN0aW9uIGRpc3RCQm94KG5vZGUsIGssIHAsIHRvQkJveCkge1xuICAgIHZhciBiYm94ID0gZW1wdHkoKTtcblxuICAgIGZvciAodmFyIGkgPSBrLCBjaGlsZDsgaSA8IHA7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChiYm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJib3g7XG59XG5cbmZ1bmN0aW9uIGVtcHR5KCkgeyByZXR1cm4gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldOyB9XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgYVswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIGFbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBhWzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgYVszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblgoYSwgYikgeyByZXR1cm4gYS5iYm94WzBdIC0gYi5iYm94WzBdOyB9XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYSwgYikgeyByZXR1cm4gYS5iYm94WzFdIC0gYi5iYm94WzFdOyB9XG5cbmZ1bmN0aW9uIGJib3hBcmVhKGEpICAgeyByZXR1cm4gKGFbMl0gLSBhWzBdKSAqIChhWzNdIC0gYVsxXSk7IH1cbmZ1bmN0aW9uIGJib3hNYXJnaW4oYSkgeyByZXR1cm4gKGFbMl0gLSBhWzBdKSArIChhWzNdIC0gYVsxXSk7IH1cblxuZnVuY3Rpb24gZW5sYXJnZWRBcmVhKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgubWF4KGJbMl0sIGFbMl0pIC0gTWF0aC5taW4oYlswXSwgYVswXSkpICpcbiAgICAgICAgICAgKE1hdGgubWF4KGJbM10sIGFbM10pIC0gTWF0aC5taW4oYlsxXSwgYVsxXSkpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25BcmVhKGEsIGIpIHtcbiAgICB2YXIgbWluWCA9IE1hdGgubWF4KGFbMF0sIGJbMF0pLFxuICAgICAgICBtaW5ZID0gTWF0aC5tYXgoYVsxXSwgYlsxXSksXG4gICAgICAgIG1heFggPSBNYXRoLm1pbihhWzJdLCBiWzJdKSxcbiAgICAgICAgbWF4WSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgIE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhWzBdIDw9IGJbMF0gJiZcbiAgICAgICAgICAgYVsxXSA8PSBiWzFdICYmXG4gICAgICAgICAgIGJbMl0gPD0gYVsyXSAmJlxuICAgICAgICAgICBiWzNdIDw9IGFbM107XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoYSwgYikge1xuICAgIHJldHVybiBiWzBdIDw9IGFbMl0gJiZcbiAgICAgICAgICAgYlsxXSA8PSBhWzNdICYmXG4gICAgICAgICAgIGJbMl0gPj0gYVswXSAmJlxuICAgICAgICAgICBiWzNdID49IGFbMV07XG59XG5cbi8vIHNvcnQgYW4gYXJyYXkgc28gdGhhdCBpdGVtcyBjb21lIGluIGdyb3VwcyBvZiBuIHVuc29ydGVkIGl0ZW1zLCB3aXRoIGdyb3VwcyBzb3J0ZWQgYmV0d2VlbiBlYWNoIG90aGVyO1xuLy8gY29tYmluZXMgc2VsZWN0aW9uIGFsZ29yaXRobSB3aXRoIGJpbmFyeSBkaXZpZGUgJiBjb25xdWVyIGFwcHJvYWNoXG5cbmZ1bmN0aW9uIG11bHRpU2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG4sIGNvbXBhcmUpIHtcbiAgICB2YXIgc3RhY2sgPSBbbGVmdCwgcmlnaHRdLFxuICAgICAgICBtaWQ7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG4pIGNvbnRpbnVlO1xuXG4gICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmNlaWwoKHJpZ2h0IC0gbGVmdCkgLyBuIC8gMikgKiBuO1xuICAgICAgICBzZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbWlkLCBjb21wYXJlKTtcblxuICAgICAgICBzdGFjay5wdXNoKGxlZnQsIG1pZCwgbWlkLCByaWdodCk7XG4gICAgfVxufVxuXG4vLyBGbG95ZC1SaXZlc3Qgc2VsZWN0aW9uIGFsZ29yaXRobTpcbi8vIHNvcnQgYW4gYXJyYXkgYmV0d2VlbiBsZWZ0IGFuZCByaWdodCAoaW5jbHVzaXZlKSBzbyB0aGF0IHRoZSBzbWFsbGVzdCBrIGVsZW1lbnRzIGNvbWUgZmlyc3QgKHVub3JkZXJlZClcbmZ1bmN0aW9uIHNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBrLCBjb21wYXJlKSB7XG4gICAgdmFyIG4sIGksIHosIHMsIHNkLCBuZXdMZWZ0LCBuZXdSaWdodCwgdCwgajtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgICAgICAgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICBpID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgICAgICAgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChpIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBpICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBpKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHNlbGVjdChhcnIsIG5ld0xlZnQsIG5ld1JpZ2h0LCBrLCBjb21wYXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQgPSBhcnJba107XG4gICAgICAgIGkgPSBsZWZ0O1xuICAgICAgICBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApIHN3YXAoYXJyLCBsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwKGFyciwgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMCkgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2pdLCB0KSA+IDApIGotLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycltsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyLCBsZWZ0LCBqKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cblxuLy8gZXhwb3J0IGFzIEFNRC9Db21tb25KUyBtb2R1bGUgb3IgZ2xvYmFsIHZhcmlhYmxlXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoJ3JidXNoJywgZnVuY3Rpb24oKSB7IHJldHVybiByYnVzaDsgfSk7XG5lbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSByYnVzaDtcbmVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgc2VsZi5yYnVzaCA9IHJidXNoO1xuZWxzZSB3aW5kb3cucmJ1c2ggPSByYnVzaDtcblxufSkoKTtcbiIsIi8vIENvcHlyaWdodCAyMDE0IFNpbW9uIEx5ZGVsbFxyXG4vLyBYMTEgKOKAnE1JVOKAnSkgTGljZW5zZWQuIChTZWUgTElDRU5TRS4pXHJcblxyXG52b2lkIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZmFjdG9yeSlcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByb290LnJlc29sdmVVcmwgPSBmYWN0b3J5KClcclxuICB9XHJcbn0odGhpcywgZnVuY3Rpb24oKSB7XHJcblxyXG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoLyogLi4udXJscyAqLykge1xyXG4gICAgdmFyIG51bVVybHMgPSBhcmd1bWVudHMubGVuZ3RoXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzb2x2ZVVybCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQ7IGdvdCBub25lLlwiKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBiYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJhc2VcIilcclxuICAgIGJhc2UuaHJlZiA9IGFyZ3VtZW50c1swXVxyXG5cclxuICAgIGlmIChudW1VcmxzID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBiYXNlLmhyZWZcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXVxyXG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoYmFzZSwgaGVhZC5maXJzdENoaWxkKVxyXG5cclxuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIilcclxuICAgIHZhciByZXNvbHZlZFxyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBudW1VcmxzOyBpbmRleCsrKSB7XHJcbiAgICAgIGEuaHJlZiA9IGFyZ3VtZW50c1tpbmRleF1cclxuICAgICAgcmVzb2x2ZWQgPSBhLmhyZWZcclxuICAgICAgYmFzZS5ocmVmID0gcmVzb2x2ZWRcclxuICAgIH1cclxuXHJcbiAgICBoZWFkLnJlbW92ZUNoaWxkKGJhc2UpXHJcblxyXG4gICAgcmV0dXJuIHJlc29sdmVkXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzb2x2ZVVybFxyXG5cclxufSkpO1xyXG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDA4IEFwcGxlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogYXJlIG1ldDpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEFQUExFIElOQy4gYGBBUyBJUycnIEFORCBBTllcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBBUFBMRSBJTkMuIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWVxuICogT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogUG9ydGVkIGZyb20gV2Via2l0XG4gKiBodHRwOi8vc3ZuLndlYmtpdC5vcmcvcmVwb3NpdG9yeS93ZWJraXQvdHJ1bmsvU291cmNlL1dlYkNvcmUvcGxhdGZvcm0vZ3JhcGhpY3MvVW5pdEJlemllci5oXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBVbml0QmV6aWVyO1xuXG5mdW5jdGlvbiBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9seW5vbWlhbCBjb2VmZmljaWVudHMsIGltcGxpY2l0IGZpcnN0IGFuZCBsYXN0IGNvbnRyb2wgcG9pbnRzIGFyZSAoMCwwKSBhbmQgKDEsMSkuXG4gICAgdGhpcy5jeCA9IDMuMCAqIHAxeDtcbiAgICB0aGlzLmJ4ID0gMy4wICogKHAyeCAtIHAxeCkgLSB0aGlzLmN4O1xuICAgIHRoaXMuYXggPSAxLjAgLSB0aGlzLmN4IC0gdGhpcy5ieDtcblxuICAgIHRoaXMuY3kgPSAzLjAgKiBwMXk7XG4gICAgdGhpcy5ieSA9IDMuMCAqIChwMnkgLSBwMXkpIC0gdGhpcy5jeTtcbiAgICB0aGlzLmF5ID0gMS4wIC0gdGhpcy5jeSAtIHRoaXMuYnk7XG5cbiAgICB0aGlzLnAxeCA9IHAxeDtcbiAgICB0aGlzLnAxeSA9IHAyeTtcbiAgICB0aGlzLnAyeCA9IHAyeDtcbiAgICB0aGlzLnAyeSA9IHAyeTtcbn1cblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVYID0gZnVuY3Rpb24odCkge1xuICAgIC8vIGBheCB0XjMgKyBieCB0XjIgKyBjeCB0JyBleHBhbmRlZCB1c2luZyBIb3JuZXIncyBydWxlLlxuICAgIHJldHVybiAoKHRoaXMuYXggKiB0ICsgdGhpcy5ieCkgKiB0ICsgdGhpcy5jeCkgKiB0O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVZID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAoKHRoaXMuYXkgKiB0ICsgdGhpcy5ieSkgKiB0ICsgdGhpcy5jeSkgKiB0O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gKDMuMCAqIHRoaXMuYXggKiB0ICsgMi4wICogdGhpcy5ieCkgKiB0ICsgdGhpcy5jeDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNvbHZlQ3VydmVYID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xuICAgIGlmICh0eXBlb2YgZXBzaWxvbiA9PT0gJ3VuZGVmaW5lZCcpIGVwc2lsb24gPSAxZS02O1xuXG4gICAgdmFyIHQwLCB0MSwgdDIsIHgyLCBpO1xuXG4gICAgLy8gRmlyc3QgdHJ5IGEgZmV3IGl0ZXJhdGlvbnMgb2YgTmV3dG9uJ3MgbWV0aG9kIC0tIG5vcm1hbGx5IHZlcnkgZmFzdC5cbiAgICBmb3IgKHQyID0geCwgaSA9IDA7IGkgPCA4OyBpKyspIHtcblxuICAgICAgICB4MiA9IHRoaXMuc2FtcGxlQ3VydmVYKHQyKSAtIHg7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MikgPCBlcHNpbG9uKSByZXR1cm4gdDI7XG5cbiAgICAgICAgdmFyIGQyID0gdGhpcy5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYKHQyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGQyKSA8IDFlLTYpIGJyZWFrO1xuXG4gICAgICAgIHQyID0gdDIgLSB4MiAvIGQyO1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byB0aGUgYmlzZWN0aW9uIG1ldGhvZCBmb3IgcmVsaWFiaWxpdHkuXG4gICAgdDAgPSAwLjA7XG4gICAgdDEgPSAxLjA7XG4gICAgdDIgPSB4O1xuXG4gICAgaWYgKHQyIDwgdDApIHJldHVybiB0MDtcbiAgICBpZiAodDIgPiB0MSkgcmV0dXJuIHQxO1xuXG4gICAgd2hpbGUgKHQwIDwgdDEpIHtcblxuICAgICAgICB4MiA9IHRoaXMuc2FtcGxlQ3VydmVYKHQyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyIC0geCkgPCBlcHNpbG9uKSByZXR1cm4gdDI7XG5cbiAgICAgICAgaWYgKHggPiB4Mikge1xuICAgICAgICAgICAgdDAgPSB0MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHQxID0gdDI7XG4gICAgICAgIH1cblxuICAgICAgICB0MiA9ICh0MSAtIHQwKSAqIDAuNSArIHQwO1xuICAgIH1cblxuICAgIC8vIEZhaWx1cmUuXG4gICAgcmV0dXJuIHQyO1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlQ3VydmVZKHRoaXMuc29sdmVDdXJ2ZVgoeCwgZXBzaWxvbikpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGUgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlLmpzJyk7XG5tb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGVmZWF0dXJlLmpzJyk7XG5tb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlTGF5ZXIgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlbGF5ZXIuanMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVMYXllciA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZWxheWVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZTtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZShwYmYsIGVuZCkge1xuICAgIHRoaXMubGF5ZXJzID0gcGJmLnJlYWRGaWVsZHMocmVhZFRpbGUsIHt9LCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkVGlsZSh0YWcsIGxheWVycywgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMykge1xuICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgVmVjdG9yVGlsZUxheWVyKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpO1xuICAgICAgICBpZiAobGF5ZXIubGVuZ3RoKSBsYXllcnNbbGF5ZXIubmFtZV0gPSBsYXllcjtcbiAgICB9XG59XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlRmVhdHVyZTtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZUZlYXR1cmUocGJmLCBlbmQsIGV4dGVudCwga2V5cywgdmFsdWVzKSB7XG4gICAgLy8gUHVibGljXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG4gICAgdGhpcy50eXBlID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9wYmYgPSBwYmY7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSAtMTtcbiAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICBwYmYucmVhZEZpZWxkcyhyZWFkRmVhdHVyZSwgdGhpcywgZW5kKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZlYXR1cmUodGFnLCBmZWF0dXJlLCBwYmYpIHtcbiAgICBpZiAodGFnID09IDEpIGZlYXR1cmUuX2lkID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT0gMikgcmVhZFRhZyhwYmYsIGZlYXR1cmUpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSAzKSBmZWF0dXJlLnR5cGUgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSA0KSBmZWF0dXJlLl9nZW9tZXRyeSA9IHBiZi5wb3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWcocGJmLCBmZWF0dXJlKSB7XG4gICAgdmFyIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIGtleSA9IGZlYXR1cmUuX2tleXNbcGJmLnJlYWRWYXJpbnQoKV0sXG4gICAgICAgICAgICB2YWx1ZSA9IGZlYXR1cmUuX3ZhbHVlc1twYmYucmVhZFZhcmludCgpXTtcbiAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG59XG5cblZlY3RvclRpbGVGZWF0dXJlLnR5cGVzID0gWydVbmtub3duJywgJ1BvaW50JywgJ0xpbmVTdHJpbmcnLCAnUG9seWdvbiddO1xuXG5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUubG9hZEdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBiZiA9IHRoaXMuX3BiZjtcbiAgICBwYmYucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MsXG4gICAgICAgIGNtZCA9IDEsXG4gICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgIHggPSAwLFxuICAgICAgICB5ID0gMCxcbiAgICAgICAgbGluZXMgPSBbXSxcbiAgICAgICAgbGluZTtcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY21kTGVuID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgICAgIGNtZCA9IGNtZExlbiAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZExlbiA+PiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoLS07XG5cbiAgICAgICAgaWYgKGNtZCA9PT0gMSB8fCBjbWQgPT09IDIpIHtcbiAgICAgICAgICAgIHggKz0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICB5ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuXG4gICAgICAgICAgICBpZiAoY21kID09PSAxKSB7IC8vIG1vdmVUb1xuICAgICAgICAgICAgICAgIGlmIChsaW5lKSBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZS5wdXNoKG5ldyBQb2ludCh4LCB5KSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjbWQgPT09IDcpIHtcblxuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBuaWstdmVjdG9yLXRpbGUvaXNzdWVzLzkwXG4gICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgIGxpbmUucHVzaChsaW5lWzBdLmNsb25lKCkpOyAvLyBjbG9zZVBvbHlnb25cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGluZSkgbGluZXMucHVzaChsaW5lKTtcblxuICAgIHJldHVybiBsaW5lcztcbn07XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBiZiA9IHRoaXMuX3BiZjtcbiAgICBwYmYucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MsXG4gICAgICAgIGNtZCA9IDEsXG4gICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgIHggPSAwLFxuICAgICAgICB5ID0gMCxcbiAgICAgICAgeDEgPSBJbmZpbml0eSxcbiAgICAgICAgeDIgPSAtSW5maW5pdHksXG4gICAgICAgIHkxID0gSW5maW5pdHksXG4gICAgICAgIHkyID0gLUluZmluaXR5O1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRMZW4gPSBwYmYucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kTGVuICYgMHg3O1xuICAgICAgICAgICAgbGVuZ3RoID0gY21kTGVuID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICBpZiAoeCA8IHgxKSB4MSA9IHg7XG4gICAgICAgICAgICBpZiAoeCA+IHgyKSB4MiA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IHkxKSB5MSA9IHk7XG4gICAgICAgICAgICBpZiAoeSA+IHkyKSB5MiA9IHk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjbWQgIT09IDcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb21tYW5kICcgKyBjbWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG59O1xuXG5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBzaXplID0gdGhpcy5leHRlbnQgKiBNYXRoLnBvdygyLCB6KSxcbiAgICAgICAgeDAgPSB0aGlzLmV4dGVudCAqIHgsXG4gICAgICAgIHkwID0gdGhpcy5leHRlbnQgKiB5LFxuICAgICAgICBjb29yZHMgPSB0aGlzLmxvYWRHZW9tZXRyeSgpLFxuICAgICAgICB0eXBlID0gVmVjdG9yVGlsZUZlYXR1cmUudHlwZXNbdGhpcy50eXBlXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gY29vcmRzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gbGluZVtqXSwgeTIgPSAxODAgLSAocC55ICsgeTApICogMzYwIC8gc2l6ZTtcbiAgICAgICAgICAgIGxpbmVbal0gPSBbXG4gICAgICAgICAgICAgICAgKHAueCArIHgwKSAqIDM2MCAvIHNpemUgLSAxODAsXG4gICAgICAgICAgICAgICAgMzYwIC8gTWF0aC5QSSAqIE1hdGguYXRhbihNYXRoLmV4cCh5MiAqIE1hdGguUEkgLyAxODApKSAtIDkwXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcgJiYgY29vcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF1bMF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXTtcbiAgICAgICAgdHlwZSA9ICdNdWx0aVBvaW50JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJyAmJiBjb29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ011bHRpTGluZVN0cmluZyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3Jkc1xuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0aWVzOiB0aGlzLnByb3BlcnRpZXNcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgnLi92ZWN0b3J0aWxlZmVhdHVyZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVMYXllcjtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZUxheWVyKHBiZiwgZW5kKSB7XG4gICAgLy8gUHVibGljXG4gICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW50ID0gNDA5NjtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5fcGJmID0gcGJmO1xuICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICB0aGlzLl9mZWF0dXJlcyA9IFtdO1xuXG4gICAgcGJmLnJlYWRGaWVsZHMocmVhZExheWVyLCB0aGlzLCBlbmQpO1xuXG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLl9mZWF0dXJlcy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHJlYWRMYXllcih0YWcsIGxheWVyLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxNSkgbGF5ZXIudmVyc2lvbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAxKSBsYXllci5uYW1lID0gcGJmLnJlYWRTdHJpbmcoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIGxheWVyLmV4dGVudCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBsYXllci5fZmVhdHVyZXMucHVzaChwYmYucG9zKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDMpIGxheWVyLl9rZXlzLnB1c2gocGJmLnJlYWRTdHJpbmcoKSk7XG4gICAgZWxzZSBpZiAodGFnID09PSA0KSBsYXllci5fdmFsdWVzLnB1c2gocmVhZFZhbHVlTWVzc2FnZShwYmYpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFZhbHVlTWVzc2FnZShwYmYpIHtcbiAgICB2YXIgdmFsdWUgPSBudWxsLFxuICAgICAgICBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcztcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSBwYmYucmVhZFZhcmludCgpID4+IDM7XG5cbiAgICAgICAgdmFsdWUgPSB0YWcgPT09IDEgPyBwYmYucmVhZFN0cmluZygpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gMiA/IHBiZi5yZWFkRmxvYXQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDMgPyBwYmYucmVhZERvdWJsZSgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNCA/IHBiZi5yZWFkVmFyaW50NjQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDUgPyBwYmYucmVhZFZhcmludCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNiA/IHBiZi5yZWFkU1ZhcmludCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNyA/IHBiZi5yZWFkQm9vbGVhbigpIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHJldHVybiBmZWF0dXJlIGBpYCBmcm9tIHRoaXMgbGF5ZXIgYXMgYSBgVmVjdG9yVGlsZUZlYXR1cmVgXG5WZWN0b3JUaWxlTGF5ZXIucHJvdG90eXBlLmZlYXR1cmUgPSBmdW5jdGlvbihpKSB7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5fZmVhdHVyZXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ2ZlYXR1cmUgaW5kZXggb3V0IG9mIGJvdW5kcycpO1xuXG4gICAgdGhpcy5fcGJmLnBvcyA9IHRoaXMuX2ZlYXR1cmVzW2ldO1xuXG4gICAgdmFyIGVuZCA9IHRoaXMuX3BiZi5yZWFkVmFyaW50KCkgKyB0aGlzLl9wYmYucG9zO1xuICAgIHJldHVybiBuZXcgVmVjdG9yVGlsZUZlYXR1cmUodGhpcy5fcGJmLCBlbmQsIHRoaXMuZXh0ZW50LCB0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMpO1xufTtcbiIsInZhciBidW5kbGVGbiA9IGFyZ3VtZW50c1szXTtcbnZhciBzb3VyY2VzID0gYXJndW1lbnRzWzRdO1xudmFyIGNhY2hlID0gYXJndW1lbnRzWzVdO1xuXG52YXIgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB2YXIgd2tleTtcbiAgICB2YXIgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICBpZiAoY2FjaGVba2V5XS5leHBvcnRzID09PSBmbikge1xuICAgICAgICAgICAgd2tleSA9IGtleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICghd2tleSkge1xuICAgICAgICB3a2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG4gICAgICAgIHZhciB3Y2FjaGUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICAgICAgd2NhY2hlW2tleV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlc1t3a2V5XSA9IFtcbiAgICAgICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZScsJ21vZHVsZScsJ2V4cG9ydHMnXSwgJygnICsgZm4gKyAnKShzZWxmKScpLFxuICAgICAgICAgICAgd2NhY2hlXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhciBza2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG4gICAgXG4gICAgdmFyIHNjYWNoZSA9IHt9OyBzY2FjaGVbd2tleV0gPSB3a2V5O1xuICAgIHNvdXJjZXNbc2tleV0gPSBbXG4gICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZSddLCdyZXF1aXJlKCcgKyBzdHJpbmdpZnkod2tleSkgKyAnKShzZWxmKScpLFxuICAgICAgICBzY2FjaGVcbiAgICBdO1xuICAgIFxuICAgIHZhciBzcmMgPSAnKCcgKyBidW5kbGVGbiArICcpKHsnXG4gICAgICAgICsgT2JqZWN0LmtleXMoc291cmNlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoa2V5KSArICc6WydcbiAgICAgICAgICAgICAgICArIHNvdXJjZXNba2V5XVswXVxuICAgICAgICAgICAgICAgICsgJywnICsgc3RyaW5naWZ5KHNvdXJjZXNba2V5XVsxXSkgKyAnXSdcbiAgICAgICAgICAgIDtcbiAgICAgICAgfSkuam9pbignLCcpXG4gICAgICAgICsgJ30se30sWycgKyBzdHJpbmdpZnkoc2tleSkgKyAnXSknXG4gICAgO1xuICAgIFxuICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG4gICAgXG4gICAgcmV0dXJuIG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChcbiAgICAgICAgbmV3IEJsb2IoW3NyY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSlcbiAgICApKTtcbn07XG4iXX0=
